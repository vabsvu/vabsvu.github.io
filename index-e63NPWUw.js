(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const a of s.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
          ? (s.credentials = "omit")
          : (s.credentials = "same-origin"),
      s
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = t(i);
    fetch(i.href, s);
  }
})();
(function () {
  const r = document.createElement("link").relList;
  if (r && r.supports && r.supports("modulepreload")) return;
  for (const n of document.querySelectorAll('link[rel="modulepreload"]')) t(n);
  new MutationObserver((n) => {
    for (const i of n)
      if (i.type === "childList")
        for (const s of i.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && t(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function e(n) {
    const i = {};
    return (
      n.integrity && (i.integrity = n.integrity),
      n.referrerPolicy && (i.referrerPolicy = n.referrerPolicy),
      n.crossOrigin === "use-credentials"
        ? (i.credentials = "include")
        : n.crossOrigin === "anonymous"
          ? (i.credentials = "omit")
          : (i.credentials = "same-origin"),
      i
    );
  }
  function t(n) {
    if (n.ep) return;
    n.ep = !0;
    const i = e(n);
    fetch(n.href, i);
  }
})();
function Vv(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default")
    ? r.default
    : r;
}
var f4 = { exports: {} },
  Rf = {},
  p4 = { exports: {} },
  fn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var m4;
function Q6() {
  if (m4) return fn;
  m4 = 1;
  var r = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    n = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    s = Symbol.for("react.provider"),
    a = Symbol.for("react.context"),
    l = Symbol.for("react.forward_ref"),
    c = Symbol.for("react.suspense"),
    d = Symbol.for("react.memo"),
    p = Symbol.for("react.lazy"),
    m = Symbol.iterator;
  function y(q) {
    return q === null || typeof q != "object"
      ? null
      : ((q = (m && q[m]) || q["@@iterator"]),
        typeof q == "function" ? q : null);
  }
  var v = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    A = Object.assign,
    M = {};
  function w(q, ce, Xe) {
    (this.props = q),
      (this.context = ce),
      (this.refs = M),
      (this.updater = Xe || v);
  }
  (w.prototype.isReactComponent = {}),
    (w.prototype.setState = function (q, ce) {
      if (typeof q != "object" && typeof q != "function" && q != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables.",
        );
      this.updater.enqueueSetState(this, q, ce, "setState");
    }),
    (w.prototype.forceUpdate = function (q) {
      this.updater.enqueueForceUpdate(this, q, "forceUpdate");
    });
  function x() {}
  x.prototype = w.prototype;
  function C(q, ce, Xe) {
    (this.props = q),
      (this.context = ce),
      (this.refs = M),
      (this.updater = Xe || v);
  }
  var T = (C.prototype = new x());
  (T.constructor = C), A(T, w.prototype), (T.isPureReactComponent = !0);
  var I = Array.isArray,
    U = Object.prototype.hasOwnProperty,
    F = { current: null },
    O = { key: !0, ref: !0, __self: !0, __source: !0 };
  function z(q, ce, Xe) {
    var ye,
      Pe = {},
      Ue = null,
      Fe = null;
    if (ce != null)
      for (ye in (ce.ref !== void 0 && (Fe = ce.ref),
      ce.key !== void 0 && (Ue = "" + ce.key),
      ce))
        U.call(ce, ye) && !O.hasOwnProperty(ye) && (Pe[ye] = ce[ye]);
    var Je = arguments.length - 2;
    if (Je === 1) Pe.children = Xe;
    else if (1 < Je) {
      for (var et = Array(Je), tt = 0; tt < Je; tt++)
        et[tt] = arguments[tt + 2];
      Pe.children = et;
    }
    if (q && q.defaultProps)
      for (ye in ((Je = q.defaultProps), Je))
        Pe[ye] === void 0 && (Pe[ye] = Je[ye]);
    return {
      $$typeof: r,
      type: q,
      key: Ue,
      ref: Fe,
      props: Pe,
      _owner: F.current,
    };
  }
  function L(q, ce) {
    return {
      $$typeof: r,
      type: q.type,
      key: ce,
      ref: q.ref,
      props: q.props,
      _owner: q._owner,
    };
  }
  function N(q) {
    return typeof q == "object" && q !== null && q.$$typeof === r;
  }
  function X(q) {
    var ce = { "=": "=0", ":": "=2" };
    return (
      "$" +
      q.replace(/[=:]/g, function (Xe) {
        return ce[Xe];
      })
    );
  }
  var ie = /\/+/g;
  function re(q, ce) {
    return typeof q == "object" && q !== null && q.key != null
      ? X("" + q.key)
      : ce.toString(36);
  }
  function me(q, ce, Xe, ye, Pe) {
    var Ue = typeof q;
    (Ue === "undefined" || Ue === "boolean") && (q = null);
    var Fe = !1;
    if (q === null) Fe = !0;
    else
      switch (Ue) {
        case "string":
        case "number":
          Fe = !0;
          break;
        case "object":
          switch (q.$$typeof) {
            case r:
            case e:
              Fe = !0;
          }
      }
    if (Fe)
      return (
        (Fe = q),
        (Pe = Pe(Fe)),
        (q = ye === "" ? "." + re(Fe, 0) : ye),
        I(Pe)
          ? ((Xe = ""),
            q != null && (Xe = q.replace(ie, "$&/") + "/"),
            me(Pe, ce, Xe, "", function (tt) {
              return tt;
            }))
          : Pe != null &&
            (N(Pe) &&
              (Pe = L(
                Pe,
                Xe +
                  (!Pe.key || (Fe && Fe.key === Pe.key)
                    ? ""
                    : ("" + Pe.key).replace(ie, "$&/") + "/") +
                  q,
              )),
            ce.push(Pe)),
        1
      );
    if (((Fe = 0), (ye = ye === "" ? "." : ye + ":"), I(q)))
      for (var Je = 0; Je < q.length; Je++) {
        Ue = q[Je];
        var et = ye + re(Ue, Je);
        Fe += me(Ue, ce, Xe, et, Pe);
      }
    else if (((et = y(q)), typeof et == "function"))
      for (q = et.call(q), Je = 0; !(Ue = q.next()).done; )
        (Ue = Ue.value),
          (et = ye + re(Ue, Je++)),
          (Fe += me(Ue, ce, Xe, et, Pe));
    else if (Ue === "object")
      throw (
        ((ce = String(q)),
        Error(
          "Objects are not valid as a React child (found: " +
            (ce === "[object Object]"
              ? "object with keys {" + Object.keys(q).join(", ") + "}"
              : ce) +
            "). If you meant to render a collection of children, use an array instead.",
        ))
      );
    return Fe;
  }
  function _e(q, ce, Xe) {
    if (q == null) return q;
    var ye = [],
      Pe = 0;
    return (
      me(q, ye, "", "", function (Ue) {
        return ce.call(Xe, Ue, Pe++);
      }),
      ye
    );
  }
  function ge(q) {
    if (q._status === -1) {
      var ce = q._result;
      (ce = ce()),
        ce.then(
          function (Xe) {
            (q._status === 0 || q._status === -1) &&
              ((q._status = 1), (q._result = Xe));
          },
          function (Xe) {
            (q._status === 0 || q._status === -1) &&
              ((q._status = 2), (q._result = Xe));
          },
        ),
        q._status === -1 && ((q._status = 0), (q._result = ce));
    }
    if (q._status === 1) return q._result.default;
    throw q._result;
  }
  var Re = { current: null },
    J = { transition: null },
    oe = {
      ReactCurrentDispatcher: Re,
      ReactCurrentBatchConfig: J,
      ReactCurrentOwner: F,
    };
  function ae() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return (
    (fn.Children = {
      map: _e,
      forEach: function (q, ce, Xe) {
        _e(
          q,
          function () {
            ce.apply(this, arguments);
          },
          Xe,
        );
      },
      count: function (q) {
        var ce = 0;
        return (
          _e(q, function () {
            ce++;
          }),
          ce
        );
      },
      toArray: function (q) {
        return (
          _e(q, function (ce) {
            return ce;
          }) || []
        );
      },
      only: function (q) {
        if (!N(q))
          throw Error(
            "React.Children.only expected to receive a single React element child.",
          );
        return q;
      },
    }),
    (fn.Component = w),
    (fn.Fragment = t),
    (fn.Profiler = i),
    (fn.PureComponent = C),
    (fn.StrictMode = n),
    (fn.Suspense = c),
    (fn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oe),
    (fn.act = ae),
    (fn.cloneElement = function (q, ce, Xe) {
      if (q == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            q +
            ".",
        );
      var ye = A({}, q.props),
        Pe = q.key,
        Ue = q.ref,
        Fe = q._owner;
      if (ce != null) {
        if (
          (ce.ref !== void 0 && ((Ue = ce.ref), (Fe = F.current)),
          ce.key !== void 0 && (Pe = "" + ce.key),
          q.type && q.type.defaultProps)
        )
          var Je = q.type.defaultProps;
        for (et in ce)
          U.call(ce, et) &&
            !O.hasOwnProperty(et) &&
            (ye[et] = ce[et] === void 0 && Je !== void 0 ? Je[et] : ce[et]);
      }
      var et = arguments.length - 2;
      if (et === 1) ye.children = Xe;
      else if (1 < et) {
        Je = Array(et);
        for (var tt = 0; tt < et; tt++) Je[tt] = arguments[tt + 2];
        ye.children = Je;
      }
      return {
        $$typeof: r,
        type: q.type,
        key: Pe,
        ref: Ue,
        props: ye,
        _owner: Fe,
      };
    }),
    (fn.createContext = function (q) {
      return (
        (q = {
          $$typeof: a,
          _currentValue: q,
          _currentValue2: q,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (q.Provider = { $$typeof: s, _context: q }),
        (q.Consumer = q)
      );
    }),
    (fn.createElement = z),
    (fn.createFactory = function (q) {
      var ce = z.bind(null, q);
      return (ce.type = q), ce;
    }),
    (fn.createRef = function () {
      return { current: null };
    }),
    (fn.forwardRef = function (q) {
      return { $$typeof: l, render: q };
    }),
    (fn.isValidElement = N),
    (fn.lazy = function (q) {
      return { $$typeof: p, _payload: { _status: -1, _result: q }, _init: ge };
    }),
    (fn.memo = function (q, ce) {
      return { $$typeof: d, type: q, compare: ce === void 0 ? null : ce };
    }),
    (fn.startTransition = function (q) {
      var ce = J.transition;
      J.transition = {};
      try {
        q();
      } finally {
        J.transition = ce;
      }
    }),
    (fn.unstable_act = ae),
    (fn.useCallback = function (q, ce) {
      return Re.current.useCallback(q, ce);
    }),
    (fn.useContext = function (q) {
      return Re.current.useContext(q);
    }),
    (fn.useDebugValue = function () {}),
    (fn.useDeferredValue = function (q) {
      return Re.current.useDeferredValue(q);
    }),
    (fn.useEffect = function (q, ce) {
      return Re.current.useEffect(q, ce);
    }),
    (fn.useId = function () {
      return Re.current.useId();
    }),
    (fn.useImperativeHandle = function (q, ce, Xe) {
      return Re.current.useImperativeHandle(q, ce, Xe);
    }),
    (fn.useInsertionEffect = function (q, ce) {
      return Re.current.useInsertionEffect(q, ce);
    }),
    (fn.useLayoutEffect = function (q, ce) {
      return Re.current.useLayoutEffect(q, ce);
    }),
    (fn.useMemo = function (q, ce) {
      return Re.current.useMemo(q, ce);
    }),
    (fn.useReducer = function (q, ce, Xe) {
      return Re.current.useReducer(q, ce, Xe);
    }),
    (fn.useRef = function (q) {
      return Re.current.useRef(q);
    }),
    (fn.useState = function (q) {
      return Re.current.useState(q);
    }),
    (fn.useSyncExternalStore = function (q, ce, Xe) {
      return Re.current.useSyncExternalStore(q, ce, Xe);
    }),
    (fn.useTransition = function () {
      return Re.current.useTransition();
    }),
    (fn.version = "18.3.1"),
    fn
  );
}
var g4;
function yg() {
  return g4 || ((g4 = 1), (p4.exports = Q6())), p4.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var y4;
function $6() {
  if (y4) return Rf;
  y4 = 1;
  var r = yg(),
    e = Symbol.for("react.element"),
    t = Symbol.for("react.fragment"),
    n = Object.prototype.hasOwnProperty,
    i = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(l, c, d) {
    var p,
      m = {},
      y = null,
      v = null;
    d !== void 0 && (y = "" + d),
      c.key !== void 0 && (y = "" + c.key),
      c.ref !== void 0 && (v = c.ref);
    for (p in c) n.call(c, p) && !s.hasOwnProperty(p) && (m[p] = c[p]);
    if (l && l.defaultProps)
      for (p in ((c = l.defaultProps), c)) m[p] === void 0 && (m[p] = c[p]);
    return {
      $$typeof: e,
      type: l,
      key: y,
      ref: v,
      props: m,
      _owner: i.current,
    };
  }
  return (Rf.Fragment = t), (Rf.jsx = a), (Rf.jsxs = a), Rf;
}
var v4;
function e8() {
  return v4 || ((v4 = 1), (f4.exports = $6())), f4.exports;
}
var H = e8(),
  he = yg();
const t8 = Vv(he);
var c1 = {},
  B2 = { exports: {} },
  os = {},
  x4 = { exports: {} },
  b4 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var _4;
function n8() {
  return (
    _4 ||
      ((_4 = 1),
      (function (r) {
        function e(J, oe) {
          var ae = J.length;
          J.push(oe);
          e: for (; 0 < ae; ) {
            var q = (ae - 1) >>> 1,
              ce = J[q];
            if (0 < i(ce, oe)) (J[q] = oe), (J[ae] = ce), (ae = q);
            else break e;
          }
        }
        function t(J) {
          return J.length === 0 ? null : J[0];
        }
        function n(J) {
          if (J.length === 0) return null;
          var oe = J[0],
            ae = J.pop();
          if (ae !== oe) {
            J[0] = ae;
            e: for (var q = 0, ce = J.length, Xe = ce >>> 1; q < Xe; ) {
              var ye = 2 * (q + 1) - 1,
                Pe = J[ye],
                Ue = ye + 1,
                Fe = J[Ue];
              if (0 > i(Pe, ae))
                Ue < ce && 0 > i(Fe, Pe)
                  ? ((J[q] = Fe), (J[Ue] = ae), (q = Ue))
                  : ((J[q] = Pe), (J[ye] = ae), (q = ye));
              else if (Ue < ce && 0 > i(Fe, ae))
                (J[q] = Fe), (J[Ue] = ae), (q = Ue);
              else break e;
            }
          }
          return oe;
        }
        function i(J, oe) {
          var ae = J.sortIndex - oe.sortIndex;
          return ae !== 0 ? ae : J.id - oe.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          r.unstable_now = function () {
            return s.now();
          };
        } else {
          var a = Date,
            l = a.now();
          r.unstable_now = function () {
            return a.now() - l;
          };
        }
        var c = [],
          d = [],
          p = 1,
          m = null,
          y = 3,
          v = !1,
          A = !1,
          M = !1,
          w = typeof setTimeout == "function" ? setTimeout : null,
          x = typeof clearTimeout == "function" ? clearTimeout : null,
          C = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function T(J) {
          for (var oe = t(d); oe !== null; ) {
            if (oe.callback === null) n(d);
            else if (oe.startTime <= J)
              n(d), (oe.sortIndex = oe.expirationTime), e(c, oe);
            else break;
            oe = t(d);
          }
        }
        function I(J) {
          if (((M = !1), T(J), !A))
            if (t(c) !== null) (A = !0), ge(U);
            else {
              var oe = t(d);
              oe !== null && Re(I, oe.startTime - J);
            }
        }
        function U(J, oe) {
          (A = !1), M && ((M = !1), x(z), (z = -1)), (v = !0);
          var ae = y;
          try {
            for (
              T(oe), m = t(c);
              m !== null && (!(m.expirationTime > oe) || (J && !X()));

            ) {
              var q = m.callback;
              if (typeof q == "function") {
                (m.callback = null), (y = m.priorityLevel);
                var ce = q(m.expirationTime <= oe);
                (oe = r.unstable_now()),
                  typeof ce == "function"
                    ? (m.callback = ce)
                    : m === t(c) && n(c),
                  T(oe);
              } else n(c);
              m = t(c);
            }
            if (m !== null) var Xe = !0;
            else {
              var ye = t(d);
              ye !== null && Re(I, ye.startTime - oe), (Xe = !1);
            }
            return Xe;
          } finally {
            (m = null), (y = ae), (v = !1);
          }
        }
        var F = !1,
          O = null,
          z = -1,
          L = 5,
          N = -1;
        function X() {
          return !(r.unstable_now() - N < L);
        }
        function ie() {
          if (O !== null) {
            var J = r.unstable_now();
            N = J;
            var oe = !0;
            try {
              oe = O(!0, J);
            } finally {
              oe ? re() : ((F = !1), (O = null));
            }
          } else F = !1;
        }
        var re;
        if (typeof C == "function")
          re = function () {
            C(ie);
          };
        else if (typeof MessageChannel < "u") {
          var me = new MessageChannel(),
            _e = me.port2;
          (me.port1.onmessage = ie),
            (re = function () {
              _e.postMessage(null);
            });
        } else
          re = function () {
            w(ie, 0);
          };
        function ge(J) {
          (O = J), F || ((F = !0), re());
        }
        function Re(J, oe) {
          z = w(function () {
            J(r.unstable_now());
          }, oe);
        }
        (r.unstable_IdlePriority = 5),
          (r.unstable_ImmediatePriority = 1),
          (r.unstable_LowPriority = 4),
          (r.unstable_NormalPriority = 3),
          (r.unstable_Profiling = null),
          (r.unstable_UserBlockingPriority = 2),
          (r.unstable_cancelCallback = function (J) {
            J.callback = null;
          }),
          (r.unstable_continueExecution = function () {
            A || v || ((A = !0), ge(U));
          }),
          (r.unstable_forceFrameRate = function (J) {
            0 > J || 125 < J
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
                )
              : (L = 0 < J ? Math.floor(1e3 / J) : 5);
          }),
          (r.unstable_getCurrentPriorityLevel = function () {
            return y;
          }),
          (r.unstable_getFirstCallbackNode = function () {
            return t(c);
          }),
          (r.unstable_next = function (J) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var oe = 3;
                break;
              default:
                oe = y;
            }
            var ae = y;
            y = oe;
            try {
              return J();
            } finally {
              y = ae;
            }
          }),
          (r.unstable_pauseExecution = function () {}),
          (r.unstable_requestPaint = function () {}),
          (r.unstable_runWithPriority = function (J, oe) {
            switch (J) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                J = 3;
            }
            var ae = y;
            y = J;
            try {
              return oe();
            } finally {
              y = ae;
            }
          }),
          (r.unstable_scheduleCallback = function (J, oe, ae) {
            var q = r.unstable_now();
            switch (
              (typeof ae == "object" && ae !== null
                ? ((ae = ae.delay),
                  (ae = typeof ae == "number" && 0 < ae ? q + ae : q))
                : (ae = q),
              J)
            ) {
              case 1:
                var ce = -1;
                break;
              case 2:
                ce = 250;
                break;
              case 5:
                ce = 1073741823;
                break;
              case 4:
                ce = 1e4;
                break;
              default:
                ce = 5e3;
            }
            return (
              (ce = ae + ce),
              (J = {
                id: p++,
                callback: oe,
                priorityLevel: J,
                startTime: ae,
                expirationTime: ce,
                sortIndex: -1,
              }),
              ae > q
                ? ((J.sortIndex = ae),
                  e(d, J),
                  t(c) === null &&
                    J === t(d) &&
                    (M ? (x(z), (z = -1)) : (M = !0), Re(I, ae - q)))
                : ((J.sortIndex = ce), e(c, J), A || v || ((A = !0), ge(U))),
              J
            );
          }),
          (r.unstable_shouldYield = X),
          (r.unstable_wrapCallback = function (J) {
            var oe = y;
            return function () {
              var ae = y;
              y = oe;
              try {
                return J.apply(this, arguments);
              } finally {
                y = ae;
              }
            };
          });
      })(b4)),
    b4
  );
}
var A4;
function r8() {
  return A4 || ((A4 = 1), (x4.exports = n8())), x4.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var w4;
function i8() {
  if (w4) return os;
  w4 = 1;
  var r = yg(),
    e = r8();
  function t(o) {
    for (
      var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + o,
        g = 1;
      g < arguments.length;
      g++
    )
      u += "&args[]=" + encodeURIComponent(arguments[g]);
    return (
      "Minified React error #" +
      o +
      "; visit " +
      u +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var n = new Set(),
    i = {};
  function s(o, u) {
    a(o, u), a(o + "Capture", u);
  }
  function a(o, u) {
    for (i[o] = u, o = 0; o < u.length; o++) n.add(u[o]);
  }
  var l = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    c = Object.prototype.hasOwnProperty,
    d =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    p = {},
    m = {};
  function y(o) {
    return c.call(m, o)
      ? !0
      : c.call(p, o)
        ? !1
        : d.test(o)
          ? (m[o] = !0)
          : ((p[o] = !0), !1);
  }
  function v(o, u, g, _) {
    if (g !== null && g.type === 0) return !1;
    switch (typeof u) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return _
          ? !1
          : g !== null
            ? !g.acceptsBooleans
            : ((o = o.toLowerCase().slice(0, 5)),
              o !== "data-" && o !== "aria-");
      default:
        return !1;
    }
  }
  function A(o, u, g, _) {
    if (u === null || typeof u > "u" || v(o, u, g, _)) return !0;
    if (_) return !1;
    if (g !== null)
      switch (g.type) {
        case 3:
          return !u;
        case 4:
          return u === !1;
        case 5:
          return isNaN(u);
        case 6:
          return isNaN(u) || 1 > u;
      }
    return !1;
  }
  function M(o, u, g, _, E, B, V) {
    (this.acceptsBooleans = u === 2 || u === 3 || u === 4),
      (this.attributeName = _),
      (this.attributeNamespace = E),
      (this.mustUseProperty = g),
      (this.propertyName = o),
      (this.type = u),
      (this.sanitizeURL = B),
      (this.removeEmptyString = V);
  }
  var w = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (o) {
      w[o] = new M(o, 0, !1, o, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (o) {
      var u = o[0];
      w[u] = new M(u, 1, !1, o[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(
      function (o) {
        w[o] = new M(o, 2, !1, o.toLowerCase(), null, !1, !1);
      },
    ),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (o) {
      w[o] = new M(o, 2, !1, o, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (o) {
        w[o] = new M(o, 3, !1, o.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (o) {
      w[o] = new M(o, 3, !0, o, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (o) {
      w[o] = new M(o, 4, !1, o, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (o) {
      w[o] = new M(o, 6, !1, o, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (o) {
      w[o] = new M(o, 5, !1, o.toLowerCase(), null, !1, !1);
    });
  var x = /[\-:]([a-z])/g;
  function C(o) {
    return o[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (o) {
      var u = o.replace(x, C);
      w[u] = new M(u, 1, !1, o, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (o) {
        var u = o.replace(x, C);
        w[u] = new M(u, 1, !1, o, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (o) {
      var u = o.replace(x, C);
      w[u] = new M(u, 1, !1, o, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (o) {
      w[o] = new M(o, 1, !1, o.toLowerCase(), null, !1, !1);
    }),
    (w.xlinkHref = new M(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1,
    )),
    ["src", "href", "action", "formAction"].forEach(function (o) {
      w[o] = new M(o, 1, !1, o.toLowerCase(), null, !0, !0);
    });
  function T(o, u, g, _) {
    var E = w.hasOwnProperty(u) ? w[u] : null;
    (E !== null
      ? E.type !== 0
      : _ ||
        !(2 < u.length) ||
        (u[0] !== "o" && u[0] !== "O") ||
        (u[1] !== "n" && u[1] !== "N")) &&
      (A(u, g, E, _) && (g = null),
      _ || E === null
        ? y(u) &&
          (g === null ? o.removeAttribute(u) : o.setAttribute(u, "" + g))
        : E.mustUseProperty
          ? (o[E.propertyName] = g === null ? (E.type === 3 ? !1 : "") : g)
          : ((u = E.attributeName),
            (_ = E.attributeNamespace),
            g === null
              ? o.removeAttribute(u)
              : ((E = E.type),
                (g = E === 3 || (E === 4 && g === !0) ? "" : "" + g),
                _ ? o.setAttributeNS(_, u, g) : o.setAttribute(u, g))));
  }
  var I = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    U = Symbol.for("react.element"),
    F = Symbol.for("react.portal"),
    O = Symbol.for("react.fragment"),
    z = Symbol.for("react.strict_mode"),
    L = Symbol.for("react.profiler"),
    N = Symbol.for("react.provider"),
    X = Symbol.for("react.context"),
    ie = Symbol.for("react.forward_ref"),
    re = Symbol.for("react.suspense"),
    me = Symbol.for("react.suspense_list"),
    _e = Symbol.for("react.memo"),
    ge = Symbol.for("react.lazy"),
    Re = Symbol.for("react.offscreen"),
    J = Symbol.iterator;
  function oe(o) {
    return o === null || typeof o != "object"
      ? null
      : ((o = (J && o[J]) || o["@@iterator"]),
        typeof o == "function" ? o : null);
  }
  var ae = Object.assign,
    q;
  function ce(o) {
    if (q === void 0)
      try {
        throw Error();
      } catch (g) {
        var u = g.stack.trim().match(/\n( *(at )?)/);
        q = (u && u[1]) || "";
      }
    return (
      `
` +
      q +
      o
    );
  }
  var Xe = !1;
  function ye(o, u) {
    if (!o || Xe) return "";
    Xe = !0;
    var g = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (u)
        if (
          ((u = function () {
            throw Error();
          }),
          Object.defineProperty(u.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(u, []);
          } catch (Ie) {
            var _ = Ie;
          }
          Reflect.construct(o, [], u);
        } else {
          try {
            u.call();
          } catch (Ie) {
            _ = Ie;
          }
          o.call(u.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ie) {
          _ = Ie;
        }
        o();
      }
    } catch (Ie) {
      if (Ie && _ && typeof Ie.stack == "string") {
        for (
          var E = Ie.stack.split(`
`),
            B = _.stack.split(`
`),
            V = E.length - 1,
            ee = B.length - 1;
          1 <= V && 0 <= ee && E[V] !== B[ee];

        )
          ee--;
        for (; 1 <= V && 0 <= ee; V--, ee--)
          if (E[V] !== B[ee]) {
            if (V !== 1 || ee !== 1)
              do
                if ((V--, ee--, 0 > ee || E[V] !== B[ee])) {
                  var ue =
                    `
` + E[V].replace(" at new ", " at ");
                  return (
                    o.displayName &&
                      ue.includes("<anonymous>") &&
                      (ue = ue.replace("<anonymous>", o.displayName)),
                    ue
                  );
                }
              while (1 <= V && 0 <= ee);
            break;
          }
      }
    } finally {
      (Xe = !1), (Error.prepareStackTrace = g);
    }
    return (o = o ? o.displayName || o.name : "") ? ce(o) : "";
  }
  function Pe(o) {
    switch (o.tag) {
      case 5:
        return ce(o.type);
      case 16:
        return ce("Lazy");
      case 13:
        return ce("Suspense");
      case 19:
        return ce("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (o = ye(o.type, !1)), o;
      case 11:
        return (o = ye(o.type.render, !1)), o;
      case 1:
        return (o = ye(o.type, !0)), o;
      default:
        return "";
    }
  }
  function Ue(o) {
    if (o == null) return null;
    if (typeof o == "function") return o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case O:
        return "Fragment";
      case F:
        return "Portal";
      case L:
        return "Profiler";
      case z:
        return "StrictMode";
      case re:
        return "Suspense";
      case me:
        return "SuspenseList";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case X:
          return (o.displayName || "Context") + ".Consumer";
        case N:
          return (o._context.displayName || "Context") + ".Provider";
        case ie:
          var u = o.render;
          return (
            (o = o.displayName),
            o ||
              ((o = u.displayName || u.name || ""),
              (o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef")),
            o
          );
        case _e:
          return (
            (u = o.displayName || null), u !== null ? u : Ue(o.type) || "Memo"
          );
        case ge:
          (u = o._payload), (o = o._init);
          try {
            return Ue(o(u));
          } catch {}
      }
    return null;
  }
  function Fe(o) {
    var u = o.type;
    switch (o.tag) {
      case 24:
        return "Cache";
      case 9:
        return (u.displayName || "Context") + ".Consumer";
      case 10:
        return (u._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (o = u.render),
          (o = o.displayName || o.name || ""),
          u.displayName || (o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return u;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ue(u);
      case 8:
        return u === z ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof u == "function") return u.displayName || u.name || null;
        if (typeof u == "string") return u;
    }
    return null;
  }
  function Je(o) {
    switch (typeof o) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function et(o) {
    var u = o.type;
    return (
      (o = o.nodeName) &&
      o.toLowerCase() === "input" &&
      (u === "checkbox" || u === "radio")
    );
  }
  function tt(o) {
    var u = et(o) ? "checked" : "value",
      g = Object.getOwnPropertyDescriptor(o.constructor.prototype, u),
      _ = "" + o[u];
    if (
      !o.hasOwnProperty(u) &&
      typeof g < "u" &&
      typeof g.get == "function" &&
      typeof g.set == "function"
    ) {
      var E = g.get,
        B = g.set;
      return (
        Object.defineProperty(o, u, {
          configurable: !0,
          get: function () {
            return E.call(this);
          },
          set: function (V) {
            (_ = "" + V), B.call(this, V);
          },
        }),
        Object.defineProperty(o, u, { enumerable: g.enumerable }),
        {
          getValue: function () {
            return _;
          },
          setValue: function (V) {
            _ = "" + V;
          },
          stopTracking: function () {
            (o._valueTracker = null), delete o[u];
          },
        }
      );
    }
  }
  function be(o) {
    o._valueTracker || (o._valueTracker = tt(o));
  }
  function Te(o) {
    if (!o) return !1;
    var u = o._valueTracker;
    if (!u) return !0;
    var g = u.getValue(),
      _ = "";
    return (
      o && (_ = et(o) ? (o.checked ? "true" : "false") : o.value),
      (o = _),
      o !== g ? (u.setValue(o), !0) : !1
    );
  }
  function Ne(o) {
    if (
      ((o = o || (typeof document < "u" ? document : void 0)), typeof o > "u")
    )
      return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  function K(o, u) {
    var g = u.checked;
    return ae({}, u, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: g ?? o._wrapperState.initialChecked,
    });
  }
  function qe(o, u) {
    var g = u.defaultValue == null ? "" : u.defaultValue,
      _ = u.checked != null ? u.checked : u.defaultChecked;
    (g = Je(u.value != null ? u.value : g)),
      (o._wrapperState = {
        initialChecked: _,
        initialValue: g,
        controlled:
          u.type === "checkbox" || u.type === "radio"
            ? u.checked != null
            : u.value != null,
      });
  }
  function ct(o, u) {
    (u = u.checked), u != null && T(o, "checked", u, !1);
  }
  function Be(o, u) {
    ct(o, u);
    var g = Je(u.value),
      _ = u.type;
    if (g != null)
      _ === "number"
        ? ((g === 0 && o.value === "") || o.value != g) && (o.value = "" + g)
        : o.value !== "" + g && (o.value = "" + g);
    else if (_ === "submit" || _ === "reset") {
      o.removeAttribute("value");
      return;
    }
    u.hasOwnProperty("value")
      ? Dt(o, u.type, g)
      : u.hasOwnProperty("defaultValue") && Dt(o, u.type, Je(u.defaultValue)),
      u.checked == null &&
        u.defaultChecked != null &&
        (o.defaultChecked = !!u.defaultChecked);
  }
  function nt(o, u, g) {
    if (u.hasOwnProperty("value") || u.hasOwnProperty("defaultValue")) {
      var _ = u.type;
      if (
        !(
          (_ !== "submit" && _ !== "reset") ||
          (u.value !== void 0 && u.value !== null)
        )
      )
        return;
      (u = "" + o._wrapperState.initialValue),
        g || u === o.value || (o.value = u),
        (o.defaultValue = u);
    }
    (g = o.name),
      g !== "" && (o.name = ""),
      (o.defaultChecked = !!o._wrapperState.initialChecked),
      g !== "" && (o.name = g);
  }
  function Dt(o, u, g) {
    (u !== "number" || Ne(o.ownerDocument) !== o) &&
      (g == null
        ? (o.defaultValue = "" + o._wrapperState.initialValue)
        : o.defaultValue !== "" + g && (o.defaultValue = "" + g));
  }
  var it = Array.isArray;
  function Z(o, u, g, _) {
    if (((o = o.options), u)) {
      u = {};
      for (var E = 0; E < g.length; E++) u["$" + g[E]] = !0;
      for (g = 0; g < o.length; g++)
        (E = u.hasOwnProperty("$" + o[g].value)),
          o[g].selected !== E && (o[g].selected = E),
          E && _ && (o[g].defaultSelected = !0);
    } else {
      for (g = "" + Je(g), u = null, E = 0; E < o.length; E++) {
        if (o[E].value === g) {
          (o[E].selected = !0), _ && (o[E].defaultSelected = !0);
          return;
        }
        u !== null || o[E].disabled || (u = o[E]);
      }
      u !== null && (u.selected = !0);
    }
  }
  function G(o, u) {
    if (u.dangerouslySetInnerHTML != null) throw Error(t(91));
    return ae({}, u, {
      value: void 0,
      defaultValue: void 0,
      children: "" + o._wrapperState.initialValue,
    });
  }
  function xe(o, u) {
    var g = u.value;
    if (g == null) {
      if (((g = u.children), (u = u.defaultValue), g != null)) {
        if (u != null) throw Error(t(92));
        if (it(g)) {
          if (1 < g.length) throw Error(t(93));
          g = g[0];
        }
        u = g;
      }
      u == null && (u = ""), (g = u);
    }
    o._wrapperState = { initialValue: Je(g) };
  }
  function ze(o, u) {
    var g = Je(u.value),
      _ = Je(u.defaultValue);
    g != null &&
      ((g = "" + g),
      g !== o.value && (o.value = g),
      u.defaultValue == null && o.defaultValue !== g && (o.defaultValue = g)),
      _ != null && (o.defaultValue = "" + _);
  }
  function We(o) {
    var u = o.textContent;
    u === o._wrapperState.initialValue &&
      u !== "" &&
      u !== null &&
      (o.value = u);
  }
  function Oe(o) {
    switch (o) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Mt(o, u) {
    return o == null || o === "http://www.w3.org/1999/xhtml"
      ? Oe(u)
      : o === "http://www.w3.org/2000/svg" && u === "foreignObject"
        ? "http://www.w3.org/1999/xhtml"
        : o;
  }
  var ot,
    ft = (function (o) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (u, g, _, E) {
            MSApp.execUnsafeLocalFunction(function () {
              return o(u, g, _, E);
            });
          }
        : o;
    })(function (o, u) {
      if (o.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in o)
        o.innerHTML = u;
      else {
        for (
          ot = ot || document.createElement("div"),
            ot.innerHTML = "<svg>" + u.valueOf().toString() + "</svg>",
            u = ot.firstChild;
          o.firstChild;

        )
          o.removeChild(o.firstChild);
        for (; u.firstChild; ) o.appendChild(u.firstChild);
      }
    });
  function Ot(o, u) {
    if (u) {
      var g = o.firstChild;
      if (g && g === o.lastChild && g.nodeType === 3) {
        g.nodeValue = u;
        return;
      }
    }
    o.textContent = u;
  }
  var Ke = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    ht = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ke).forEach(function (o) {
    ht.forEach(function (u) {
      (u = u + o.charAt(0).toUpperCase() + o.substring(1)), (Ke[u] = Ke[o]);
    });
  });
  function Tt(o, u, g) {
    return u == null || typeof u == "boolean" || u === ""
      ? ""
      : g || typeof u != "number" || u === 0 || (Ke.hasOwnProperty(o) && Ke[o])
        ? ("" + u).trim()
        : u + "px";
  }
  function st(o, u) {
    o = o.style;
    for (var g in u)
      if (u.hasOwnProperty(g)) {
        var _ = g.indexOf("--") === 0,
          E = Tt(g, u[g], _);
        g === "float" && (g = "cssFloat"), _ ? o.setProperty(g, E) : (o[g] = E);
      }
  }
  var xt = ae(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    },
  );
  function Qt(o, u) {
    if (u) {
      if (xt[o] && (u.children != null || u.dangerouslySetInnerHTML != null))
        throw Error(t(137, o));
      if (u.dangerouslySetInnerHTML != null) {
        if (u.children != null) throw Error(t(60));
        if (
          typeof u.dangerouslySetInnerHTML != "object" ||
          !("__html" in u.dangerouslySetInnerHTML)
        )
          throw Error(t(61));
      }
      if (u.style != null && typeof u.style != "object") throw Error(t(62));
    }
  }
  function D(o, u) {
    if (o.indexOf("-") === -1) return typeof u.is == "string";
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var W = null;
  function k(o) {
    return (
      (o = o.target || o.srcElement || window),
      o.correspondingUseElement && (o = o.correspondingUseElement),
      o.nodeType === 3 ? o.parentNode : o
    );
  }
  var ne = null,
    Q = null,
    te = null;
  function Ae(o) {
    if ((o = dr(o))) {
      if (typeof ne != "function") throw Error(t(280));
      var u = o.stateNode;
      u && ((u = cd(u)), ne(o.stateNode, o.type, u));
    }
  }
  function pe(o) {
    Q ? (te ? te.push(o) : (te = [o])) : (Q = o);
  }
  function Ve() {
    if (Q) {
      var o = Q,
        u = te;
      if (((te = Q = null), Ae(o), u)) for (o = 0; o < u.length; o++) Ae(u[o]);
    }
  }
  function He(o, u) {
    return o(u);
  }
  function Qe() {}
  var ke = !1;
  function nn(o, u, g) {
    if (ke) return o(u, g);
    ke = !0;
    try {
      return He(o, u, g);
    } finally {
      (ke = !1), (Q !== null || te !== null) && (Qe(), Ve());
    }
  }
  function vt(o, u) {
    var g = o.stateNode;
    if (g === null) return null;
    var _ = cd(g);
    if (_ === null) return null;
    g = _[u];
    e: switch (u) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (_ = !_.disabled) ||
          ((o = o.type),
          (_ = !(
            o === "button" ||
            o === "input" ||
            o === "select" ||
            o === "textarea"
          ))),
          (o = !_);
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (g && typeof g != "function") throw Error(t(231, u, typeof g));
    return g;
  }
  var It = !1;
  if (l)
    try {
      var Ht = {};
      Object.defineProperty(Ht, "passive", {
        get: function () {
          It = !0;
        },
      }),
        window.addEventListener("test", Ht, Ht),
        window.removeEventListener("test", Ht, Ht);
    } catch {
      It = !1;
    }
  function Wt(o, u, g, _, E, B, V, ee, ue) {
    var Ie = Array.prototype.slice.call(arguments, 3);
    try {
      u.apply(g, Ie);
    } catch (Ze) {
      this.onError(Ze);
    }
  }
  var dn = !1,
    An = null,
    mn = !1,
    Wn = null,
    wn = {
      onError: function (o) {
        (dn = !0), (An = o);
      },
    };
  function Fr(o, u, g, _, E, B, V, ee, ue) {
    (dn = !1), (An = null), Wt.apply(wn, arguments);
  }
  function lr(o, u, g, _, E, B, V, ee, ue) {
    if ((Fr.apply(this, arguments), dn)) {
      if (dn) {
        var Ie = An;
        (dn = !1), (An = null);
      } else throw Error(t(198));
      mn || ((mn = !0), (Wn = Ie));
    }
  }
  function Dn(o) {
    var u = o,
      g = o;
    if (o.alternate) for (; u.return; ) u = u.return;
    else {
      o = u;
      do (u = o), u.flags & 4098 && (g = u.return), (o = u.return);
      while (o);
    }
    return u.tag === 3 ? g : null;
  }
  function hi(o) {
    if (o.tag === 13) {
      var u = o.memoizedState;
      if (
        (u === null && ((o = o.alternate), o !== null && (u = o.memoizedState)),
        u !== null)
      )
        return u.dehydrated;
    }
    return null;
  }
  function ps(o) {
    if (Dn(o) !== o) throw Error(t(188));
  }
  function jr(o) {
    var u = o.alternate;
    if (!u) {
      if (((u = Dn(o)), u === null)) throw Error(t(188));
      return u !== o ? null : o;
    }
    for (var g = o, _ = u; ; ) {
      var E = g.return;
      if (E === null) break;
      var B = E.alternate;
      if (B === null) {
        if (((_ = E.return), _ !== null)) {
          g = _;
          continue;
        }
        break;
      }
      if (E.child === B.child) {
        for (B = E.child; B; ) {
          if (B === g) return ps(E), o;
          if (B === _) return ps(E), u;
          B = B.sibling;
        }
        throw Error(t(188));
      }
      if (g.return !== _.return) (g = E), (_ = B);
      else {
        for (var V = !1, ee = E.child; ee; ) {
          if (ee === g) {
            (V = !0), (g = E), (_ = B);
            break;
          }
          if (ee === _) {
            (V = !0), (_ = E), (g = B);
            break;
          }
          ee = ee.sibling;
        }
        if (!V) {
          for (ee = B.child; ee; ) {
            if (ee === g) {
              (V = !0), (g = B), (_ = E);
              break;
            }
            if (ee === _) {
              (V = !0), (_ = B), (g = E);
              break;
            }
            ee = ee.sibling;
          }
          if (!V) throw Error(t(189));
        }
      }
      if (g.alternate !== _) throw Error(t(190));
    }
    if (g.tag !== 3) throw Error(t(188));
    return g.stateNode.current === g ? o : u;
  }
  function Fn(o) {
    return (o = jr(o)), o !== null ? Zn(o) : null;
  }
  function Zn(o) {
    if (o.tag === 5 || o.tag === 6) return o;
    for (o = o.child; o !== null; ) {
      var u = Zn(o);
      if (u !== null) return u;
      o = o.sibling;
    }
    return null;
  }
  var j = e.unstable_scheduleCallback,
    le = e.unstable_cancelCallback,
    Me = e.unstable_shouldYield,
    Ee = e.unstable_requestPaint,
    se = e.unstable_now,
    Ge = e.unstable_getCurrentPriorityLevel,
    pt = e.unstable_ImmediatePriority,
    _t = e.unstable_UserBlockingPriority,
    St = e.unstable_NormalPriority,
    zt = e.unstable_LowPriority,
    Ut = e.unstable_IdlePriority,
    gt = null,
    At = null;
  function hn(o) {
    if (At && typeof At.onCommitFiberRoot == "function")
      try {
        At.onCommitFiberRoot(gt, o, void 0, (o.current.flags & 128) === 128);
      } catch {}
  }
  var Jt = Math.clz32 ? Math.clz32 : Ft,
    $t = Math.log,
    gn = Math.LN2;
  function Ft(o) {
    return (o >>>= 0), o === 0 ? 32 : (31 - (($t(o) / gn) | 0)) | 0;
  }
  var vn = 64,
    $r = 4194304;
  function Mr(o) {
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return o & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return o;
    }
  }
  function Yi(o, u) {
    var g = o.pendingLanes;
    if (g === 0) return 0;
    var _ = 0,
      E = o.suspendedLanes,
      B = o.pingedLanes,
      V = g & 268435455;
    if (V !== 0) {
      var ee = V & ~E;
      ee !== 0 ? (_ = Mr(ee)) : ((B &= V), B !== 0 && (_ = Mr(B)));
    } else (V = g & ~E), V !== 0 ? (_ = Mr(V)) : B !== 0 && (_ = Mr(B));
    if (_ === 0) return 0;
    if (
      u !== 0 &&
      u !== _ &&
      !(u & E) &&
      ((E = _ & -_), (B = u & -u), E >= B || (E === 16 && (B & 4194240) !== 0))
    )
      return u;
    if ((_ & 4 && (_ |= g & 16), (u = o.entangledLanes), u !== 0))
      for (o = o.entanglements, u &= _; 0 < u; )
        (g = 31 - Jt(u)), (E = 1 << g), (_ |= o[g]), (u &= ~E);
    return _;
  }
  function Sr(o, u) {
    switch (o) {
      case 1:
      case 2:
      case 4:
        return u + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ra(o, u) {
    for (
      var g = o.suspendedLanes,
        _ = o.pingedLanes,
        E = o.expirationTimes,
        B = o.pendingLanes;
      0 < B;

    ) {
      var V = 31 - Jt(B),
        ee = 1 << V,
        ue = E[V];
      ue === -1
        ? (!(ee & g) || ee & _) && (E[V] = Sr(ee, u))
        : ue <= u && (o.expiredLanes |= ee),
        (B &= ~ee);
    }
  }
  function cn(o) {
    return (
      (o = o.pendingLanes & -1073741825),
      o !== 0 ? o : o & 1073741824 ? 1073741824 : 0
    );
  }
  function ei() {
    var o = vn;
    return (vn <<= 1), !(vn & 4194240) && (vn = 64), o;
  }
  function Wr(o) {
    for (var u = [], g = 0; 31 > g; g++) u.push(o);
    return u;
  }
  function Kn(o, u, g) {
    (o.pendingLanes |= u),
      u !== 536870912 && ((o.suspendedLanes = 0), (o.pingedLanes = 0)),
      (o = o.eventTimes),
      (u = 31 - Jt(u)),
      (o[u] = g);
  }
  function Xr(o, u) {
    var g = o.pendingLanes & ~u;
    (o.pendingLanes = u),
      (o.suspendedLanes = 0),
      (o.pingedLanes = 0),
      (o.expiredLanes &= u),
      (o.mutableReadLanes &= u),
      (o.entangledLanes &= u),
      (u = o.entanglements);
    var _ = o.eventTimes;
    for (o = o.expirationTimes; 0 < g; ) {
      var E = 31 - Jt(g),
        B = 1 << E;
      (u[E] = 0), (_[E] = -1), (o[E] = -1), (g &= ~B);
    }
  }
  function Ts(o, u) {
    var g = (o.entangledLanes |= u);
    for (o = o.entanglements; g; ) {
      var _ = 31 - Jt(g),
        E = 1 << _;
      (E & u) | (o[_] & u) && (o[_] |= u), (g &= ~E);
    }
  }
  var rn = 0;
  function $l(o) {
    return (
      (o &= -o), 1 < o ? (4 < o ? (o & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var fm,
    Ih,
    Xc,
    Jc,
    $o,
    Bh = !1,
    el = [],
    ln = null,
    Zs = null,
    Rs = null,
    tl = new Map(),
    eu = new Map(),
    Ia = [],
    Er =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " ",
      );
  function Yc(o, u) {
    switch (o) {
      case "focusin":
      case "focusout":
        ln = null;
        break;
      case "dragenter":
      case "dragleave":
        Zs = null;
        break;
      case "mouseover":
      case "mouseout":
        Rs = null;
        break;
      case "pointerover":
      case "pointerout":
        tl.delete(u.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        eu.delete(u.pointerId);
    }
  }
  function tu(o, u, g, _, E, B) {
    return o === null || o.nativeEvent !== B
      ? ((o = {
          blockedOn: u,
          domEventName: g,
          eventSystemFlags: _,
          nativeEvent: B,
          targetContainers: [E],
        }),
        u !== null && ((u = dr(u)), u !== null && Ih(u)),
        o)
      : ((o.eventSystemFlags |= _),
        (u = o.targetContainers),
        E !== null && u.indexOf(E) === -1 && u.push(E),
        o);
  }
  function Ph(o, u, g, _, E) {
    switch (u) {
      case "focusin":
        return (ln = tu(ln, o, u, g, _, E)), !0;
      case "dragenter":
        return (Zs = tu(Zs, o, u, g, _, E)), !0;
      case "mouseover":
        return (Rs = tu(Rs, o, u, g, _, E)), !0;
      case "pointerover":
        var B = E.pointerId;
        return tl.set(B, tu(tl.get(B) || null, o, u, g, _, E)), !0;
      case "gotpointercapture":
        return (
          (B = E.pointerId), eu.set(B, tu(eu.get(B) || null, o, u, g, _, E)), !0
        );
    }
    return !1;
  }
  function pm(o) {
    var u = vs(o.target);
    if (u !== null) {
      var g = Dn(u);
      if (g !== null) {
        if (((u = g.tag), u === 13)) {
          if (((u = hi(g)), u !== null)) {
            (o.blockedOn = u),
              $o(o.priority, function () {
                Xc(g);
              });
            return;
          }
        } else if (u === 3 && g.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = g.tag === 3 ? g.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function lo(o) {
    if (o.blockedOn !== null) return !1;
    for (var u = o.targetContainers; 0 < u.length; ) {
      var g = Fh(o.domEventName, o.eventSystemFlags, u[0], o.nativeEvent);
      if (g === null) {
        g = o.nativeEvent;
        var _ = new g.constructor(g.type, g);
        (W = _), g.target.dispatchEvent(_), (W = null);
      } else return (u = dr(g)), u !== null && Ih(u), (o.blockedOn = g), !1;
      u.shift();
    }
    return !0;
  }
  function ms(o, u, g) {
    lo(o) && g.delete(u);
  }
  function a2() {
    (Bh = !1),
      ln !== null && lo(ln) && (ln = null),
      Zs !== null && lo(Zs) && (Zs = null),
      Rs !== null && lo(Rs) && (Rs = null),
      tl.forEach(ms),
      eu.forEach(ms);
  }
  function nu(o, u) {
    o.blockedOn === u &&
      ((o.blockedOn = null),
      Bh ||
        ((Bh = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, a2)));
  }
  function fi(o) {
    function u(E) {
      return nu(E, o);
    }
    if (0 < el.length) {
      nu(el[0], o);
      for (var g = 1; g < el.length; g++) {
        var _ = el[g];
        _.blockedOn === o && (_.blockedOn = null);
      }
    }
    for (
      ln !== null && nu(ln, o),
        Zs !== null && nu(Zs, o),
        Rs !== null && nu(Rs, o),
        tl.forEach(u),
        eu.forEach(u),
        g = 0;
      g < Ia.length;
      g++
    )
      (_ = Ia[g]), _.blockedOn === o && (_.blockedOn = null);
    for (; 0 < Ia.length && ((g = Ia[0]), g.blockedOn === null); )
      pm(g), g.blockedOn === null && Ia.shift();
  }
  var pi = I.ReactCurrentBatchConfig,
    uo = !0;
  function Lh(o, u, g, _) {
    var E = rn,
      B = pi.transition;
    pi.transition = null;
    try {
      (rn = 1), Dh(o, u, g, _);
    } finally {
      (rn = E), (pi.transition = B);
    }
  }
  function mm(o, u, g, _) {
    var E = rn,
      B = pi.transition;
    pi.transition = null;
    try {
      (rn = 4), Dh(o, u, g, _);
    } finally {
      (rn = E), (pi.transition = B);
    }
  }
  function Dh(o, u, g, _) {
    if (uo) {
      var E = Fh(o, u, g, _);
      if (E === null) od(o, u, _, Bi, g), Yc(o, _);
      else if (Ph(E, o, u, g, _)) _.stopPropagation();
      else if ((Yc(o, _), u & 4 && -1 < Er.indexOf(o))) {
        for (; E !== null; ) {
          var B = dr(E);
          if (
            (B !== null && fm(B),
            (B = Fh(o, u, g, _)),
            B === null && od(o, u, _, Bi, g),
            B === E)
          )
            break;
          E = B;
        }
        E !== null && _.stopPropagation();
      } else od(o, u, _, null, g);
    }
  }
  var Bi = null;
  function Fh(o, u, g, _) {
    if (((Bi = null), (o = k(_)), (o = vs(o)), o !== null))
      if (((u = Dn(o)), u === null)) o = null;
      else if (((g = u.tag), g === 13)) {
        if (((o = hi(u)), o !== null)) return o;
        o = null;
      } else if (g === 3) {
        if (u.stateNode.current.memoizedState.isDehydrated)
          return u.tag === 3 ? u.stateNode.containerInfo : null;
        o = null;
      } else u !== o && (o = null);
    return (Bi = o), null;
  }
  function ru(o) {
    switch (o) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Ge()) {
          case pt:
            return 1;
          case _t:
            return 4;
          case St:
          case zt:
            return 16;
          case Ut:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ba = null,
    Pi = null,
    co = null;
  function iu() {
    if (co) return co;
    var o,
      u = Pi,
      g = u.length,
      _,
      E = "value" in Ba ? Ba.value : Ba.textContent,
      B = E.length;
    for (o = 0; o < g && u[o] === E[o]; o++);
    var V = g - o;
    for (_ = 1; _ <= V && u[g - _] === E[B - _]; _++);
    return (co = E.slice(o, 1 < _ ? 1 - _ : void 0));
  }
  function qs(o) {
    var u = o.keyCode;
    return (
      "charCode" in o
        ? ((o = o.charCode), o === 0 && u === 13 && (o = 13))
        : (o = u),
      o === 10 && (o = 13),
      32 <= o || o === 13 ? o : 0
    );
  }
  function nl() {
    return !0;
  }
  function Zc() {
    return !1;
  }
  function mi(o) {
    function u(g, _, E, B, V) {
      (this._reactName = g),
        (this._targetInst = E),
        (this.type = _),
        (this.nativeEvent = B),
        (this.target = V),
        (this.currentTarget = null);
      for (var ee in o)
        o.hasOwnProperty(ee) && ((g = o[ee]), (this[ee] = g ? g(B) : B[ee]));
      return (
        (this.isDefaultPrevented = (
          B.defaultPrevented != null ? B.defaultPrevented : B.returnValue === !1
        )
          ? nl
          : Zc),
        (this.isPropagationStopped = Zc),
        this
      );
    }
    return (
      ae(u.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var g = this.nativeEvent;
          g &&
            (g.preventDefault
              ? g.preventDefault()
              : typeof g.returnValue != "unknown" && (g.returnValue = !1),
            (this.isDefaultPrevented = nl));
        },
        stopPropagation: function () {
          var g = this.nativeEvent;
          g &&
            (g.stopPropagation
              ? g.stopPropagation()
              : typeof g.cancelBubble != "unknown" && (g.cancelBubble = !0),
            (this.isPropagationStopped = nl));
        },
        persist: function () {},
        isPersistent: nl,
      }),
      u
    );
  }
  var Pa = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (o) {
        return o.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    su = mi(Pa),
    Is = ae({}, Pa, { view: 0, detail: 0 }),
    Zi = mi(Is),
    qi,
    Bs,
    ho,
    au = ae({}, Is, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: al,
      button: 0,
      buttons: 0,
      relatedTarget: function (o) {
        return o.relatedTarget === void 0
          ? o.fromElement === o.srcElement
            ? o.toElement
            : o.fromElement
          : o.relatedTarget;
      },
      movementX: function (o) {
        return "movementX" in o
          ? o.movementX
          : (o !== ho &&
              (ho && o.type === "mousemove"
                ? ((qi = o.screenX - ho.screenX), (Bs = o.screenY - ho.screenY))
                : (Bs = qi = 0),
              (ho = o)),
            qi);
      },
      movementY: function (o) {
        return "movementY" in o ? o.movementY : Bs;
      },
    }),
    Ps = mi(au),
    La = ae({}, au, { dataTransfer: 0 }),
    qc = mi(La),
    gm = ae({}, Is, { relatedTarget: 0 }),
    rl = mi(gm),
    ym = ae({}, Pa, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    vm = mi(ym),
    Nh = ae({}, Pa, {
      clipboardData: function (o) {
        return "clipboardData" in o ? o.clipboardData : window.clipboardData;
      },
    }),
    Kc = mi(Nh),
    xm = ae({}, Pa, { data: 0 }),
    Uh = mi(xm),
    bm = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    Oh = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    il = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function sl(o) {
    var u = this.nativeEvent;
    return u.getModifierState
      ? u.getModifierState(o)
      : (o = il[o])
        ? !!u[o]
        : !1;
  }
  function al() {
    return sl;
  }
  var Qc = ae({}, Is, {
      key: function (o) {
        if (o.key) {
          var u = bm[o.key] || o.key;
          if (u !== "Unidentified") return u;
        }
        return o.type === "keypress"
          ? ((o = qs(o)), o === 13 ? "Enter" : String.fromCharCode(o))
          : o.type === "keydown" || o.type === "keyup"
            ? Oh[o.keyCode] || "Unidentified"
            : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: al,
      charCode: function (o) {
        return o.type === "keypress" ? qs(o) : 0;
      },
      keyCode: function (o) {
        return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
      },
      which: function (o) {
        return o.type === "keypress"
          ? qs(o)
          : o.type === "keydown" || o.type === "keyup"
            ? o.keyCode
            : 0;
      },
    }),
    Ki = mi(Qc),
    Qi = ae({}, au, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Da = mi(Qi),
    Ks = ae({}, Is, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: al,
    }),
    Qs = mi(Ks),
    fo = ae({}, Pa, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    _m = mi(fo),
    kh = ae({}, au, {
      deltaX: function (o) {
        return "deltaX" in o
          ? o.deltaX
          : "wheelDeltaX" in o
            ? -o.wheelDeltaX
            : 0;
      },
      deltaY: function (o) {
        return "deltaY" in o
          ? o.deltaY
          : "wheelDeltaY" in o
            ? -o.wheelDeltaY
            : "wheelDelta" in o
              ? -o.wheelDelta
              : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    zh = mi(kh),
    Li = [9, 13, 27, 32],
    ti = l && "CompositionEvent" in window,
    On = null;
  l && "documentMode" in document && (On = document.documentMode);
  var ou = l && "TextEvent" in window && !On,
    $i = l && (!ti || (On && 8 < On && 11 >= On)),
    Hh = " ",
    Vh = !1;
  function $c(o, u) {
    switch (o) {
      case "keyup":
        return Li.indexOf(u.keyCode) !== -1;
      case "keydown":
        return u.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function ed(o) {
    return (o = o.detail), typeof o == "object" && "data" in o ? o.data : null;
  }
  var po = !1;
  function lu(o, u) {
    switch (o) {
      case "compositionend":
        return ed(u);
      case "keypress":
        return u.which !== 32 ? null : ((Vh = !0), Hh);
      case "textInput":
        return (o = u.data), o === Hh && Vh ? null : o;
      default:
        return null;
    }
  }
  function ol(o, u) {
    if (po)
      return o === "compositionend" || (!ti && $c(o, u))
        ? ((o = iu()), (co = Pi = Ba = null), (po = !1), o)
        : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(u.ctrlKey || u.altKey || u.metaKey) || (u.ctrlKey && u.altKey)) {
          if (u.char && 1 < u.char.length) return u.char;
          if (u.which) return String.fromCharCode(u.which);
        }
        return null;
      case "compositionend":
        return $i && u.locale !== "ko" ? null : u.data;
      default:
        return null;
    }
  }
  var Gh = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function ll(o) {
    var u = o && o.nodeName && o.nodeName.toLowerCase();
    return u === "input" ? !!Gh[o.type] : u === "textarea";
  }
  function uu(o, u, g, _) {
    pe(_),
      (u = vu(u, "onChange")),
      0 < u.length &&
        ((g = new su("onChange", "change", null, g, _)),
        o.push({ event: g, listeners: u }));
  }
  var ul = null,
    cl = null;
  function dl(o) {
    $h(o, 0);
  }
  function cu(o) {
    var u = gl(o);
    if (Te(u)) return o;
  }
  function du(o, u) {
    if (o === "change") return u;
  }
  var Di = !1;
  if (l) {
    var mo;
    if (l) {
      var Fa = "oninput" in document;
      if (!Fa) {
        var gs = document.createElement("div");
        gs.setAttribute("oninput", "return;"),
          (Fa = typeof gs.oninput == "function");
      }
      mo = Fa;
    } else mo = !1;
    Di = mo && (!document.documentMode || 9 < document.documentMode);
  }
  function td() {
    ul && (ul.detachEvent("onpropertychange", go), (cl = ul = null));
  }
  function go(o) {
    if (o.propertyName === "value" && cu(cl)) {
      var u = [];
      uu(u, cl, o, k(o)), nn(dl, u);
    }
  }
  function Am(o, u, g) {
    o === "focusin"
      ? (td(), (ul = u), (cl = g), ul.attachEvent("onpropertychange", go))
      : o === "focusout" && td();
  }
  function jh(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return cu(cl);
  }
  function Qn(o, u) {
    if (o === "click") return cu(u);
  }
  function nd(o, u) {
    if (o === "input" || o === "change") return cu(u);
  }
  function Wh(o, u) {
    return (o === u && (o !== 0 || 1 / o === 1 / u)) || (o !== o && u !== u);
  }
  var Fi = typeof Object.is == "function" ? Object.is : Wh;
  function Na(o, u) {
    if (Fi(o, u)) return !0;
    if (
      typeof o != "object" ||
      o === null ||
      typeof u != "object" ||
      u === null
    )
      return !1;
    var g = Object.keys(o),
      _ = Object.keys(u);
    if (g.length !== _.length) return !1;
    for (_ = 0; _ < g.length; _++) {
      var E = g[_];
      if (!c.call(u, E) || !Fi(o[E], u[E])) return !1;
    }
    return !0;
  }
  function Ni(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function yo(o, u) {
    var g = Ni(o);
    o = 0;
    for (var _; g; ) {
      if (g.nodeType === 3) {
        if (((_ = o + g.textContent.length), o <= u && _ >= u))
          return { node: g, offset: u - o };
        o = _;
      }
      e: {
        for (; g; ) {
          if (g.nextSibling) {
            g = g.nextSibling;
            break e;
          }
          g = g.parentNode;
        }
        g = void 0;
      }
      g = Ni(g);
    }
  }
  function $n(o, u) {
    return o && u
      ? o === u
        ? !0
        : o && o.nodeType === 3
          ? !1
          : u && u.nodeType === 3
            ? $n(o, u.parentNode)
            : "contains" in o
              ? o.contains(u)
              : o.compareDocumentPosition
                ? !!(o.compareDocumentPosition(u) & 16)
                : !1
      : !1;
  }
  function Nr() {
    for (var o = window, u = Ne(); u instanceof o.HTMLIFrameElement; ) {
      try {
        var g = typeof u.contentWindow.location.href == "string";
      } catch {
        g = !1;
      }
      if (g) o = u.contentWindow;
      else break;
      u = Ne(o.document);
    }
    return u;
  }
  function ur(o) {
    var u = o && o.nodeName && o.nodeName.toLowerCase();
    return (
      u &&
      ((u === "input" &&
        (o.type === "text" ||
          o.type === "search" ||
          o.type === "tel" ||
          o.type === "url" ||
          o.type === "password")) ||
        u === "textarea" ||
        o.contentEditable === "true")
    );
  }
  function rd(o) {
    var u = Nr(),
      g = o.focusedElem,
      _ = o.selectionRange;
    if (
      u !== g &&
      g &&
      g.ownerDocument &&
      $n(g.ownerDocument.documentElement, g)
    ) {
      if (_ !== null && ur(g)) {
        if (
          ((u = _.start),
          (o = _.end),
          o === void 0 && (o = u),
          "selectionStart" in g)
        )
          (g.selectionStart = u),
            (g.selectionEnd = Math.min(o, g.value.length));
        else if (
          ((o = ((u = g.ownerDocument || document) && u.defaultView) || window),
          o.getSelection)
        ) {
          o = o.getSelection();
          var E = g.textContent.length,
            B = Math.min(_.start, E);
          (_ = _.end === void 0 ? B : Math.min(_.end, E)),
            !o.extend && B > _ && ((E = _), (_ = B), (B = E)),
            (E = yo(g, B));
          var V = yo(g, _);
          E &&
            V &&
            (o.rangeCount !== 1 ||
              o.anchorNode !== E.node ||
              o.anchorOffset !== E.offset ||
              o.focusNode !== V.node ||
              o.focusOffset !== V.offset) &&
            ((u = u.createRange()),
            u.setStart(E.node, E.offset),
            o.removeAllRanges(),
            B > _
              ? (o.addRange(u), o.extend(V.node, V.offset))
              : (u.setEnd(V.node, V.offset), o.addRange(u)));
        }
      }
      for (u = [], o = g; (o = o.parentNode); )
        o.nodeType === 1 &&
          u.push({ element: o, left: o.scrollLeft, top: o.scrollTop });
      for (typeof g.focus == "function" && g.focus(), g = 0; g < u.length; g++)
        (o = u[g]),
          (o.element.scrollLeft = o.left),
          (o.element.scrollTop = o.top);
    }
  }
  var hu = l && "documentMode" in document && 11 >= document.documentMode,
    Ls = null,
    Xh = null,
    cr = null,
    fu = !1;
  function id(o, u, g) {
    var _ =
      g.window === g ? g.document : g.nodeType === 9 ? g : g.ownerDocument;
    fu ||
      Ls == null ||
      Ls !== Ne(_) ||
      ((_ = Ls),
      "selectionStart" in _ && ur(_)
        ? (_ = { start: _.selectionStart, end: _.selectionEnd })
        : ((_ = (
            (_.ownerDocument && _.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (_ = {
            anchorNode: _.anchorNode,
            anchorOffset: _.anchorOffset,
            focusNode: _.focusNode,
            focusOffset: _.focusOffset,
          })),
      (cr && Na(cr, _)) ||
        ((cr = _),
        (_ = vu(Xh, "onSelect")),
        0 < _.length &&
          ((u = new su("onSelect", "select", null, u, g)),
          o.push({ event: u, listeners: _ }),
          (u.target = Ls))));
  }
  function hl(o, u) {
    var g = {};
    return (
      (g[o.toLowerCase()] = u.toLowerCase()),
      (g["Webkit" + o] = "webkit" + u),
      (g["Moz" + o] = "moz" + u),
      g
    );
  }
  var gi = {
      animationend: hl("Animation", "AnimationEnd"),
      animationiteration: hl("Animation", "AnimationIteration"),
      animationstart: hl("Animation", "AnimationStart"),
      transitionend: hl("Transition", "TransitionEnd"),
    },
    es = {},
    Ua = {};
  l &&
    ((Ua = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete gi.animationend.animation,
      delete gi.animationiteration.animation,
      delete gi.animationstart.animation),
    "TransitionEvent" in window || delete gi.transitionend.transition);
  function vo(o) {
    if (es[o]) return es[o];
    if (!gi[o]) return o;
    var u = gi[o],
      g;
    for (g in u) if (u.hasOwnProperty(g) && g in Ua) return (es[o] = u[g]);
    return o;
  }
  var pu = vo("animationend"),
    Jh = vo("animationiteration"),
    Yh = vo("animationstart"),
    Zh = vo("transitionend"),
    qh = new Map(),
    Kh =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " ",
      );
  function $s(o, u) {
    qh.set(o, u), s(u, [o]);
  }
  for (var mu = 0; mu < Kh.length; mu++) {
    var xo = Kh[mu],
      wm = xo.toLowerCase(),
      sd = xo[0].toUpperCase() + xo.slice(1);
    $s(wm, "on" + sd);
  }
  $s(pu, "onAnimationEnd"),
    $s(Jh, "onAnimationIteration"),
    $s(Yh, "onAnimationStart"),
    $s("dblclick", "onDoubleClick"),
    $s("focusin", "onFocus"),
    $s("focusout", "onBlur"),
    $s(Zh, "onTransitionEnd"),
    a("onMouseEnter", ["mouseout", "mouseover"]),
    a("onMouseLeave", ["mouseout", "mouseover"]),
    a("onPointerEnter", ["pointerout", "pointerover"]),
    a("onPointerLeave", ["pointerout", "pointerover"]),
    s(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " ",
      ),
    ),
    s(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " ",
      ),
    ),
    s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    s(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" "),
    ),
    s(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" "),
    ),
    s(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" "),
    );
  var Oa =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " ",
      ),
    Qh = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(Oa),
    );
  function fl(o, u, g) {
    var _ = o.type || "unknown-event";
    (o.currentTarget = g), lr(_, u, void 0, o), (o.currentTarget = null);
  }
  function $h(o, u) {
    u = (u & 4) !== 0;
    for (var g = 0; g < o.length; g++) {
      var _ = o[g],
        E = _.event;
      _ = _.listeners;
      e: {
        var B = void 0;
        if (u)
          for (var V = _.length - 1; 0 <= V; V--) {
            var ee = _[V],
              ue = ee.instance,
              Ie = ee.currentTarget;
            if (((ee = ee.listener), ue !== B && E.isPropagationStopped()))
              break e;
            fl(E, ee, Ie), (B = ue);
          }
        else
          for (V = 0; V < _.length; V++) {
            if (
              ((ee = _[V]),
              (ue = ee.instance),
              (Ie = ee.currentTarget),
              (ee = ee.listener),
              ue !== B && E.isPropagationStopped())
            )
              break e;
            fl(E, ee, Ie), (B = ue);
          }
      }
    }
    if (mn) throw ((o = Wn), (mn = !1), (Wn = null), o);
  }
  function Vn(o, u) {
    var g = u[ml];
    g === void 0 && (g = u[ml] = new Set());
    var _ = o + "__bubble";
    g.has(_) || (ef(u, o, 2, !1), g.add(_));
  }
  function ad(o, u, g) {
    var _ = 0;
    u && (_ |= 4), ef(g, o, _, u);
  }
  var gu = "_reactListening" + Math.random().toString(36).slice(2);
  function bo(o) {
    if (!o[gu]) {
      (o[gu] = !0),
        n.forEach(function (g) {
          g !== "selectionchange" && (Qh.has(g) || ad(g, !1, o), ad(g, !0, o));
        });
      var u = o.nodeType === 9 ? o : o.ownerDocument;
      u === null || u[gu] || ((u[gu] = !0), ad("selectionchange", !1, u));
    }
  }
  function ef(o, u, g, _) {
    switch (ru(u)) {
      case 1:
        var E = Lh;
        break;
      case 4:
        E = mm;
        break;
      default:
        E = Dh;
    }
    (g = E.bind(null, u, g, o)),
      (E = void 0),
      !It ||
        (u !== "touchstart" && u !== "touchmove" && u !== "wheel") ||
        (E = !0),
      _
        ? E !== void 0
          ? o.addEventListener(u, g, { capture: !0, passive: E })
          : o.addEventListener(u, g, !0)
        : E !== void 0
          ? o.addEventListener(u, g, { passive: E })
          : o.addEventListener(u, g, !1);
  }
  function od(o, u, g, _, E) {
    var B = _;
    if (!(u & 1) && !(u & 2) && _ !== null)
      e: for (;;) {
        if (_ === null) return;
        var V = _.tag;
        if (V === 3 || V === 4) {
          var ee = _.stateNode.containerInfo;
          if (ee === E || (ee.nodeType === 8 && ee.parentNode === E)) break;
          if (V === 4)
            for (V = _.return; V !== null; ) {
              var ue = V.tag;
              if (
                (ue === 3 || ue === 4) &&
                ((ue = V.stateNode.containerInfo),
                ue === E || (ue.nodeType === 8 && ue.parentNode === E))
              )
                return;
              V = V.return;
            }
          for (; ee !== null; ) {
            if (((V = vs(ee)), V === null)) return;
            if (((ue = V.tag), ue === 5 || ue === 6)) {
              _ = B = V;
              continue e;
            }
            ee = ee.parentNode;
          }
        }
        _ = _.return;
      }
    nn(function () {
      var Ie = B,
        Ze = k(g),
        $e = [];
      e: {
        var Ye = qh.get(o);
        if (Ye !== void 0) {
          var wt = su,
            Rt = o;
          switch (o) {
            case "keypress":
              if (qs(g) === 0) break e;
            case "keydown":
            case "keyup":
              wt = Ki;
              break;
            case "focusin":
              (Rt = "focus"), (wt = rl);
              break;
            case "focusout":
              (Rt = "blur"), (wt = rl);
              break;
            case "beforeblur":
            case "afterblur":
              wt = rl;
              break;
            case "click":
              if (g.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              wt = Ps;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              wt = qc;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              wt = Qs;
              break;
            case pu:
            case Jh:
            case Yh:
              wt = vm;
              break;
            case Zh:
              wt = _m;
              break;
            case "scroll":
              wt = Zi;
              break;
            case "wheel":
              wt = zh;
              break;
            case "copy":
            case "cut":
            case "paste":
              wt = Kc;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              wt = Da;
          }
          var Bt = (u & 4) !== 0,
            xr = !Bt && o === "scroll",
            we = Bt ? (Ye !== null ? Ye + "Capture" : null) : Ye;
          Bt = [];
          for (var de = Ie, Se; de !== null; ) {
            Se = de;
            var at = Se.stateNode;
            if (
              (Se.tag === 5 &&
                at !== null &&
                ((Se = at),
                we !== null &&
                  ((at = vt(de, we)), at != null && Bt.push(yu(de, at, Se)))),
              xr)
            )
              break;
            de = de.return;
          }
          0 < Bt.length &&
            ((Ye = new wt(Ye, Rt, null, g, Ze)),
            $e.push({ event: Ye, listeners: Bt }));
        }
      }
      if (!(u & 7)) {
        e: {
          if (
            ((Ye = o === "mouseover" || o === "pointerover"),
            (wt = o === "mouseout" || o === "pointerout"),
            Ye &&
              g !== W &&
              (Rt = g.relatedTarget || g.fromElement) &&
              (vs(Rt) || Rt[Ui]))
          )
            break e;
          if (
            (wt || Ye) &&
            ((Ye =
              Ze.window === Ze
                ? Ze
                : (Ye = Ze.ownerDocument)
                  ? Ye.defaultView || Ye.parentWindow
                  : window),
            wt
              ? ((Rt = g.relatedTarget || g.toElement),
                (wt = Ie),
                (Rt = Rt ? vs(Rt) : null),
                Rt !== null &&
                  ((xr = Dn(Rt)),
                  Rt !== xr || (Rt.tag !== 5 && Rt.tag !== 6)) &&
                  (Rt = null))
              : ((wt = null), (Rt = Ie)),
            wt !== Rt)
          ) {
            if (
              ((Bt = Ps),
              (at = "onMouseLeave"),
              (we = "onMouseEnter"),
              (de = "mouse"),
              (o === "pointerout" || o === "pointerover") &&
                ((Bt = Da),
                (at = "onPointerLeave"),
                (we = "onPointerEnter"),
                (de = "pointer")),
              (xr = wt == null ? Ye : gl(wt)),
              (Se = Rt == null ? Ye : gl(Rt)),
              (Ye = new Bt(at, de + "leave", wt, g, Ze)),
              (Ye.target = xr),
              (Ye.relatedTarget = Se),
              (at = null),
              vs(Ze) === Ie &&
                ((Bt = new Bt(we, de + "enter", Rt, g, Ze)),
                (Bt.target = Se),
                (Bt.relatedTarget = xr),
                (at = Bt)),
              (xr = at),
              wt && Rt)
            )
              t: {
                for (Bt = wt, we = Rt, de = 0, Se = Bt; Se; Se = pl(Se)) de++;
                for (Se = 0, at = we; at; at = pl(at)) Se++;
                for (; 0 < de - Se; ) (Bt = pl(Bt)), de--;
                for (; 0 < Se - de; ) (we = pl(we)), Se--;
                for (; de--; ) {
                  if (Bt === we || (we !== null && Bt === we.alternate))
                    break t;
                  (Bt = pl(Bt)), (we = pl(we));
                }
                Bt = null;
              }
            else Bt = null;
            wt !== null && Mm($e, Ye, wt, Bt, !1),
              Rt !== null && xr !== null && Mm($e, xr, Rt, Bt, !0);
          }
        }
        e: {
          if (
            ((Ye = Ie ? gl(Ie) : window),
            (wt = Ye.nodeName && Ye.nodeName.toLowerCase()),
            wt === "select" || (wt === "input" && Ye.type === "file"))
          )
            var Nt = du;
          else if (ll(Ye))
            if (Di) Nt = nd;
            else {
              Nt = jh;
              var Vt = Am;
            }
          else
            (wt = Ye.nodeName) &&
              wt.toLowerCase() === "input" &&
              (Ye.type === "checkbox" || Ye.type === "radio") &&
              (Nt = Qn);
          if (Nt && (Nt = Nt(o, Ie))) {
            uu($e, Nt, g, Ze);
            break e;
          }
          Vt && Vt(o, Ye, Ie),
            o === "focusout" &&
              (Vt = Ye._wrapperState) &&
              Vt.controlled &&
              Ye.type === "number" &&
              Dt(Ye, "number", Ye.value);
        }
        switch (((Vt = Ie ? gl(Ie) : window), o)) {
          case "focusin":
            (ll(Vt) || Vt.contentEditable === "true") &&
              ((Ls = Vt), (Xh = Ie), (cr = null));
            break;
          case "focusout":
            cr = Xh = Ls = null;
            break;
          case "mousedown":
            fu = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (fu = !1), id($e, g, Ze);
            break;
          case "selectionchange":
            if (hu) break;
          case "keydown":
          case "keyup":
            id($e, g, Ze);
        }
        var Gt;
        if (ti)
          e: {
            switch (o) {
              case "compositionstart":
                var qt = "onCompositionStart";
                break e;
              case "compositionend":
                qt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                qt = "onCompositionUpdate";
                break e;
            }
            qt = void 0;
          }
        else
          po
            ? $c(o, g) && (qt = "onCompositionEnd")
            : o === "keydown" &&
              g.keyCode === 229 &&
              (qt = "onCompositionStart");
        qt &&
          ($i &&
            g.locale !== "ko" &&
            (po || qt !== "onCompositionStart"
              ? qt === "onCompositionEnd" && po && (Gt = iu())
              : ((Ba = Ze),
                (Pi = "value" in Ba ? Ba.value : Ba.textContent),
                (po = !0))),
          (Vt = vu(Ie, qt)),
          0 < Vt.length &&
            ((qt = new Uh(qt, o, null, g, Ze)),
            $e.push({ event: qt, listeners: Vt }),
            Gt
              ? (qt.data = Gt)
              : ((Gt = ed(g)), Gt !== null && (qt.data = Gt)))),
          (Gt = ou ? lu(o, g) : ol(o, g)) &&
            ((Ie = vu(Ie, "onBeforeInput")),
            0 < Ie.length &&
              ((Ze = new Uh("onBeforeInput", "beforeinput", null, g, Ze)),
              $e.push({ event: Ze, listeners: Ie }),
              (Ze.data = Gt)));
      }
      $h($e, u);
    });
  }
  function yu(o, u, g) {
    return { instance: o, listener: u, currentTarget: g };
  }
  function vu(o, u) {
    for (var g = u + "Capture", _ = []; o !== null; ) {
      var E = o,
        B = E.stateNode;
      E.tag === 5 &&
        B !== null &&
        ((E = B),
        (B = vt(o, g)),
        B != null && _.unshift(yu(o, B, E)),
        (B = vt(o, u)),
        B != null && _.push(yu(o, B, E))),
        (o = o.return);
    }
    return _;
  }
  function pl(o) {
    if (o === null) return null;
    do o = o.return;
    while (o && o.tag !== 5);
    return o || null;
  }
  function Mm(o, u, g, _, E) {
    for (var B = u._reactName, V = []; g !== null && g !== _; ) {
      var ee = g,
        ue = ee.alternate,
        Ie = ee.stateNode;
      if (ue !== null && ue === _) break;
      ee.tag === 5 &&
        Ie !== null &&
        ((ee = Ie),
        E
          ? ((ue = vt(g, B)), ue != null && V.unshift(yu(g, ue, ee)))
          : E || ((ue = vt(g, B)), ue != null && V.push(yu(g, ue, ee)))),
        (g = g.return);
    }
    V.length !== 0 && o.push({ event: u, listeners: V });
  }
  var Sm = /\r\n?/g,
    Em = /\u0000|\uFFFD/g;
  function tf(o) {
    return (typeof o == "string" ? o : "" + o)
      .replace(
        Sm,
        `
`,
      )
      .replace(Em, "");
  }
  function xu(o, u, g) {
    if (((u = tf(u)), tf(o) !== u && g)) throw Error(t(425));
  }
  function _o() {}
  var nf = null,
    rf = null;
  function sf(o, u) {
    return (
      o === "textarea" ||
      o === "noscript" ||
      typeof u.children == "string" ||
      typeof u.children == "number" ||
      (typeof u.dangerouslySetInnerHTML == "object" &&
        u.dangerouslySetInnerHTML !== null &&
        u.dangerouslySetInnerHTML.__html != null)
    );
  }
  var bu = typeof setTimeout == "function" ? setTimeout : void 0,
    af = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Cm = typeof Promise == "function" ? Promise : void 0,
    Tm =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof Cm < "u"
          ? function (o) {
              return Cm.resolve(null).then(o).catch(Rm);
            }
          : bu;
  function Rm(o) {
    setTimeout(function () {
      throw o;
    });
  }
  function ld(o, u) {
    var g = u,
      _ = 0;
    do {
      var E = g.nextSibling;
      if ((o.removeChild(g), E && E.nodeType === 8))
        if (((g = E.data), g === "/$")) {
          if (_ === 0) {
            o.removeChild(E), fi(u);
            return;
          }
          _--;
        } else (g !== "$" && g !== "$?" && g !== "$!") || _++;
      g = E;
    } while (g);
    fi(u);
  }
  function ea(o) {
    for (; o != null; o = o.nextSibling) {
      var u = o.nodeType;
      if (u === 1 || u === 3) break;
      if (u === 8) {
        if (((u = o.data), u === "$" || u === "$!" || u === "$?")) break;
        if (u === "/$") return null;
      }
    }
    return o;
  }
  function of(o) {
    o = o.previousSibling;
    for (var u = 0; o; ) {
      if (o.nodeType === 8) {
        var g = o.data;
        if (g === "$" || g === "$!" || g === "$?") {
          if (u === 0) return o;
          u--;
        } else g === "/$" && u++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  var ni = Math.random().toString(36).slice(2),
    ys = "__reactFiber$" + ni,
    ta = "__reactProps$" + ni,
    Ui = "__reactContainer$" + ni,
    ml = "__reactEvents$" + ni,
    ud = "__reactListeners$" + ni,
    Im = "__reactHandles$" + ni;
  function vs(o) {
    var u = o[ys];
    if (u) return u;
    for (var g = o.parentNode; g; ) {
      if ((u = g[Ui] || g[ys])) {
        if (
          ((g = u.alternate),
          u.child !== null || (g !== null && g.child !== null))
        )
          for (o = of(o); o !== null; ) {
            if ((g = o[ys])) return g;
            o = of(o);
          }
        return u;
      }
      (o = g), (g = o.parentNode);
    }
    return null;
  }
  function dr(o) {
    return (
      (o = o[ys] || o[Ui]),
      !o || (o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3)
        ? null
        : o
    );
  }
  function gl(o) {
    if (o.tag === 5 || o.tag === 6) return o.stateNode;
    throw Error(t(33));
  }
  function cd(o) {
    return o[ta] || null;
  }
  var ri = [],
    hr = -1;
  function na(o) {
    return { current: o };
  }
  function Gn(o) {
    0 > hr || ((o.current = ri[hr]), (ri[hr] = null), hr--);
  }
  function kn(o, u) {
    hr++, (ri[hr] = o.current), (o.current = u);
  }
  var ra = {},
    Ur = na(ra),
    Jr = na(!1),
    ka = ra;
  function za(o, u) {
    var g = o.type.contextTypes;
    if (!g) return ra;
    var _ = o.stateNode;
    if (_ && _.__reactInternalMemoizedUnmaskedChildContext === u)
      return _.__reactInternalMemoizedMaskedChildContext;
    var E = {},
      B;
    for (B in g) E[B] = u[B];
    return (
      _ &&
        ((o = o.stateNode),
        (o.__reactInternalMemoizedUnmaskedChildContext = u),
        (o.__reactInternalMemoizedMaskedChildContext = E)),
      E
    );
  }
  function ii(o) {
    return (o = o.childContextTypes), o != null;
  }
  function _u() {
    Gn(Jr), Gn(Ur);
  }
  function Au(o, u, g) {
    if (Ur.current !== ra) throw Error(t(168));
    kn(Ur, u), kn(Jr, g);
  }
  function wu(o, u, g) {
    var _ = o.stateNode;
    if (((u = u.childContextTypes), typeof _.getChildContext != "function"))
      return g;
    _ = _.getChildContext();
    for (var E in _) if (!(E in u)) throw Error(t(108, Fe(o) || "Unknown", E));
    return ae({}, g, _);
  }
  function Mu(o) {
    return (
      (o =
        ((o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext) ||
        ra),
      (ka = Ur.current),
      kn(Ur, o),
      kn(Jr, Jr.current),
      !0
    );
  }
  function dd(o, u, g) {
    var _ = o.stateNode;
    if (!_) throw Error(t(169));
    g
      ? ((o = wu(o, u, ka)),
        (_.__reactInternalMemoizedMergedChildContext = o),
        Gn(Jr),
        Gn(Ur),
        kn(Ur, o))
      : Gn(Jr),
      kn(Jr, g);
  }
  var Ds = null,
    Su = !1,
    yl = !1;
  function lf(o) {
    Ds === null ? (Ds = [o]) : Ds.push(o);
  }
  function uf(o) {
    (Su = !0), lf(o);
  }
  function ia() {
    if (!yl && Ds !== null) {
      yl = !0;
      var o = 0,
        u = rn;
      try {
        var g = Ds;
        for (rn = 1; o < g.length; o++) {
          var _ = g[o];
          do _ = _(!0);
          while (_ !== null);
        }
        (Ds = null), (Su = !1);
      } catch (E) {
        throw (Ds !== null && (Ds = Ds.slice(o + 1)), j(pt, ia), E);
      } finally {
        (rn = u), (yl = !1);
      }
    }
    return null;
  }
  var yi = [],
    vl = 0,
    hd = null,
    Ao = 0,
    Cr = [],
    ts = 0,
    ut = null,
    ns = 1,
    Fs = "";
  function Ha(o, u) {
    (yi[vl++] = Ao), (yi[vl++] = hd), (hd = o), (Ao = u);
  }
  function Bm(o, u, g) {
    (Cr[ts++] = ns), (Cr[ts++] = Fs), (Cr[ts++] = ut), (ut = o);
    var _ = ns;
    o = Fs;
    var E = 32 - Jt(_) - 1;
    (_ &= ~(1 << E)), (g += 1);
    var B = 32 - Jt(u) + E;
    if (30 < B) {
      var V = E - (E % 5);
      (B = (_ & ((1 << V) - 1)).toString(32)),
        (_ >>= V),
        (E -= V),
        (ns = (1 << (32 - Jt(u) + E)) | (g << E) | _),
        (Fs = B + o);
    } else (ns = (1 << B) | (g << E) | _), (Fs = o);
  }
  function sa(o) {
    o.return !== null && (Ha(o, 1), Bm(o, 1, 0));
  }
  function wo(o) {
    for (; o === hd; )
      (hd = yi[--vl]), (yi[vl] = null), (Ao = yi[--vl]), (yi[vl] = null);
    for (; o === ut; )
      (ut = Cr[--ts]),
        (Cr[ts] = null),
        (Fs = Cr[--ts]),
        (Cr[ts] = null),
        (ns = Cr[--ts]),
        (Cr[ts] = null);
  }
  var si = null,
    vi = null,
    Xn = !1,
    rs = null;
  function cf(o, u) {
    var g = Hs(5, null, null, 0);
    (g.elementType = "DELETED"),
      (g.stateNode = u),
      (g.return = o),
      (u = o.deletions),
      u === null ? ((o.deletions = [g]), (o.flags |= 16)) : u.push(g);
  }
  function df(o, u) {
    switch (o.tag) {
      case 5:
        var g = o.type;
        return (
          (u =
            u.nodeType !== 1 || g.toLowerCase() !== u.nodeName.toLowerCase()
              ? null
              : u),
          u !== null
            ? ((o.stateNode = u), (si = o), (vi = ea(u.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (u = o.pendingProps === "" || u.nodeType !== 3 ? null : u),
          u !== null ? ((o.stateNode = u), (si = o), (vi = null), !0) : !1
        );
      case 13:
        return (
          (u = u.nodeType !== 8 ? null : u),
          u !== null
            ? ((g = ut !== null ? { id: ns, overflow: Fs } : null),
              (o.memoizedState = {
                dehydrated: u,
                treeContext: g,
                retryLane: 1073741824,
              }),
              (g = Hs(18, null, null, 0)),
              (g.stateNode = u),
              (g.return = o),
              (o.child = g),
              (si = o),
              (vi = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function fd(o) {
    return (o.mode & 1) !== 0 && (o.flags & 128) === 0;
  }
  function Eu(o) {
    if (Xn) {
      var u = vi;
      if (u) {
        var g = u;
        if (!df(o, u)) {
          if (fd(o)) throw Error(t(418));
          u = ea(g.nextSibling);
          var _ = si;
          u && df(o, u)
            ? cf(_, g)
            : ((o.flags = (o.flags & -4097) | 2), (Xn = !1), (si = o));
        }
      } else {
        if (fd(o)) throw Error(t(418));
        (o.flags = (o.flags & -4097) | 2), (Xn = !1), (si = o);
      }
    }
  }
  function pd(o) {
    for (
      o = o.return;
      o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13;

    )
      o = o.return;
    si = o;
  }
  function Cu(o) {
    if (o !== si) return !1;
    if (!Xn) return pd(o), (Xn = !0), !1;
    var u;
    if (
      ((u = o.tag !== 3) &&
        !(u = o.tag !== 5) &&
        ((u = o.type),
        (u = u !== "head" && u !== "body" && !sf(o.type, o.memoizedProps))),
      u && (u = vi))
    ) {
      if (fd(o)) throw (md(), Error(t(418)));
      for (; u; ) cf(o, u), (u = ea(u.nextSibling));
    }
    if ((pd(o), o.tag === 13)) {
      if (((o = o.memoizedState), (o = o !== null ? o.dehydrated : null), !o))
        throw Error(t(317));
      e: {
        for (o = o.nextSibling, u = 0; o; ) {
          if (o.nodeType === 8) {
            var g = o.data;
            if (g === "/$") {
              if (u === 0) {
                vi = ea(o.nextSibling);
                break e;
              }
              u--;
            } else (g !== "$" && g !== "$!" && g !== "$?") || u++;
          }
          o = o.nextSibling;
        }
        vi = null;
      }
    } else vi = si ? ea(o.stateNode.nextSibling) : null;
    return !0;
  }
  function md() {
    for (var o = vi; o; ) o = ea(o.nextSibling);
  }
  function aa() {
    (vi = si = null), (Xn = !1);
  }
  function hf(o) {
    rs === null ? (rs = [o]) : rs.push(o);
  }
  var o2 = I.ReactCurrentBatchConfig;
  function xl(o, u, g) {
    if (
      ((o = g.ref),
      o !== null && typeof o != "function" && typeof o != "object")
    ) {
      if (g._owner) {
        if (((g = g._owner), g)) {
          if (g.tag !== 1) throw Error(t(309));
          var _ = g.stateNode;
        }
        if (!_) throw Error(t(147, o));
        var E = _,
          B = "" + o;
        return u !== null &&
          u.ref !== null &&
          typeof u.ref == "function" &&
          u.ref._stringRef === B
          ? u.ref
          : ((u = function (V) {
              var ee = E.refs;
              V === null ? delete ee[B] : (ee[B] = V);
            }),
            (u._stringRef = B),
            u);
      }
      if (typeof o != "string") throw Error(t(284));
      if (!g._owner) throw Error(t(290, o));
    }
    return o;
  }
  function Tu(o, u) {
    throw (
      ((o = Object.prototype.toString.call(u)),
      Error(
        t(
          31,
          o === "[object Object]"
            ? "object with keys {" + Object.keys(u).join(", ") + "}"
            : o,
        ),
      ))
    );
  }
  function ff(o) {
    var u = o._init;
    return u(o._payload);
  }
  function pf(o) {
    function u(we, de) {
      if (o) {
        var Se = we.deletions;
        Se === null ? ((we.deletions = [de]), (we.flags |= 16)) : Se.push(de);
      }
    }
    function g(we, de) {
      if (!o) return null;
      for (; de !== null; ) u(we, de), (de = de.sibling);
      return null;
    }
    function _(we, de) {
      for (we = new Map(); de !== null; )
        de.key !== null ? we.set(de.key, de) : we.set(de.index, de),
          (de = de.sibling);
      return we;
    }
    function E(we, de) {
      return (we = Cl(we, de)), (we.index = 0), (we.sibling = null), we;
    }
    function B(we, de, Se) {
      return (
        (we.index = Se),
        o
          ? ((Se = we.alternate),
            Se !== null
              ? ((Se = Se.index), Se < de ? ((we.flags |= 2), de) : Se)
              : ((we.flags |= 2), de))
          : ((we.flags |= 1048576), de)
      );
    }
    function V(we) {
      return o && we.alternate === null && (we.flags |= 2), we;
    }
    function ee(we, de, Se, at) {
      return de === null || de.tag !== 6
        ? ((de = S2(Se, we.mode, at)), (de.return = we), de)
        : ((de = E(de, Se)), (de.return = we), de);
    }
    function ue(we, de, Se, at) {
      var Nt = Se.type;
      return Nt === O
        ? Ze(we, de, Se.props.children, at, Se.key)
        : de !== null &&
            (de.elementType === Nt ||
              (typeof Nt == "object" &&
                Nt !== null &&
                Nt.$$typeof === ge &&
                ff(Nt) === de.type))
          ? ((at = E(de, Se.props)),
            (at.ref = xl(we, de, Se)),
            (at.return = we),
            at)
          : ((at = n1(Se.type, Se.key, Se.props, null, we.mode, at)),
            (at.ref = xl(we, de, Se)),
            (at.return = we),
            at);
    }
    function Ie(we, de, Se, at) {
      return de === null ||
        de.tag !== 4 ||
        de.stateNode.containerInfo !== Se.containerInfo ||
        de.stateNode.implementation !== Se.implementation
        ? ((de = E2(Se, we.mode, at)), (de.return = we), de)
        : ((de = E(de, Se.children || [])), (de.return = we), de);
    }
    function Ze(we, de, Se, at, Nt) {
      return de === null || de.tag !== 7
        ? ((de = Ju(Se, we.mode, at, Nt)), (de.return = we), de)
        : ((de = E(de, Se)), (de.return = we), de);
    }
    function $e(we, de, Se) {
      if ((typeof de == "string" && de !== "") || typeof de == "number")
        return (de = S2("" + de, we.mode, Se)), (de.return = we), de;
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case U:
            return (
              (Se = n1(de.type, de.key, de.props, null, we.mode, Se)),
              (Se.ref = xl(we, null, de)),
              (Se.return = we),
              Se
            );
          case F:
            return (de = E2(de, we.mode, Se)), (de.return = we), de;
          case ge:
            var at = de._init;
            return $e(we, at(de._payload), Se);
        }
        if (it(de) || oe(de))
          return (de = Ju(de, we.mode, Se, null)), (de.return = we), de;
        Tu(we, de);
      }
      return null;
    }
    function Ye(we, de, Se, at) {
      var Nt = de !== null ? de.key : null;
      if ((typeof Se == "string" && Se !== "") || typeof Se == "number")
        return Nt !== null ? null : ee(we, de, "" + Se, at);
      if (typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case U:
            return Se.key === Nt ? ue(we, de, Se, at) : null;
          case F:
            return Se.key === Nt ? Ie(we, de, Se, at) : null;
          case ge:
            return (Nt = Se._init), Ye(we, de, Nt(Se._payload), at);
        }
        if (it(Se) || oe(Se))
          return Nt !== null ? null : Ze(we, de, Se, at, null);
        Tu(we, Se);
      }
      return null;
    }
    function wt(we, de, Se, at, Nt) {
      if ((typeof at == "string" && at !== "") || typeof at == "number")
        return (we = we.get(Se) || null), ee(de, we, "" + at, Nt);
      if (typeof at == "object" && at !== null) {
        switch (at.$$typeof) {
          case U:
            return (
              (we = we.get(at.key === null ? Se : at.key) || null),
              ue(de, we, at, Nt)
            );
          case F:
            return (
              (we = we.get(at.key === null ? Se : at.key) || null),
              Ie(de, we, at, Nt)
            );
          case ge:
            var Vt = at._init;
            return wt(we, de, Se, Vt(at._payload), Nt);
        }
        if (it(at) || oe(at))
          return (we = we.get(Se) || null), Ze(de, we, at, Nt, null);
        Tu(de, at);
      }
      return null;
    }
    function Rt(we, de, Se, at) {
      for (
        var Nt = null, Vt = null, Gt = de, qt = (de = 0), Zr = null;
        Gt !== null && qt < Se.length;
        qt++
      ) {
        Gt.index > qt ? ((Zr = Gt), (Gt = null)) : (Zr = Gt.sibling);
        var Bn = Ye(we, Gt, Se[qt], at);
        if (Bn === null) {
          Gt === null && (Gt = Zr);
          break;
        }
        o && Gt && Bn.alternate === null && u(we, Gt),
          (de = B(Bn, de, qt)),
          Vt === null ? (Nt = Bn) : (Vt.sibling = Bn),
          (Vt = Bn),
          (Gt = Zr);
      }
      if (qt === Se.length) return g(we, Gt), Xn && Ha(we, qt), Nt;
      if (Gt === null) {
        for (; qt < Se.length; qt++)
          (Gt = $e(we, Se[qt], at)),
            Gt !== null &&
              ((de = B(Gt, de, qt)),
              Vt === null ? (Nt = Gt) : (Vt.sibling = Gt),
              (Vt = Gt));
        return Xn && Ha(we, qt), Nt;
      }
      for (Gt = _(we, Gt); qt < Se.length; qt++)
        (Zr = wt(Gt, we, qt, Se[qt], at)),
          Zr !== null &&
            (o &&
              Zr.alternate !== null &&
              Gt.delete(Zr.key === null ? qt : Zr.key),
            (de = B(Zr, de, qt)),
            Vt === null ? (Nt = Zr) : (Vt.sibling = Zr),
            (Vt = Zr));
      return (
        o &&
          Gt.forEach(function (Tl) {
            return u(we, Tl);
          }),
        Xn && Ha(we, qt),
        Nt
      );
    }
    function Bt(we, de, Se, at) {
      var Nt = oe(Se);
      if (typeof Nt != "function") throw Error(t(150));
      if (((Se = Nt.call(Se)), Se == null)) throw Error(t(151));
      for (
        var Vt = (Nt = null), Gt = de, qt = (de = 0), Zr = null, Bn = Se.next();
        Gt !== null && !Bn.done;
        qt++, Bn = Se.next()
      ) {
        Gt.index > qt ? ((Zr = Gt), (Gt = null)) : (Zr = Gt.sibling);
        var Tl = Ye(we, Gt, Bn.value, at);
        if (Tl === null) {
          Gt === null && (Gt = Zr);
          break;
        }
        o && Gt && Tl.alternate === null && u(we, Gt),
          (de = B(Tl, de, qt)),
          Vt === null ? (Nt = Tl) : (Vt.sibling = Tl),
          (Vt = Tl),
          (Gt = Zr);
      }
      if (Bn.done) return g(we, Gt), Xn && Ha(we, qt), Nt;
      if (Gt === null) {
        for (; !Bn.done; qt++, Bn = Se.next())
          (Bn = $e(we, Bn.value, at)),
            Bn !== null &&
              ((de = B(Bn, de, qt)),
              Vt === null ? (Nt = Bn) : (Vt.sibling = Bn),
              (Vt = Bn));
        return Xn && Ha(we, qt), Nt;
      }
      for (Gt = _(we, Gt); !Bn.done; qt++, Bn = Se.next())
        (Bn = wt(Gt, we, qt, Bn.value, at)),
          Bn !== null &&
            (o &&
              Bn.alternate !== null &&
              Gt.delete(Bn.key === null ? qt : Bn.key),
            (de = B(Bn, de, qt)),
            Vt === null ? (Nt = Bn) : (Vt.sibling = Bn),
            (Vt = Bn));
      return (
        o &&
          Gt.forEach(function (K6) {
            return u(we, K6);
          }),
        Xn && Ha(we, qt),
        Nt
      );
    }
    function xr(we, de, Se, at) {
      if (
        (typeof Se == "object" &&
          Se !== null &&
          Se.type === O &&
          Se.key === null &&
          (Se = Se.props.children),
        typeof Se == "object" && Se !== null)
      ) {
        switch (Se.$$typeof) {
          case U:
            e: {
              for (var Nt = Se.key, Vt = de; Vt !== null; ) {
                if (Vt.key === Nt) {
                  if (((Nt = Se.type), Nt === O)) {
                    if (Vt.tag === 7) {
                      g(we, Vt.sibling),
                        (de = E(Vt, Se.props.children)),
                        (de.return = we),
                        (we = de);
                      break e;
                    }
                  } else if (
                    Vt.elementType === Nt ||
                    (typeof Nt == "object" &&
                      Nt !== null &&
                      Nt.$$typeof === ge &&
                      ff(Nt) === Vt.type)
                  ) {
                    g(we, Vt.sibling),
                      (de = E(Vt, Se.props)),
                      (de.ref = xl(we, Vt, Se)),
                      (de.return = we),
                      (we = de);
                    break e;
                  }
                  g(we, Vt);
                  break;
                } else u(we, Vt);
                Vt = Vt.sibling;
              }
              Se.type === O
                ? ((de = Ju(Se.props.children, we.mode, at, Se.key)),
                  (de.return = we),
                  (we = de))
                : ((at = n1(Se.type, Se.key, Se.props, null, we.mode, at)),
                  (at.ref = xl(we, de, Se)),
                  (at.return = we),
                  (we = at));
            }
            return V(we);
          case F:
            e: {
              for (Vt = Se.key; de !== null; ) {
                if (de.key === Vt)
                  if (
                    de.tag === 4 &&
                    de.stateNode.containerInfo === Se.containerInfo &&
                    de.stateNode.implementation === Se.implementation
                  ) {
                    g(we, de.sibling),
                      (de = E(de, Se.children || [])),
                      (de.return = we),
                      (we = de);
                    break e;
                  } else {
                    g(we, de);
                    break;
                  }
                else u(we, de);
                de = de.sibling;
              }
              (de = E2(Se, we.mode, at)), (de.return = we), (we = de);
            }
            return V(we);
          case ge:
            return (Vt = Se._init), xr(we, de, Vt(Se._payload), at);
        }
        if (it(Se)) return Rt(we, de, Se, at);
        if (oe(Se)) return Bt(we, de, Se, at);
        Tu(we, Se);
      }
      return (typeof Se == "string" && Se !== "") || typeof Se == "number"
        ? ((Se = "" + Se),
          de !== null && de.tag === 6
            ? (g(we, de.sibling), (de = E(de, Se)), (de.return = we), (we = de))
            : (g(we, de),
              (de = S2(Se, we.mode, at)),
              (de.return = we),
              (we = de)),
          V(we))
        : g(we, de);
    }
    return xr;
  }
  var oa = pf(!0),
    Ru = pf(!1),
    Mo = na(null),
    So = null,
    la = null,
    Eo = null;
  function Iu() {
    Eo = la = So = null;
  }
  function Bu(o) {
    var u = Mo.current;
    Gn(Mo), (o._currentValue = u);
  }
  function Pu(o, u, g) {
    for (; o !== null; ) {
      var _ = o.alternate;
      if (
        ((o.childLanes & u) !== u
          ? ((o.childLanes |= u), _ !== null && (_.childLanes |= u))
          : _ !== null && (_.childLanes & u) !== u && (_.childLanes |= u),
        o === g)
      )
        break;
      o = o.return;
    }
  }
  function Co(o, u) {
    (So = o),
      (Eo = la = null),
      (o = o.dependencies),
      o !== null &&
        o.firstContext !== null &&
        (o.lanes & u && (bt = !0), (o.firstContext = null));
  }
  function xi(o) {
    var u = o._currentValue;
    if (Eo !== o)
      if (((o = { context: o, memoizedValue: u, next: null }), la === null)) {
        if (So === null) throw Error(t(308));
        (la = o), (So.dependencies = { lanes: 0, firstContext: o });
      } else la = la.next = o;
    return u;
  }
  var To = null;
  function bl(o) {
    To === null ? (To = [o]) : To.push(o);
  }
  function gd(o, u, g, _) {
    var E = u.interleaved;
    return (
      E === null ? ((g.next = g), bl(u)) : ((g.next = E.next), (E.next = g)),
      (u.interleaved = g),
      Nn(o, _)
    );
  }
  function Nn(o, u) {
    o.lanes |= u;
    var g = o.alternate;
    for (g !== null && (g.lanes |= u), g = o, o = o.return; o !== null; )
      (o.childLanes |= u),
        (g = o.alternate),
        g !== null && (g.childLanes |= u),
        (g = o),
        (o = o.return);
    return g.tag === 3 ? g.stateNode : null;
  }
  var Yt = !1;
  function tr(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function rr(o, u) {
    (o = o.updateQueue),
      u.updateQueue === o &&
        (u.updateQueue = {
          baseState: o.baseState,
          firstBaseUpdate: o.firstBaseUpdate,
          lastBaseUpdate: o.lastBaseUpdate,
          shared: o.shared,
          effects: o.effects,
        });
  }
  function Jn(o, u) {
    return {
      eventTime: o,
      lane: u,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function fr(o, u, g) {
    var _ = o.updateQueue;
    if (_ === null) return null;
    if (((_ = _.shared), En & 2)) {
      var E = _.pending;
      return (
        E === null ? (u.next = u) : ((u.next = E.next), (E.next = u)),
        (_.pending = u),
        Nn(o, g)
      );
    }
    return (
      (E = _.interleaved),
      E === null ? ((u.next = u), bl(_)) : ((u.next = E.next), (E.next = u)),
      (_.interleaved = u),
      Nn(o, g)
    );
  }
  function ua(o, u, g) {
    if (
      ((u = u.updateQueue), u !== null && ((u = u.shared), (g & 4194240) !== 0))
    ) {
      var _ = u.lanes;
      (_ &= o.pendingLanes), (g |= _), (u.lanes = g), Ts(o, g);
    }
  }
  function pr(o, u) {
    var g = o.updateQueue,
      _ = o.alternate;
    if (_ !== null && ((_ = _.updateQueue), g === _)) {
      var E = null,
        B = null;
      if (((g = g.firstBaseUpdate), g !== null)) {
        do {
          var V = {
            eventTime: g.eventTime,
            lane: g.lane,
            tag: g.tag,
            payload: g.payload,
            callback: g.callback,
            next: null,
          };
          B === null ? (E = B = V) : (B = B.next = V), (g = g.next);
        } while (g !== null);
        B === null ? (E = B = u) : (B = B.next = u);
      } else E = B = u;
      (g = {
        baseState: _.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: B,
        shared: _.shared,
        effects: _.effects,
      }),
        (o.updateQueue = g);
      return;
    }
    (o = g.lastBaseUpdate),
      o === null ? (g.firstBaseUpdate = u) : (o.next = u),
      (g.lastBaseUpdate = u);
  }
  function Va(o, u, g, _) {
    var E = o.updateQueue;
    Yt = !1;
    var B = E.firstBaseUpdate,
      V = E.lastBaseUpdate,
      ee = E.shared.pending;
    if (ee !== null) {
      E.shared.pending = null;
      var ue = ee,
        Ie = ue.next;
      (ue.next = null), V === null ? (B = Ie) : (V.next = Ie), (V = ue);
      var Ze = o.alternate;
      Ze !== null &&
        ((Ze = Ze.updateQueue),
        (ee = Ze.lastBaseUpdate),
        ee !== V &&
          (ee === null ? (Ze.firstBaseUpdate = Ie) : (ee.next = Ie),
          (Ze.lastBaseUpdate = ue)));
    }
    if (B !== null) {
      var $e = E.baseState;
      (V = 0), (Ze = Ie = ue = null), (ee = B);
      do {
        var Ye = ee.lane,
          wt = ee.eventTime;
        if ((_ & Ye) === Ye) {
          Ze !== null &&
            (Ze = Ze.next =
              {
                eventTime: wt,
                lane: 0,
                tag: ee.tag,
                payload: ee.payload,
                callback: ee.callback,
                next: null,
              });
          e: {
            var Rt = o,
              Bt = ee;
            switch (((Ye = u), (wt = g), Bt.tag)) {
              case 1:
                if (((Rt = Bt.payload), typeof Rt == "function")) {
                  $e = Rt.call(wt, $e, Ye);
                  break e;
                }
                $e = Rt;
                break e;
              case 3:
                Rt.flags = (Rt.flags & -65537) | 128;
              case 0:
                if (
                  ((Rt = Bt.payload),
                  (Ye = typeof Rt == "function" ? Rt.call(wt, $e, Ye) : Rt),
                  Ye == null)
                )
                  break e;
                $e = ae({}, $e, Ye);
                break e;
              case 2:
                Yt = !0;
            }
          }
          ee.callback !== null &&
            ee.lane !== 0 &&
            ((o.flags |= 64),
            (Ye = E.effects),
            Ye === null ? (E.effects = [ee]) : Ye.push(ee));
        } else
          (wt = {
            eventTime: wt,
            lane: Ye,
            tag: ee.tag,
            payload: ee.payload,
            callback: ee.callback,
            next: null,
          }),
            Ze === null ? ((Ie = Ze = wt), (ue = $e)) : (Ze = Ze.next = wt),
            (V |= Ye);
        if (((ee = ee.next), ee === null)) {
          if (((ee = E.shared.pending), ee === null)) break;
          (Ye = ee),
            (ee = Ye.next),
            (Ye.next = null),
            (E.lastBaseUpdate = Ye),
            (E.shared.pending = null);
        }
      } while (!0);
      if (
        (Ze === null && (ue = $e),
        (E.baseState = ue),
        (E.firstBaseUpdate = Ie),
        (E.lastBaseUpdate = Ze),
        (u = E.shared.interleaved),
        u !== null)
      ) {
        E = u;
        do (V |= E.lane), (E = E.next);
        while (E !== u);
      } else B === null && (E.shared.lanes = 0);
      (Gu |= V), (o.lanes = V), (o.memoizedState = $e);
    }
  }
  function Ro(o, u, g) {
    if (((o = u.effects), (u.effects = null), o !== null))
      for (u = 0; u < o.length; u++) {
        var _ = o[u],
          E = _.callback;
        if (E !== null) {
          if (((_.callback = null), (_ = g), typeof E != "function"))
            throw Error(t(191, E));
          E.call(_);
        }
      }
  }
  var Ga = {},
    is = na(Ga),
    ca = na(Ga),
    Tr = na(Ga);
  function da(o) {
    if (o === Ga) throw Error(t(174));
    return o;
  }
  function Lu(o, u) {
    switch ((kn(Tr, u), kn(ca, o), kn(is, Ga), (o = u.nodeType), o)) {
      case 9:
      case 11:
        u = (u = u.documentElement) ? u.namespaceURI : Mt(null, "");
        break;
      default:
        (o = o === 8 ? u.parentNode : u),
          (u = o.namespaceURI || null),
          (o = o.tagName),
          (u = Mt(u, o));
    }
    Gn(is), kn(is, u);
  }
  function xs() {
    Gn(is), Gn(ca), Gn(Tr);
  }
  function Du(o) {
    da(Tr.current);
    var u = da(is.current),
      g = Mt(u, o.type);
    u !== g && (kn(ca, o), kn(is, g));
  }
  function Fu(o) {
    ca.current === o && (Gn(is), Gn(ca));
  }
  var Rn = na(0);
  function Io(o) {
    for (var u = o; u !== null; ) {
      if (u.tag === 13) {
        var g = u.memoizedState;
        if (
          g !== null &&
          ((g = g.dehydrated), g === null || g.data === "$?" || g.data === "$!")
        )
          return u;
      } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
        if (u.flags & 128) return u;
      } else if (u.child !== null) {
        (u.child.return = u), (u = u.child);
        continue;
      }
      if (u === o) break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === o) return null;
        u = u.return;
      }
      (u.sibling.return = u.return), (u = u.sibling);
    }
    return null;
  }
  var Ns = [];
  function _l() {
    for (var o = 0; o < Ns.length; o++)
      Ns[o]._workInProgressVersionPrimary = null;
    Ns.length = 0;
  }
  var ja = I.ReactCurrentDispatcher,
    Nu = I.ReactCurrentBatchConfig,
    Us = 0,
    jn = null,
    xn = null,
    Yn = null,
    ai = !1,
    Wa = !1,
    Rr = 0,
    Pm = 0;
  function Ir() {
    throw Error(t(321));
  }
  function Uu(o, u) {
    if (u === null) return !1;
    for (var g = 0; g < u.length && g < o.length; g++)
      if (!Fi(o[g], u[g])) return !1;
    return !0;
  }
  function mf(o, u, g, _, E, B) {
    if (
      ((Us = B),
      (jn = u),
      (u.memoizedState = null),
      (u.updateQueue = null),
      (u.lanes = 0),
      (ja.current = o === null || o.memoizedState === null ? zm : Hm),
      (o = g(_, E)),
      Wa)
    ) {
      B = 0;
      do {
        if (((Wa = !1), (Rr = 0), 25 <= B)) throw Error(t(301));
        (B += 1),
          (Yn = xn = null),
          (u.updateQueue = null),
          (ja.current = Vm),
          (o = g(_, E));
      } while (Wa);
    }
    if (
      ((ja.current = Vu),
      (u = xn !== null && xn.next !== null),
      (Us = 0),
      (Yn = xn = jn = null),
      (ai = !1),
      u)
    )
      throw Error(t(300));
    return o;
  }
  function Os() {
    var o = Rr !== 0;
    return (Rr = 0), o;
  }
  function bs() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Yn === null ? (jn.memoizedState = Yn = o) : (Yn = Yn.next = o), Yn;
  }
  function Oi() {
    if (xn === null) {
      var o = jn.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = xn.next;
    var u = Yn === null ? jn.memoizedState : Yn.next;
    if (u !== null) (Yn = u), (xn = o);
    else {
      if (o === null) throw Error(t(310));
      (xn = o),
        (o = {
          memoizedState: xn.memoizedState,
          baseState: xn.baseState,
          baseQueue: xn.baseQueue,
          queue: xn.queue,
          next: null,
        }),
        Yn === null ? (jn.memoizedState = Yn = o) : (Yn = Yn.next = o);
    }
    return Yn;
  }
  function Bo(o, u) {
    return typeof u == "function" ? u(o) : u;
  }
  function ha(o) {
    var u = Oi(),
      g = u.queue;
    if (g === null) throw Error(t(311));
    g.lastRenderedReducer = o;
    var _ = xn,
      E = _.baseQueue,
      B = g.pending;
    if (B !== null) {
      if (E !== null) {
        var V = E.next;
        (E.next = B.next), (B.next = V);
      }
      (_.baseQueue = E = B), (g.pending = null);
    }
    if (E !== null) {
      (B = E.next), (_ = _.baseState);
      var ee = (V = null),
        ue = null,
        Ie = B;
      do {
        var Ze = Ie.lane;
        if ((Us & Ze) === Ze)
          ue !== null &&
            (ue = ue.next =
              {
                lane: 0,
                action: Ie.action,
                hasEagerState: Ie.hasEagerState,
                eagerState: Ie.eagerState,
                next: null,
              }),
            (_ = Ie.hasEagerState ? Ie.eagerState : o(_, Ie.action));
        else {
          var $e = {
            lane: Ze,
            action: Ie.action,
            hasEagerState: Ie.hasEagerState,
            eagerState: Ie.eagerState,
            next: null,
          };
          ue === null ? ((ee = ue = $e), (V = _)) : (ue = ue.next = $e),
            (jn.lanes |= Ze),
            (Gu |= Ze);
        }
        Ie = Ie.next;
      } while (Ie !== null && Ie !== B);
      ue === null ? (V = _) : (ue.next = ee),
        Fi(_, u.memoizedState) || (bt = !0),
        (u.memoizedState = _),
        (u.baseState = V),
        (u.baseQueue = ue),
        (g.lastRenderedState = _);
    }
    if (((o = g.interleaved), o !== null)) {
      E = o;
      do (B = E.lane), (jn.lanes |= B), (Gu |= B), (E = E.next);
      while (E !== o);
    } else E === null && (g.lanes = 0);
    return [u.memoizedState, g.dispatch];
  }
  function yd(o) {
    var u = Oi(),
      g = u.queue;
    if (g === null) throw Error(t(311));
    g.lastRenderedReducer = o;
    var _ = g.dispatch,
      E = g.pending,
      B = u.memoizedState;
    if (E !== null) {
      g.pending = null;
      var V = (E = E.next);
      do (B = o(B, V.action)), (V = V.next);
      while (V !== E);
      Fi(B, u.memoizedState) || (bt = !0),
        (u.memoizedState = B),
        u.baseQueue === null && (u.baseState = B),
        (g.lastRenderedState = B);
    }
    return [B, _];
  }
  function gf() {}
  function vd(o, u) {
    var g = jn,
      _ = Oi(),
      E = u(),
      B = !Fi(_.memoizedState, E);
    if (
      (B && ((_.memoizedState = E), (bt = !0)),
      (_ = _.queue),
      xd(Dm.bind(null, g, _, o), [o]),
      _.getSnapshot !== u || B || (Yn !== null && Yn.memoizedState.tag & 1))
    ) {
      if (
        ((g.flags |= 2048),
        ku(9, Lm.bind(null, g, _, E, u), void 0, null),
        Yr === null)
      )
        throw Error(t(349));
      Us & 30 || Ou(g, u, E);
    }
    return E;
  }
  function Ou(o, u, g) {
    (o.flags |= 16384),
      (o = { getSnapshot: u, value: g }),
      (u = jn.updateQueue),
      u === null
        ? ((u = { lastEffect: null, stores: null }),
          (jn.updateQueue = u),
          (u.stores = [o]))
        : ((g = u.stores), g === null ? (u.stores = [o]) : g.push(o));
  }
  function Lm(o, u, g, _) {
    (u.value = g), (u.getSnapshot = _), yf(u) && vf(o);
  }
  function Dm(o, u, g) {
    return g(function () {
      yf(u) && vf(o);
    });
  }
  function yf(o) {
    var u = o.getSnapshot;
    o = o.value;
    try {
      var g = u();
      return !Fi(o, g);
    } catch {
      return !0;
    }
  }
  function vf(o) {
    var u = Nn(o, 1);
    u !== null && ma(u, o, 1, -1);
  }
  function Xa(o) {
    var u = bs();
    return (
      typeof o == "function" && (o = o()),
      (u.memoizedState = u.baseState = o),
      (o = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Bo,
        lastRenderedState: o,
      }),
      (u.queue = o),
      (o = o.dispatch = _d.bind(null, jn, o)),
      [u.memoizedState, o]
    );
  }
  function ku(o, u, g, _) {
    return (
      (o = { tag: o, create: u, destroy: g, deps: _, next: null }),
      (u = jn.updateQueue),
      u === null
        ? ((u = { lastEffect: null, stores: null }),
          (jn.updateQueue = u),
          (u.lastEffect = o.next = o))
        : ((g = u.lastEffect),
          g === null
            ? (u.lastEffect = o.next = o)
            : ((_ = g.next), (g.next = o), (o.next = _), (u.lastEffect = o))),
      o
    );
  }
  function Ja() {
    return Oi().memoizedState;
  }
  function zu(o, u, g, _) {
    var E = bs();
    (jn.flags |= o),
      (E.memoizedState = ku(1 | u, g, void 0, _ === void 0 ? null : _));
  }
  function Or(o, u, g, _) {
    var E = Oi();
    _ = _ === void 0 ? null : _;
    var B = void 0;
    if (xn !== null) {
      var V = xn.memoizedState;
      if (((B = V.destroy), _ !== null && Uu(_, V.deps))) {
        E.memoizedState = ku(u, g, B, _);
        return;
      }
    }
    (jn.flags |= o), (E.memoizedState = ku(1 | u, g, B, _));
  }
  function Fm(o, u) {
    return zu(8390656, 8, o, u);
  }
  function xd(o, u) {
    return Or(2048, 8, o, u);
  }
  function Nm(o, u) {
    return Or(4, 2, o, u);
  }
  function Um(o, u) {
    return Or(4, 4, o, u);
  }
  function xf(o, u) {
    if (typeof u == "function")
      return (
        (o = o()),
        u(o),
        function () {
          u(null);
        }
      );
    if (u != null)
      return (
        (o = o()),
        (u.current = o),
        function () {
          u.current = null;
        }
      );
  }
  function bf(o, u, g) {
    return (
      (g = g != null ? g.concat([o]) : null), Or(4, 4, xf.bind(null, u, o), g)
    );
  }
  function _f() {}
  function ki(o, u) {
    var g = Oi();
    u = u === void 0 ? null : u;
    var _ = g.memoizedState;
    return _ !== null && u !== null && Uu(u, _[1])
      ? _[0]
      : ((g.memoizedState = [o, u]), o);
  }
  function bd(o, u) {
    var g = Oi();
    u = u === void 0 ? null : u;
    var _ = g.memoizedState;
    return _ !== null && u !== null && Uu(u, _[1])
      ? _[0]
      : ((o = o()), (g.memoizedState = [o, u]), o);
  }
  function Om(o, u, g) {
    return Us & 21
      ? (Fi(g, u) ||
          ((g = ei()), (jn.lanes |= g), (Gu |= g), (o.baseState = !0)),
        u)
      : (o.baseState && ((o.baseState = !1), (bt = !0)), (o.memoizedState = g));
  }
  function Ya(o, u) {
    var g = rn;
    (rn = g !== 0 && 4 > g ? g : 4), o(!0);
    var _ = Nu.transition;
    Nu.transition = {};
    try {
      o(!1), u();
    } finally {
      (rn = g), (Nu.transition = _);
    }
  }
  function Hu() {
    return Oi().memoizedState;
  }
  function Po(o, u, g) {
    var _ = Sl(o);
    if (
      ((g = {
        lane: _,
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      Ad(o))
    )
      wd(u, g);
    else if (((g = gd(o, u, g, _)), g !== null)) {
      var E = Vi();
      ma(g, o, _, E), km(g, u, _);
    }
  }
  function _d(o, u, g) {
    var _ = Sl(o),
      E = {
        lane: _,
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (Ad(o)) wd(u, E);
    else {
      var B = o.alternate;
      if (
        o.lanes === 0 &&
        (B === null || B.lanes === 0) &&
        ((B = u.lastRenderedReducer), B !== null)
      )
        try {
          var V = u.lastRenderedState,
            ee = B(V, g);
          if (((E.hasEagerState = !0), (E.eagerState = ee), Fi(ee, V))) {
            var ue = u.interleaved;
            ue === null
              ? ((E.next = E), bl(u))
              : ((E.next = ue.next), (ue.next = E)),
              (u.interleaved = E);
            return;
          }
        } catch {
        } finally {
        }
      (g = gd(o, u, E, _)),
        g !== null && ((E = Vi()), ma(g, o, _, E), km(g, u, _));
    }
  }
  function Ad(o) {
    var u = o.alternate;
    return o === jn || (u !== null && u === jn);
  }
  function wd(o, u) {
    Wa = ai = !0;
    var g = o.pending;
    g === null ? (u.next = u) : ((u.next = g.next), (g.next = u)),
      (o.pending = u);
  }
  function km(o, u, g) {
    if (g & 4194240) {
      var _ = u.lanes;
      (_ &= o.pendingLanes), (g |= _), (u.lanes = g), Ts(o, g);
    }
  }
  var Vu = {
      readContext: xi,
      useCallback: Ir,
      useContext: Ir,
      useEffect: Ir,
      useImperativeHandle: Ir,
      useInsertionEffect: Ir,
      useLayoutEffect: Ir,
      useMemo: Ir,
      useReducer: Ir,
      useRef: Ir,
      useState: Ir,
      useDebugValue: Ir,
      useDeferredValue: Ir,
      useTransition: Ir,
      useMutableSource: Ir,
      useSyncExternalStore: Ir,
      useId: Ir,
      unstable_isNewReconciler: !1,
    },
    zm = {
      readContext: xi,
      useCallback: function (o, u) {
        return (bs().memoizedState = [o, u === void 0 ? null : u]), o;
      },
      useContext: xi,
      useEffect: Fm,
      useImperativeHandle: function (o, u, g) {
        return (
          (g = g != null ? g.concat([o]) : null),
          zu(4194308, 4, xf.bind(null, u, o), g)
        );
      },
      useLayoutEffect: function (o, u) {
        return zu(4194308, 4, o, u);
      },
      useInsertionEffect: function (o, u) {
        return zu(4, 2, o, u);
      },
      useMemo: function (o, u) {
        var g = bs();
        return (
          (u = u === void 0 ? null : u),
          (o = o()),
          (g.memoizedState = [o, u]),
          o
        );
      },
      useReducer: function (o, u, g) {
        var _ = bs();
        return (
          (u = g !== void 0 ? g(u) : u),
          (_.memoizedState = _.baseState = u),
          (o = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: o,
            lastRenderedState: u,
          }),
          (_.queue = o),
          (o = o.dispatch = Po.bind(null, jn, o)),
          [_.memoizedState, o]
        );
      },
      useRef: function (o) {
        var u = bs();
        return (o = { current: o }), (u.memoizedState = o);
      },
      useState: Xa,
      useDebugValue: _f,
      useDeferredValue: function (o) {
        return (bs().memoizedState = o);
      },
      useTransition: function () {
        var o = Xa(!1),
          u = o[0];
        return (o = Ya.bind(null, o[1])), (bs().memoizedState = o), [u, o];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (o, u, g) {
        var _ = jn,
          E = bs();
        if (Xn) {
          if (g === void 0) throw Error(t(407));
          g = g();
        } else {
          if (((g = u()), Yr === null)) throw Error(t(349));
          Us & 30 || Ou(_, u, g);
        }
        E.memoizedState = g;
        var B = { value: g, getSnapshot: u };
        return (
          (E.queue = B),
          Fm(Dm.bind(null, _, B, o), [o]),
          (_.flags |= 2048),
          ku(9, Lm.bind(null, _, B, g, u), void 0, null),
          g
        );
      },
      useId: function () {
        var o = bs(),
          u = Yr.identifierPrefix;
        if (Xn) {
          var g = Fs,
            _ = ns;
          (g = (_ & ~(1 << (32 - Jt(_) - 1))).toString(32) + g),
            (u = ":" + u + "R" + g),
            (g = Rr++),
            0 < g && (u += "H" + g.toString(32)),
            (u += ":");
        } else (g = Pm++), (u = ":" + u + "r" + g.toString(32) + ":");
        return (o.memoizedState = u);
      },
      unstable_isNewReconciler: !1,
    },
    Hm = {
      readContext: xi,
      useCallback: ki,
      useContext: xi,
      useEffect: xd,
      useImperativeHandle: bf,
      useInsertionEffect: Nm,
      useLayoutEffect: Um,
      useMemo: bd,
      useReducer: ha,
      useRef: Ja,
      useState: function () {
        return ha(Bo);
      },
      useDebugValue: _f,
      useDeferredValue: function (o) {
        var u = Oi();
        return Om(u, xn.memoizedState, o);
      },
      useTransition: function () {
        var o = ha(Bo)[0],
          u = Oi().memoizedState;
        return [o, u];
      },
      useMutableSource: gf,
      useSyncExternalStore: vd,
      useId: Hu,
      unstable_isNewReconciler: !1,
    },
    Vm = {
      readContext: xi,
      useCallback: ki,
      useContext: xi,
      useEffect: xd,
      useImperativeHandle: bf,
      useInsertionEffect: Nm,
      useLayoutEffect: Um,
      useMemo: bd,
      useReducer: yd,
      useRef: Ja,
      useState: function () {
        return yd(Bo);
      },
      useDebugValue: _f,
      useDeferredValue: function (o) {
        var u = Oi();
        return xn === null ? (u.memoizedState = o) : Om(u, xn.memoizedState, o);
      },
      useTransition: function () {
        var o = yd(Bo)[0],
          u = Oi().memoizedState;
        return [o, u];
      },
      useMutableSource: gf,
      useSyncExternalStore: vd,
      useId: Hu,
      unstable_isNewReconciler: !1,
    };
  function zi(o, u) {
    if (o && o.defaultProps) {
      (u = ae({}, u)), (o = o.defaultProps);
      for (var g in o) u[g] === void 0 && (u[g] = o[g]);
      return u;
    }
    return u;
  }
  function Af(o, u, g, _) {
    (u = o.memoizedState),
      (g = g(_, u)),
      (g = g == null ? u : ae({}, u, g)),
      (o.memoizedState = g),
      o.lanes === 0 && (o.updateQueue.baseState = g);
  }
  var Md = {
    isMounted: function (o) {
      return (o = o._reactInternals) ? Dn(o) === o : !1;
    },
    enqueueSetState: function (o, u, g) {
      o = o._reactInternals;
      var _ = Vi(),
        E = Sl(o),
        B = Jn(_, E);
      (B.payload = u),
        g != null && (B.callback = g),
        (u = fr(o, B, E)),
        u !== null && (ma(u, o, E, _), ua(u, o, E));
    },
    enqueueReplaceState: function (o, u, g) {
      o = o._reactInternals;
      var _ = Vi(),
        E = Sl(o),
        B = Jn(_, E);
      (B.tag = 1),
        (B.payload = u),
        g != null && (B.callback = g),
        (u = fr(o, B, E)),
        u !== null && (ma(u, o, E, _), ua(u, o, E));
    },
    enqueueForceUpdate: function (o, u) {
      o = o._reactInternals;
      var g = Vi(),
        _ = Sl(o),
        E = Jn(g, _);
      (E.tag = 2),
        u != null && (E.callback = u),
        (u = fr(o, E, _)),
        u !== null && (ma(u, o, _, g), ua(u, o, _));
    },
  };
  function h(o, u, g, _, E, B, V) {
    return (
      (o = o.stateNode),
      typeof o.shouldComponentUpdate == "function"
        ? o.shouldComponentUpdate(_, B, V)
        : u.prototype && u.prototype.isPureReactComponent
          ? !Na(g, _) || !Na(E, B)
          : !0
    );
  }
  function f(o, u, g) {
    var _ = !1,
      E = ra,
      B = u.contextType;
    return (
      typeof B == "object" && B !== null
        ? (B = xi(B))
        : ((E = ii(u) ? ka : Ur.current),
          (_ = u.contextTypes),
          (B = (_ = _ != null) ? za(o, E) : ra)),
      (u = new u(g, B)),
      (o.memoizedState =
        u.state !== null && u.state !== void 0 ? u.state : null),
      (u.updater = Md),
      (o.stateNode = u),
      (u._reactInternals = o),
      _ &&
        ((o = o.stateNode),
        (o.__reactInternalMemoizedUnmaskedChildContext = E),
        (o.__reactInternalMemoizedMaskedChildContext = B)),
      u
    );
  }
  function b(o, u, g, _) {
    (o = u.state),
      typeof u.componentWillReceiveProps == "function" &&
        u.componentWillReceiveProps(g, _),
      typeof u.UNSAFE_componentWillReceiveProps == "function" &&
        u.UNSAFE_componentWillReceiveProps(g, _),
      u.state !== o && Md.enqueueReplaceState(u, u.state, null);
  }
  function S(o, u, g, _) {
    var E = o.stateNode;
    (E.props = g), (E.state = o.memoizedState), (E.refs = {}), tr(o);
    var B = u.contextType;
    typeof B == "object" && B !== null
      ? (E.context = xi(B))
      : ((B = ii(u) ? ka : Ur.current), (E.context = za(o, B))),
      (E.state = o.memoizedState),
      (B = u.getDerivedStateFromProps),
      typeof B == "function" && (Af(o, u, B, g), (E.state = o.memoizedState)),
      typeof u.getDerivedStateFromProps == "function" ||
        typeof E.getSnapshotBeforeUpdate == "function" ||
        (typeof E.UNSAFE_componentWillMount != "function" &&
          typeof E.componentWillMount != "function") ||
        ((u = E.state),
        typeof E.componentWillMount == "function" && E.componentWillMount(),
        typeof E.UNSAFE_componentWillMount == "function" &&
          E.UNSAFE_componentWillMount(),
        u !== E.state && Md.enqueueReplaceState(E, E.state, null),
        Va(o, g, E, _),
        (E.state = o.memoizedState)),
      typeof E.componentDidMount == "function" && (o.flags |= 4194308);
  }
  function R(o, u) {
    try {
      var g = "",
        _ = u;
      do (g += Pe(_)), (_ = _.return);
      while (_);
      var E = g;
    } catch (B) {
      E =
        `
Error generating stack: ` +
        B.message +
        `
` +
        B.stack;
    }
    return { value: o, source: u, stack: E, digest: null };
  }
  function P(o, u, g) {
    return { value: o, source: null, stack: g ?? null, digest: u ?? null };
  }
  function $(o, u) {
    try {
      console.error(u.value);
    } catch (g) {
      setTimeout(function () {
        throw g;
      });
    }
  }
  var fe = typeof WeakMap == "function" ? WeakMap : Map;
  function De(o, u, g) {
    (g = Jn(-1, g)), (g.tag = 3), (g.payload = { element: null });
    var _ = u.value;
    return (
      (g.callback = function () {
        qm || ((qm = !0), (y2 = _)), $(o, u);
      }),
      g
    );
  }
  function rt(o, u, g) {
    (g = Jn(-1, g)), (g.tag = 3);
    var _ = o.type.getDerivedStateFromError;
    if (typeof _ == "function") {
      var E = u.value;
      (g.payload = function () {
        return _(E);
      }),
        (g.callback = function () {
          $(o, u);
        });
    }
    var B = o.stateNode;
    return (
      B !== null &&
        typeof B.componentDidCatch == "function" &&
        (g.callback = function () {
          $(o, u),
            typeof _ != "function" &&
              (wl === null ? (wl = new Set([this])) : wl.add(this));
          var V = u.stack;
          this.componentDidCatch(u.value, {
            componentStack: V !== null ? V : "",
          });
        }),
      g
    );
  }
  function Et(o, u, g) {
    var _ = o.pingCache;
    if (_ === null) {
      _ = o.pingCache = new fe();
      var E = new Set();
      _.set(u, E);
    } else (E = _.get(u)), E === void 0 && ((E = new Set()), _.set(u, E));
    E.has(g) || (E.add(g), (o = H6.bind(null, o, u, g)), u.then(o, o));
  }
  function Kt(o) {
    do {
      var u;
      if (
        ((u = o.tag === 13) &&
          ((u = o.memoizedState),
          (u = u !== null ? u.dehydrated !== null : !0)),
        u)
      )
        return o;
      o = o.return;
    } while (o !== null);
    return null;
  }
  function kt(o, u, g, _, E) {
    return o.mode & 1
      ? ((o.flags |= 65536), (o.lanes = E), o)
      : (o === u
          ? (o.flags |= 65536)
          : ((o.flags |= 128),
            (g.flags |= 131072),
            (g.flags &= -52805),
            g.tag === 1 &&
              (g.alternate === null
                ? (g.tag = 17)
                : ((u = Jn(-1, 1)), (u.tag = 2), fr(g, u, 1))),
            (g.lanes |= 1)),
        o);
  }
  var zn = I.ReactCurrentOwner,
    bt = !1;
  function In(o, u, g, _) {
    u.child = o === null ? Ru(u, null, g, _) : oa(u, o.child, g, _);
  }
  function Hi(o, u, g, _, E) {
    g = g.render;
    var B = u.ref;
    return (
      Co(u, E),
      (_ = mf(o, u, g, _, B, E)),
      (g = Os()),
      o !== null && !bt
        ? ((u.updateQueue = o.updateQueue),
          (u.flags &= -2053),
          (o.lanes &= ~E),
          Lo(o, u, E))
        : (Xn && g && sa(u), (u.flags |= 1), In(o, u, _, E), u.child)
    );
  }
  function Ce(o, u, g, _, E) {
    if (o === null) {
      var B = g.type;
      return typeof B == "function" &&
        !M2(B) &&
        B.defaultProps === void 0 &&
        g.compare === null &&
        g.defaultProps === void 0
        ? ((u.tag = 15), (u.type = B), ve(o, u, B, _, E))
        : ((o = n1(g.type, null, _, u, u.mode, E)),
          (o.ref = u.ref),
          (o.return = u),
          (u.child = o));
    }
    if (((B = o.child), !(o.lanes & E))) {
      var V = B.memoizedProps;
      if (
        ((g = g.compare), (g = g !== null ? g : Na), g(V, _) && o.ref === u.ref)
      )
        return Lo(o, u, E);
    }
    return (
      (u.flags |= 1),
      (o = Cl(B, _)),
      (o.ref = u.ref),
      (o.return = u),
      (u.child = o)
    );
  }
  function ve(o, u, g, _, E) {
    if (o !== null) {
      var B = o.memoizedProps;
      if (Na(B, _) && o.ref === u.ref)
        if (((bt = !1), (u.pendingProps = _ = B), (o.lanes & E) !== 0))
          o.flags & 131072 && (bt = !0);
        else return (u.lanes = o.lanes), Lo(o, u, E);
    }
    return Pt(o, u, g, _, E);
  }
  function Le(o, u, g) {
    var _ = u.pendingProps,
      E = _.children,
      B = o !== null ? o.memoizedState : null;
    if (_.mode === "hidden")
      if (!(u.mode & 1))
        (u.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          kn(Ed, _s),
          (_s |= g);
      else {
        if (!(g & 1073741824))
          return (
            (o = B !== null ? B.baseLanes | g : g),
            (u.lanes = u.childLanes = 1073741824),
            (u.memoizedState = {
              baseLanes: o,
              cachePool: null,
              transitions: null,
            }),
            (u.updateQueue = null),
            kn(Ed, _s),
            (_s |= o),
            null
          );
        (u.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (_ = B !== null ? B.baseLanes : g),
          kn(Ed, _s),
          (_s |= _);
      }
    else
      B !== null ? ((_ = B.baseLanes | g), (u.memoizedState = null)) : (_ = g),
        kn(Ed, _s),
        (_s |= _);
    return In(o, u, E, g), u.child;
  }
  function yt(o, u) {
    var g = u.ref;
    ((o === null && g !== null) || (o !== null && o.ref !== g)) &&
      ((u.flags |= 512), (u.flags |= 2097152));
  }
  function Pt(o, u, g, _, E) {
    var B = ii(g) ? ka : Ur.current;
    return (
      (B = za(u, B)),
      Co(u, E),
      (g = mf(o, u, g, _, B, E)),
      (_ = Os()),
      o !== null && !bt
        ? ((u.updateQueue = o.updateQueue),
          (u.flags &= -2053),
          (o.lanes &= ~E),
          Lo(o, u, E))
        : (Xn && _ && sa(u), (u.flags |= 1), In(o, u, g, E), u.child)
    );
  }
  function sn(o, u, g, _, E) {
    if (ii(g)) {
      var B = !0;
      Mu(u);
    } else B = !1;
    if ((Co(u, E), u.stateNode === null))
      Wm(o, u), f(u, g, _), S(u, g, _, E), (_ = !0);
    else if (o === null) {
      var V = u.stateNode,
        ee = u.memoizedProps;
      V.props = ee;
      var ue = V.context,
        Ie = g.contextType;
      typeof Ie == "object" && Ie !== null
        ? (Ie = xi(Ie))
        : ((Ie = ii(g) ? ka : Ur.current), (Ie = za(u, Ie)));
      var Ze = g.getDerivedStateFromProps,
        $e =
          typeof Ze == "function" ||
          typeof V.getSnapshotBeforeUpdate == "function";
      $e ||
        (typeof V.UNSAFE_componentWillReceiveProps != "function" &&
          typeof V.componentWillReceiveProps != "function") ||
        ((ee !== _ || ue !== Ie) && b(u, V, _, Ie)),
        (Yt = !1);
      var Ye = u.memoizedState;
      (V.state = Ye),
        Va(u, _, V, E),
        (ue = u.memoizedState),
        ee !== _ || Ye !== ue || Jr.current || Yt
          ? (typeof Ze == "function" &&
              (Af(u, g, Ze, _), (ue = u.memoizedState)),
            (ee = Yt || h(u, g, ee, _, Ye, ue, Ie))
              ? ($e ||
                  (typeof V.UNSAFE_componentWillMount != "function" &&
                    typeof V.componentWillMount != "function") ||
                  (typeof V.componentWillMount == "function" &&
                    V.componentWillMount(),
                  typeof V.UNSAFE_componentWillMount == "function" &&
                    V.UNSAFE_componentWillMount()),
                typeof V.componentDidMount == "function" &&
                  (u.flags |= 4194308))
              : (typeof V.componentDidMount == "function" &&
                  (u.flags |= 4194308),
                (u.memoizedProps = _),
                (u.memoizedState = ue)),
            (V.props = _),
            (V.state = ue),
            (V.context = Ie),
            (_ = ee))
          : (typeof V.componentDidMount == "function" && (u.flags |= 4194308),
            (_ = !1));
    } else {
      (V = u.stateNode),
        rr(o, u),
        (ee = u.memoizedProps),
        (Ie = u.type === u.elementType ? ee : zi(u.type, ee)),
        (V.props = Ie),
        ($e = u.pendingProps),
        (Ye = V.context),
        (ue = g.contextType),
        typeof ue == "object" && ue !== null
          ? (ue = xi(ue))
          : ((ue = ii(g) ? ka : Ur.current), (ue = za(u, ue)));
      var wt = g.getDerivedStateFromProps;
      (Ze =
        typeof wt == "function" ||
        typeof V.getSnapshotBeforeUpdate == "function") ||
        (typeof V.UNSAFE_componentWillReceiveProps != "function" &&
          typeof V.componentWillReceiveProps != "function") ||
        ((ee !== $e || Ye !== ue) && b(u, V, _, ue)),
        (Yt = !1),
        (Ye = u.memoizedState),
        (V.state = Ye),
        Va(u, _, V, E);
      var Rt = u.memoizedState;
      ee !== $e || Ye !== Rt || Jr.current || Yt
        ? (typeof wt == "function" && (Af(u, g, wt, _), (Rt = u.memoizedState)),
          (Ie = Yt || h(u, g, Ie, _, Ye, Rt, ue) || !1)
            ? (Ze ||
                (typeof V.UNSAFE_componentWillUpdate != "function" &&
                  typeof V.componentWillUpdate != "function") ||
                (typeof V.componentWillUpdate == "function" &&
                  V.componentWillUpdate(_, Rt, ue),
                typeof V.UNSAFE_componentWillUpdate == "function" &&
                  V.UNSAFE_componentWillUpdate(_, Rt, ue)),
              typeof V.componentDidUpdate == "function" && (u.flags |= 4),
              typeof V.getSnapshotBeforeUpdate == "function" &&
                (u.flags |= 1024))
            : (typeof V.componentDidUpdate != "function" ||
                (ee === o.memoizedProps && Ye === o.memoizedState) ||
                (u.flags |= 4),
              typeof V.getSnapshotBeforeUpdate != "function" ||
                (ee === o.memoizedProps && Ye === o.memoizedState) ||
                (u.flags |= 1024),
              (u.memoizedProps = _),
              (u.memoizedState = Rt)),
          (V.props = _),
          (V.state = Rt),
          (V.context = ue),
          (_ = Ie))
        : (typeof V.componentDidUpdate != "function" ||
            (ee === o.memoizedProps && Ye === o.memoizedState) ||
            (u.flags |= 4),
          typeof V.getSnapshotBeforeUpdate != "function" ||
            (ee === o.memoizedProps && Ye === o.memoizedState) ||
            (u.flags |= 1024),
          (_ = !1));
    }
    return Zt(o, u, g, _, B, E);
  }
  function Zt(o, u, g, _, E, B) {
    yt(o, u);
    var V = (u.flags & 128) !== 0;
    if (!_ && !V) return E && dd(u, g, !1), Lo(o, u, B);
    (_ = u.stateNode), (zn.current = u);
    var ee =
      V && typeof g.getDerivedStateFromError != "function" ? null : _.render();
    return (
      (u.flags |= 1),
      o !== null && V
        ? ((u.child = oa(u, o.child, null, B)), (u.child = oa(u, null, ee, B)))
        : In(o, u, ee, B),
      (u.memoizedState = _.state),
      E && dd(u, g, !0),
      u.child
    );
  }
  function bn(o) {
    var u = o.stateNode;
    u.pendingContext
      ? Au(o, u.pendingContext, u.pendingContext !== u.context)
      : u.context && Au(o, u.context, !1),
      Lu(o, u.containerInfo);
  }
  function vr(o, u, g, _, E) {
    return aa(), hf(E), (u.flags |= 256), In(o, u, g, _), u.child;
  }
  var yn = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ks(o) {
    return { baseLanes: o, cachePool: null, transitions: null };
  }
  function Gm(o, u, g) {
    var _ = u.pendingProps,
      E = Rn.current,
      B = !1,
      V = (u.flags & 128) !== 0,
      ee;
    if (
      ((ee = V) ||
        (ee = o !== null && o.memoizedState === null ? !1 : (E & 2) !== 0),
      ee
        ? ((B = !0), (u.flags &= -129))
        : (o === null || o.memoizedState !== null) && (E |= 1),
      kn(Rn, E & 1),
      o === null)
    )
      return (
        Eu(u),
        (o = u.memoizedState),
        o !== null && ((o = o.dehydrated), o !== null)
          ? (u.mode & 1
              ? o.data === "$!"
                ? (u.lanes = 8)
                : (u.lanes = 1073741824)
              : (u.lanes = 1),
            null)
          : ((V = _.children),
            (o = _.fallback),
            B
              ? ((_ = u.mode),
                (B = u.child),
                (V = { mode: "hidden", children: V }),
                !(_ & 1) && B !== null
                  ? ((B.childLanes = 0), (B.pendingProps = V))
                  : (B = r1(V, _, 0, null)),
                (o = Ju(o, _, g, null)),
                (B.return = u),
                (o.return = u),
                (B.sibling = o),
                (u.child = B),
                (u.child.memoizedState = ks(g)),
                (u.memoizedState = yn),
                o)
              : l2(u, V))
      );
    if (
      ((E = o.memoizedState), E !== null && ((ee = E.dehydrated), ee !== null))
    )
      return R6(o, u, V, _, ee, E, g);
    if (B) {
      (B = _.fallback), (V = u.mode), (E = o.child), (ee = E.sibling);
      var ue = { mode: "hidden", children: _.children };
      return (
        !(V & 1) && u.child !== E
          ? ((_ = u.child),
            (_.childLanes = 0),
            (_.pendingProps = ue),
            (u.deletions = null))
          : ((_ = Cl(E, ue)), (_.subtreeFlags = E.subtreeFlags & 14680064)),
        ee !== null
          ? (B = Cl(ee, B))
          : ((B = Ju(B, V, g, null)), (B.flags |= 2)),
        (B.return = u),
        (_.return = u),
        (_.sibling = B),
        (u.child = _),
        (_ = B),
        (B = u.child),
        (V = o.child.memoizedState),
        (V =
          V === null
            ? ks(g)
            : {
                baseLanes: V.baseLanes | g,
                cachePool: null,
                transitions: V.transitions,
              }),
        (B.memoizedState = V),
        (B.childLanes = o.childLanes & ~g),
        (u.memoizedState = yn),
        _
      );
    }
    return (
      (B = o.child),
      (o = B.sibling),
      (_ = Cl(B, { mode: "visible", children: _.children })),
      !(u.mode & 1) && (_.lanes = g),
      (_.return = u),
      (_.sibling = null),
      o !== null &&
        ((g = u.deletions),
        g === null ? ((u.deletions = [o]), (u.flags |= 16)) : g.push(o)),
      (u.child = _),
      (u.memoizedState = null),
      _
    );
  }
  function l2(o, u) {
    return (
      (u = r1({ mode: "visible", children: u }, o.mode, 0, null)),
      (u.return = o),
      (o.child = u)
    );
  }
  function jm(o, u, g, _) {
    return (
      _ !== null && hf(_),
      oa(u, o.child, null, g),
      (o = l2(u, u.pendingProps.children)),
      (o.flags |= 2),
      (u.memoizedState = null),
      o
    );
  }
  function R6(o, u, g, _, E, B, V) {
    if (g)
      return u.flags & 256
        ? ((u.flags &= -257), (_ = P(Error(t(422)))), jm(o, u, V, _))
        : u.memoizedState !== null
          ? ((u.child = o.child), (u.flags |= 128), null)
          : ((B = _.fallback),
            (E = u.mode),
            (_ = r1({ mode: "visible", children: _.children }, E, 0, null)),
            (B = Ju(B, E, V, null)),
            (B.flags |= 2),
            (_.return = u),
            (B.return = u),
            (_.sibling = B),
            (u.child = _),
            u.mode & 1 && oa(u, o.child, null, V),
            (u.child.memoizedState = ks(V)),
            (u.memoizedState = yn),
            B);
    if (!(u.mode & 1)) return jm(o, u, V, null);
    if (E.data === "$!") {
      if (((_ = E.nextSibling && E.nextSibling.dataset), _)) var ee = _.dgst;
      return (
        (_ = ee), (B = Error(t(419))), (_ = P(B, _, void 0)), jm(o, u, V, _)
      );
    }
    if (((ee = (V & o.childLanes) !== 0), bt || ee)) {
      if (((_ = Yr), _ !== null)) {
        switch (V & -V) {
          case 4:
            E = 2;
            break;
          case 16:
            E = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            E = 32;
            break;
          case 536870912:
            E = 268435456;
            break;
          default:
            E = 0;
        }
        (E = E & (_.suspendedLanes | V) ? 0 : E),
          E !== 0 &&
            E !== B.retryLane &&
            ((B.retryLane = E), Nn(o, E), ma(_, o, E, -1));
      }
      return w2(), (_ = P(Error(t(421)))), jm(o, u, V, _);
    }
    return E.data === "$?"
      ? ((u.flags |= 128),
        (u.child = o.child),
        (u = V6.bind(null, o)),
        (E._reactRetry = u),
        null)
      : ((o = B.treeContext),
        (vi = ea(E.nextSibling)),
        (si = u),
        (Xn = !0),
        (rs = null),
        o !== null &&
          ((Cr[ts++] = ns),
          (Cr[ts++] = Fs),
          (Cr[ts++] = ut),
          (ns = o.id),
          (Fs = o.overflow),
          (ut = u)),
        (u = l2(u, _.children)),
        (u.flags |= 4096),
        u);
  }
  function Fx(o, u, g) {
    o.lanes |= u;
    var _ = o.alternate;
    _ !== null && (_.lanes |= u), Pu(o.return, u, g);
  }
  function u2(o, u, g, _, E) {
    var B = o.memoizedState;
    B === null
      ? (o.memoizedState = {
          isBackwards: u,
          rendering: null,
          renderingStartTime: 0,
          last: _,
          tail: g,
          tailMode: E,
        })
      : ((B.isBackwards = u),
        (B.rendering = null),
        (B.renderingStartTime = 0),
        (B.last = _),
        (B.tail = g),
        (B.tailMode = E));
  }
  function Nx(o, u, g) {
    var _ = u.pendingProps,
      E = _.revealOrder,
      B = _.tail;
    if ((In(o, u, _.children, g), (_ = Rn.current), _ & 2))
      (_ = (_ & 1) | 2), (u.flags |= 128);
    else {
      if (o !== null && o.flags & 128)
        e: for (o = u.child; o !== null; ) {
          if (o.tag === 13) o.memoizedState !== null && Fx(o, g, u);
          else if (o.tag === 19) Fx(o, g, u);
          else if (o.child !== null) {
            (o.child.return = o), (o = o.child);
            continue;
          }
          if (o === u) break e;
          for (; o.sibling === null; ) {
            if (o.return === null || o.return === u) break e;
            o = o.return;
          }
          (o.sibling.return = o.return), (o = o.sibling);
        }
      _ &= 1;
    }
    if ((kn(Rn, _), !(u.mode & 1))) u.memoizedState = null;
    else
      switch (E) {
        case "forwards":
          for (g = u.child, E = null; g !== null; )
            (o = g.alternate),
              o !== null && Io(o) === null && (E = g),
              (g = g.sibling);
          (g = E),
            g === null
              ? ((E = u.child), (u.child = null))
              : ((E = g.sibling), (g.sibling = null)),
            u2(u, !1, E, g, B);
          break;
        case "backwards":
          for (g = null, E = u.child, u.child = null; E !== null; ) {
            if (((o = E.alternate), o !== null && Io(o) === null)) {
              u.child = E;
              break;
            }
            (o = E.sibling), (E.sibling = g), (g = E), (E = o);
          }
          u2(u, !0, g, null, B);
          break;
        case "together":
          u2(u, !1, null, null, void 0);
          break;
        default:
          u.memoizedState = null;
      }
    return u.child;
  }
  function Wm(o, u) {
    !(u.mode & 1) &&
      o !== null &&
      ((o.alternate = null), (u.alternate = null), (u.flags |= 2));
  }
  function Lo(o, u, g) {
    if (
      (o !== null && (u.dependencies = o.dependencies),
      (Gu |= u.lanes),
      !(g & u.childLanes))
    )
      return null;
    if (o !== null && u.child !== o.child) throw Error(t(153));
    if (u.child !== null) {
      for (
        o = u.child, g = Cl(o, o.pendingProps), u.child = g, g.return = u;
        o.sibling !== null;

      )
        (o = o.sibling),
          (g = g.sibling = Cl(o, o.pendingProps)),
          (g.return = u);
      g.sibling = null;
    }
    return u.child;
  }
  function I6(o, u, g) {
    switch (u.tag) {
      case 3:
        bn(u), aa();
        break;
      case 5:
        Du(u);
        break;
      case 1:
        ii(u.type) && Mu(u);
        break;
      case 4:
        Lu(u, u.stateNode.containerInfo);
        break;
      case 10:
        var _ = u.type._context,
          E = u.memoizedProps.value;
        kn(Mo, _._currentValue), (_._currentValue = E);
        break;
      case 13:
        if (((_ = u.memoizedState), _ !== null))
          return _.dehydrated !== null
            ? (kn(Rn, Rn.current & 1), (u.flags |= 128), null)
            : g & u.child.childLanes
              ? Gm(o, u, g)
              : (kn(Rn, Rn.current & 1),
                (o = Lo(o, u, g)),
                o !== null ? o.sibling : null);
        kn(Rn, Rn.current & 1);
        break;
      case 19:
        if (((_ = (g & u.childLanes) !== 0), o.flags & 128)) {
          if (_) return Nx(o, u, g);
          u.flags |= 128;
        }
        if (
          ((E = u.memoizedState),
          E !== null &&
            ((E.rendering = null), (E.tail = null), (E.lastEffect = null)),
          kn(Rn, Rn.current),
          _)
        )
          break;
        return null;
      case 22:
      case 23:
        return (u.lanes = 0), Le(o, u, g);
    }
    return Lo(o, u, g);
  }
  var Ux, c2, Ox, kx;
  (Ux = function (o, u) {
    for (var g = u.child; g !== null; ) {
      if (g.tag === 5 || g.tag === 6) o.appendChild(g.stateNode);
      else if (g.tag !== 4 && g.child !== null) {
        (g.child.return = g), (g = g.child);
        continue;
      }
      if (g === u) break;
      for (; g.sibling === null; ) {
        if (g.return === null || g.return === u) return;
        g = g.return;
      }
      (g.sibling.return = g.return), (g = g.sibling);
    }
  }),
    (c2 = function () {}),
    (Ox = function (o, u, g, _) {
      var E = o.memoizedProps;
      if (E !== _) {
        (o = u.stateNode), da(is.current);
        var B = null;
        switch (g) {
          case "input":
            (E = K(o, E)), (_ = K(o, _)), (B = []);
            break;
          case "select":
            (E = ae({}, E, { value: void 0 })),
              (_ = ae({}, _, { value: void 0 })),
              (B = []);
            break;
          case "textarea":
            (E = G(o, E)), (_ = G(o, _)), (B = []);
            break;
          default:
            typeof E.onClick != "function" &&
              typeof _.onClick == "function" &&
              (o.onclick = _o);
        }
        Qt(g, _);
        var V;
        g = null;
        for (Ie in E)
          if (!_.hasOwnProperty(Ie) && E.hasOwnProperty(Ie) && E[Ie] != null)
            if (Ie === "style") {
              var ee = E[Ie];
              for (V in ee)
                ee.hasOwnProperty(V) && (g || (g = {}), (g[V] = ""));
            } else
              Ie !== "dangerouslySetInnerHTML" &&
                Ie !== "children" &&
                Ie !== "suppressContentEditableWarning" &&
                Ie !== "suppressHydrationWarning" &&
                Ie !== "autoFocus" &&
                (i.hasOwnProperty(Ie)
                  ? B || (B = [])
                  : (B = B || []).push(Ie, null));
        for (Ie in _) {
          var ue = _[Ie];
          if (
            ((ee = E != null ? E[Ie] : void 0),
            _.hasOwnProperty(Ie) && ue !== ee && (ue != null || ee != null))
          )
            if (Ie === "style")
              if (ee) {
                for (V in ee)
                  !ee.hasOwnProperty(V) ||
                    (ue && ue.hasOwnProperty(V)) ||
                    (g || (g = {}), (g[V] = ""));
                for (V in ue)
                  ue.hasOwnProperty(V) &&
                    ee[V] !== ue[V] &&
                    (g || (g = {}), (g[V] = ue[V]));
              } else g || (B || (B = []), B.push(Ie, g)), (g = ue);
            else
              Ie === "dangerouslySetInnerHTML"
                ? ((ue = ue ? ue.__html : void 0),
                  (ee = ee ? ee.__html : void 0),
                  ue != null && ee !== ue && (B = B || []).push(Ie, ue))
                : Ie === "children"
                  ? (typeof ue != "string" && typeof ue != "number") ||
                    (B = B || []).push(Ie, "" + ue)
                  : Ie !== "suppressContentEditableWarning" &&
                    Ie !== "suppressHydrationWarning" &&
                    (i.hasOwnProperty(Ie)
                      ? (ue != null && Ie === "onScroll" && Vn("scroll", o),
                        B || ee === ue || (B = []))
                      : (B = B || []).push(Ie, ue));
        }
        g && (B = B || []).push("style", g);
        var Ie = B;
        (u.updateQueue = Ie) && (u.flags |= 4);
      }
    }),
    (kx = function (o, u, g, _) {
      g !== _ && (u.flags |= 4);
    });
  function wf(o, u) {
    if (!Xn)
      switch (o.tailMode) {
        case "hidden":
          u = o.tail;
          for (var g = null; u !== null; )
            u.alternate !== null && (g = u), (u = u.sibling);
          g === null ? (o.tail = null) : (g.sibling = null);
          break;
        case "collapsed":
          g = o.tail;
          for (var _ = null; g !== null; )
            g.alternate !== null && (_ = g), (g = g.sibling);
          _ === null
            ? u || o.tail === null
              ? (o.tail = null)
              : (o.tail.sibling = null)
            : (_.sibling = null);
      }
  }
  function bi(o) {
    var u = o.alternate !== null && o.alternate.child === o.child,
      g = 0,
      _ = 0;
    if (u)
      for (var E = o.child; E !== null; )
        (g |= E.lanes | E.childLanes),
          (_ |= E.subtreeFlags & 14680064),
          (_ |= E.flags & 14680064),
          (E.return = o),
          (E = E.sibling);
    else
      for (E = o.child; E !== null; )
        (g |= E.lanes | E.childLanes),
          (_ |= E.subtreeFlags),
          (_ |= E.flags),
          (E.return = o),
          (E = E.sibling);
    return (o.subtreeFlags |= _), (o.childLanes = g), u;
  }
  function B6(o, u, g) {
    var _ = u.pendingProps;
    switch ((wo(u), u.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bi(u), null;
      case 1:
        return ii(u.type) && _u(), bi(u), null;
      case 3:
        return (
          (_ = u.stateNode),
          xs(),
          Gn(Jr),
          Gn(Ur),
          _l(),
          _.pendingContext &&
            ((_.context = _.pendingContext), (_.pendingContext = null)),
          (o === null || o.child === null) &&
            (Cu(u)
              ? (u.flags |= 4)
              : o === null ||
                (o.memoizedState.isDehydrated && !(u.flags & 256)) ||
                ((u.flags |= 1024), rs !== null && (b2(rs), (rs = null)))),
          c2(o, u),
          bi(u),
          null
        );
      case 5:
        Fu(u);
        var E = da(Tr.current);
        if (((g = u.type), o !== null && u.stateNode != null))
          Ox(o, u, g, _, E),
            o.ref !== u.ref && ((u.flags |= 512), (u.flags |= 2097152));
        else {
          if (!_) {
            if (u.stateNode === null) throw Error(t(166));
            return bi(u), null;
          }
          if (((o = da(is.current)), Cu(u))) {
            (_ = u.stateNode), (g = u.type);
            var B = u.memoizedProps;
            switch (((_[ys] = u), (_[ta] = B), (o = (u.mode & 1) !== 0), g)) {
              case "dialog":
                Vn("cancel", _), Vn("close", _);
                break;
              case "iframe":
              case "object":
              case "embed":
                Vn("load", _);
                break;
              case "video":
              case "audio":
                for (E = 0; E < Oa.length; E++) Vn(Oa[E], _);
                break;
              case "source":
                Vn("error", _);
                break;
              case "img":
              case "image":
              case "link":
                Vn("error", _), Vn("load", _);
                break;
              case "details":
                Vn("toggle", _);
                break;
              case "input":
                qe(_, B), Vn("invalid", _);
                break;
              case "select":
                (_._wrapperState = { wasMultiple: !!B.multiple }),
                  Vn("invalid", _);
                break;
              case "textarea":
                xe(_, B), Vn("invalid", _);
            }
            Qt(g, B), (E = null);
            for (var V in B)
              if (B.hasOwnProperty(V)) {
                var ee = B[V];
                V === "children"
                  ? typeof ee == "string"
                    ? _.textContent !== ee &&
                      (B.suppressHydrationWarning !== !0 &&
                        xu(_.textContent, ee, o),
                      (E = ["children", ee]))
                    : typeof ee == "number" &&
                      _.textContent !== "" + ee &&
                      (B.suppressHydrationWarning !== !0 &&
                        xu(_.textContent, ee, o),
                      (E = ["children", "" + ee]))
                  : i.hasOwnProperty(V) &&
                    ee != null &&
                    V === "onScroll" &&
                    Vn("scroll", _);
              }
            switch (g) {
              case "input":
                be(_), nt(_, B, !0);
                break;
              case "textarea":
                be(_), We(_);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof B.onClick == "function" && (_.onclick = _o);
            }
            (_ = E), (u.updateQueue = _), _ !== null && (u.flags |= 4);
          } else {
            (V = E.nodeType === 9 ? E : E.ownerDocument),
              o === "http://www.w3.org/1999/xhtml" && (o = Oe(g)),
              o === "http://www.w3.org/1999/xhtml"
                ? g === "script"
                  ? ((o = V.createElement("div")),
                    (o.innerHTML = "<script><\/script>"),
                    (o = o.removeChild(o.firstChild)))
                  : typeof _.is == "string"
                    ? (o = V.createElement(g, { is: _.is }))
                    : ((o = V.createElement(g)),
                      g === "select" &&
                        ((V = o),
                        _.multiple
                          ? (V.multiple = !0)
                          : _.size && (V.size = _.size)))
                : (o = V.createElementNS(o, g)),
              (o[ys] = u),
              (o[ta] = _),
              Ux(o, u, !1, !1),
              (u.stateNode = o);
            e: {
              switch (((V = D(g, _)), g)) {
                case "dialog":
                  Vn("cancel", o), Vn("close", o), (E = _);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Vn("load", o), (E = _);
                  break;
                case "video":
                case "audio":
                  for (E = 0; E < Oa.length; E++) Vn(Oa[E], o);
                  E = _;
                  break;
                case "source":
                  Vn("error", o), (E = _);
                  break;
                case "img":
                case "image":
                case "link":
                  Vn("error", o), Vn("load", o), (E = _);
                  break;
                case "details":
                  Vn("toggle", o), (E = _);
                  break;
                case "input":
                  qe(o, _), (E = K(o, _)), Vn("invalid", o);
                  break;
                case "option":
                  E = _;
                  break;
                case "select":
                  (o._wrapperState = { wasMultiple: !!_.multiple }),
                    (E = ae({}, _, { value: void 0 })),
                    Vn("invalid", o);
                  break;
                case "textarea":
                  xe(o, _), (E = G(o, _)), Vn("invalid", o);
                  break;
                default:
                  E = _;
              }
              Qt(g, E), (ee = E);
              for (B in ee)
                if (ee.hasOwnProperty(B)) {
                  var ue = ee[B];
                  B === "style"
                    ? st(o, ue)
                    : B === "dangerouslySetInnerHTML"
                      ? ((ue = ue ? ue.__html : void 0),
                        ue != null && ft(o, ue))
                      : B === "children"
                        ? typeof ue == "string"
                          ? (g !== "textarea" || ue !== "") && Ot(o, ue)
                          : typeof ue == "number" && Ot(o, "" + ue)
                        : B !== "suppressContentEditableWarning" &&
                          B !== "suppressHydrationWarning" &&
                          B !== "autoFocus" &&
                          (i.hasOwnProperty(B)
                            ? ue != null && B === "onScroll" && Vn("scroll", o)
                            : ue != null && T(o, B, ue, V));
                }
              switch (g) {
                case "input":
                  be(o), nt(o, _, !1);
                  break;
                case "textarea":
                  be(o), We(o);
                  break;
                case "option":
                  _.value != null && o.setAttribute("value", "" + Je(_.value));
                  break;
                case "select":
                  (o.multiple = !!_.multiple),
                    (B = _.value),
                    B != null
                      ? Z(o, !!_.multiple, B, !1)
                      : _.defaultValue != null &&
                        Z(o, !!_.multiple, _.defaultValue, !0);
                  break;
                default:
                  typeof E.onClick == "function" && (o.onclick = _o);
              }
              switch (g) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  _ = !!_.autoFocus;
                  break e;
                case "img":
                  _ = !0;
                  break e;
                default:
                  _ = !1;
              }
            }
            _ && (u.flags |= 4);
          }
          u.ref !== null && ((u.flags |= 512), (u.flags |= 2097152));
        }
        return bi(u), null;
      case 6:
        if (o && u.stateNode != null) kx(o, u, o.memoizedProps, _);
        else {
          if (typeof _ != "string" && u.stateNode === null) throw Error(t(166));
          if (((g = da(Tr.current)), da(is.current), Cu(u))) {
            if (
              ((_ = u.stateNode),
              (g = u.memoizedProps),
              (_[ys] = u),
              (B = _.nodeValue !== g) && ((o = si), o !== null))
            )
              switch (o.tag) {
                case 3:
                  xu(_.nodeValue, g, (o.mode & 1) !== 0);
                  break;
                case 5:
                  o.memoizedProps.suppressHydrationWarning !== !0 &&
                    xu(_.nodeValue, g, (o.mode & 1) !== 0);
              }
            B && (u.flags |= 4);
          } else
            (_ = (g.nodeType === 9 ? g : g.ownerDocument).createTextNode(_)),
              (_[ys] = u),
              (u.stateNode = _);
        }
        return bi(u), null;
      case 13:
        if (
          (Gn(Rn),
          (_ = u.memoizedState),
          o === null ||
            (o.memoizedState !== null && o.memoizedState.dehydrated !== null))
        ) {
          if (Xn && vi !== null && u.mode & 1 && !(u.flags & 128))
            md(), aa(), (u.flags |= 98560), (B = !1);
          else if (((B = Cu(u)), _ !== null && _.dehydrated !== null)) {
            if (o === null) {
              if (!B) throw Error(t(318));
              if (
                ((B = u.memoizedState),
                (B = B !== null ? B.dehydrated : null),
                !B)
              )
                throw Error(t(317));
              B[ys] = u;
            } else
              aa(),
                !(u.flags & 128) && (u.memoizedState = null),
                (u.flags |= 4);
            bi(u), (B = !1);
          } else rs !== null && (b2(rs), (rs = null)), (B = !0);
          if (!B) return u.flags & 65536 ? u : null;
        }
        return u.flags & 128
          ? ((u.lanes = g), u)
          : ((_ = _ !== null),
            _ !== (o !== null && o.memoizedState !== null) &&
              _ &&
              ((u.child.flags |= 8192),
              u.mode & 1 &&
                (o === null || Rn.current & 1 ? kr === 0 && (kr = 3) : w2())),
            u.updateQueue !== null && (u.flags |= 4),
            bi(u),
            null);
      case 4:
        return (
          xs(),
          c2(o, u),
          o === null && bo(u.stateNode.containerInfo),
          bi(u),
          null
        );
      case 10:
        return Bu(u.type._context), bi(u), null;
      case 17:
        return ii(u.type) && _u(), bi(u), null;
      case 19:
        if ((Gn(Rn), (B = u.memoizedState), B === null)) return bi(u), null;
        if (((_ = (u.flags & 128) !== 0), (V = B.rendering), V === null))
          if (_) wf(B, !1);
          else {
            if (kr !== 0 || (o !== null && o.flags & 128))
              for (o = u.child; o !== null; ) {
                if (((V = Io(o)), V !== null)) {
                  for (
                    u.flags |= 128,
                      wf(B, !1),
                      _ = V.updateQueue,
                      _ !== null && ((u.updateQueue = _), (u.flags |= 4)),
                      u.subtreeFlags = 0,
                      _ = g,
                      g = u.child;
                    g !== null;

                  )
                    (B = g),
                      (o = _),
                      (B.flags &= 14680066),
                      (V = B.alternate),
                      V === null
                        ? ((B.childLanes = 0),
                          (B.lanes = o),
                          (B.child = null),
                          (B.subtreeFlags = 0),
                          (B.memoizedProps = null),
                          (B.memoizedState = null),
                          (B.updateQueue = null),
                          (B.dependencies = null),
                          (B.stateNode = null))
                        : ((B.childLanes = V.childLanes),
                          (B.lanes = V.lanes),
                          (B.child = V.child),
                          (B.subtreeFlags = 0),
                          (B.deletions = null),
                          (B.memoizedProps = V.memoizedProps),
                          (B.memoizedState = V.memoizedState),
                          (B.updateQueue = V.updateQueue),
                          (B.type = V.type),
                          (o = V.dependencies),
                          (B.dependencies =
                            o === null
                              ? null
                              : {
                                  lanes: o.lanes,
                                  firstContext: o.firstContext,
                                })),
                      (g = g.sibling);
                  return kn(Rn, (Rn.current & 1) | 2), u.child;
                }
                o = o.sibling;
              }
            B.tail !== null &&
              se() > Cd &&
              ((u.flags |= 128), (_ = !0), wf(B, !1), (u.lanes = 4194304));
          }
        else {
          if (!_)
            if (((o = Io(V)), o !== null)) {
              if (
                ((u.flags |= 128),
                (_ = !0),
                (g = o.updateQueue),
                g !== null && ((u.updateQueue = g), (u.flags |= 4)),
                wf(B, !0),
                B.tail === null &&
                  B.tailMode === "hidden" &&
                  !V.alternate &&
                  !Xn)
              )
                return bi(u), null;
            } else
              2 * se() - B.renderingStartTime > Cd &&
                g !== 1073741824 &&
                ((u.flags |= 128), (_ = !0), wf(B, !1), (u.lanes = 4194304));
          B.isBackwards
            ? ((V.sibling = u.child), (u.child = V))
            : ((g = B.last),
              g !== null ? (g.sibling = V) : (u.child = V),
              (B.last = V));
        }
        return B.tail !== null
          ? ((u = B.tail),
            (B.rendering = u),
            (B.tail = u.sibling),
            (B.renderingStartTime = se()),
            (u.sibling = null),
            (g = Rn.current),
            kn(Rn, _ ? (g & 1) | 2 : g & 1),
            u)
          : (bi(u), null);
      case 22:
      case 23:
        return (
          A2(),
          (_ = u.memoizedState !== null),
          o !== null && (o.memoizedState !== null) !== _ && (u.flags |= 8192),
          _ && u.mode & 1
            ? _s & 1073741824 &&
              (bi(u), u.subtreeFlags & 6 && (u.flags |= 8192))
            : bi(u),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, u.tag));
  }
  function P6(o, u) {
    switch ((wo(u), u.tag)) {
      case 1:
        return (
          ii(u.type) && _u(),
          (o = u.flags),
          o & 65536 ? ((u.flags = (o & -65537) | 128), u) : null
        );
      case 3:
        return (
          xs(),
          Gn(Jr),
          Gn(Ur),
          _l(),
          (o = u.flags),
          o & 65536 && !(o & 128) ? ((u.flags = (o & -65537) | 128), u) : null
        );
      case 5:
        return Fu(u), null;
      case 13:
        if (
          (Gn(Rn), (o = u.memoizedState), o !== null && o.dehydrated !== null)
        ) {
          if (u.alternate === null) throw Error(t(340));
          aa();
        }
        return (
          (o = u.flags), o & 65536 ? ((u.flags = (o & -65537) | 128), u) : null
        );
      case 19:
        return Gn(Rn), null;
      case 4:
        return xs(), null;
      case 10:
        return Bu(u.type._context), null;
      case 22:
      case 23:
        return A2(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Xm = !1,
    _i = !1,
    L6 = typeof WeakSet == "function" ? WeakSet : Set,
    Ct = null;
  function Sd(o, u) {
    var g = o.ref;
    if (g !== null)
      if (typeof g == "function")
        try {
          g(null);
        } catch (_) {
          mr(o, u, _);
        }
      else g.current = null;
  }
  function zx(o, u, g) {
    try {
      g();
    } catch (_) {
      mr(o, u, _);
    }
  }
  var Hx = !1;
  function D6(o, u) {
    if (((nf = uo), (o = Nr()), ur(o))) {
      if ("selectionStart" in o)
        var g = { start: o.selectionStart, end: o.selectionEnd };
      else
        e: {
          g = ((g = o.ownerDocument) && g.defaultView) || window;
          var _ = g.getSelection && g.getSelection();
          if (_ && _.rangeCount !== 0) {
            g = _.anchorNode;
            var E = _.anchorOffset,
              B = _.focusNode;
            _ = _.focusOffset;
            try {
              g.nodeType, B.nodeType;
            } catch {
              g = null;
              break e;
            }
            var V = 0,
              ee = -1,
              ue = -1,
              Ie = 0,
              Ze = 0,
              $e = o,
              Ye = null;
            t: for (;;) {
              for (
                var wt;
                $e !== g || (E !== 0 && $e.nodeType !== 3) || (ee = V + E),
                  $e !== B || (_ !== 0 && $e.nodeType !== 3) || (ue = V + _),
                  $e.nodeType === 3 && (V += $e.nodeValue.length),
                  (wt = $e.firstChild) !== null;

              )
                (Ye = $e), ($e = wt);
              for (;;) {
                if ($e === o) break t;
                if (
                  (Ye === g && ++Ie === E && (ee = V),
                  Ye === B && ++Ze === _ && (ue = V),
                  (wt = $e.nextSibling) !== null)
                )
                  break;
                ($e = Ye), (Ye = $e.parentNode);
              }
              $e = wt;
            }
            g = ee === -1 || ue === -1 ? null : { start: ee, end: ue };
          } else g = null;
        }
      g = g || { start: 0, end: 0 };
    } else g = null;
    for (
      rf = { focusedElem: o, selectionRange: g }, uo = !1, Ct = u;
      Ct !== null;

    )
      if (
        ((u = Ct), (o = u.child), (u.subtreeFlags & 1028) !== 0 && o !== null)
      )
        (o.return = u), (Ct = o);
      else
        for (; Ct !== null; ) {
          u = Ct;
          try {
            var Rt = u.alternate;
            if (u.flags & 1024)
              switch (u.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Rt !== null) {
                    var Bt = Rt.memoizedProps,
                      xr = Rt.memoizedState,
                      we = u.stateNode,
                      de = we.getSnapshotBeforeUpdate(
                        u.elementType === u.type ? Bt : zi(u.type, Bt),
                        xr,
                      );
                    we.__reactInternalSnapshotBeforeUpdate = de;
                  }
                  break;
                case 3:
                  var Se = u.stateNode.containerInfo;
                  Se.nodeType === 1
                    ? (Se.textContent = "")
                    : Se.nodeType === 9 &&
                      Se.documentElement &&
                      Se.removeChild(Se.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (at) {
            mr(u, u.return, at);
          }
          if (((o = u.sibling), o !== null)) {
            (o.return = u.return), (Ct = o);
            break;
          }
          Ct = u.return;
        }
    return (Rt = Hx), (Hx = !1), Rt;
  }
  function Mf(o, u, g) {
    var _ = u.updateQueue;
    if (((_ = _ !== null ? _.lastEffect : null), _ !== null)) {
      var E = (_ = _.next);
      do {
        if ((E.tag & o) === o) {
          var B = E.destroy;
          (E.destroy = void 0), B !== void 0 && zx(u, g, B);
        }
        E = E.next;
      } while (E !== _);
    }
  }
  function Jm(o, u) {
    if (
      ((u = u.updateQueue), (u = u !== null ? u.lastEffect : null), u !== null)
    ) {
      var g = (u = u.next);
      do {
        if ((g.tag & o) === o) {
          var _ = g.create;
          g.destroy = _();
        }
        g = g.next;
      } while (g !== u);
    }
  }
  function d2(o) {
    var u = o.ref;
    if (u !== null) {
      var g = o.stateNode;
      switch (o.tag) {
        case 5:
          o = g;
          break;
        default:
          o = g;
      }
      typeof u == "function" ? u(o) : (u.current = o);
    }
  }
  function Vx(o) {
    var u = o.alternate;
    u !== null && ((o.alternate = null), Vx(u)),
      (o.child = null),
      (o.deletions = null),
      (o.sibling = null),
      o.tag === 5 &&
        ((u = o.stateNode),
        u !== null &&
          (delete u[ys],
          delete u[ta],
          delete u[ml],
          delete u[ud],
          delete u[Im])),
      (o.stateNode = null),
      (o.return = null),
      (o.dependencies = null),
      (o.memoizedProps = null),
      (o.memoizedState = null),
      (o.pendingProps = null),
      (o.stateNode = null),
      (o.updateQueue = null);
  }
  function Gx(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 4;
  }
  function jx(o) {
    e: for (;;) {
      for (; o.sibling === null; ) {
        if (o.return === null || Gx(o.return)) return null;
        o = o.return;
      }
      for (
        o.sibling.return = o.return, o = o.sibling;
        o.tag !== 5 && o.tag !== 6 && o.tag !== 18;

      ) {
        if (o.flags & 2 || o.child === null || o.tag === 4) continue e;
        (o.child.return = o), (o = o.child);
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function h2(o, u, g) {
    var _ = o.tag;
    if (_ === 5 || _ === 6)
      (o = o.stateNode),
        u
          ? g.nodeType === 8
            ? g.parentNode.insertBefore(o, u)
            : g.insertBefore(o, u)
          : (g.nodeType === 8
              ? ((u = g.parentNode), u.insertBefore(o, g))
              : ((u = g), u.appendChild(o)),
            (g = g._reactRootContainer),
            g != null || u.onclick !== null || (u.onclick = _o));
    else if (_ !== 4 && ((o = o.child), o !== null))
      for (h2(o, u, g), o = o.sibling; o !== null; )
        h2(o, u, g), (o = o.sibling);
  }
  function f2(o, u, g) {
    var _ = o.tag;
    if (_ === 5 || _ === 6)
      (o = o.stateNode), u ? g.insertBefore(o, u) : g.appendChild(o);
    else if (_ !== 4 && ((o = o.child), o !== null))
      for (f2(o, u, g), o = o.sibling; o !== null; )
        f2(o, u, g), (o = o.sibling);
  }
  var oi = null,
    fa = !1;
  function Al(o, u, g) {
    for (g = g.child; g !== null; ) Wx(o, u, g), (g = g.sibling);
  }
  function Wx(o, u, g) {
    if (At && typeof At.onCommitFiberUnmount == "function")
      try {
        At.onCommitFiberUnmount(gt, g);
      } catch {}
    switch (g.tag) {
      case 5:
        _i || Sd(g, u);
      case 6:
        var _ = oi,
          E = fa;
        (oi = null),
          Al(o, u, g),
          (oi = _),
          (fa = E),
          oi !== null &&
            (fa
              ? ((o = oi),
                (g = g.stateNode),
                o.nodeType === 8
                  ? o.parentNode.removeChild(g)
                  : o.removeChild(g))
              : oi.removeChild(g.stateNode));
        break;
      case 18:
        oi !== null &&
          (fa
            ? ((o = oi),
              (g = g.stateNode),
              o.nodeType === 8
                ? ld(o.parentNode, g)
                : o.nodeType === 1 && ld(o, g),
              fi(o))
            : ld(oi, g.stateNode));
        break;
      case 4:
        (_ = oi),
          (E = fa),
          (oi = g.stateNode.containerInfo),
          (fa = !0),
          Al(o, u, g),
          (oi = _),
          (fa = E);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !_i &&
          ((_ = g.updateQueue), _ !== null && ((_ = _.lastEffect), _ !== null))
        ) {
          E = _ = _.next;
          do {
            var B = E,
              V = B.destroy;
            (B = B.tag),
              V !== void 0 && (B & 2 || B & 4) && zx(g, u, V),
              (E = E.next);
          } while (E !== _);
        }
        Al(o, u, g);
        break;
      case 1:
        if (
          !_i &&
          (Sd(g, u),
          (_ = g.stateNode),
          typeof _.componentWillUnmount == "function")
        )
          try {
            (_.props = g.memoizedProps),
              (_.state = g.memoizedState),
              _.componentWillUnmount();
          } catch (ee) {
            mr(g, u, ee);
          }
        Al(o, u, g);
        break;
      case 21:
        Al(o, u, g);
        break;
      case 22:
        g.mode & 1
          ? ((_i = (_ = _i) || g.memoizedState !== null), Al(o, u, g), (_i = _))
          : Al(o, u, g);
        break;
      default:
        Al(o, u, g);
    }
  }
  function Xx(o) {
    var u = o.updateQueue;
    if (u !== null) {
      o.updateQueue = null;
      var g = o.stateNode;
      g === null && (g = o.stateNode = new L6()),
        u.forEach(function (_) {
          var E = G6.bind(null, o, _);
          g.has(_) || (g.add(_), _.then(E, E));
        });
    }
  }
  function pa(o, u) {
    var g = u.deletions;
    if (g !== null)
      for (var _ = 0; _ < g.length; _++) {
        var E = g[_];
        try {
          var B = o,
            V = u,
            ee = V;
          e: for (; ee !== null; ) {
            switch (ee.tag) {
              case 5:
                (oi = ee.stateNode), (fa = !1);
                break e;
              case 3:
                (oi = ee.stateNode.containerInfo), (fa = !0);
                break e;
              case 4:
                (oi = ee.stateNode.containerInfo), (fa = !0);
                break e;
            }
            ee = ee.return;
          }
          if (oi === null) throw Error(t(160));
          Wx(B, V, E), (oi = null), (fa = !1);
          var ue = E.alternate;
          ue !== null && (ue.return = null), (E.return = null);
        } catch (Ie) {
          mr(E, u, Ie);
        }
      }
    if (u.subtreeFlags & 12854)
      for (u = u.child; u !== null; ) Jx(u, o), (u = u.sibling);
  }
  function Jx(o, u) {
    var g = o.alternate,
      _ = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((pa(u, o), Za(o), _ & 4)) {
          try {
            Mf(3, o, o.return), Jm(3, o);
          } catch (Bt) {
            mr(o, o.return, Bt);
          }
          try {
            Mf(5, o, o.return);
          } catch (Bt) {
            mr(o, o.return, Bt);
          }
        }
        break;
      case 1:
        pa(u, o), Za(o), _ & 512 && g !== null && Sd(g, g.return);
        break;
      case 5:
        if (
          (pa(u, o),
          Za(o),
          _ & 512 && g !== null && Sd(g, g.return),
          o.flags & 32)
        ) {
          var E = o.stateNode;
          try {
            Ot(E, "");
          } catch (Bt) {
            mr(o, o.return, Bt);
          }
        }
        if (_ & 4 && ((E = o.stateNode), E != null)) {
          var B = o.memoizedProps,
            V = g !== null ? g.memoizedProps : B,
            ee = o.type,
            ue = o.updateQueue;
          if (((o.updateQueue = null), ue !== null))
            try {
              ee === "input" &&
                B.type === "radio" &&
                B.name != null &&
                ct(E, B),
                D(ee, V);
              var Ie = D(ee, B);
              for (V = 0; V < ue.length; V += 2) {
                var Ze = ue[V],
                  $e = ue[V + 1];
                Ze === "style"
                  ? st(E, $e)
                  : Ze === "dangerouslySetInnerHTML"
                    ? ft(E, $e)
                    : Ze === "children"
                      ? Ot(E, $e)
                      : T(E, Ze, $e, Ie);
              }
              switch (ee) {
                case "input":
                  Be(E, B);
                  break;
                case "textarea":
                  ze(E, B);
                  break;
                case "select":
                  var Ye = E._wrapperState.wasMultiple;
                  E._wrapperState.wasMultiple = !!B.multiple;
                  var wt = B.value;
                  wt != null
                    ? Z(E, !!B.multiple, wt, !1)
                    : Ye !== !!B.multiple &&
                      (B.defaultValue != null
                        ? Z(E, !!B.multiple, B.defaultValue, !0)
                        : Z(E, !!B.multiple, B.multiple ? [] : "", !1));
              }
              E[ta] = B;
            } catch (Bt) {
              mr(o, o.return, Bt);
            }
        }
        break;
      case 6:
        if ((pa(u, o), Za(o), _ & 4)) {
          if (o.stateNode === null) throw Error(t(162));
          (E = o.stateNode), (B = o.memoizedProps);
          try {
            E.nodeValue = B;
          } catch (Bt) {
            mr(o, o.return, Bt);
          }
        }
        break;
      case 3:
        if (
          (pa(u, o), Za(o), _ & 4 && g !== null && g.memoizedState.isDehydrated)
        )
          try {
            fi(u.containerInfo);
          } catch (Bt) {
            mr(o, o.return, Bt);
          }
        break;
      case 4:
        pa(u, o), Za(o);
        break;
      case 13:
        pa(u, o),
          Za(o),
          (E = o.child),
          E.flags & 8192 &&
            ((B = E.memoizedState !== null),
            (E.stateNode.isHidden = B),
            !B ||
              (E.alternate !== null && E.alternate.memoizedState !== null) ||
              (g2 = se())),
          _ & 4 && Xx(o);
        break;
      case 22:
        if (
          ((Ze = g !== null && g.memoizedState !== null),
          o.mode & 1 ? ((_i = (Ie = _i) || Ze), pa(u, o), (_i = Ie)) : pa(u, o),
          Za(o),
          _ & 8192)
        ) {
          if (
            ((Ie = o.memoizedState !== null),
            (o.stateNode.isHidden = Ie) && !Ze && o.mode & 1)
          )
            for (Ct = o, Ze = o.child; Ze !== null; ) {
              for ($e = Ct = Ze; Ct !== null; ) {
                switch (((Ye = Ct), (wt = Ye.child), Ye.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Mf(4, Ye, Ye.return);
                    break;
                  case 1:
                    Sd(Ye, Ye.return);
                    var Rt = Ye.stateNode;
                    if (typeof Rt.componentWillUnmount == "function") {
                      (_ = Ye), (g = Ye.return);
                      try {
                        (u = _),
                          (Rt.props = u.memoizedProps),
                          (Rt.state = u.memoizedState),
                          Rt.componentWillUnmount();
                      } catch (Bt) {
                        mr(_, g, Bt);
                      }
                    }
                    break;
                  case 5:
                    Sd(Ye, Ye.return);
                    break;
                  case 22:
                    if (Ye.memoizedState !== null) {
                      qx($e);
                      continue;
                    }
                }
                wt !== null ? ((wt.return = Ye), (Ct = wt)) : qx($e);
              }
              Ze = Ze.sibling;
            }
          e: for (Ze = null, $e = o; ; ) {
            if ($e.tag === 5) {
              if (Ze === null) {
                Ze = $e;
                try {
                  (E = $e.stateNode),
                    Ie
                      ? ((B = E.style),
                        typeof B.setProperty == "function"
                          ? B.setProperty("display", "none", "important")
                          : (B.display = "none"))
                      : ((ee = $e.stateNode),
                        (ue = $e.memoizedProps.style),
                        (V =
                          ue != null && ue.hasOwnProperty("display")
                            ? ue.display
                            : null),
                        (ee.style.display = Tt("display", V)));
                } catch (Bt) {
                  mr(o, o.return, Bt);
                }
              }
            } else if ($e.tag === 6) {
              if (Ze === null)
                try {
                  $e.stateNode.nodeValue = Ie ? "" : $e.memoizedProps;
                } catch (Bt) {
                  mr(o, o.return, Bt);
                }
            } else if (
              (($e.tag !== 22 && $e.tag !== 23) ||
                $e.memoizedState === null ||
                $e === o) &&
              $e.child !== null
            ) {
              ($e.child.return = $e), ($e = $e.child);
              continue;
            }
            if ($e === o) break e;
            for (; $e.sibling === null; ) {
              if ($e.return === null || $e.return === o) break e;
              Ze === $e && (Ze = null), ($e = $e.return);
            }
            Ze === $e && (Ze = null),
              ($e.sibling.return = $e.return),
              ($e = $e.sibling);
          }
        }
        break;
      case 19:
        pa(u, o), Za(o), _ & 4 && Xx(o);
        break;
      case 21:
        break;
      default:
        pa(u, o), Za(o);
    }
  }
  function Za(o) {
    var u = o.flags;
    if (u & 2) {
      try {
        e: {
          for (var g = o.return; g !== null; ) {
            if (Gx(g)) {
              var _ = g;
              break e;
            }
            g = g.return;
          }
          throw Error(t(160));
        }
        switch (_.tag) {
          case 5:
            var E = _.stateNode;
            _.flags & 32 && (Ot(E, ""), (_.flags &= -33));
            var B = jx(o);
            f2(o, B, E);
            break;
          case 3:
          case 4:
            var V = _.stateNode.containerInfo,
              ee = jx(o);
            h2(o, ee, V);
            break;
          default:
            throw Error(t(161));
        }
      } catch (ue) {
        mr(o, o.return, ue);
      }
      o.flags &= -3;
    }
    u & 4096 && (o.flags &= -4097);
  }
  function F6(o, u, g) {
    (Ct = o), Yx(o);
  }
  function Yx(o, u, g) {
    for (var _ = (o.mode & 1) !== 0; Ct !== null; ) {
      var E = Ct,
        B = E.child;
      if (E.tag === 22 && _) {
        var V = E.memoizedState !== null || Xm;
        if (!V) {
          var ee = E.alternate,
            ue = (ee !== null && ee.memoizedState !== null) || _i;
          ee = Xm;
          var Ie = _i;
          if (((Xm = V), (_i = ue) && !Ie))
            for (Ct = E; Ct !== null; )
              (V = Ct),
                (ue = V.child),
                V.tag === 22 && V.memoizedState !== null
                  ? Kx(E)
                  : ue !== null
                    ? ((ue.return = V), (Ct = ue))
                    : Kx(E);
          for (; B !== null; ) (Ct = B), Yx(B), (B = B.sibling);
          (Ct = E), (Xm = ee), (_i = Ie);
        }
        Zx(o);
      } else
        E.subtreeFlags & 8772 && B !== null
          ? ((B.return = E), (Ct = B))
          : Zx(o);
    }
  }
  function Zx(o) {
    for (; Ct !== null; ) {
      var u = Ct;
      if (u.flags & 8772) {
        var g = u.alternate;
        try {
          if (u.flags & 8772)
            switch (u.tag) {
              case 0:
              case 11:
              case 15:
                _i || Jm(5, u);
                break;
              case 1:
                var _ = u.stateNode;
                if (u.flags & 4 && !_i)
                  if (g === null) _.componentDidMount();
                  else {
                    var E =
                      u.elementType === u.type
                        ? g.memoizedProps
                        : zi(u.type, g.memoizedProps);
                    _.componentDidUpdate(
                      E,
                      g.memoizedState,
                      _.__reactInternalSnapshotBeforeUpdate,
                    );
                  }
                var B = u.updateQueue;
                B !== null && Ro(u, B, _);
                break;
              case 3:
                var V = u.updateQueue;
                if (V !== null) {
                  if (((g = null), u.child !== null))
                    switch (u.child.tag) {
                      case 5:
                        g = u.child.stateNode;
                        break;
                      case 1:
                        g = u.child.stateNode;
                    }
                  Ro(u, V, g);
                }
                break;
              case 5:
                var ee = u.stateNode;
                if (g === null && u.flags & 4) {
                  g = ee;
                  var ue = u.memoizedProps;
                  switch (u.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ue.autoFocus && g.focus();
                      break;
                    case "img":
                      ue.src && (g.src = ue.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (u.memoizedState === null) {
                  var Ie = u.alternate;
                  if (Ie !== null) {
                    var Ze = Ie.memoizedState;
                    if (Ze !== null) {
                      var $e = Ze.dehydrated;
                      $e !== null && fi($e);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          _i || (u.flags & 512 && d2(u));
        } catch (Ye) {
          mr(u, u.return, Ye);
        }
      }
      if (u === o) {
        Ct = null;
        break;
      }
      if (((g = u.sibling), g !== null)) {
        (g.return = u.return), (Ct = g);
        break;
      }
      Ct = u.return;
    }
  }
  function qx(o) {
    for (; Ct !== null; ) {
      var u = Ct;
      if (u === o) {
        Ct = null;
        break;
      }
      var g = u.sibling;
      if (g !== null) {
        (g.return = u.return), (Ct = g);
        break;
      }
      Ct = u.return;
    }
  }
  function Kx(o) {
    for (; Ct !== null; ) {
      var u = Ct;
      try {
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            var g = u.return;
            try {
              Jm(4, u);
            } catch (ue) {
              mr(u, g, ue);
            }
            break;
          case 1:
            var _ = u.stateNode;
            if (typeof _.componentDidMount == "function") {
              var E = u.return;
              try {
                _.componentDidMount();
              } catch (ue) {
                mr(u, E, ue);
              }
            }
            var B = u.return;
            try {
              d2(u);
            } catch (ue) {
              mr(u, B, ue);
            }
            break;
          case 5:
            var V = u.return;
            try {
              d2(u);
            } catch (ue) {
              mr(u, V, ue);
            }
        }
      } catch (ue) {
        mr(u, u.return, ue);
      }
      if (u === o) {
        Ct = null;
        break;
      }
      var ee = u.sibling;
      if (ee !== null) {
        (ee.return = u.return), (Ct = ee);
        break;
      }
      Ct = u.return;
    }
  }
  var N6 = Math.ceil,
    Ym = I.ReactCurrentDispatcher,
    p2 = I.ReactCurrentOwner,
    zs = I.ReactCurrentBatchConfig,
    En = 0,
    Yr = null,
    Br = null,
    li = 0,
    _s = 0,
    Ed = na(0),
    kr = 0,
    Sf = null,
    Gu = 0,
    Zm = 0,
    m2 = 0,
    Ef = null,
    ss = null,
    g2 = 0,
    Cd = 1 / 0,
    Do = null,
    qm = !1,
    y2 = null,
    wl = null,
    Km = !1,
    Ml = null,
    Qm = 0,
    Cf = 0,
    v2 = null,
    $m = -1,
    e1 = 0;
  function Vi() {
    return En & 6 ? se() : $m !== -1 ? $m : ($m = se());
  }
  function Sl(o) {
    return o.mode & 1
      ? En & 2 && li !== 0
        ? li & -li
        : o2.transition !== null
          ? (e1 === 0 && (e1 = ei()), e1)
          : ((o = rn),
            o !== 0 ||
              ((o = window.event), (o = o === void 0 ? 16 : ru(o.type))),
            o)
      : 1;
  }
  function ma(o, u, g, _) {
    if (50 < Cf) throw ((Cf = 0), (v2 = null), Error(t(185)));
    Kn(o, g, _),
      (!(En & 2) || o !== Yr) &&
        (o === Yr && (!(En & 2) && (Zm |= g), kr === 4 && El(o, li)),
        as(o, _),
        g === 1 &&
          En === 0 &&
          !(u.mode & 1) &&
          ((Cd = se() + 500), Su && ia()));
  }
  function as(o, u) {
    var g = o.callbackNode;
    Ra(o, u);
    var _ = Yi(o, o === Yr ? li : 0);
    if (_ === 0)
      g !== null && le(g), (o.callbackNode = null), (o.callbackPriority = 0);
    else if (((u = _ & -_), o.callbackPriority !== u)) {
      if ((g != null && le(g), u === 1))
        o.tag === 0 ? uf($x.bind(null, o)) : lf($x.bind(null, o)),
          Tm(function () {
            !(En & 6) && ia();
          }),
          (g = null);
      else {
        switch ($l(_)) {
          case 1:
            g = pt;
            break;
          case 4:
            g = _t;
            break;
          case 16:
            g = St;
            break;
          case 536870912:
            g = Ut;
            break;
          default:
            g = St;
        }
        g = o4(g, Qx.bind(null, o));
      }
      (o.callbackPriority = u), (o.callbackNode = g);
    }
  }
  function Qx(o, u) {
    if ((($m = -1), (e1 = 0), En & 6)) throw Error(t(327));
    var g = o.callbackNode;
    if (Td() && o.callbackNode !== g) return null;
    var _ = Yi(o, o === Yr ? li : 0);
    if (_ === 0) return null;
    if (_ & 30 || _ & o.expiredLanes || u) u = t1(o, _);
    else {
      u = _;
      var E = En;
      En |= 2;
      var B = t4();
      (Yr !== o || li !== u) && ((Do = null), (Cd = se() + 500), Wu(o, u));
      do
        try {
          k6();
          break;
        } catch (ee) {
          e4(o, ee);
        }
      while (!0);
      Iu(),
        (Ym.current = B),
        (En = E),
        Br !== null ? (u = 0) : ((Yr = null), (li = 0), (u = kr));
    }
    if (u !== 0) {
      if (
        (u === 2 && ((E = cn(o)), E !== 0 && ((_ = E), (u = x2(o, E)))),
        u === 1)
      )
        throw ((g = Sf), Wu(o, 0), El(o, _), as(o, se()), g);
      if (u === 6) El(o, _);
      else {
        if (
          ((E = o.current.alternate),
          !(_ & 30) &&
            !U6(E) &&
            ((u = t1(o, _)),
            u === 2 && ((B = cn(o)), B !== 0 && ((_ = B), (u = x2(o, B)))),
            u === 1))
        )
          throw ((g = Sf), Wu(o, 0), El(o, _), as(o, se()), g);
        switch (((o.finishedWork = E), (o.finishedLanes = _), u)) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Xu(o, ss, Do);
            break;
          case 3:
            if (
              (El(o, _),
              (_ & 130023424) === _ && ((u = g2 + 500 - se()), 10 < u))
            ) {
              if (Yi(o, 0) !== 0) break;
              if (((E = o.suspendedLanes), (E & _) !== _)) {
                Vi(), (o.pingedLanes |= o.suspendedLanes & E);
                break;
              }
              o.timeoutHandle = bu(Xu.bind(null, o, ss, Do), u);
              break;
            }
            Xu(o, ss, Do);
            break;
          case 4:
            if ((El(o, _), (_ & 4194240) === _)) break;
            for (u = o.eventTimes, E = -1; 0 < _; ) {
              var V = 31 - Jt(_);
              (B = 1 << V), (V = u[V]), V > E && (E = V), (_ &= ~B);
            }
            if (
              ((_ = E),
              (_ = se() - _),
              (_ =
                (120 > _
                  ? 120
                  : 480 > _
                    ? 480
                    : 1080 > _
                      ? 1080
                      : 1920 > _
                        ? 1920
                        : 3e3 > _
                          ? 3e3
                          : 4320 > _
                            ? 4320
                            : 1960 * N6(_ / 1960)) - _),
              10 < _)
            ) {
              o.timeoutHandle = bu(Xu.bind(null, o, ss, Do), _);
              break;
            }
            Xu(o, ss, Do);
            break;
          case 5:
            Xu(o, ss, Do);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return as(o, se()), o.callbackNode === g ? Qx.bind(null, o) : null;
  }
  function x2(o, u) {
    var g = Ef;
    return (
      o.current.memoizedState.isDehydrated && (Wu(o, u).flags |= 256),
      (o = t1(o, u)),
      o !== 2 && ((u = ss), (ss = g), u !== null && b2(u)),
      o
    );
  }
  function b2(o) {
    ss === null ? (ss = o) : ss.push.apply(ss, o);
  }
  function U6(o) {
    for (var u = o; ; ) {
      if (u.flags & 16384) {
        var g = u.updateQueue;
        if (g !== null && ((g = g.stores), g !== null))
          for (var _ = 0; _ < g.length; _++) {
            var E = g[_],
              B = E.getSnapshot;
            E = E.value;
            try {
              if (!Fi(B(), E)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((g = u.child), u.subtreeFlags & 16384 && g !== null))
        (g.return = u), (u = g);
      else {
        if (u === o) break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === o) return !0;
          u = u.return;
        }
        (u.sibling.return = u.return), (u = u.sibling);
      }
    }
    return !0;
  }
  function El(o, u) {
    for (
      u &= ~m2,
        u &= ~Zm,
        o.suspendedLanes |= u,
        o.pingedLanes &= ~u,
        o = o.expirationTimes;
      0 < u;

    ) {
      var g = 31 - Jt(u),
        _ = 1 << g;
      (o[g] = -1), (u &= ~_);
    }
  }
  function $x(o) {
    if (En & 6) throw Error(t(327));
    Td();
    var u = Yi(o, 0);
    if (!(u & 1)) return as(o, se()), null;
    var g = t1(o, u);
    if (o.tag !== 0 && g === 2) {
      var _ = cn(o);
      _ !== 0 && ((u = _), (g = x2(o, _)));
    }
    if (g === 1) throw ((g = Sf), Wu(o, 0), El(o, u), as(o, se()), g);
    if (g === 6) throw Error(t(345));
    return (
      (o.finishedWork = o.current.alternate),
      (o.finishedLanes = u),
      Xu(o, ss, Do),
      as(o, se()),
      null
    );
  }
  function _2(o, u) {
    var g = En;
    En |= 1;
    try {
      return o(u);
    } finally {
      (En = g), En === 0 && ((Cd = se() + 500), Su && ia());
    }
  }
  function ju(o) {
    Ml !== null && Ml.tag === 0 && !(En & 6) && Td();
    var u = En;
    En |= 1;
    var g = zs.transition,
      _ = rn;
    try {
      if (((zs.transition = null), (rn = 1), o)) return o();
    } finally {
      (rn = _), (zs.transition = g), (En = u), !(En & 6) && ia();
    }
  }
  function A2() {
    (_s = Ed.current), Gn(Ed);
  }
  function Wu(o, u) {
    (o.finishedWork = null), (o.finishedLanes = 0);
    var g = o.timeoutHandle;
    if ((g !== -1 && ((o.timeoutHandle = -1), af(g)), Br !== null))
      for (g = Br.return; g !== null; ) {
        var _ = g;
        switch ((wo(_), _.tag)) {
          case 1:
            (_ = _.type.childContextTypes), _ != null && _u();
            break;
          case 3:
            xs(), Gn(Jr), Gn(Ur), _l();
            break;
          case 5:
            Fu(_);
            break;
          case 4:
            xs();
            break;
          case 13:
            Gn(Rn);
            break;
          case 19:
            Gn(Rn);
            break;
          case 10:
            Bu(_.type._context);
            break;
          case 22:
          case 23:
            A2();
        }
        g = g.return;
      }
    if (
      ((Yr = o),
      (Br = o = Cl(o.current, null)),
      (li = _s = u),
      (kr = 0),
      (Sf = null),
      (m2 = Zm = Gu = 0),
      (ss = Ef = null),
      To !== null)
    ) {
      for (u = 0; u < To.length; u++)
        if (((g = To[u]), (_ = g.interleaved), _ !== null)) {
          g.interleaved = null;
          var E = _.next,
            B = g.pending;
          if (B !== null) {
            var V = B.next;
            (B.next = E), (_.next = V);
          }
          g.pending = _;
        }
      To = null;
    }
    return o;
  }
  function e4(o, u) {
    do {
      var g = Br;
      try {
        if ((Iu(), (ja.current = Vu), ai)) {
          for (var _ = jn.memoizedState; _ !== null; ) {
            var E = _.queue;
            E !== null && (E.pending = null), (_ = _.next);
          }
          ai = !1;
        }
        if (
          ((Us = 0),
          (Yn = xn = jn = null),
          (Wa = !1),
          (Rr = 0),
          (p2.current = null),
          g === null || g.return === null)
        ) {
          (kr = 1), (Sf = u), (Br = null);
          break;
        }
        e: {
          var B = o,
            V = g.return,
            ee = g,
            ue = u;
          if (
            ((u = li),
            (ee.flags |= 32768),
            ue !== null &&
              typeof ue == "object" &&
              typeof ue.then == "function")
          ) {
            var Ie = ue,
              Ze = ee,
              $e = Ze.tag;
            if (!(Ze.mode & 1) && ($e === 0 || $e === 11 || $e === 15)) {
              var Ye = Ze.alternate;
              Ye
                ? ((Ze.updateQueue = Ye.updateQueue),
                  (Ze.memoizedState = Ye.memoizedState),
                  (Ze.lanes = Ye.lanes))
                : ((Ze.updateQueue = null), (Ze.memoizedState = null));
            }
            var wt = Kt(V);
            if (wt !== null) {
              (wt.flags &= -257),
                kt(wt, V, ee, B, u),
                wt.mode & 1 && Et(B, Ie, u),
                (u = wt),
                (ue = Ie);
              var Rt = u.updateQueue;
              if (Rt === null) {
                var Bt = new Set();
                Bt.add(ue), (u.updateQueue = Bt);
              } else Rt.add(ue);
              break e;
            } else {
              if (!(u & 1)) {
                Et(B, Ie, u), w2();
                break e;
              }
              ue = Error(t(426));
            }
          } else if (Xn && ee.mode & 1) {
            var xr = Kt(V);
            if (xr !== null) {
              !(xr.flags & 65536) && (xr.flags |= 256),
                kt(xr, V, ee, B, u),
                hf(R(ue, ee));
              break e;
            }
          }
          (B = ue = R(ue, ee)),
            kr !== 4 && (kr = 2),
            Ef === null ? (Ef = [B]) : Ef.push(B),
            (B = V);
          do {
            switch (B.tag) {
              case 3:
                (B.flags |= 65536), (u &= -u), (B.lanes |= u);
                var we = De(B, ue, u);
                pr(B, we);
                break e;
              case 1:
                ee = ue;
                var de = B.type,
                  Se = B.stateNode;
                if (
                  !(B.flags & 128) &&
                  (typeof de.getDerivedStateFromError == "function" ||
                    (Se !== null &&
                      typeof Se.componentDidCatch == "function" &&
                      (wl === null || !wl.has(Se))))
                ) {
                  (B.flags |= 65536), (u &= -u), (B.lanes |= u);
                  var at = rt(B, ee, u);
                  pr(B, at);
                  break e;
                }
            }
            B = B.return;
          } while (B !== null);
        }
        r4(g);
      } catch (Nt) {
        (u = Nt), Br === g && g !== null && (Br = g = g.return);
        continue;
      }
      break;
    } while (!0);
  }
  function t4() {
    var o = Ym.current;
    return (Ym.current = Vu), o === null ? Vu : o;
  }
  function w2() {
    (kr === 0 || kr === 3 || kr === 2) && (kr = 4),
      Yr === null || (!(Gu & 268435455) && !(Zm & 268435455)) || El(Yr, li);
  }
  function t1(o, u) {
    var g = En;
    En |= 2;
    var _ = t4();
    (Yr !== o || li !== u) && ((Do = null), Wu(o, u));
    do
      try {
        O6();
        break;
      } catch (E) {
        e4(o, E);
      }
    while (!0);
    if ((Iu(), (En = g), (Ym.current = _), Br !== null)) throw Error(t(261));
    return (Yr = null), (li = 0), kr;
  }
  function O6() {
    for (; Br !== null; ) n4(Br);
  }
  function k6() {
    for (; Br !== null && !Me(); ) n4(Br);
  }
  function n4(o) {
    var u = a4(o.alternate, o, _s);
    (o.memoizedProps = o.pendingProps),
      u === null ? r4(o) : (Br = u),
      (p2.current = null);
  }
  function r4(o) {
    var u = o;
    do {
      var g = u.alternate;
      if (((o = u.return), u.flags & 32768)) {
        if (((g = P6(g, u)), g !== null)) {
          (g.flags &= 32767), (Br = g);
          return;
        }
        if (o !== null)
          (o.flags |= 32768), (o.subtreeFlags = 0), (o.deletions = null);
        else {
          (kr = 6), (Br = null);
          return;
        }
      } else if (((g = B6(g, u, _s)), g !== null)) {
        Br = g;
        return;
      }
      if (((u = u.sibling), u !== null)) {
        Br = u;
        return;
      }
      Br = u = o;
    } while (u !== null);
    kr === 0 && (kr = 5);
  }
  function Xu(o, u, g) {
    var _ = rn,
      E = zs.transition;
    try {
      (zs.transition = null), (rn = 1), z6(o, u, g, _);
    } finally {
      (zs.transition = E), (rn = _);
    }
    return null;
  }
  function z6(o, u, g, _) {
    do Td();
    while (Ml !== null);
    if (En & 6) throw Error(t(327));
    g = o.finishedWork;
    var E = o.finishedLanes;
    if (g === null) return null;
    if (((o.finishedWork = null), (o.finishedLanes = 0), g === o.current))
      throw Error(t(177));
    (o.callbackNode = null), (o.callbackPriority = 0);
    var B = g.lanes | g.childLanes;
    if (
      (Xr(o, B),
      o === Yr && ((Br = Yr = null), (li = 0)),
      (!(g.subtreeFlags & 2064) && !(g.flags & 2064)) ||
        Km ||
        ((Km = !0),
        o4(St, function () {
          return Td(), null;
        })),
      (B = (g.flags & 15990) !== 0),
      g.subtreeFlags & 15990 || B)
    ) {
      (B = zs.transition), (zs.transition = null);
      var V = rn;
      rn = 1;
      var ee = En;
      (En |= 4),
        (p2.current = null),
        D6(o, g),
        Jx(g, o),
        rd(rf),
        (uo = !!nf),
        (rf = nf = null),
        (o.current = g),
        F6(g),
        Ee(),
        (En = ee),
        (rn = V),
        (zs.transition = B);
    } else o.current = g;
    if (
      (Km && ((Km = !1), (Ml = o), (Qm = E)),
      (B = o.pendingLanes),
      B === 0 && (wl = null),
      hn(g.stateNode),
      as(o, se()),
      u !== null)
    )
      for (_ = o.onRecoverableError, g = 0; g < u.length; g++)
        (E = u[g]), _(E.value, { componentStack: E.stack, digest: E.digest });
    if (qm) throw ((qm = !1), (o = y2), (y2 = null), o);
    return (
      Qm & 1 && o.tag !== 0 && Td(),
      (B = o.pendingLanes),
      B & 1 ? (o === v2 ? Cf++ : ((Cf = 0), (v2 = o))) : (Cf = 0),
      ia(),
      null
    );
  }
  function Td() {
    if (Ml !== null) {
      var o = $l(Qm),
        u = zs.transition,
        g = rn;
      try {
        if (((zs.transition = null), (rn = 16 > o ? 16 : o), Ml === null))
          var _ = !1;
        else {
          if (((o = Ml), (Ml = null), (Qm = 0), En & 6)) throw Error(t(331));
          var E = En;
          for (En |= 4, Ct = o.current; Ct !== null; ) {
            var B = Ct,
              V = B.child;
            if (Ct.flags & 16) {
              var ee = B.deletions;
              if (ee !== null) {
                for (var ue = 0; ue < ee.length; ue++) {
                  var Ie = ee[ue];
                  for (Ct = Ie; Ct !== null; ) {
                    var Ze = Ct;
                    switch (Ze.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Mf(8, Ze, B);
                    }
                    var $e = Ze.child;
                    if ($e !== null) ($e.return = Ze), (Ct = $e);
                    else
                      for (; Ct !== null; ) {
                        Ze = Ct;
                        var Ye = Ze.sibling,
                          wt = Ze.return;
                        if ((Vx(Ze), Ze === Ie)) {
                          Ct = null;
                          break;
                        }
                        if (Ye !== null) {
                          (Ye.return = wt), (Ct = Ye);
                          break;
                        }
                        Ct = wt;
                      }
                  }
                }
                var Rt = B.alternate;
                if (Rt !== null) {
                  var Bt = Rt.child;
                  if (Bt !== null) {
                    Rt.child = null;
                    do {
                      var xr = Bt.sibling;
                      (Bt.sibling = null), (Bt = xr);
                    } while (Bt !== null);
                  }
                }
                Ct = B;
              }
            }
            if (B.subtreeFlags & 2064 && V !== null) (V.return = B), (Ct = V);
            else
              e: for (; Ct !== null; ) {
                if (((B = Ct), B.flags & 2048))
                  switch (B.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Mf(9, B, B.return);
                  }
                var we = B.sibling;
                if (we !== null) {
                  (we.return = B.return), (Ct = we);
                  break e;
                }
                Ct = B.return;
              }
          }
          var de = o.current;
          for (Ct = de; Ct !== null; ) {
            V = Ct;
            var Se = V.child;
            if (V.subtreeFlags & 2064 && Se !== null)
              (Se.return = V), (Ct = Se);
            else
              e: for (V = de; Ct !== null; ) {
                if (((ee = Ct), ee.flags & 2048))
                  try {
                    switch (ee.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Jm(9, ee);
                    }
                  } catch (Nt) {
                    mr(ee, ee.return, Nt);
                  }
                if (ee === V) {
                  Ct = null;
                  break e;
                }
                var at = ee.sibling;
                if (at !== null) {
                  (at.return = ee.return), (Ct = at);
                  break e;
                }
                Ct = ee.return;
              }
          }
          if (
            ((En = E),
            ia(),
            At && typeof At.onPostCommitFiberRoot == "function")
          )
            try {
              At.onPostCommitFiberRoot(gt, o);
            } catch {}
          _ = !0;
        }
        return _;
      } finally {
        (rn = g), (zs.transition = u);
      }
    }
    return !1;
  }
  function i4(o, u, g) {
    (u = R(g, u)),
      (u = De(o, u, 1)),
      (o = fr(o, u, 1)),
      (u = Vi()),
      o !== null && (Kn(o, 1, u), as(o, u));
  }
  function mr(o, u, g) {
    if (o.tag === 3) i4(o, o, g);
    else
      for (; u !== null; ) {
        if (u.tag === 3) {
          i4(u, o, g);
          break;
        } else if (u.tag === 1) {
          var _ = u.stateNode;
          if (
            typeof u.type.getDerivedStateFromError == "function" ||
            (typeof _.componentDidCatch == "function" &&
              (wl === null || !wl.has(_)))
          ) {
            (o = R(g, o)),
              (o = rt(u, o, 1)),
              (u = fr(u, o, 1)),
              (o = Vi()),
              u !== null && (Kn(u, 1, o), as(u, o));
            break;
          }
        }
        u = u.return;
      }
  }
  function H6(o, u, g) {
    var _ = o.pingCache;
    _ !== null && _.delete(u),
      (u = Vi()),
      (o.pingedLanes |= o.suspendedLanes & g),
      Yr === o &&
        (li & g) === g &&
        (kr === 4 || (kr === 3 && (li & 130023424) === li && 500 > se() - g2)
          ? Wu(o, 0)
          : (m2 |= g)),
      as(o, u);
  }
  function s4(o, u) {
    u === 0 &&
      (o.mode & 1
        ? ((u = $r), ($r <<= 1), !($r & 130023424) && ($r = 4194304))
        : (u = 1));
    var g = Vi();
    (o = Nn(o, u)), o !== null && (Kn(o, u, g), as(o, g));
  }
  function V6(o) {
    var u = o.memoizedState,
      g = 0;
    u !== null && (g = u.retryLane), s4(o, g);
  }
  function G6(o, u) {
    var g = 0;
    switch (o.tag) {
      case 13:
        var _ = o.stateNode,
          E = o.memoizedState;
        E !== null && (g = E.retryLane);
        break;
      case 19:
        _ = o.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    _ !== null && _.delete(u), s4(o, g);
  }
  var a4;
  a4 = function (o, u, g) {
    if (o !== null)
      if (o.memoizedProps !== u.pendingProps || Jr.current) bt = !0;
      else {
        if (!(o.lanes & g) && !(u.flags & 128)) return (bt = !1), I6(o, u, g);
        bt = !!(o.flags & 131072);
      }
    else (bt = !1), Xn && u.flags & 1048576 && Bm(u, Ao, u.index);
    switch (((u.lanes = 0), u.tag)) {
      case 2:
        var _ = u.type;
        Wm(o, u), (o = u.pendingProps);
        var E = za(u, Ur.current);
        Co(u, g), (E = mf(null, u, _, o, E, g));
        var B = Os();
        return (
          (u.flags |= 1),
          typeof E == "object" &&
          E !== null &&
          typeof E.render == "function" &&
          E.$$typeof === void 0
            ? ((u.tag = 1),
              (u.memoizedState = null),
              (u.updateQueue = null),
              ii(_) ? ((B = !0), Mu(u)) : (B = !1),
              (u.memoizedState =
                E.state !== null && E.state !== void 0 ? E.state : null),
              tr(u),
              (E.updater = Md),
              (u.stateNode = E),
              (E._reactInternals = u),
              S(u, _, o, g),
              (u = Zt(null, u, _, !0, B, g)))
            : ((u.tag = 0), Xn && B && sa(u), In(null, u, E, g), (u = u.child)),
          u
        );
      case 16:
        _ = u.elementType;
        e: {
          switch (
            (Wm(o, u),
            (o = u.pendingProps),
            (E = _._init),
            (_ = E(_._payload)),
            (u.type = _),
            (E = u.tag = W6(_)),
            (o = zi(_, o)),
            E)
          ) {
            case 0:
              u = Pt(null, u, _, o, g);
              break e;
            case 1:
              u = sn(null, u, _, o, g);
              break e;
            case 11:
              u = Hi(null, u, _, o, g);
              break e;
            case 14:
              u = Ce(null, u, _, zi(_.type, o), g);
              break e;
          }
          throw Error(t(306, _, ""));
        }
        return u;
      case 0:
        return (
          (_ = u.type),
          (E = u.pendingProps),
          (E = u.elementType === _ ? E : zi(_, E)),
          Pt(o, u, _, E, g)
        );
      case 1:
        return (
          (_ = u.type),
          (E = u.pendingProps),
          (E = u.elementType === _ ? E : zi(_, E)),
          sn(o, u, _, E, g)
        );
      case 3:
        e: {
          if ((bn(u), o === null)) throw Error(t(387));
          (_ = u.pendingProps),
            (B = u.memoizedState),
            (E = B.element),
            rr(o, u),
            Va(u, _, null, g);
          var V = u.memoizedState;
          if (((_ = V.element), B.isDehydrated))
            if (
              ((B = {
                element: _,
                isDehydrated: !1,
                cache: V.cache,
                pendingSuspenseBoundaries: V.pendingSuspenseBoundaries,
                transitions: V.transitions,
              }),
              (u.updateQueue.baseState = B),
              (u.memoizedState = B),
              u.flags & 256)
            ) {
              (E = R(Error(t(423)), u)), (u = vr(o, u, _, g, E));
              break e;
            } else if (_ !== E) {
              (E = R(Error(t(424)), u)), (u = vr(o, u, _, g, E));
              break e;
            } else
              for (
                vi = ea(u.stateNode.containerInfo.firstChild),
                  si = u,
                  Xn = !0,
                  rs = null,
                  g = Ru(u, null, _, g),
                  u.child = g;
                g;

              )
                (g.flags = (g.flags & -3) | 4096), (g = g.sibling);
          else {
            if ((aa(), _ === E)) {
              u = Lo(o, u, g);
              break e;
            }
            In(o, u, _, g);
          }
          u = u.child;
        }
        return u;
      case 5:
        return (
          Du(u),
          o === null && Eu(u),
          (_ = u.type),
          (E = u.pendingProps),
          (B = o !== null ? o.memoizedProps : null),
          (V = E.children),
          sf(_, E) ? (V = null) : B !== null && sf(_, B) && (u.flags |= 32),
          yt(o, u),
          In(o, u, V, g),
          u.child
        );
      case 6:
        return o === null && Eu(u), null;
      case 13:
        return Gm(o, u, g);
      case 4:
        return (
          Lu(u, u.stateNode.containerInfo),
          (_ = u.pendingProps),
          o === null ? (u.child = oa(u, null, _, g)) : In(o, u, _, g),
          u.child
        );
      case 11:
        return (
          (_ = u.type),
          (E = u.pendingProps),
          (E = u.elementType === _ ? E : zi(_, E)),
          Hi(o, u, _, E, g)
        );
      case 7:
        return In(o, u, u.pendingProps, g), u.child;
      case 8:
        return In(o, u, u.pendingProps.children, g), u.child;
      case 12:
        return In(o, u, u.pendingProps.children, g), u.child;
      case 10:
        e: {
          if (
            ((_ = u.type._context),
            (E = u.pendingProps),
            (B = u.memoizedProps),
            (V = E.value),
            kn(Mo, _._currentValue),
            (_._currentValue = V),
            B !== null)
          )
            if (Fi(B.value, V)) {
              if (B.children === E.children && !Jr.current) {
                u = Lo(o, u, g);
                break e;
              }
            } else
              for (B = u.child, B !== null && (B.return = u); B !== null; ) {
                var ee = B.dependencies;
                if (ee !== null) {
                  V = B.child;
                  for (var ue = ee.firstContext; ue !== null; ) {
                    if (ue.context === _) {
                      if (B.tag === 1) {
                        (ue = Jn(-1, g & -g)), (ue.tag = 2);
                        var Ie = B.updateQueue;
                        if (Ie !== null) {
                          Ie = Ie.shared;
                          var Ze = Ie.pending;
                          Ze === null
                            ? (ue.next = ue)
                            : ((ue.next = Ze.next), (Ze.next = ue)),
                            (Ie.pending = ue);
                        }
                      }
                      (B.lanes |= g),
                        (ue = B.alternate),
                        ue !== null && (ue.lanes |= g),
                        Pu(B.return, g, u),
                        (ee.lanes |= g);
                      break;
                    }
                    ue = ue.next;
                  }
                } else if (B.tag === 10) V = B.type === u.type ? null : B.child;
                else if (B.tag === 18) {
                  if (((V = B.return), V === null)) throw Error(t(341));
                  (V.lanes |= g),
                    (ee = V.alternate),
                    ee !== null && (ee.lanes |= g),
                    Pu(V, g, u),
                    (V = B.sibling);
                } else V = B.child;
                if (V !== null) V.return = B;
                else
                  for (V = B; V !== null; ) {
                    if (V === u) {
                      V = null;
                      break;
                    }
                    if (((B = V.sibling), B !== null)) {
                      (B.return = V.return), (V = B);
                      break;
                    }
                    V = V.return;
                  }
                B = V;
              }
          In(o, u, E.children, g), (u = u.child);
        }
        return u;
      case 9:
        return (
          (E = u.type),
          (_ = u.pendingProps.children),
          Co(u, g),
          (E = xi(E)),
          (_ = _(E)),
          (u.flags |= 1),
          In(o, u, _, g),
          u.child
        );
      case 14:
        return (
          (_ = u.type),
          (E = zi(_, u.pendingProps)),
          (E = zi(_.type, E)),
          Ce(o, u, _, E, g)
        );
      case 15:
        return ve(o, u, u.type, u.pendingProps, g);
      case 17:
        return (
          (_ = u.type),
          (E = u.pendingProps),
          (E = u.elementType === _ ? E : zi(_, E)),
          Wm(o, u),
          (u.tag = 1),
          ii(_) ? ((o = !0), Mu(u)) : (o = !1),
          Co(u, g),
          f(u, _, E),
          S(u, _, E, g),
          Zt(null, u, _, !0, o, g)
        );
      case 19:
        return Nx(o, u, g);
      case 22:
        return Le(o, u, g);
    }
    throw Error(t(156, u.tag));
  };
  function o4(o, u) {
    return j(o, u);
  }
  function j6(o, u, g, _) {
    (this.tag = o),
      (this.key = g),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = u),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = _),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Hs(o, u, g, _) {
    return new j6(o, u, g, _);
  }
  function M2(o) {
    return (o = o.prototype), !(!o || !o.isReactComponent);
  }
  function W6(o) {
    if (typeof o == "function") return M2(o) ? 1 : 0;
    if (o != null) {
      if (((o = o.$$typeof), o === ie)) return 11;
      if (o === _e) return 14;
    }
    return 2;
  }
  function Cl(o, u) {
    var g = o.alternate;
    return (
      g === null
        ? ((g = Hs(o.tag, u, o.key, o.mode)),
          (g.elementType = o.elementType),
          (g.type = o.type),
          (g.stateNode = o.stateNode),
          (g.alternate = o),
          (o.alternate = g))
        : ((g.pendingProps = u),
          (g.type = o.type),
          (g.flags = 0),
          (g.subtreeFlags = 0),
          (g.deletions = null)),
      (g.flags = o.flags & 14680064),
      (g.childLanes = o.childLanes),
      (g.lanes = o.lanes),
      (g.child = o.child),
      (g.memoizedProps = o.memoizedProps),
      (g.memoizedState = o.memoizedState),
      (g.updateQueue = o.updateQueue),
      (u = o.dependencies),
      (g.dependencies =
        u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }),
      (g.sibling = o.sibling),
      (g.index = o.index),
      (g.ref = o.ref),
      g
    );
  }
  function n1(o, u, g, _, E, B) {
    var V = 2;
    if (((_ = o), typeof o == "function")) M2(o) && (V = 1);
    else if (typeof o == "string") V = 5;
    else
      e: switch (o) {
        case O:
          return Ju(g.children, E, B, u);
        case z:
          (V = 8), (E |= 8);
          break;
        case L:
          return (
            (o = Hs(12, g, u, E | 2)), (o.elementType = L), (o.lanes = B), o
          );
        case re:
          return (o = Hs(13, g, u, E)), (o.elementType = re), (o.lanes = B), o;
        case me:
          return (o = Hs(19, g, u, E)), (o.elementType = me), (o.lanes = B), o;
        case Re:
          return r1(g, E, B, u);
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case N:
                V = 10;
                break e;
              case X:
                V = 9;
                break e;
              case ie:
                V = 11;
                break e;
              case _e:
                V = 14;
                break e;
              case ge:
                (V = 16), (_ = null);
                break e;
            }
          throw Error(t(130, o == null ? o : typeof o, ""));
      }
    return (
      (u = Hs(V, g, u, E)), (u.elementType = o), (u.type = _), (u.lanes = B), u
    );
  }
  function Ju(o, u, g, _) {
    return (o = Hs(7, o, _, u)), (o.lanes = g), o;
  }
  function r1(o, u, g, _) {
    return (
      (o = Hs(22, o, _, u)),
      (o.elementType = Re),
      (o.lanes = g),
      (o.stateNode = { isHidden: !1 }),
      o
    );
  }
  function S2(o, u, g) {
    return (o = Hs(6, o, null, u)), (o.lanes = g), o;
  }
  function E2(o, u, g) {
    return (
      (u = Hs(4, o.children !== null ? o.children : [], o.key, u)),
      (u.lanes = g),
      (u.stateNode = {
        containerInfo: o.containerInfo,
        pendingChildren: null,
        implementation: o.implementation,
      }),
      u
    );
  }
  function X6(o, u, g, _, E) {
    (this.tag = u),
      (this.containerInfo = o),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Wr(0)),
      (this.expirationTimes = Wr(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Wr(0)),
      (this.identifierPrefix = _),
      (this.onRecoverableError = E),
      (this.mutableSourceEagerHydrationData = null);
  }
  function C2(o, u, g, _, E, B, V, ee, ue) {
    return (
      (o = new X6(o, u, g, ee, ue)),
      u === 1 ? ((u = 1), B === !0 && (u |= 8)) : (u = 0),
      (B = Hs(3, null, null, u)),
      (o.current = B),
      (B.stateNode = o),
      (B.memoizedState = {
        element: _,
        isDehydrated: g,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      tr(B),
      o
    );
  }
  function J6(o, u, g) {
    var _ =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: F,
      key: _ == null ? null : "" + _,
      children: o,
      containerInfo: u,
      implementation: g,
    };
  }
  function l4(o) {
    if (!o) return ra;
    o = o._reactInternals;
    e: {
      if (Dn(o) !== o || o.tag !== 1) throw Error(t(170));
      var u = o;
      do {
        switch (u.tag) {
          case 3:
            u = u.stateNode.context;
            break e;
          case 1:
            if (ii(u.type)) {
              u = u.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        u = u.return;
      } while (u !== null);
      throw Error(t(171));
    }
    if (o.tag === 1) {
      var g = o.type;
      if (ii(g)) return wu(o, g, u);
    }
    return u;
  }
  function u4(o, u, g, _, E, B, V, ee, ue) {
    return (
      (o = C2(g, _, !0, o, E, B, V, ee, ue)),
      (o.context = l4(null)),
      (g = o.current),
      (_ = Vi()),
      (E = Sl(g)),
      (B = Jn(_, E)),
      (B.callback = u ?? null),
      fr(g, B, E),
      (o.current.lanes = E),
      Kn(o, E, _),
      as(o, _),
      o
    );
  }
  function i1(o, u, g, _) {
    var E = u.current,
      B = Vi(),
      V = Sl(E);
    return (
      (g = l4(g)),
      u.context === null ? (u.context = g) : (u.pendingContext = g),
      (u = Jn(B, V)),
      (u.payload = { element: o }),
      (_ = _ === void 0 ? null : _),
      _ !== null && (u.callback = _),
      (o = fr(E, u, V)),
      o !== null && (ma(o, E, V, B), ua(o, E, V)),
      V
    );
  }
  function s1(o) {
    if (((o = o.current), !o.child)) return null;
    switch (o.child.tag) {
      case 5:
        return o.child.stateNode;
      default:
        return o.child.stateNode;
    }
  }
  function c4(o, u) {
    if (((o = o.memoizedState), o !== null && o.dehydrated !== null)) {
      var g = o.retryLane;
      o.retryLane = g !== 0 && g < u ? g : u;
    }
  }
  function T2(o, u) {
    c4(o, u), (o = o.alternate) && c4(o, u);
  }
  var d4 =
    typeof reportError == "function"
      ? reportError
      : function (o) {
          console.error(o);
        };
  function R2(o) {
    this._internalRoot = o;
  }
  (a1.prototype.render = R2.prototype.render =
    function (o) {
      var u = this._internalRoot;
      if (u === null) throw Error(t(409));
      i1(o, u, null, null);
    }),
    (a1.prototype.unmount = R2.prototype.unmount =
      function () {
        var o = this._internalRoot;
        if (o !== null) {
          this._internalRoot = null;
          var u = o.containerInfo;
          ju(function () {
            i1(null, o, null, null);
          }),
            (u[Ui] = null);
        }
      });
  function a1(o) {
    this._internalRoot = o;
  }
  a1.prototype.unstable_scheduleHydration = function (o) {
    if (o) {
      var u = Jc();
      o = { blockedOn: null, target: o, priority: u };
      for (var g = 0; g < Ia.length && u !== 0 && u < Ia[g].priority; g++);
      Ia.splice(g, 0, o), g === 0 && pm(o);
    }
  };
  function I2(o) {
    return !(!o || (o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11));
  }
  function o1(o) {
    return !(
      !o ||
      (o.nodeType !== 1 &&
        o.nodeType !== 9 &&
        o.nodeType !== 11 &&
        (o.nodeType !== 8 || o.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function h4() {}
  function Y6(o, u, g, _, E) {
    if (E) {
      if (typeof _ == "function") {
        var B = _;
        _ = function () {
          var Ie = s1(V);
          B.call(Ie);
        };
      }
      var V = u4(u, _, o, 0, null, !1, !1, "", h4);
      return (
        (o._reactRootContainer = V),
        (o[Ui] = V.current),
        bo(o.nodeType === 8 ? o.parentNode : o),
        ju(),
        V
      );
    }
    for (; (E = o.lastChild); ) o.removeChild(E);
    if (typeof _ == "function") {
      var ee = _;
      _ = function () {
        var Ie = s1(ue);
        ee.call(Ie);
      };
    }
    var ue = C2(o, 0, !1, null, null, !1, !1, "", h4);
    return (
      (o._reactRootContainer = ue),
      (o[Ui] = ue.current),
      bo(o.nodeType === 8 ? o.parentNode : o),
      ju(function () {
        i1(u, ue, g, _);
      }),
      ue
    );
  }
  function l1(o, u, g, _, E) {
    var B = g._reactRootContainer;
    if (B) {
      var V = B;
      if (typeof E == "function") {
        var ee = E;
        E = function () {
          var ue = s1(V);
          ee.call(ue);
        };
      }
      i1(u, V, o, E);
    } else V = Y6(g, u, o, E, _);
    return s1(V);
  }
  (fm = function (o) {
    switch (o.tag) {
      case 3:
        var u = o.stateNode;
        if (u.current.memoizedState.isDehydrated) {
          var g = Mr(u.pendingLanes);
          g !== 0 &&
            (Ts(u, g | 1), as(u, se()), !(En & 6) && ((Cd = se() + 500), ia()));
        }
        break;
      case 13:
        ju(function () {
          var _ = Nn(o, 1);
          if (_ !== null) {
            var E = Vi();
            ma(_, o, 1, E);
          }
        }),
          T2(o, 1);
    }
  }),
    (Ih = function (o) {
      if (o.tag === 13) {
        var u = Nn(o, 134217728);
        if (u !== null) {
          var g = Vi();
          ma(u, o, 134217728, g);
        }
        T2(o, 134217728);
      }
    }),
    (Xc = function (o) {
      if (o.tag === 13) {
        var u = Sl(o),
          g = Nn(o, u);
        if (g !== null) {
          var _ = Vi();
          ma(g, o, u, _);
        }
        T2(o, u);
      }
    }),
    (Jc = function () {
      return rn;
    }),
    ($o = function (o, u) {
      var g = rn;
      try {
        return (rn = o), u();
      } finally {
        rn = g;
      }
    }),
    (ne = function (o, u, g) {
      switch (u) {
        case "input":
          if ((Be(o, g), (u = g.name), g.type === "radio" && u != null)) {
            for (g = o; g.parentNode; ) g = g.parentNode;
            for (
              g = g.querySelectorAll(
                "input[name=" + JSON.stringify("" + u) + '][type="radio"]',
              ),
                u = 0;
              u < g.length;
              u++
            ) {
              var _ = g[u];
              if (_ !== o && _.form === o.form) {
                var E = cd(_);
                if (!E) throw Error(t(90));
                Te(_), Be(_, E);
              }
            }
          }
          break;
        case "textarea":
          ze(o, g);
          break;
        case "select":
          (u = g.value), u != null && Z(o, !!g.multiple, u, !1);
      }
    }),
    (He = _2),
    (Qe = ju);
  var Z6 = { usingClientEntryPoint: !1, Events: [dr, gl, cd, pe, Ve, _2] },
    Tf = {
      findFiberByHostInstance: vs,
      bundleType: 0,
      version: "18.3.1",
      rendererPackageName: "react-dom",
    },
    q6 = {
      bundleType: Tf.bundleType,
      version: Tf.version,
      rendererPackageName: Tf.rendererPackageName,
      rendererConfig: Tf.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: I.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (o) {
        return (o = Fn(o)), o === null ? null : o.stateNode;
      },
      findFiberByHostInstance: Tf.findFiberByHostInstance,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var u1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!u1.isDisabled && u1.supportsFiber)
      try {
        (gt = u1.inject(q6)), (At = u1);
      } catch {}
  }
  return (
    (os.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Z6),
    (os.createPortal = function (o, u) {
      var g =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!I2(u)) throw Error(t(200));
      return J6(o, u, null, g);
    }),
    (os.createRoot = function (o, u) {
      if (!I2(o)) throw Error(t(299));
      var g = !1,
        _ = "",
        E = d4;
      return (
        u != null &&
          (u.unstable_strictMode === !0 && (g = !0),
          u.identifierPrefix !== void 0 && (_ = u.identifierPrefix),
          u.onRecoverableError !== void 0 && (E = u.onRecoverableError)),
        (u = C2(o, 1, !1, null, null, g, !1, _, E)),
        (o[Ui] = u.current),
        bo(o.nodeType === 8 ? o.parentNode : o),
        new R2(u)
      );
    }),
    (os.findDOMNode = function (o) {
      if (o == null) return null;
      if (o.nodeType === 1) return o;
      var u = o._reactInternals;
      if (u === void 0)
        throw typeof o.render == "function"
          ? Error(t(188))
          : ((o = Object.keys(o).join(",")), Error(t(268, o)));
      return (o = Fn(u)), (o = o === null ? null : o.stateNode), o;
    }),
    (os.flushSync = function (o) {
      return ju(o);
    }),
    (os.hydrate = function (o, u, g) {
      if (!o1(u)) throw Error(t(200));
      return l1(null, o, u, !0, g);
    }),
    (os.hydrateRoot = function (o, u, g) {
      if (!I2(o)) throw Error(t(405));
      var _ = (g != null && g.hydratedSources) || null,
        E = !1,
        B = "",
        V = d4;
      if (
        (g != null &&
          (g.unstable_strictMode === !0 && (E = !0),
          g.identifierPrefix !== void 0 && (B = g.identifierPrefix),
          g.onRecoverableError !== void 0 && (V = g.onRecoverableError)),
        (u = u4(u, null, o, 1, g ?? null, E, !1, B, V)),
        (o[Ui] = u.current),
        bo(o),
        _)
      )
        for (o = 0; o < _.length; o++)
          (g = _[o]),
            (E = g._getVersion),
            (E = E(g._source)),
            u.mutableSourceEagerHydrationData == null
              ? (u.mutableSourceEagerHydrationData = [g, E])
              : u.mutableSourceEagerHydrationData.push(g, E);
      return new a1(u);
    }),
    (os.render = function (o, u, g) {
      if (!o1(u)) throw Error(t(200));
      return l1(null, o, u, !1, g);
    }),
    (os.unmountComponentAtNode = function (o) {
      if (!o1(o)) throw Error(t(40));
      return o._reactRootContainer
        ? (ju(function () {
            l1(null, null, o, !1, function () {
              (o._reactRootContainer = null), (o[Ui] = null);
            });
          }),
          !0)
        : !1;
    }),
    (os.unstable_batchedUpdates = _2),
    (os.unstable_renderSubtreeIntoContainer = function (o, u, g, _) {
      if (!o1(g)) throw Error(t(200));
      if (o == null || o._reactInternals === void 0) throw Error(t(38));
      return l1(o, u, g, !1, _);
    }),
    (os.version = "18.3.1-next-f1338f8080-20240426"),
    os
  );
}
var M4;
function s8() {
  if (M4) return B2.exports;
  M4 = 1;
  function r() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r);
      } catch (e) {
        console.error(e);
      }
  }
  return r(), (B2.exports = i8()), B2.exports;
}
var S4;
function a8() {
  if (S4) return c1;
  S4 = 1;
  var r = s8();
  return (c1.createRoot = r.createRoot), (c1.hydrateRoot = r.hydrateRoot), c1;
}
var o8 = a8();
let l8 = class extends he.Component {
  constructor() {
    super(...arguments), (this.state = { hasError: !1 });
  }
  static getDerivedStateFromError(r) {
    return { hasError: !0 };
  }
  componentDidCatch(r, e) {
    console.error("Caught error:", r, e);
  }
  render() {
    return this.state.hasError
      ? this.props.fallback ||
          H.jsxs("div", {
            className: "text-center p-4",
            children: [
              H.jsx("h2", {
                className: "text-3xl font-quattrocento text-almond",
                children: "Mock Shaadi",
              }),
              H.jsx("p", { className: "text-gold", children: "2025" }),
            ],
          })
      : this.props.children;
  }
};
function u8(r) {
  if (typeof Proxy > "u") return r;
  const e = new Map(),
    t = (...n) => r(...n);
  return new Proxy(t, {
    get: (n, i) =>
      i === "create" ? r : (e.has(i) || e.set(i, r(i)), e.get(i)),
  });
}
function vg(r) {
  return r !== null && typeof r == "object" && typeof r.start == "function";
}
const qy = (r) => Array.isArray(r);
function vw(r, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== r.length) return !1;
  for (let n = 0; n < t; n++) if (e[n] !== r[n]) return !1;
  return !0;
}
function _p(r) {
  return typeof r == "string" || Array.isArray(r);
}
function E4(r) {
  const e = [{}, {}];
  return (
    r == null ||
      r.values.forEach((t, n) => {
        (e[0][n] = t.get()), (e[1][n] = t.getVelocity());
      }),
    e
  );
}
function Gv(r, e, t, n) {
  if (typeof e == "function") {
    const [i, s] = E4(n);
    e = e(t !== void 0 ? t : r.custom, i, s);
  }
  if (
    (typeof e == "string" && (e = r.variants && r.variants[e]),
    typeof e == "function")
  ) {
    const [i, s] = E4(n);
    e = e(t !== void 0 ? t : r.custom, i, s);
  }
  return e;
}
function xg(r, e, t) {
  const n = r.getProps();
  return Gv(n, e, t !== void 0 ? t : n.custom, r);
}
const jv = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  Wv = ["initial", ...jv],
  Xi = (r) => r;
let c8 = Xi,
  Ky = Xi;
function Xv(r) {
  let e;
  return () => (e === void 0 && (e = r()), e);
}
const Bc = (r, e, t) => {
    const n = e - r;
    return n === 0 ? 1 : (t - r) / n;
  },
  Xo = (r) => r * 1e3,
  Jo = (r) => r / 1e3,
  xw = Xv(() => window.ScrollTimeline !== void 0);
class d8 {
  constructor(e) {
    (this.stop = () => this.runAll("stop")),
      (this.animations = e.filter(Boolean));
  }
  get finished() {
    return Promise.all(
      this.animations.map((e) => ("finished" in e ? e.finished : e)),
    );
  }
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, t) {
    for (let n = 0; n < this.animations.length; n++) this.animations[n][e] = t;
  }
  attachTimeline(e, t) {
    const n = this.animations.map((i) =>
      xw() && i.attachTimeline ? i.attachTimeline(e) : t(i),
    );
    return () => {
      n.forEach((i, s) => {
        i && i(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let t = 0; t < this.animations.length; t++)
      e = Math.max(e, this.animations[t].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((t) => t[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class h8 extends d8 {
  then(e, t) {
    return Promise.all(this.animations).then(e).catch(t);
  }
}
function Jv(r, e) {
  return r ? r[e] || r.default || r : void 0;
}
const Qy = 2e4;
function bw(r) {
  let e = 0;
  const t = 50;
  let n = r.next(e);
  for (; !n.done && e < Qy; ) (e += t), (n = r.next(e));
  return e >= Qy ? 1 / 0 : e;
}
function Yv(r) {
  return typeof r == "function";
}
function C4(r, e) {
  (r.timeline = e), (r.onfinish = null);
}
const Zv = (r) => Array.isArray(r) && typeof r[0] == "number",
  f8 = { linearEasing: void 0 };
function p8(r, e) {
  const t = Xv(r);
  return () => {
    var n;
    return (n = f8[e]) !== null && n !== void 0 ? n : t();
  };
}
const b0 = p8(() => {
    try {
      document
        .createElement("div")
        .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  _w = (r, e, t = 10) => {
    let n = "";
    const i = Math.max(Math.round(e / t), 2);
    for (let s = 0; s < i; s++) n += r(Bc(0, i - 1, s)) + ", ";
    return `linear(${n.substring(0, n.length - 2)})`;
  };
function Aw(r) {
  return !!(
    (typeof r == "function" && b0()) ||
    !r ||
    (typeof r == "string" && (r in $y || b0())) ||
    Zv(r) ||
    (Array.isArray(r) && r.every(Aw))
  );
}
const Zf = ([r, e, t, n]) => `cubic-bezier(${r}, ${e}, ${t}, ${n})`,
  $y = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Zf([0, 0.65, 0.55, 1]),
    circOut: Zf([0.55, 0, 1, 0.45]),
    backIn: Zf([0.31, 0.01, 0.66, -0.59]),
    backOut: Zf([0.33, 1.53, 0.69, 0.99]),
  };
function ww(r, e) {
  if (r)
    return typeof r == "function" && b0()
      ? _w(r, e)
      : Zv(r)
        ? Zf(r)
        : Array.isArray(r)
          ? r.map((t) => ww(t, e) || $y.easeOut)
          : $y[r];
}
const ba = { x: !1, y: !1 };
function Mw() {
  return ba.x || ba.y;
}
function Sw(r, e, t) {
  var n;
  if (r instanceof Element) return [r];
  if (typeof r == "string") {
    let i = document;
    const s = (n = void 0) !== null && n !== void 0 ? n : i.querySelectorAll(r);
    return s ? Array.from(s) : [];
  }
  return Array.from(r);
}
function Ew(r, e) {
  const t = Sw(r),
    n = new AbortController(),
    i = { passive: !0, ...e, signal: n.signal };
  return [t, i, () => n.abort()];
}
function T4(r) {
  return (e) => {
    e.pointerType === "touch" || Mw() || r(e);
  };
}
function m8(r, e, t = {}) {
  const [n, i, s] = Ew(r, t),
    a = T4((l) => {
      const { target: c } = l,
        d = e(l);
      if (!d || !c) return;
      const p = T4((m) => {
        d(m), c.removeEventListener("pointerleave", p);
      });
      c.addEventListener("pointerleave", p, i);
    });
  return (
    n.forEach((l) => {
      l.addEventListener("pointerenter", a, i);
    }),
    s
  );
}
const qv = (r) =>
    r.pointerType === "mouse"
      ? typeof r.button != "number" || r.button <= 0
      : r.isPrimary !== !1,
  qf = new WeakSet();
function R4(r) {
  return (e) => {
    e.key === "Enter" && r(e);
  };
}
function P2(r, e) {
  r.dispatchEvent(
    new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 }),
  );
}
const g8 = (r, e) => {
    const t = r.currentTarget;
    if (!t) return;
    const n = R4(() => {
      if (qf.has(t)) return;
      P2(t, "down");
      const i = R4(() => {
          P2(t, "up");
        }),
        s = () => P2(t, "cancel");
      t.addEventListener("keyup", i, e), t.addEventListener("blur", s, e);
    });
    t.addEventListener("keydown", n, e),
      t.addEventListener("blur", () => t.removeEventListener("keydown", n), e);
  },
  y8 = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function v8(r) {
  return y8.has(r.tagName) || r.tabIndex !== -1;
}
const Cw = (r, e) => (e ? (r === e ? !0 : Cw(r, e.parentElement)) : !1);
function I4(r) {
  return qv(r) && !Mw();
}
function x8(r, e, t = {}) {
  const [n, i, s] = Ew(r, t),
    a = (l) => {
      const c = l.currentTarget;
      if (!I4(l) || qf.has(c)) return;
      qf.add(c);
      const d = e(l),
        p = (v, A) => {
          window.removeEventListener("pointerup", m),
            window.removeEventListener("pointercancel", y),
            !(!I4(v) || !qf.has(c)) &&
              (qf.delete(c), d && d(v, { success: A }));
        },
        m = (v) => {
          p(v, t.useGlobalTarget || Cw(c, v.target));
        },
        y = (v) => {
          p(v, !1);
        };
      window.addEventListener("pointerup", m, i),
        window.addEventListener("pointercancel", y, i);
    };
  return (
    n.forEach((l) => {
      v8(l) || (l.tabIndex = 0),
        (t.useGlobalTarget ? window : l).addEventListener("pointerdown", a, i),
        l.addEventListener("focus", (c) => g8(c, i), i);
    }),
    s
  );
}
function b8(r) {
  return r === "x" || r === "y"
    ? ba[r]
      ? null
      : ((ba[r] = !0),
        () => {
          ba[r] = !1;
        })
    : ba.x || ba.y
      ? null
      : ((ba.x = ba.y = !0),
        () => {
          ba.x = ba.y = !1;
        });
}
const Vp = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  Hc = new Set(Vp),
  _8 = (r) => !!(r && typeof r == "object" && r.mix && r.toValue),
  A8 = (r) => (qy(r) ? r[r.length - 1] || 0 : r),
  w8 = { skipAnimations: !1, useManualTiming: !1 };
function M8(r) {
  let e = new Set(),
    t = new Set(),
    n = !1,
    i = !1;
  const s = new WeakSet();
  let a = { delta: 0, timestamp: 0, isProcessing: !1 };
  function l(d) {
    s.has(d) && (c.schedule(d), r()), d(a);
  }
  const c = {
    schedule: (d, p = !1, m = !1) => {
      const y = m && n ? e : t;
      return p && s.add(d), y.has(d) || y.add(d), d;
    },
    cancel: (d) => {
      t.delete(d), s.delete(d);
    },
    process: (d) => {
      if (((a = d), n)) {
        i = !0;
        return;
      }
      (n = !0),
        ([e, t] = [t, e]),
        e.forEach(l),
        e.clear(),
        (n = !1),
        i && ((i = !1), c.process(d));
    },
  };
  return c;
}
const d1 = [
    "read",
    "resolveKeyframes",
    "update",
    "preRender",
    "render",
    "postRender",
  ],
  S8 = 40;
function Tw(r, e) {
  let t = !1,
    n = !0;
  const i = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    a = d1.reduce((M, w) => ((M[w] = M8(s)), M), {}),
    {
      read: l,
      resolveKeyframes: c,
      update: d,
      preRender: p,
      render: m,
      postRender: y,
    } = a,
    v = () => {
      const M = performance.now();
      (t = !1),
        (i.delta = n ? 1e3 / 60 : Math.max(Math.min(M - i.timestamp, S8), 1)),
        (i.timestamp = M),
        (i.isProcessing = !0),
        l.process(i),
        c.process(i),
        d.process(i),
        p.process(i),
        m.process(i),
        y.process(i),
        (i.isProcessing = !1),
        t && e && ((n = !1), r(v));
    },
    A = () => {
      (t = !0), (n = !0), i.isProcessing || r(v);
    };
  return {
    schedule: d1.reduce((M, w) => {
      const x = a[w];
      return (M[w] = (C, T = !1, I = !1) => (t || A(), x.schedule(C, T, I))), M;
    }, {}),
    cancel: (M) => {
      for (let w = 0; w < d1.length; w++) a[d1[w]].cancel(M);
    },
    state: i,
    steps: a,
  };
}
const {
  schedule: Pn,
  cancel: Sa,
  state: zr,
  steps: L2,
} = Tw(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Xi, !0);
let h0;
function E8() {
  h0 = void 0;
}
const Qa = {
  now: () => (
    h0 === void 0 &&
      Qa.set(
        zr.isProcessing || w8.useManualTiming
          ? zr.timestamp
          : performance.now(),
      ),
    h0
  ),
  set: (r) => {
    (h0 = r), queueMicrotask(E8);
  },
};
function Kv(r, e) {
  r.indexOf(e) === -1 && r.push(e);
}
function Qv(r, e) {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}
class $v {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return Kv(this.subscriptions, e), () => Qv(this.subscriptions, e);
  }
  notify(e, t, n) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1) this.subscriptions[0](e, t, n);
      else
        for (let s = 0; s < i; s++) {
          const a = this.subscriptions[s];
          a && a(e, t, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function e3(r, e) {
  return e ? r * (1e3 / e) : 0;
}
const B4 = 30,
  C8 = (r) => !isNaN(parseFloat(r)),
  rp = { current: void 0 };
class T8 {
  constructor(e, t = {}) {
    (this.version = "11.16.0"),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (n, i = !0) => {
        const s = Qa.now();
        this.updatedAt !== s && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(n),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          i &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner);
  }
  setCurrent(e) {
    (this.current = e),
      (this.updatedAt = Qa.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = C8(this.current));
  }
  setPrevFrameValue(e = this.current) {
    (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new $v());
    const n = this.events[e].add(t);
    return e === "change"
      ? () => {
          n(),
            Pn.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : n;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, n) {
    this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - n);
  }
  jump(e, t = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return rp.current && rp.current.push(this), this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = Qa.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > B4
    )
      return 0;
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, B4);
    return e3(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function qa(r, e) {
  return new T8(r, e);
}
function R8(r, e, t) {
  r.hasValue(e) ? r.getValue(e).set(t) : r.addValue(e, qa(t));
}
function I8(r, e) {
  const t = xg(r, e);
  let { transitionEnd: n = {}, transition: i = {}, ...s } = t || {};
  s = { ...s, ...n };
  for (const a in s) {
    const l = A8(s[a]);
    R8(r, a, l);
  }
}
const Lr = (r) => !!(r && r.getVelocity);
function B8(r) {
  return !!(Lr(r) && r.add);
}
function ev(r, e) {
  const t = r.getValue("willChange");
  if (B8(t)) return t.add(e);
}
const t3 = (r) => r.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  P8 = "framerAppearId",
  Rw = "data-" + t3(P8);
function Iw(r) {
  return r.props[Rw];
}
const Bw = (r, e, t) =>
    (((1 - 3 * t + 3 * e) * r + (3 * t - 6 * e)) * r + 3 * e) * r,
  L8 = 1e-7,
  D8 = 12;
function F8(r, e, t, n, i) {
  let s,
    a,
    l = 0;
  do (a = e + (t - e) / 2), (s = Bw(a, n, i) - r), s > 0 ? (t = a) : (e = a);
  while (Math.abs(s) > L8 && ++l < D8);
  return a;
}
function Gp(r, e, t, n) {
  if (r === e && t === n) return Xi;
  const i = (s) => F8(s, 0, 1, r, t);
  return (s) => (s === 0 || s === 1 ? s : Bw(i(s), e, n));
}
const Pw = (r) => (e) => (e <= 0.5 ? r(2 * e) / 2 : (2 - r(2 * (1 - e))) / 2),
  Lw = (r) => (e) => 1 - r(1 - e),
  Dw = Gp(0.33, 1.53, 0.69, 0.99),
  n3 = Lw(Dw),
  Fw = Pw(n3),
  Nw = (r) =>
    (r *= 2) < 1 ? 0.5 * n3(r) : 0.5 * (2 - Math.pow(2, -10 * (r - 1))),
  r3 = (r) => 1 - Math.sin(Math.acos(r)),
  Uw = Lw(r3),
  Ow = Pw(r3),
  kw = (r) => /^0[^.\s]+$/u.test(r);
function N8(r) {
  return typeof r == "number"
    ? r === 0
    : r !== null
      ? r === "none" || r === "0" || kw(r)
      : !0;
}
const zw = (r) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(r),
  Hw = (r) => (e) => typeof e == "string" && e.startsWith(r),
  Vw = Hw("--"),
  U8 = Hw("var(--"),
  i3 = (r) => (U8(r) ? O8.test(r.split("/*")[0].trim()) : !1),
  O8 =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  k8 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function z8(r) {
  const e = k8.exec(r);
  if (!e) return [,];
  const [, t, n, i] = e;
  return [`--${t ?? n}`, i];
}
function Gw(r, e, t = 1) {
  const [n, i] = z8(r);
  if (!n) return;
  const s = window.getComputedStyle(e).getPropertyValue(n);
  if (s) {
    const a = s.trim();
    return zw(a) ? parseFloat(a) : a;
  }
  return i3(i) ? Gw(i, e, t + 1) : i;
}
const qo = (r, e, t) => (t > e ? e : t < r ? r : t),
  Ah = {
    test: (r) => typeof r == "number",
    parse: parseFloat,
    transform: (r) => r,
  },
  Ap = { ...Ah, transform: (r) => qo(0, 1, r) },
  h1 = { ...Ah, default: 1 },
  jp = (r) => ({
    test: (e) =>
      typeof e == "string" && e.endsWith(r) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${r}`,
  }),
  Ol = jp("deg"),
  $a = jp("%"),
  Xt = jp("px"),
  H8 = jp("vh"),
  V8 = jp("vw"),
  P4 = {
    ...$a,
    parse: (r) => $a.parse(r) / 100,
    transform: (r) => $a.transform(r * 100),
  },
  G8 = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY",
  ]),
  L4 = (r) => r === Ah || r === Xt,
  D4 = (r, e) => parseFloat(r.split(", ")[e]),
  F4 =
    (r, e) =>
    (t, { transform: n }) => {
      if (n === "none" || !n) return 0;
      const i = n.match(/^matrix3d\((.+)\)$/u);
      if (i) return D4(i[1], e);
      {
        const s = n.match(/^matrix\((.+)\)$/u);
        return s ? D4(s[1], r) : 0;
      }
    },
  j8 = new Set(["x", "y", "z"]),
  W8 = Vp.filter((r) => !j8.has(r));
function X8(r) {
  const e = [];
  return (
    W8.forEach((t) => {
      const n = r.getValue(t);
      n !== void 0 &&
        (e.push([t, n.get()]), n.set(t.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const ch = {
  width: ({ x: r }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
    r.max - r.min - parseFloat(e) - parseFloat(t),
  height: ({ y: r }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
    r.max - r.min - parseFloat(e) - parseFloat(t),
  top: (r, { top: e }) => parseFloat(e),
  left: (r, { left: e }) => parseFloat(e),
  bottom: ({ y: r }, { top: e }) => parseFloat(e) + (r.max - r.min),
  right: ({ x: r }, { left: e }) => parseFloat(e) + (r.max - r.min),
  x: F4(4, 13),
  y: F4(5, 14),
};
ch.translateX = ch.x;
ch.translateY = ch.y;
const jw = (r) => (e) => e.test(r),
  J8 = { test: (r) => r === "auto", parse: (r) => r },
  Ww = [Ah, Xt, $a, Ol, V8, H8, J8],
  N4 = (r) => Ww.find(jw(r)),
  Mc = new Set();
let tv = !1,
  nv = !1;
function Xw() {
  if (nv) {
    const r = Array.from(Mc).filter((n) => n.needsMeasurement),
      e = new Set(r.map((n) => n.element)),
      t = new Map();
    e.forEach((n) => {
      const i = X8(n);
      i.length && (t.set(n, i), n.render());
    }),
      r.forEach((n) => n.measureInitialState()),
      e.forEach((n) => {
        n.render();
        const i = t.get(n);
        i &&
          i.forEach(([s, a]) => {
            var l;
            (l = n.getValue(s)) === null || l === void 0 || l.set(a);
          });
      }),
      r.forEach((n) => n.measureEndState()),
      r.forEach((n) => {
        n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
      });
  }
  (nv = !1), (tv = !1), Mc.forEach((r) => r.complete()), Mc.clear();
}
function Jw() {
  Mc.forEach((r) => {
    r.readKeyframes(), r.needsMeasurement && (nv = !0);
  });
}
function Y8() {
  Jw(), Xw();
}
class s3 {
  constructor(e, t, n, i, s, a = !1) {
    (this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = n),
      (this.motionValue = i),
      (this.element = s),
      (this.isAsync = a);
  }
  scheduleResolve() {
    (this.isScheduled = !0),
      this.isAsync
        ? (Mc.add(this),
          tv || ((tv = !0), Pn.read(Jw), Pn.resolveKeyframes(Xw)))
        : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: t,
      element: n,
      motionValue: i,
    } = this;
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const a = i == null ? void 0 : i.get(),
            l = e[e.length - 1];
          if (a !== void 0) e[0] = a;
          else if (n && t) {
            const c = n.readValue(t, l);
            c != null && (e[0] = c);
          }
          e[0] === void 0 && (e[0] = l), i && a === void 0 && i.set(e[0]);
        } else e[s] = e[s - 1];
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    (this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      Mc.delete(this);
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), Mc.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const ip = (r) => Math.round(r * 1e5) / 1e5,
  a3 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function Z8(r) {
  return r == null;
}
const q8 =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  o3 = (r, e) => (t) =>
    !!(
      (typeof t == "string" && q8.test(t) && t.startsWith(r)) ||
      (e && !Z8(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  Yw = (r, e, t) => (n) => {
    if (typeof n != "string") return n;
    const [i, s, a, l] = n.match(a3);
    return {
      [r]: parseFloat(i),
      [e]: parseFloat(s),
      [t]: parseFloat(a),
      alpha: l !== void 0 ? parseFloat(l) : 1,
    };
  },
  K8 = (r) => qo(0, 255, r),
  D2 = { ...Ah, transform: (r) => Math.round(K8(r)) },
  mc = {
    test: o3("rgb", "red"),
    parse: Yw("red", "green", "blue"),
    transform: ({ red: r, green: e, blue: t, alpha: n = 1 }) =>
      "rgba(" +
      D2.transform(r) +
      ", " +
      D2.transform(e) +
      ", " +
      D2.transform(t) +
      ", " +
      ip(Ap.transform(n)) +
      ")",
  };
function Q8(r) {
  let e = "",
    t = "",
    n = "",
    i = "";
  return (
    r.length > 5
      ? ((e = r.substring(1, 3)),
        (t = r.substring(3, 5)),
        (n = r.substring(5, 7)),
        (i = r.substring(7, 9)))
      : ((e = r.substring(1, 2)),
        (t = r.substring(2, 3)),
        (n = r.substring(3, 4)),
        (i = r.substring(4, 5)),
        (e += e),
        (t += t),
        (n += n),
        (i += i)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(n, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1,
    }
  );
}
const rv = { test: o3("#"), parse: Q8, transform: mc.transform },
  Qd = {
    test: o3("hsl", "hue"),
    parse: Yw("hue", "saturation", "lightness"),
    transform: ({ hue: r, saturation: e, lightness: t, alpha: n = 1 }) =>
      "hsla(" +
      Math.round(r) +
      ", " +
      $a.transform(ip(e)) +
      ", " +
      $a.transform(ip(t)) +
      ", " +
      ip(Ap.transform(n)) +
      ")",
  },
  Si = {
    test: (r) => mc.test(r) || rv.test(r) || Qd.test(r),
    parse: (r) =>
      mc.test(r) ? mc.parse(r) : Qd.test(r) ? Qd.parse(r) : rv.parse(r),
    transform: (r) =>
      typeof r == "string"
        ? r
        : r.hasOwnProperty("red")
          ? mc.transform(r)
          : Qd.transform(r),
  },
  $8 =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function eE(r) {
  var e, t;
  return (
    isNaN(r) &&
    typeof r == "string" &&
    (((e = r.match(a3)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = r.match($8)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  );
}
const Zw = "number",
  qw = "color",
  tE = "var",
  nE = "var(",
  U4 = "${}",
  rE =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function wp(r) {
  const e = r.toString(),
    t = [],
    n = { color: [], number: [], var: [] },
    i = [];
  let s = 0;
  const a = e
    .replace(
      rE,
      (l) => (
        Si.test(l)
          ? (n.color.push(s), i.push(qw), t.push(Si.parse(l)))
          : l.startsWith(nE)
            ? (n.var.push(s), i.push(tE), t.push(l))
            : (n.number.push(s), i.push(Zw), t.push(parseFloat(l))),
        ++s,
        U4
      ),
    )
    .split(U4);
  return { values: t, split: a, indexes: n, types: i };
}
function Kw(r) {
  return wp(r).values;
}
function Qw(r) {
  const { split: e, types: t } = wp(r),
    n = e.length;
  return (i) => {
    let s = "";
    for (let a = 0; a < n; a++)
      if (((s += e[a]), i[a] !== void 0)) {
        const l = t[a];
        l === Zw
          ? (s += ip(i[a]))
          : l === qw
            ? (s += Si.transform(i[a]))
            : (s += i[a]);
      }
    return s;
  };
}
const iE = (r) => (typeof r == "number" ? 0 : r);
function sE(r) {
  const e = Kw(r);
  return Qw(r)(e.map(iE));
}
const Gl = {
    test: eE,
    parse: Kw,
    createTransformer: Qw,
    getAnimatableNone: sE,
  },
  aE = new Set(["brightness", "contrast", "saturate", "opacity"]);
function oE(r) {
  const [e, t] = r.slice(0, -1).split("(");
  if (e === "drop-shadow") return r;
  const [n] = t.match(a3) || [];
  if (!n) return r;
  const i = t.replace(n, "");
  let s = aE.has(e) ? 1 : 0;
  return n !== t && (s *= 100), e + "(" + s + i + ")";
}
const lE = /\b([a-z-]*)\(.*?\)/gu,
  iv = {
    ...Gl,
    getAnimatableNone: (r) => {
      const e = r.match(lE);
      return e ? e.map(oE).join(" ") : r;
    },
  },
  uE = {
    borderWidth: Xt,
    borderTopWidth: Xt,
    borderRightWidth: Xt,
    borderBottomWidth: Xt,
    borderLeftWidth: Xt,
    borderRadius: Xt,
    radius: Xt,
    borderTopLeftRadius: Xt,
    borderTopRightRadius: Xt,
    borderBottomRightRadius: Xt,
    borderBottomLeftRadius: Xt,
    width: Xt,
    maxWidth: Xt,
    height: Xt,
    maxHeight: Xt,
    top: Xt,
    right: Xt,
    bottom: Xt,
    left: Xt,
    padding: Xt,
    paddingTop: Xt,
    paddingRight: Xt,
    paddingBottom: Xt,
    paddingLeft: Xt,
    margin: Xt,
    marginTop: Xt,
    marginRight: Xt,
    marginBottom: Xt,
    marginLeft: Xt,
    backgroundPositionX: Xt,
    backgroundPositionY: Xt,
  },
  cE = {
    rotate: Ol,
    rotateX: Ol,
    rotateY: Ol,
    rotateZ: Ol,
    scale: h1,
    scaleX: h1,
    scaleY: h1,
    scaleZ: h1,
    skew: Ol,
    skewX: Ol,
    skewY: Ol,
    distance: Xt,
    translateX: Xt,
    translateY: Xt,
    translateZ: Xt,
    x: Xt,
    y: Xt,
    z: Xt,
    perspective: Xt,
    transformPerspective: Xt,
    opacity: Ap,
    originX: P4,
    originY: P4,
    originZ: Xt,
  },
  O4 = { ...Ah, transform: Math.round },
  l3 = {
    ...uE,
    ...cE,
    zIndex: O4,
    size: Xt,
    fillOpacity: Ap,
    strokeOpacity: Ap,
    numOctaves: O4,
  },
  dE = {
    ...l3,
    color: Si,
    backgroundColor: Si,
    outlineColor: Si,
    fill: Si,
    stroke: Si,
    borderColor: Si,
    borderTopColor: Si,
    borderRightColor: Si,
    borderBottomColor: Si,
    borderLeftColor: Si,
    filter: iv,
    WebkitFilter: iv,
  },
  u3 = (r) => dE[r];
function $w(r, e) {
  let t = u3(r);
  return (
    t !== iv && (t = Gl), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const hE = new Set(["auto", "none", "0"]);
function fE(r, e, t) {
  let n = 0,
    i;
  for (; n < r.length && !i; ) {
    const s = r[n];
    typeof s == "string" && !hE.has(s) && wp(s).values.length && (i = r[n]),
      n++;
  }
  if (i && t) for (const s of e) r[s] = $w(t, i);
}
class eM extends s3 {
  constructor(e, t, n, i, s) {
    super(e, t, n, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: n } = this;
    if (!t || !t.current) return;
    super.readKeyframes();
    for (let c = 0; c < e.length; c++) {
      let d = e[c];
      if (typeof d == "string" && ((d = d.trim()), i3(d))) {
        const p = Gw(d, t.current);
        p !== void 0 && (e[c] = p),
          c === e.length - 1 && (this.finalKeyframe = d);
      }
    }
    if ((this.resolveNoneKeyframes(), !G8.has(n) || e.length !== 2)) return;
    const [i, s] = e,
      a = N4(i),
      l = N4(s);
    if (a !== l)
      if (L4(a) && L4(l))
        for (let c = 0; c < e.length; c++) {
          const d = e[c];
          typeof d == "string" && (e[c] = parseFloat(d));
        }
      else this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      n = [];
    for (let i = 0; i < e.length; i++) N8(e[i]) && n.push(i);
    n.length && fE(e, n, t);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: n } = this;
    if (!e || !e.current) return;
    n === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = ch[n](
        e.measureViewportBox(),
        window.getComputedStyle(e.current),
      )),
      (t[0] = this.measuredOrigin);
    const i = t[t.length - 1];
    i !== void 0 && e.getValue(n, i).jump(i, !1);
  }
  measureEndState() {
    var e;
    const { element: t, name: n, unresolvedKeyframes: i } = this;
    if (!t || !t.current) return;
    const s = t.getValue(n);
    s && s.jump(this.measuredOrigin, !1);
    const a = i.length - 1,
      l = i[a];
    (i[a] = ch[n](t.measureViewportBox(), window.getComputedStyle(t.current))),
      l !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = l),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([c, d]) => {
          t.getValue(c).set(d);
        }),
      this.resolveNoneKeyframes();
  }
}
const k4 = (r, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof r == "number" ||
        Array.isArray(r) ||
        (typeof r == "string" &&
          (Gl.test(r) || r === "0") &&
          !r.startsWith("url("))
      );
function pE(r) {
  const e = r[0];
  if (r.length === 1) return !0;
  for (let t = 0; t < r.length; t++) if (r[t] !== e) return !0;
}
function mE(r, e, t, n) {
  const i = r[0];
  if (i === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const s = r[r.length - 1],
    a = k4(i, e),
    l = k4(s, e);
  return !a || !l ? !1 : pE(r) || ((t === "spring" || Yv(t)) && n);
}
const gE = (r) => r !== null;
function bg(r, { repeat: e, repeatType: t = "loop" }, n) {
  const i = r.filter(gE),
    s = e && t !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return !s || n === void 0 ? i[s] : n;
}
const yE = 40;
class tM {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: n = "keyframes",
    repeat: i = 0,
    repeatDelay: s = 0,
    repeatType: a = "loop",
    ...l
  }) {
    (this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = Qa.now()),
      (this.options = {
        autoplay: e,
        delay: t,
        type: n,
        repeat: i,
        repeatDelay: s,
        repeatType: a,
        ...l,
      }),
      this.updateFinishedPromise();
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > yE
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt;
  }
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && Y8(), this._resolved;
  }
  onKeyframesResolved(e, t) {
    (this.resolvedAt = Qa.now()), (this.hasAttemptedResolve = !0);
    const {
      name: n,
      type: i,
      velocity: s,
      delay: a,
      onComplete: l,
      onUpdate: c,
      isGenerator: d,
    } = this.options;
    if (!d && !mE(e, n, i, s))
      if (a) this.options.duration = 0;
      else {
        c == null || c(bg(e, this.options, t)),
          l == null || l(),
          this.resolveFinishedPromise();
        return;
      }
    const p = this.initPlayback(e, t);
    p !== !1 &&
      ((this._resolved = { keyframes: e, finalKeyframe: t, ...p }),
      this.onPostResolved());
  }
  onPostResolved() {}
  then(e, t) {
    return this.currentFinishedPromise.then(e, t);
  }
  flatten() {
    (this.options.type = "keyframes"), (this.options.ease = "linear");
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
const ir = (r, e, t) => r + (e - r) * t;
function F2(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? r + (e - r) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? r + (e - r) * (2 / 3 - t) * 6
          : r
  );
}
function vE({ hue: r, saturation: e, lightness: t, alpha: n }) {
  (r /= 360), (e /= 100), (t /= 100);
  let i = 0,
    s = 0,
    a = 0;
  if (!e) i = s = a = t;
  else {
    const l = t < 0.5 ? t * (1 + e) : t + e - t * e,
      c = 2 * t - l;
    (i = F2(c, l, r + 1 / 3)), (s = F2(c, l, r)), (a = F2(c, l, r - 1 / 3));
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(a * 255),
    alpha: n,
  };
}
function _0(r, e) {
  return (t) => (t > 0 ? e : r);
}
const N2 = (r, e, t) => {
    const n = r * r,
      i = t * (e * e - n) + n;
    return i < 0 ? 0 : Math.sqrt(i);
  },
  xE = [rv, mc, Qd],
  bE = (r) => xE.find((e) => e.test(r));
function z4(r) {
  const e = bE(r);
  if (!e) return !1;
  let t = e.parse(r);
  return e === Qd && (t = vE(t)), t;
}
const H4 = (r, e) => {
    const t = z4(r),
      n = z4(e);
    if (!t || !n) return _0(r, e);
    const i = { ...t };
    return (s) => (
      (i.red = N2(t.red, n.red, s)),
      (i.green = N2(t.green, n.green, s)),
      (i.blue = N2(t.blue, n.blue, s)),
      (i.alpha = ir(t.alpha, n.alpha, s)),
      mc.transform(i)
    );
  },
  _E = (r, e) => (t) => e(r(t)),
  Wp = (...r) => r.reduce(_E),
  sv = new Set(["none", "hidden"]);
function AE(r, e) {
  return sv.has(r) ? (t) => (t <= 0 ? r : e) : (t) => (t >= 1 ? e : r);
}
function wE(r, e) {
  return (t) => ir(r, e, t);
}
function c3(r) {
  return typeof r == "number"
    ? wE
    : typeof r == "string"
      ? i3(r)
        ? _0
        : Si.test(r)
          ? H4
          : EE
      : Array.isArray(r)
        ? nM
        : typeof r == "object"
          ? Si.test(r)
            ? H4
            : ME
          : _0;
}
function nM(r, e) {
  const t = [...r],
    n = t.length,
    i = r.map((s, a) => c3(s)(s, e[a]));
  return (s) => {
    for (let a = 0; a < n; a++) t[a] = i[a](s);
    return t;
  };
}
function ME(r, e) {
  const t = { ...r, ...e },
    n = {};
  for (const i in t)
    r[i] !== void 0 && e[i] !== void 0 && (n[i] = c3(r[i])(r[i], e[i]));
  return (i) => {
    for (const s in n) t[s] = n[s](i);
    return t;
  };
}
function SE(r, e) {
  var t;
  const n = [],
    i = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < e.values.length; s++) {
    const a = e.types[s],
      l = r.indexes[a][i[a]],
      c = (t = r.values[l]) !== null && t !== void 0 ? t : 0;
    (n[s] = c), i[a]++;
  }
  return n;
}
const EE = (r, e) => {
  const t = Gl.createTransformer(e),
    n = wp(r),
    i = wp(e);
  return n.indexes.var.length === i.indexes.var.length &&
    n.indexes.color.length === i.indexes.color.length &&
    n.indexes.number.length >= i.indexes.number.length
    ? (sv.has(r) && !i.values.length) || (sv.has(e) && !n.values.length)
      ? AE(r, e)
      : Wp(nM(SE(n, i), i.values), t)
    : _0(r, e);
};
function rM(r, e, t) {
  return typeof r == "number" && typeof e == "number" && typeof t == "number"
    ? ir(r, e, t)
    : c3(r)(r, e);
}
const CE = 5;
function iM(r, e, t) {
  const n = Math.max(e - CE, 0);
  return e3(t - r(n), e - n);
}
const yr = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  V4 = 0.001;
function TE({
  duration: r = yr.duration,
  bounce: e = yr.bounce,
  velocity: t = yr.velocity,
  mass: n = yr.mass,
}) {
  let i,
    s,
    a = 1 - e;
  (a = qo(yr.minDamping, yr.maxDamping, a)),
    (r = qo(yr.minDuration, yr.maxDuration, Jo(r))),
    a < 1
      ? ((i = (d) => {
          const p = d * a,
            m = p * r,
            y = p - t,
            v = av(d, a),
            A = Math.exp(-m);
          return V4 - (y / v) * A;
        }),
        (s = (d) => {
          const p = d * a * r,
            m = p * t + t,
            y = Math.pow(a, 2) * Math.pow(d, 2) * r,
            v = Math.exp(-p),
            A = av(Math.pow(d, 2), a);
          return ((-i(d) + V4 > 0 ? -1 : 1) * ((m - y) * v)) / A;
        }))
      : ((i = (d) => {
          const p = Math.exp(-d * r),
            m = (d - t) * r + 1;
          return -0.001 + p * m;
        }),
        (s = (d) => {
          const p = Math.exp(-d * r),
            m = (t - d) * (r * r);
          return p * m;
        }));
  const l = 5 / r,
    c = IE(i, s, l);
  if (((r = Xo(r)), isNaN(c)))
    return { stiffness: yr.stiffness, damping: yr.damping, duration: r };
  {
    const d = Math.pow(c, 2) * n;
    return { stiffness: d, damping: a * 2 * Math.sqrt(n * d), duration: r };
  }
}
const RE = 12;
function IE(r, e, t) {
  let n = t;
  for (let i = 1; i < RE; i++) n = n - r(n) / e(n);
  return n;
}
function av(r, e) {
  return r * Math.sqrt(1 - e * e);
}
const BE = ["duration", "bounce"],
  PE = ["stiffness", "damping", "mass"];
function G4(r, e) {
  return e.some((t) => r[t] !== void 0);
}
function LE(r) {
  let e = {
    velocity: yr.velocity,
    stiffness: yr.stiffness,
    damping: yr.damping,
    mass: yr.mass,
    isResolvedFromDuration: !1,
    ...r,
  };
  if (!G4(r, PE) && G4(r, BE))
    if (r.visualDuration) {
      const t = r.visualDuration,
        n = (2 * Math.PI) / (t * 1.2),
        i = n * n,
        s = 2 * qo(0.05, 1, 1 - (r.bounce || 0)) * Math.sqrt(i);
      e = { ...e, mass: yr.mass, stiffness: i, damping: s };
    } else {
      const t = TE(r);
      (e = { ...e, ...t, mass: yr.mass }), (e.isResolvedFromDuration = !0);
    }
  return e;
}
function sM(r = yr.visualDuration, e = yr.bounce) {
  const t =
    typeof r != "object"
      ? { visualDuration: r, keyframes: [0, 1], bounce: e }
      : r;
  let { restSpeed: n, restDelta: i } = t;
  const s = t.keyframes[0],
    a = t.keyframes[t.keyframes.length - 1],
    l = { done: !1, value: s },
    {
      stiffness: c,
      damping: d,
      mass: p,
      duration: m,
      velocity: y,
      isResolvedFromDuration: v,
    } = LE({ ...t, velocity: -Jo(t.velocity || 0) }),
    A = y || 0,
    M = d / (2 * Math.sqrt(c * p)),
    w = a - s,
    x = Jo(Math.sqrt(c / p)),
    C = Math.abs(w) < 5;
  n || (n = C ? yr.restSpeed.granular : yr.restSpeed.default),
    i || (i = C ? yr.restDelta.granular : yr.restDelta.default);
  let T;
  if (M < 1) {
    const U = av(x, M);
    T = (F) => {
      const O = Math.exp(-M * x * F);
      return (
        a - O * (((A + M * x * w) / U) * Math.sin(U * F) + w * Math.cos(U * F))
      );
    };
  } else if (M === 1) T = (U) => a - Math.exp(-x * U) * (w + (A + x * w) * U);
  else {
    const U = x * Math.sqrt(M * M - 1);
    T = (F) => {
      const O = Math.exp(-M * x * F),
        z = Math.min(U * F, 300);
      return (
        a - (O * ((A + M * x * w) * Math.sinh(z) + U * w * Math.cosh(z))) / U
      );
    };
  }
  const I = {
    calculatedDuration: (v && m) || null,
    next: (U) => {
      const F = T(U);
      if (v) l.done = U >= m;
      else {
        let O = 0;
        M < 1 && (O = U === 0 ? Xo(A) : iM(T, U, F));
        const z = Math.abs(O) <= n,
          L = Math.abs(a - F) <= i;
        l.done = z && L;
      }
      return (l.value = l.done ? a : F), l;
    },
    toString: () => {
      const U = Math.min(bw(I), Qy),
        F = _w((O) => I.next(U * O).value, U, 30);
      return U + "ms " + F;
    },
  };
  return I;
}
function j4({
  keyframes: r,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: n = 325,
  bounceDamping: i = 10,
  bounceStiffness: s = 500,
  modifyTarget: a,
  min: l,
  max: c,
  restDelta: d = 0.5,
  restSpeed: p,
}) {
  const m = r[0],
    y = { done: !1, value: m },
    v = (z) => (l !== void 0 && z < l) || (c !== void 0 && z > c),
    A = (z) =>
      l === void 0
        ? c
        : c === void 0 || Math.abs(l - z) < Math.abs(c - z)
          ? l
          : c;
  let M = t * e;
  const w = m + M,
    x = a === void 0 ? w : a(w);
  x !== w && (M = x - m);
  const C = (z) => -M * Math.exp(-z / n),
    T = (z) => x + C(z),
    I = (z) => {
      const L = C(z),
        N = T(z);
      (y.done = Math.abs(L) <= d), (y.value = y.done ? x : N);
    };
  let U, F;
  const O = (z) => {
    v(y.value) &&
      ((U = z),
      (F = sM({
        keyframes: [y.value, A(y.value)],
        velocity: iM(T, z, y.value),
        damping: i,
        stiffness: s,
        restDelta: d,
        restSpeed: p,
      })));
  };
  return (
    O(0),
    {
      calculatedDuration: null,
      next: (z) => {
        let L = !1;
        return (
          !F && U === void 0 && ((L = !0), I(z), O(z)),
          U !== void 0 && z >= U ? F.next(z - U) : (!L && I(z), y)
        );
      },
    }
  );
}
const DE = Gp(0.42, 0, 1, 1),
  FE = Gp(0, 0, 0.58, 1),
  aM = Gp(0.42, 0, 0.58, 1),
  NE = (r) => Array.isArray(r) && typeof r[0] != "number",
  W4 = {
    linear: Xi,
    easeIn: DE,
    easeInOut: aM,
    easeOut: FE,
    circIn: r3,
    circInOut: Ow,
    circOut: Uw,
    backIn: n3,
    backInOut: Fw,
    backOut: Dw,
    anticipate: Nw,
  },
  X4 = (r) => {
    if (Zv(r)) {
      Ky(r.length === 4);
      const [e, t, n, i] = r;
      return Gp(e, t, n, i);
    } else if (typeof r == "string") return Ky(W4[r] !== void 0), W4[r];
    return r;
  };
function UE(r, e, t) {
  const n = [],
    i = t || rM,
    s = r.length - 1;
  for (let a = 0; a < s; a++) {
    let l = i(r[a], r[a + 1]);
    if (e) {
      const c = Array.isArray(e) ? e[a] || Xi : e;
      l = Wp(c, l);
    }
    n.push(l);
  }
  return n;
}
function d3(r, e, { clamp: t = !0, ease: n, mixer: i } = {}) {
  const s = r.length;
  if ((Ky(s === e.length), s === 1)) return () => e[0];
  if (s === 2 && r[0] === r[1]) return () => e[1];
  r[0] > r[s - 1] && ((r = [...r].reverse()), (e = [...e].reverse()));
  const a = UE(e, n, i),
    l = a.length,
    c = (d) => {
      let p = 0;
      if (l > 1) for (; p < r.length - 2 && !(d < r[p + 1]); p++);
      const m = Bc(r[p], r[p + 1], d);
      return a[p](m);
    };
  return t ? (d) => c(qo(r[0], r[s - 1], d)) : c;
}
function OE(r, e) {
  const t = r[r.length - 1];
  for (let n = 1; n <= e; n++) {
    const i = Bc(0, e, n);
    r.push(ir(t, 1, i));
  }
}
function oM(r) {
  const e = [0];
  return OE(e, r.length - 1), e;
}
function kE(r, e) {
  return r.map((t) => t * e);
}
function zE(r, e) {
  return r.map(() => e || aM).splice(0, r.length - 1);
}
function A0({
  duration: r = 300,
  keyframes: e,
  times: t,
  ease: n = "easeInOut",
}) {
  const i = NE(n) ? n.map(X4) : X4(n),
    s = { done: !1, value: e[0] },
    a = kE(t && t.length === e.length ? t : oM(e), r),
    l = d3(a, e, { ease: Array.isArray(i) ? i : zE(e, i) });
  return {
    calculatedDuration: r,
    next: (c) => ((s.value = l(c)), (s.done = c >= r), s),
  };
}
const HE = (r) => {
    const e = ({ timestamp: t }) => r(t);
    return {
      start: () => Pn.update(e, !0),
      stop: () => Sa(e),
      now: () => (zr.isProcessing ? zr.timestamp : Qa.now()),
    };
  },
  VE = { decay: j4, inertia: j4, tween: A0, keyframes: A0, spring: sM },
  GE = (r) => r / 100;
class _g extends tM {
  constructor(e) {
    super(e),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = "running"),
      (this.startTime = null),
      (this.state = "idle"),
      (this.stop = () => {
        if (
          (this.resolver.cancel(), (this.isStopped = !0), this.state === "idle")
        )
          return;
        this.teardown();
        const { onStop: c } = this.options;
        c && c();
      });
    const { name: t, motionValue: n, element: i, keyframes: s } = this.options,
      a = (i == null ? void 0 : i.KeyframeResolver) || s3,
      l = (c, d) => this.onKeyframesResolved(c, d);
    (this.resolver = new a(s, l, t, n, i)), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(),
      this._resolved &&
        Object.assign(
          this._resolved,
          this.initPlayback(this._resolved.keyframes),
        );
  }
  initPlayback(e) {
    const {
        type: t = "keyframes",
        repeat: n = 0,
        repeatDelay: i = 0,
        repeatType: s,
        velocity: a = 0,
      } = this.options,
      l = Yv(t) ? t : VE[t] || A0;
    let c, d;
    l !== A0 &&
      typeof e[0] != "number" &&
      ((c = Wp(GE, rM(e[0], e[1]))), (e = [0, 100]));
    const p = l({ ...this.options, keyframes: e });
    s === "mirror" &&
      (d = l({ ...this.options, keyframes: [...e].reverse(), velocity: -a })),
      p.calculatedDuration === null && (p.calculatedDuration = bw(p));
    const { calculatedDuration: m } = p,
      y = m + i,
      v = y * (n + 1) - i;
    return {
      generator: p,
      mirroredGenerator: d,
      mapPercentToKeyframes: c,
      calculatedDuration: m,
      resolvedDuration: y,
      totalDuration: v,
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(),
      this.pendingPlayState === "paused" || !e
        ? this.pause()
        : (this.state = this.pendingPlayState);
  }
  tick(e, t = !1) {
    const { resolved: n } = this;
    if (!n) {
      const { keyframes: z } = this.options;
      return { done: !0, value: z[z.length - 1] };
    }
    const {
      finalKeyframe: i,
      generator: s,
      mirroredGenerator: a,
      mapPercentToKeyframes: l,
      keyframes: c,
      calculatedDuration: d,
      totalDuration: p,
      resolvedDuration: m,
    } = n;
    if (this.startTime === null) return s.next(0);
    const {
      delay: y,
      repeat: v,
      repeatType: A,
      repeatDelay: M,
      onUpdate: w,
    } = this.options;
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - p / this.speed, this.startTime)),
      t
        ? (this.currentTime = e)
        : this.holdTime !== null
          ? (this.currentTime = this.holdTime)
          : (this.currentTime = Math.round(e - this.startTime) * this.speed);
    const x = this.currentTime - y * (this.speed >= 0 ? 1 : -1),
      C = this.speed >= 0 ? x < 0 : x > p;
    (this.currentTime = Math.max(x, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = p);
    let T = this.currentTime,
      I = s;
    if (v) {
      const z = Math.min(this.currentTime, p) / m;
      let L = Math.floor(z),
        N = z % 1;
      !N && z >= 1 && (N = 1),
        N === 1 && L--,
        (L = Math.min(L, v + 1)),
        L % 2 &&
          (A === "reverse"
            ? ((N = 1 - N), M && (N -= M / m))
            : A === "mirror" && (I = a)),
        (T = qo(0, 1, N) * m);
    }
    const U = C ? { done: !1, value: c[0] } : I.next(T);
    l && (U.value = l(U.value));
    let { done: F } = U;
    !C &&
      d !== null &&
      (F = this.speed >= 0 ? this.currentTime >= p : this.currentTime <= 0);
    const O =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && F));
    return (
      O && i !== void 0 && (U.value = bg(c, this.options, i)),
      w && w(U.value),
      O && this.finish(),
      U
    );
  }
  get duration() {
    const { resolved: e } = this;
    return e ? Jo(e.calculatedDuration) : 0;
  }
  get time() {
    return Jo(this.currentTime);
  }
  set time(e) {
    (e = Xo(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const t = this.playbackSpeed !== e;
    (this.playbackSpeed = e), t && (this.time = Jo(this.currentTime));
  }
  play() {
    if (
      (this.resolver.isScheduled || this.resolver.resume(), !this._resolved)
    ) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped) return;
    const { driver: e = HE, onPlay: t, startTime: n } = this.options;
    this.driver || (this.driver = e((s) => this.tick(s))), t && t();
    const i = this.driver.now();
    this.holdTime !== null
      ? (this.startTime = i - this.holdTime)
      : this.startTime
        ? this.state === "finished" && (this.startTime = i)
        : (this.startTime = n ?? this.calcStartTime()),
      this.state === "finished" && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    (this.state = "paused"),
      (this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0);
  }
  complete() {
    this.state !== "running" && this.play(),
      (this.pendingPlayState = this.state = "finished"),
      (this.holdTime = null);
  }
  finish() {
    this.teardown(), (this.state = "finished");
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise();
  }
  teardown() {
    (this.state = "idle"),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0);
  }
}
function jE(r) {
  return new _g(r);
}
const WE = new Set(["opacity", "clipPath", "filter", "transform"]);
function XE(
  r,
  e,
  t,
  {
    delay: n = 0,
    duration: i = 300,
    repeat: s = 0,
    repeatType: a = "loop",
    ease: l = "easeInOut",
    times: c,
  } = {},
) {
  const d = { [e]: t };
  c && (d.offset = c);
  const p = ww(l, i);
  return (
    Array.isArray(p) && (d.easing = p),
    r.animate(d, {
      delay: n,
      duration: i,
      easing: Array.isArray(p) ? "linear" : p,
      fill: "both",
      iterations: s + 1,
      direction: a === "reverse" ? "alternate" : "normal",
    })
  );
}
const JE = Xv(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
  w0 = 10,
  YE = 2e4;
function ZE(r) {
  return Yv(r.type) || r.type === "spring" || !Aw(r.ease);
}
function qE(r, e) {
  const t = new _g({
    ...e,
    keyframes: r,
    repeat: 0,
    delay: 0,
    isGenerator: !0,
  });
  let n = { done: !1, value: r[0] };
  const i = [];
  let s = 0;
  for (; !n.done && s < YE; ) (n = t.sample(s)), i.push(n.value), (s += w0);
  return { times: void 0, keyframes: i, duration: s - w0, ease: "linear" };
}
const lM = { anticipate: Nw, backInOut: Fw, circInOut: Ow };
function KE(r) {
  return r in lM;
}
class J4 extends tM {
  constructor(e) {
    super(e);
    const { name: t, motionValue: n, element: i, keyframes: s } = this.options;
    (this.resolver = new eM(
      s,
      (a, l) => this.onKeyframesResolved(a, l),
      t,
      n,
      i,
    )),
      this.resolver.scheduleResolve();
  }
  initPlayback(e, t) {
    var n;
    let {
      duration: i = 300,
      times: s,
      ease: a,
      type: l,
      motionValue: c,
      name: d,
      startTime: p,
    } = this.options;
    if (!(!((n = c.owner) === null || n === void 0) && n.current)) return !1;
    if (
      (typeof a == "string" && b0() && KE(a) && (a = lM[a]), ZE(this.options))
    ) {
      const {
          onComplete: y,
          onUpdate: v,
          motionValue: A,
          element: M,
          ...w
        } = this.options,
        x = qE(e, w);
      (e = x.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (i = x.duration),
        (s = x.times),
        (a = x.ease),
        (l = "keyframes");
    }
    const m = XE(c.owner.current, d, e, {
      ...this.options,
      duration: i,
      times: s,
      ease: a,
    });
    return (
      (m.startTime = p ?? this.calcStartTime()),
      this.pendingTimeline
        ? (C4(m, this.pendingTimeline), (this.pendingTimeline = void 0))
        : (m.onfinish = () => {
            const { onComplete: y } = this.options;
            c.set(bg(e, this.options, t)),
              y && y(),
              this.cancel(),
              this.resolveFinishedPromise();
          }),
      { animation: m, duration: i, times: s, type: l, ease: a, keyframes: e }
    );
  }
  get duration() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { duration: t } = e;
    return Jo(t);
  }
  get time() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { animation: t } = e;
    return Jo(t.currentTime || 0);
  }
  set time(e) {
    const { resolved: t } = this;
    if (!t) return;
    const { animation: n } = t;
    n.currentTime = Xo(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e) return 1;
    const { animation: t } = e;
    return t.playbackRate;
  }
  set speed(e) {
    const { resolved: t } = this;
    if (!t) return;
    const { animation: n } = t;
    n.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e) return "idle";
    const { animation: t } = e;
    return t.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e) return null;
    const { animation: t } = e;
    return t.startTime;
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e;
    else {
      const { resolved: t } = this;
      if (!t) return Xi;
      const { animation: n } = t;
      C4(n, e);
    }
    return Xi;
  }
  play() {
    if (this.isStopped) return;
    const { resolved: e } = this;
    if (!e) return;
    const { animation: t } = e;
    t.playState === "finished" && this.updateFinishedPromise(), t.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e) return;
    const { animation: t } = e;
    t.pause();
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === "idle"))
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e) return;
    const {
      animation: t,
      keyframes: n,
      duration: i,
      type: s,
      ease: a,
      times: l,
    } = e;
    if (t.playState === "idle" || t.playState === "finished") return;
    if (this.time) {
      const {
          motionValue: d,
          onUpdate: p,
          onComplete: m,
          element: y,
          ...v
        } = this.options,
        A = new _g({
          ...v,
          keyframes: n,
          duration: i,
          type: s,
          ease: a,
          times: l,
          isGenerator: !0,
        }),
        M = Xo(this.time);
      d.setWithVelocity(A.sample(M - w0).value, A.sample(M).value, w0);
    }
    const { onStop: c } = this.options;
    c && c(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const {
      motionValue: t,
      name: n,
      repeatDelay: i,
      repeatType: s,
      damping: a,
      type: l,
    } = e;
    return (
      JE() &&
      n &&
      WE.has(n) &&
      t &&
      t.owner &&
      t.owner.current instanceof HTMLElement &&
      !t.owner.getProps().onUpdate &&
      !i &&
      s !== "mirror" &&
      a !== 0 &&
      l !== "inertia"
    );
  }
}
const QE = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  $E = (r) => ({
    type: "spring",
    stiffness: 550,
    damping: r === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  eC = { type: "keyframes", duration: 0.8 },
  tC = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  nC = (r, { keyframes: e }) =>
    e.length > 2
      ? eC
      : Hc.has(r)
        ? r.startsWith("scale")
          ? $E(e[1])
          : QE
        : tC;
function rC({
  when: r,
  delay: e,
  delayChildren: t,
  staggerChildren: n,
  staggerDirection: i,
  repeat: s,
  repeatType: a,
  repeatDelay: l,
  from: c,
  elapsed: d,
  ...p
}) {
  return !!Object.keys(p).length;
}
const h3 =
  (r, e, t, n = {}, i, s) =>
  (a) => {
    const l = Jv(n, r) || {},
      c = l.delay || n.delay || 0;
    let { elapsed: d = 0 } = n;
    d = d - Xo(c);
    let p = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...l,
      delay: -d,
      onUpdate: (y) => {
        e.set(y), l.onUpdate && l.onUpdate(y);
      },
      onComplete: () => {
        a(), l.onComplete && l.onComplete();
      },
      name: r,
      motionValue: e,
      element: s ? void 0 : i,
    };
    rC(l) || (p = { ...p, ...nC(r, p) }),
      p.duration && (p.duration = Xo(p.duration)),
      p.repeatDelay && (p.repeatDelay = Xo(p.repeatDelay)),
      p.from !== void 0 && (p.keyframes[0] = p.from);
    let m = !1;
    if (
      ((p.type === !1 || (p.duration === 0 && !p.repeatDelay)) &&
        ((p.duration = 0), p.delay === 0 && (m = !0)),
      m && !s && e.get() !== void 0)
    ) {
      const y = bg(p.keyframes, l);
      if (y !== void 0)
        return (
          Pn.update(() => {
            p.onUpdate(y), p.onComplete();
          }),
          new h8([])
        );
    }
    return !s && J4.supports(p) ? new J4(p) : new _g(p);
  };
function iC({ protectedKeys: r, needsAnimating: e }, t) {
  const n = r.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), n;
}
function uM(r, e, { delay: t = 0, transitionOverride: n, type: i } = {}) {
  var s;
  let { transition: a = r.getDefaultTransition(), transitionEnd: l, ...c } = e;
  n && (a = n);
  const d = [],
    p = i && r.animationState && r.animationState.getState()[i];
  for (const m in c) {
    const y = r.getValue(
        m,
        (s = r.latestValues[m]) !== null && s !== void 0 ? s : null,
      ),
      v = c[m];
    if (v === void 0 || (p && iC(p, m))) continue;
    const A = { delay: t, ...Jv(a || {}, m) };
    let M = !1;
    if (window.MotionHandoffAnimation) {
      const x = Iw(r);
      if (x) {
        const C = window.MotionHandoffAnimation(x, m, Pn);
        C !== null && ((A.startTime = C), (M = !0));
      }
    }
    ev(r, m),
      y.start(
        h3(m, y, v, r.shouldReduceMotion && Hc.has(m) ? { type: !1 } : A, r, M),
      );
    const w = y.animation;
    w && d.push(w);
  }
  return (
    l &&
      Promise.all(d).then(() => {
        Pn.update(() => {
          l && I8(r, l);
        });
      }),
    d
  );
}
function ov(r, e, t = {}) {
  var n;
  const i = xg(
    r,
    e,
    t.type === "exit"
      ? (n = r.presenceContext) === null || n === void 0
        ? void 0
        : n.custom
      : void 0,
  );
  let { transition: s = r.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (s = t.transitionOverride);
  const a = i ? () => Promise.all(uM(r, i, t)) : () => Promise.resolve(),
    l =
      r.variantChildren && r.variantChildren.size
        ? (d = 0) => {
            const {
              delayChildren: p = 0,
              staggerChildren: m,
              staggerDirection: y,
            } = s;
            return sC(r, e, p + d, m, y, t);
          }
        : () => Promise.resolve(),
    { when: c } = s;
  if (c) {
    const [d, p] = c === "beforeChildren" ? [a, l] : [l, a];
    return d().then(() => p());
  } else return Promise.all([a(), l(t.delay)]);
}
function sC(r, e, t = 0, n = 0, i = 1, s) {
  const a = [],
    l = (r.variantChildren.size - 1) * n,
    c = i === 1 ? (d = 0) => d * n : (d = 0) => l - d * n;
  return (
    Array.from(r.variantChildren)
      .sort(aC)
      .forEach((d, p) => {
        d.notify("AnimationStart", e),
          a.push(
            ov(d, e, { ...s, delay: t + c(p) }).then(() =>
              d.notify("AnimationComplete", e),
            ),
          );
      }),
    Promise.all(a)
  );
}
function aC(r, e) {
  return r.sortNodePosition(e);
}
function oC(r, e, t = {}) {
  r.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const i = e.map((s) => ov(r, s, t));
    n = Promise.all(i);
  } else if (typeof e == "string") n = ov(r, e, t);
  else {
    const i = typeof e == "function" ? xg(r, e, t.custom) : e;
    n = Promise.all(uM(r, i, t));
  }
  return n.then(() => {
    r.notify("AnimationComplete", e);
  });
}
const lC = Wv.length;
function cM(r) {
  if (!r) return;
  if (!r.isControllingVariants) {
    const t = r.parent ? cM(r.parent) || {} : {};
    return r.props.initial !== void 0 && (t.initial = r.props.initial), t;
  }
  const e = {};
  for (let t = 0; t < lC; t++) {
    const n = Wv[t],
      i = r.props[n];
    (_p(i) || i === !1) && (e[n] = i);
  }
  return e;
}
const uC = [...jv].reverse(),
  cC = jv.length;
function dC(r) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: n }) => oC(r, t, n)));
}
function hC(r) {
  let e = dC(r),
    t = Y4(),
    n = !0;
  const i = (c) => (d, p) => {
    var m;
    const y = xg(
      r,
      p,
      c === "exit"
        ? (m = r.presenceContext) === null || m === void 0
          ? void 0
          : m.custom
        : void 0,
    );
    if (y) {
      const { transition: v, transitionEnd: A, ...M } = y;
      d = { ...d, ...M, ...A };
    }
    return d;
  };
  function s(c) {
    e = c(r);
  }
  function a(c) {
    const { props: d } = r,
      p = cM(r.parent) || {},
      m = [],
      y = new Set();
    let v = {},
      A = 1 / 0;
    for (let w = 0; w < cC; w++) {
      const x = uC[w],
        C = t[x],
        T = d[x] !== void 0 ? d[x] : p[x],
        I = _p(T),
        U = x === c ? C.isActive : null;
      U === !1 && (A = w);
      let F = T === p[x] && T !== d[x] && I;
      if (
        (F && n && r.manuallyAnimateOnMount && (F = !1),
        (C.protectedKeys = { ...v }),
        (!C.isActive && U === null) ||
          (!T && !C.prevProp) ||
          vg(T) ||
          typeof T == "boolean")
      )
        continue;
      const O = fC(C.prevProp, T);
      let z = O || (x === c && C.isActive && !F && I) || (w > A && I),
        L = !1;
      const N = Array.isArray(T) ? T : [T];
      let X = N.reduce(i(x), {});
      U === !1 && (X = {});
      const { prevResolvedValues: ie = {} } = C,
        re = { ...ie, ...X },
        me = (_e) => {
          (z = !0),
            y.has(_e) && ((L = !0), y.delete(_e)),
            (C.needsAnimating[_e] = !0);
          const ge = r.getValue(_e);
          ge && (ge.liveStyle = !1);
        };
      for (const _e in re) {
        const ge = X[_e],
          Re = ie[_e];
        if (v.hasOwnProperty(_e)) continue;
        let J = !1;
        qy(ge) && qy(Re) ? (J = !vw(ge, Re)) : (J = ge !== Re),
          J
            ? ge != null
              ? me(_e)
              : y.add(_e)
            : ge !== void 0 && y.has(_e)
              ? me(_e)
              : (C.protectedKeys[_e] = !0);
      }
      (C.prevProp = T),
        (C.prevResolvedValues = X),
        C.isActive && (v = { ...v, ...X }),
        n && r.blockInitialAnimation && (z = !1),
        z &&
          (!(F && O) || L) &&
          m.push(...N.map((_e) => ({ animation: _e, options: { type: x } })));
    }
    if (y.size) {
      const w = {};
      y.forEach((x) => {
        const C = r.getBaseTarget(x),
          T = r.getValue(x);
        T && (T.liveStyle = !0), (w[x] = C ?? null);
      }),
        m.push({ animation: w });
    }
    let M = !!m.length;
    return (
      n &&
        (d.initial === !1 || d.initial === d.animate) &&
        !r.manuallyAnimateOnMount &&
        (M = !1),
      (n = !1),
      M ? e(m) : Promise.resolve()
    );
  }
  function l(c, d) {
    var p;
    if (t[c].isActive === d) return Promise.resolve();
    (p = r.variantChildren) === null ||
      p === void 0 ||
      p.forEach((y) => {
        var v;
        return (v = y.animationState) === null || v === void 0
          ? void 0
          : v.setActive(c, d);
      }),
      (t[c].isActive = d);
    const m = a(c);
    for (const y in t) t[y].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: a,
    setActive: l,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      (t = Y4()), (n = !0);
    },
  };
}
function fC(r, e) {
  return typeof e == "string" ? e !== r : Array.isArray(e) ? !vw(e, r) : !1;
}
function Yu(r = !1) {
  return {
    isActive: r,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function Y4() {
  return {
    animate: Yu(!0),
    whileInView: Yu(),
    whileHover: Yu(),
    whileTap: Yu(),
    whileDrag: Yu(),
    whileFocus: Yu(),
    exit: Yu(),
  };
}
class Yl {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
class pC extends Yl {
  constructor(e) {
    super(e), e.animationState || (e.animationState = hC(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    vg(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(),
      (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let mC = 0;
class gC extends Yl {
  constructor() {
    super(...arguments), (this.id = mC++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
      { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === n) return;
    const i = this.node.animationState.setActive("exit", !e);
    t && !e && i.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const yC = { animation: { Feature: pC }, exit: { Feature: gC } };
function Mp(r, e, t, n = { passive: !0 }) {
  return r.addEventListener(e, t, n), () => r.removeEventListener(e, t);
}
function Xp(r) {
  return { point: { x: r.pageX, y: r.pageY } };
}
const vC = (r) => (e) => qv(e) && r(e, Xp(e));
function sp(r, e, t, n) {
  return Mp(r, e, vC(t), n);
}
const Z4 = (r, e) => Math.abs(r - e);
function xC(r, e) {
  const t = Z4(r.x, e.x),
    n = Z4(r.y, e.y);
  return Math.sqrt(t ** 2 + n ** 2);
}
class dM {
  constructor(
    e,
    t,
    { transformPagePoint: n, contextWindow: i, dragSnapToOrigin: s = !1 } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const m = O2(this.lastMoveEventInfo, this.history),
          y = this.startEvent !== null,
          v = xC(m.offset, { x: 0, y: 0 }) >= 3;
        if (!y && !v) return;
        const { point: A } = m,
          { timestamp: M } = zr;
        this.history.push({ ...A, timestamp: M });
        const { onStart: w, onMove: x } = this.handlers;
        y ||
          (w && w(this.lastMoveEvent, m),
          (this.startEvent = this.lastMoveEvent)),
          x && x(this.lastMoveEvent, m);
      }),
      (this.handlePointerMove = (m, y) => {
        (this.lastMoveEvent = m),
          (this.lastMoveEventInfo = U2(y, this.transformPagePoint)),
          Pn.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (m, y) => {
        this.end();
        const { onEnd: v, onSessionEnd: A, resumeAnimation: M } = this.handlers;
        if (
          (this.dragSnapToOrigin && M && M(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const w = O2(
          m.type === "pointercancel"
            ? this.lastMoveEventInfo
            : U2(y, this.transformPagePoint),
          this.history,
        );
        this.startEvent && v && v(m, w), A && A(m, w);
      }),
      !qv(e))
    )
      return;
    (this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = n),
      (this.contextWindow = i || window);
    const a = Xp(e),
      l = U2(a, this.transformPagePoint),
      { point: c } = l,
      { timestamp: d } = zr;
    this.history = [{ ...c, timestamp: d }];
    const { onSessionStart: p } = t;
    p && p(e, O2(l, this.history)),
      (this.removeListeners = Wp(
        sp(this.contextWindow, "pointermove", this.handlePointerMove),
        sp(this.contextWindow, "pointerup", this.handlePointerUp),
        sp(this.contextWindow, "pointercancel", this.handlePointerUp),
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Sa(this.updatePoint);
  }
}
function U2(r, e) {
  return e ? { point: e(r.point) } : r;
}
function q4(r, e) {
  return { x: r.x - e.x, y: r.y - e.y };
}
function O2({ point: r }, e) {
  return {
    point: r,
    delta: q4(r, hM(e)),
    offset: q4(r, bC(e)),
    velocity: _C(e, 0.1),
  };
}
function bC(r) {
  return r[0];
}
function hM(r) {
  return r[r.length - 1];
}
function _C(r, e) {
  if (r.length < 2) return { x: 0, y: 0 };
  let t = r.length - 1,
    n = null;
  const i = hM(r);
  for (; t >= 0 && ((n = r[t]), !(i.timestamp - n.timestamp > Xo(e))); ) t--;
  if (!n) return { x: 0, y: 0 };
  const s = Jo(i.timestamp - n.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const a = { x: (i.x - n.x) / s, y: (i.y - n.y) / s };
  return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a;
}
function $d(r) {
  return (
    r &&
    typeof r == "object" &&
    Object.prototype.hasOwnProperty.call(r, "current")
  );
}
const fM = 1e-4,
  AC = 1 - fM,
  wC = 1 + fM,
  pM = 0.01,
  MC = 0 - pM,
  SC = 0 + pM;
function Ss(r) {
  return r.max - r.min;
}
function EC(r, e, t) {
  return Math.abs(r - e) <= t;
}
function K4(r, e, t, n = 0.5) {
  (r.origin = n),
    (r.originPoint = ir(e.min, e.max, r.origin)),
    (r.scale = Ss(t) / Ss(e)),
    (r.translate = ir(t.min, t.max, r.origin) - r.originPoint),
    ((r.scale >= AC && r.scale <= wC) || isNaN(r.scale)) && (r.scale = 1),
    ((r.translate >= MC && r.translate <= SC) || isNaN(r.translate)) &&
      (r.translate = 0);
}
function ap(r, e, t, n) {
  K4(r.x, e.x, t.x, n ? n.originX : void 0),
    K4(r.y, e.y, t.y, n ? n.originY : void 0);
}
function Q4(r, e, t) {
  (r.min = t.min + e.min), (r.max = r.min + Ss(e));
}
function CC(r, e, t) {
  Q4(r.x, e.x, t.x), Q4(r.y, e.y, t.y);
}
function $4(r, e, t) {
  (r.min = e.min - t.min), (r.max = r.min + Ss(e));
}
function op(r, e, t) {
  $4(r.x, e.x, t.x), $4(r.y, e.y, t.y);
}
function TC(r, { min: e, max: t }, n) {
  return (
    e !== void 0 && r < e
      ? (r = n ? ir(e, r, n.min) : Math.max(r, e))
      : t !== void 0 && r > t && (r = n ? ir(t, r, n.max) : Math.min(r, t)),
    r
  );
}
function eb(r, e, t) {
  return {
    min: e !== void 0 ? r.min + e : void 0,
    max: t !== void 0 ? r.max + t - (r.max - r.min) : void 0,
  };
}
function RC(r, { top: e, left: t, bottom: n, right: i }) {
  return { x: eb(r.x, t, i), y: eb(r.y, e, n) };
}
function tb(r, e) {
  let t = e.min - r.min,
    n = e.max - r.max;
  return e.max - e.min < r.max - r.min && ([t, n] = [n, t]), { min: t, max: n };
}
function IC(r, e) {
  return { x: tb(r.x, e.x), y: tb(r.y, e.y) };
}
function BC(r, e) {
  let t = 0.5;
  const n = Ss(r),
    i = Ss(e);
  return (
    i > n
      ? (t = Bc(e.min, e.max - n, r.min))
      : n > i && (t = Bc(r.min, r.max - i, e.min)),
    qo(0, 1, t)
  );
}
function PC(r, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - r.min),
    e.max !== void 0 && (t.max = e.max - r.min),
    t
  );
}
const lv = 0.35;
function LC(r = lv) {
  return (
    r === !1 ? (r = 0) : r === !0 && (r = lv),
    { x: nb(r, "left", "right"), y: nb(r, "top", "bottom") }
  );
}
function nb(r, e, t) {
  return { min: rb(r, e), max: rb(r, t) };
}
function rb(r, e) {
  return typeof r == "number" ? r : r[e] || 0;
}
const ib = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  eh = () => ({ x: ib(), y: ib() }),
  sb = () => ({ min: 0, max: 0 }),
  _r = () => ({ x: sb(), y: sb() });
function js(r) {
  return [r("x"), r("y")];
}
function mM({ top: r, left: e, right: t, bottom: n }) {
  return { x: { min: e, max: t }, y: { min: r, max: n } };
}
function DC({ x: r, y: e }) {
  return { top: e.min, right: r.max, bottom: e.max, left: r.min };
}
function FC(r, e) {
  if (!e) return r;
  const t = e({ x: r.left, y: r.top }),
    n = e({ x: r.right, y: r.bottom });
  return { top: t.y, left: t.x, bottom: n.y, right: n.x };
}
function k2(r) {
  return r === void 0 || r === 1;
}
function uv({ scale: r, scaleX: e, scaleY: t }) {
  return !k2(r) || !k2(e) || !k2(t);
}
function cc(r) {
  return (
    uv(r) ||
    gM(r) ||
    r.z ||
    r.rotate ||
    r.rotateX ||
    r.rotateY ||
    r.skewX ||
    r.skewY
  );
}
function gM(r) {
  return ab(r.x) || ab(r.y);
}
function ab(r) {
  return r && r !== "0%";
}
function M0(r, e, t) {
  const n = r - t,
    i = e * n;
  return t + i;
}
function ob(r, e, t, n, i) {
  return i !== void 0 && (r = M0(r, i, n)), M0(r, t, n) + e;
}
function cv(r, e = 0, t = 1, n, i) {
  (r.min = ob(r.min, e, t, n, i)), (r.max = ob(r.max, e, t, n, i));
}
function yM(r, { x: e, y: t }) {
  cv(r.x, e.translate, e.scale, e.originPoint),
    cv(r.y, t.translate, t.scale, t.originPoint);
}
const lb = 0.999999999999,
  ub = 1.0000000000001;
function NC(r, e, t, n = !1) {
  const i = t.length;
  if (!i) return;
  e.x = e.y = 1;
  let s, a;
  for (let l = 0; l < i; l++) {
    (s = t[l]), (a = s.projectionDelta);
    const { visualElement: c } = s.options;
    (c && c.props.style && c.props.style.display === "contents") ||
      (n &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        nh(r, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      a && ((e.x *= a.x.scale), (e.y *= a.y.scale), yM(r, a)),
      n && cc(s.latestValues) && nh(r, s.latestValues));
  }
  e.x < ub && e.x > lb && (e.x = 1), e.y < ub && e.y > lb && (e.y = 1);
}
function th(r, e) {
  (r.min = r.min + e), (r.max = r.max + e);
}
function cb(r, e, t, n, i = 0.5) {
  const s = ir(r.min, r.max, i);
  cv(r, e, t, s, n);
}
function nh(r, e) {
  cb(r.x, e.x, e.scaleX, e.scale, e.originX),
    cb(r.y, e.y, e.scaleY, e.scale, e.originY);
}
function vM(r, e) {
  return mM(FC(r.getBoundingClientRect(), e));
}
function UC(r, e, t) {
  const n = vM(r, t),
    { scroll: i } = e;
  return i && (th(n.x, i.offset.x), th(n.y, i.offset.y)), n;
}
const xM = ({ current: r }) => (r ? r.ownerDocument.defaultView : null),
  OC = new WeakMap();
class kC {
  constructor(e) {
    (this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = _r()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1) return;
    const i = (p) => {
        const { dragSnapToOrigin: m } = this.getProps();
        m ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(Xp(p).point);
      },
      s = (p, m) => {
        const { drag: y, dragPropagation: v, onDragStart: A } = this.getProps();
        if (
          y &&
          !v &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = b8(y)),
          !this.openDragLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          js((w) => {
            let x = this.getAxisMotionValue(w).get() || 0;
            if ($a.test(x)) {
              const { projection: C } = this.visualElement;
              if (C && C.layout) {
                const T = C.layout.layoutBox[w];
                T && (x = Ss(T) * (parseFloat(x) / 100));
              }
            }
            this.originPoint[w] = x;
          }),
          A && Pn.postRender(() => A(p, m)),
          ev(this.visualElement, "transform");
        const { animationState: M } = this.visualElement;
        M && M.setActive("whileDrag", !0);
      },
      a = (p, m) => {
        const {
          dragPropagation: y,
          dragDirectionLock: v,
          onDirectionLock: A,
          onDrag: M,
        } = this.getProps();
        if (!y && !this.openDragLock) return;
        const { offset: w } = m;
        if (v && this.currentDirection === null) {
          (this.currentDirection = zC(w)),
            this.currentDirection !== null && A && A(this.currentDirection);
          return;
        }
        this.updateAxis("x", m.point, w),
          this.updateAxis("y", m.point, w),
          this.visualElement.render(),
          M && M(p, m);
      },
      l = (p, m) => this.stop(p, m),
      c = () =>
        js((p) => {
          var m;
          return (
            this.getAnimationState(p) === "paused" &&
            ((m = this.getAxisMotionValue(p).animation) === null || m === void 0
              ? void 0
              : m.play())
          );
        }),
      { dragSnapToOrigin: d } = this.getProps();
    this.panSession = new dM(
      e,
      {
        onSessionStart: i,
        onStart: s,
        onMove: a,
        onSessionEnd: l,
        resumeAnimation: c,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: d,
        contextWindow: xM(this.visualElement),
      },
    );
  }
  stop(e, t) {
    const n = this.isDragging;
    if ((this.cancel(), !n)) return;
    const { velocity: i } = t;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s && Pn.postRender(() => s(e, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: n } = this.getProps();
    !n &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, n) {
    const { drag: i } = this.getProps();
    if (!n || !f1(e, i, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let a = this.originPoint[e] + n[e];
    this.constraints &&
      this.constraints[e] &&
      (a = TC(a, this.constraints[e], this.elastic[e])),
      s.set(a);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: t, dragElastic: n } = this.getProps(),
      i =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
            ? void 0
            : e.layout,
      s = this.constraints;
    t && $d(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : t && i
        ? (this.constraints = RC(i.layoutBox, t))
        : (this.constraints = !1),
      (this.elastic = LC(n)),
      s !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        js((a) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(a) &&
            (this.constraints[a] = PC(i.layoutBox[a], this.constraints[a]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !$d(e)) return !1;
    const n = e.current,
      { projection: i } = this.visualElement;
    if (!i || !i.layout) return !1;
    const s = UC(n, i.root, this.visualElement.getTransformPagePoint());
    let a = IC(i.layout.layoutBox, s);
    if (t) {
      const l = t(DC(a));
      (this.hasMutatedConstraints = !!l), l && (a = mM(l));
    }
    return a;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: n,
        dragElastic: i,
        dragTransition: s,
        dragSnapToOrigin: a,
        onDragTransitionEnd: l,
      } = this.getProps(),
      c = this.constraints || {},
      d = js((p) => {
        if (!f1(p, t, this.currentDirection)) return;
        let m = c[p] || {};
        a && (m = { min: 0, max: 0 });
        const y = i ? 200 : 1e6,
          v = i ? 40 : 1e7,
          A = {
            type: "inertia",
            velocity: n ? e[p] : 0,
            bounceStiffness: y,
            bounceDamping: v,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...m,
          };
        return this.startAxisValueAnimation(p, A);
      });
    return Promise.all(d).then(l);
  }
  startAxisValueAnimation(e, t) {
    const n = this.getAxisMotionValue(e);
    return (
      ev(this.visualElement, e), n.start(h3(e, n, 0, t, this.visualElement, !1))
    );
  }
  stopAnimation() {
    js((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    js((e) => {
      var t;
      return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
        ? void 0
        : t.pause();
    });
  }
  getAnimationState(e) {
    var t;
    return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
      ? void 0
      : t.state;
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      n = this.visualElement.getProps();
    return (
      n[t] ||
      this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    js((t) => {
      const { drag: n } = this.getProps();
      if (!f1(t, n, this.currentDirection)) return;
      const { projection: i } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (i && i.layout) {
        const { min: a, max: l } = i.layout.layoutBox[t];
        s.set(e[t] - ir(a, l, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: n } = this.visualElement;
    if (!$d(t) || !n || !this.constraints) return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    js((a) => {
      const l = this.getAxisMotionValue(a);
      if (l && this.constraints !== !1) {
        const c = l.get();
        i[a] = BC({ min: c, max: c }, this.constraints[a]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      n.root && n.root.updateScroll(),
      n.updateLayout(),
      this.resolveConstraints(),
      js((a) => {
        if (!f1(a, e, null)) return;
        const l = this.getAxisMotionValue(a),
          { min: c, max: d } = this.constraints[a];
        l.set(ir(c, d, i[a]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    OC.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = sp(e, "pointerdown", (c) => {
        const { drag: d, dragListener: p = !0 } = this.getProps();
        d && p && this.start(c);
      }),
      n = () => {
        const { dragConstraints: c } = this.getProps();
        $d(c) && c.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: i } = this.visualElement,
      s = i.addEventListener("measure", n);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()),
      Pn.read(n);
    const a = Mp(window, "resize", () => this.scalePositionWithinConstraints()),
      l = i.addEventListener(
        "didUpdate",
        ({ delta: c, hasLayoutChanged: d }) => {
          this.isDragging &&
            d &&
            (js((p) => {
              const m = this.getAxisMotionValue(p);
              m &&
                ((this.originPoint[p] += c[p].translate),
                m.set(m.get() + c[p].translate));
            }),
            this.visualElement.render());
        },
      );
    return () => {
      a(), t(), s(), l && l();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: n = !1,
        dragPropagation: i = !1,
        dragConstraints: s = !1,
        dragElastic: a = lv,
        dragMomentum: l = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: a,
      dragMomentum: l,
    };
  }
}
function f1(r, e, t) {
  return (e === !0 || e === r) && (t === null || t === r);
}
function zC(r, e = 10) {
  let t = null;
  return Math.abs(r.y) > e ? (t = "y") : Math.abs(r.x) > e && (t = "x"), t;
}
class HC extends Yl {
  constructor(e) {
    super(e),
      (this.removeGroupControls = Xi),
      (this.removeListeners = Xi),
      (this.controls = new kC(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Xi);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const db = (r) => (e, t) => {
  r && Pn.postRender(() => r(e, t));
};
class VC extends Yl {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Xi);
  }
  onPointerDown(e) {
    this.session = new dM(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: xM(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: n,
      onPanEnd: i,
    } = this.node.getProps();
    return {
      onSessionStart: db(e),
      onStart: db(t),
      onMove: n,
      onEnd: (s, a) => {
        delete this.session, i && Pn.postRender(() => i(s, a));
      },
    };
  }
  mount() {
    this.removePointerDownListener = sp(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e),
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Ag = he.createContext(null);
function GC() {
  const r = he.useContext(Ag);
  if (r === null) return [!0, null];
  const { isPresent: e, onExitComplete: t, register: n } = r,
    i = he.useId();
  he.useEffect(() => n(i), []);
  const s = he.useCallback(() => t && t(i), [i, t]);
  return !e && t ? [!1, s] : [!0];
}
const f3 = he.createContext({}),
  bM = he.createContext({}),
  f0 = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function hb(r, e) {
  return e.max === e.min ? 0 : (r / (e.max - e.min)) * 100;
}
const If = {
    correct: (r, e) => {
      if (!e.target) return r;
      if (typeof r == "string")
        if (Xt.test(r)) r = parseFloat(r);
        else return r;
      const t = hb(r, e.target.x),
        n = hb(r, e.target.y);
      return `${t}% ${n}%`;
    },
  },
  jC = {
    correct: (r, { treeScale: e, projectionDelta: t }) => {
      const n = r,
        i = Gl.parse(r);
      if (i.length > 5) return n;
      const s = Gl.createTransformer(r),
        a = typeof i[0] != "number" ? 1 : 0,
        l = t.x.scale * e.x,
        c = t.y.scale * e.y;
      (i[0 + a] /= l), (i[1 + a] /= c);
      const d = ir(l, c, 0.5);
      return (
        typeof i[2 + a] == "number" && (i[2 + a] /= d),
        typeof i[3 + a] == "number" && (i[3 + a] /= d),
        s(i)
      );
    },
  },
  S0 = {};
function WC(r) {
  Object.assign(S0, r);
}
const { schedule: p3, cancel: Xk } = Tw(queueMicrotask, !1);
class XC extends he.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: n,
        layoutId: i,
      } = this.props,
      { projection: s } = e;
    WC(JC),
      s &&
        (t.group && t.group.add(s),
        n && n.register && i && n.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (f0.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: n,
        drag: i,
        isPresent: s,
      } = this.props,
      a = n.projection;
    return (
      a &&
        ((a.isPresent = s),
        i || e.layoutDependency !== t || t === void 0
          ? a.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? a.promote()
            : a.relegate() ||
              Pn.postRender(() => {
                const l = a.getStack();
                (!l || !l.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      p3.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: n,
      } = this.props,
      { projection: i } = e;
    i &&
      (i.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(i),
      n && n.deregister && n.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function _M(r) {
  const [e, t] = GC(),
    n = he.useContext(f3);
  return H.jsx(XC, {
    ...r,
    layoutGroup: n,
    switchLayoutGroup: he.useContext(bM),
    isPresent: e,
    safeToRemove: t,
  });
}
const JC = {
  borderRadius: {
    ...If,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: If,
  borderTopRightRadius: If,
  borderBottomLeftRadius: If,
  borderBottomRightRadius: If,
  boxShadow: jC,
};
function YC(r, e, t) {
  const n = Lr(r) ? r : qa(r);
  return n.start(h3("", n, e, t)), n.animation;
}
function ZC(r) {
  return r instanceof SVGElement && r.tagName !== "svg";
}
const qC = (r, e) => r.depth - e.depth;
class KC {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    Kv(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    Qv(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(qC),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function QC(r, e) {
  const t = Qa.now(),
    n = ({ timestamp: i }) => {
      const s = i - t;
      s >= e && (Sa(n), r(s - e));
    };
  return Pn.read(n, !0), () => Sa(n);
}
function p0(r) {
  const e = Lr(r) ? r.get() : r;
  return _8(e) ? e.toValue() : e;
}
const AM = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  $C = AM.length,
  fb = (r) => (typeof r == "string" ? parseFloat(r) : r),
  pb = (r) => typeof r == "number" || Xt.test(r);
function eT(r, e, t, n, i, s) {
  i
    ? ((r.opacity = ir(0, t.opacity !== void 0 ? t.opacity : 1, tT(n))),
      (r.opacityExit = ir(e.opacity !== void 0 ? e.opacity : 1, 0, nT(n))))
    : s &&
      (r.opacity = ir(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        n,
      ));
  for (let a = 0; a < $C; a++) {
    const l = `border${AM[a]}Radius`;
    let c = mb(e, l),
      d = mb(t, l);
    (c === void 0 && d === void 0) ||
      (c || (c = 0),
      d || (d = 0),
      c === 0 || d === 0 || pb(c) === pb(d)
        ? ((r[l] = Math.max(ir(fb(c), fb(d), n), 0)),
          ($a.test(d) || $a.test(c)) && (r[l] += "%"))
        : (r[l] = d));
  }
  (e.rotate || t.rotate) && (r.rotate = ir(e.rotate || 0, t.rotate || 0, n));
}
function mb(r, e) {
  return r[e] !== void 0 ? r[e] : r.borderRadius;
}
const tT = wM(0, 0.5, Uw),
  nT = wM(0.5, 0.95, Xi);
function wM(r, e, t) {
  return (n) => (n < r ? 0 : n > e ? 1 : t(Bc(r, e, n)));
}
function gb(r, e) {
  (r.min = e.min), (r.max = e.max);
}
function Vs(r, e) {
  gb(r.x, e.x), gb(r.y, e.y);
}
function yb(r, e) {
  (r.translate = e.translate),
    (r.scale = e.scale),
    (r.originPoint = e.originPoint),
    (r.origin = e.origin);
}
function vb(r, e, t, n, i) {
  return (
    (r -= e), (r = M0(r, 1 / t, n)), i !== void 0 && (r = M0(r, 1 / i, n)), r
  );
}
function rT(r, e = 0, t = 1, n = 0.5, i, s = r, a = r) {
  if (
    ($a.test(e) &&
      ((e = parseFloat(e)), (e = ir(a.min, a.max, e / 100) - a.min)),
    typeof e != "number")
  )
    return;
  let l = ir(s.min, s.max, n);
  r === s && (l -= e),
    (r.min = vb(r.min, e, t, l, i)),
    (r.max = vb(r.max, e, t, l, i));
}
function xb(r, e, [t, n, i], s, a) {
  rT(r, e[t], e[n], e[i], e.scale, s, a);
}
const iT = ["x", "scaleX", "originX"],
  sT = ["y", "scaleY", "originY"];
function bb(r, e, t, n) {
  xb(r.x, e, iT, t ? t.x : void 0, n ? n.x : void 0),
    xb(r.y, e, sT, t ? t.y : void 0, n ? n.y : void 0);
}
function _b(r) {
  return r.translate === 0 && r.scale === 1;
}
function MM(r) {
  return _b(r.x) && _b(r.y);
}
function Ab(r, e) {
  return r.min === e.min && r.max === e.max;
}
function aT(r, e) {
  return Ab(r.x, e.x) && Ab(r.y, e.y);
}
function wb(r, e) {
  return (
    Math.round(r.min) === Math.round(e.min) &&
    Math.round(r.max) === Math.round(e.max)
  );
}
function SM(r, e) {
  return wb(r.x, e.x) && wb(r.y, e.y);
}
function Mb(r) {
  return Ss(r.x) / Ss(r.y);
}
function Sb(r, e) {
  return (
    r.translate === e.translate &&
    r.scale === e.scale &&
    r.originPoint === e.originPoint
  );
}
class oT {
  constructor() {
    this.members = [];
  }
  add(e) {
    Kv(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (Qv(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((i) => e === i);
    if (t === 0) return !1;
    let n;
    for (let i = t; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        n = s;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, t) {
    const n = this.lead;
    if (e !== n && ((this.prevLead = n), (this.lead = e), e.show(), n)) {
      n.instance && n.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = n),
        t && (e.resumeFrom.preserveOpacity = !0),
        n.snapshot &&
          ((e.snapshot = n.snapshot),
          (e.snapshot.latestValues = n.animationValues || n.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: i } = e.options;
      i === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: n } = e;
      t.onExitComplete && t.onExitComplete(),
        n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function lT(r, e, t) {
  let n = "";
  const i = r.x.translate / e.x,
    s = r.y.translate / e.y,
    a = (t == null ? void 0 : t.z) || 0;
  if (
    ((i || s || a) && (n = `translate3d(${i}px, ${s}px, ${a}px) `),
    (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: d,
      rotate: p,
      rotateX: m,
      rotateY: y,
      skewX: v,
      skewY: A,
    } = t;
    d && (n = `perspective(${d}px) ${n}`),
      p && (n += `rotate(${p}deg) `),
      m && (n += `rotateX(${m}deg) `),
      y && (n += `rotateY(${y}deg) `),
      v && (n += `skewX(${v}deg) `),
      A && (n += `skewY(${A}deg) `);
  }
  const l = r.x.scale * e.x,
    c = r.y.scale * e.y;
  return (l !== 1 || c !== 1) && (n += `scale(${l}, ${c})`), n || "none";
}
const dc = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  Kf = typeof window < "u" && window.MotionDebug !== void 0,
  z2 = ["", "X", "Y", "Z"],
  uT = { visibility: "hidden" },
  Eb = 1e3;
let cT = 0;
function H2(r, e, t, n) {
  const { latestValues: i } = e;
  i[r] && ((t[r] = i[r]), e.setStaticValue(r, 0), n && (n[r] = 0));
}
function EM(r) {
  if (((r.hasCheckedOptimisedAppear = !0), r.root === r)) return;
  const { visualElement: e } = r.options;
  if (!e) return;
  const t = Iw(e);
  if (window.MotionHasOptimisedAnimation(t, "transform")) {
    const { layout: i, layoutId: s } = r.options;
    window.MotionCancelOptimisedAnimation(t, "transform", Pn, !(i || s));
  }
  const { parent: n } = r;
  n && !n.hasCheckedOptimisedAppear && EM(n);
}
function CM({
  attachResizeListener: r,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: n,
  resetTransform: i,
}) {
  return class {
    constructor(s = {}, a = e == null ? void 0 : e()) {
      (this.id = cT++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            Kf &&
              (dc.totalNodes =
                dc.resolvedTargetDeltas =
                dc.recalculatedProjection =
                  0),
            this.nodes.forEach(fT),
            this.nodes.forEach(vT),
            this.nodes.forEach(xT),
            this.nodes.forEach(pT),
            Kf && window.MotionDebug.record(dc);
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = s),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0);
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new KC());
    }
    addEventListener(s, a) {
      return (
        this.eventHandlers.has(s) || this.eventHandlers.set(s, new $v()),
        this.eventHandlers.get(s).add(a)
      );
    }
    notifyListeners(s, ...a) {
      const l = this.eventHandlers.get(s);
      l && l.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    mount(s, a = this.root.hasTreeAnimated) {
      if (this.instance) return;
      (this.isSVG = ZC(s)), (this.instance = s);
      const { layoutId: l, layout: c, visualElement: d } = this.options;
      if (
        (d && !d.current && d.mount(s),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        a && (c || l) && (this.isLayoutDirty = !0),
        r)
      ) {
        let p;
        const m = () => (this.root.updateBlockedByResize = !1);
        r(s, () => {
          (this.root.updateBlockedByResize = !0),
            p && p(),
            (p = QC(m, 250)),
            f0.hasAnimatedSinceResize &&
              ((f0.hasAnimatedSinceResize = !1), this.nodes.forEach(Tb));
        });
      }
      l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          d &&
          (l || c) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: p,
              hasLayoutChanged: m,
              hasRelativeTargetChanged: y,
              layout: v,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const A =
                  this.options.transition || d.getDefaultTransition() || MT,
                { onLayoutAnimationStart: M, onLayoutAnimationComplete: w } =
                  d.getProps(),
                x = !this.targetLayout || !SM(this.targetLayout, v) || y,
                C = !m && y;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                C ||
                (m && (x || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(p, C);
                const T = { ...Jv(A, "layout"), onPlay: M, onComplete: w };
                (d.shouldReduceMotion || this.options.layoutRoot) &&
                  ((T.delay = 0), (T.type = !1)),
                  this.startAnimation(T);
              } else
                m || Tb(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = v;
            },
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Sa(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(bT),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          EM(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let d = 0; d < this.path.length; d++) {
        const p = this.path[d];
        (p.shouldResetTransform = !0),
          p.updateScroll("snapshot"),
          p.options.layoutRoot && p.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const c = this.getTransformTemplate();
      (this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        s && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Cb);
        return;
      }
      this.isUpdating || this.nodes.forEach(gT),
        (this.isUpdating = !1),
        this.nodes.forEach(yT),
        this.nodes.forEach(dT),
        this.nodes.forEach(hT),
        this.clearAllSnapshots();
      const s = Qa.now();
      (zr.delta = qo(0, 1e3 / 60, s - zr.timestamp)),
        (zr.timestamp = s),
        (zr.isProcessing = !0),
        L2.update.process(zr),
        L2.preRender.process(zr),
        L2.render.process(zr),
        (zr.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), p3.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(mT), this.sharedNodes.forEach(_T);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        Pn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Pn.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const s = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = _r()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          s ? s.layoutBox : void 0,
        );
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === s &&
          (a = !1),
        a)
      ) {
        const l = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: l,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        };
      }
    }
    resetTransform() {
      if (!i) return;
      const s =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        a = this.projectionDelta && !MM(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, "") : void 0,
        d = c !== this.prevTransformTemplateValue;
      s &&
        (a || cc(this.latestValues) || d) &&
        (i(this.instance, c),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        s && (l = this.removeTransform(l)),
        ST(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var s;
      const { visualElement: a } = this.options;
      if (!a) return _r();
      const l = a.measureViewportBox();
      if (
        !(
          (!((s = this.scroll) === null || s === void 0) && s.wasRoot) ||
          this.path.some(ET)
        )
      ) {
        const { scroll: c } = this.root;
        c && (th(l.x, c.offset.x), th(l.y, c.offset.y));
      }
      return l;
    }
    removeElementScroll(s) {
      var a;
      const l = _r();
      if (
        (Vs(l, s), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
      )
        return l;
      for (let c = 0; c < this.path.length; c++) {
        const d = this.path[c],
          { scroll: p, options: m } = d;
        d !== this.root &&
          p &&
          m.layoutScroll &&
          (p.wasRoot && Vs(l, s), th(l.x, p.offset.x), th(l.y, p.offset.y));
      }
      return l;
    }
    applyTransform(s, a = !1) {
      const l = _r();
      Vs(l, s);
      for (let c = 0; c < this.path.length; c++) {
        const d = this.path[c];
        !a &&
          d.options.layoutScroll &&
          d.scroll &&
          d !== d.root &&
          nh(l, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }),
          cc(d.latestValues) && nh(l, d.latestValues);
      }
      return cc(this.latestValues) && nh(l, this.latestValues), l;
    }
    removeTransform(s) {
      const a = _r();
      Vs(a, s);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !cc(c.latestValues)) continue;
        uv(c.latestValues) && c.updateSnapshot();
        const d = _r(),
          p = c.measurePageBox();
        Vs(d, p),
          bb(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, d);
      }
      return cc(this.latestValues) && bb(a, this.latestValues), a;
    }
    setTargetDelta(s) {
      (this.targetDelta = s),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== zr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (
        !(
          s ||
          (c && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: d, layoutId: p } = this.options;
      if (!(!this.layout || !(d || p))) {
        if (
          ((this.resolvedRelativeTargetAt = zr.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const m = this.getClosestProjectingParent();
          m && m.layout && this.animationProgress !== 1
            ? ((this.relativeParent = m),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = _r()),
              (this.relativeTargetOrigin = _r()),
              op(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                m.layout.layoutBox,
              ),
              Vs(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = _r()), (this.targetWithTransforms = _r())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                CC(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target,
                ))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : Vs(this.target, this.layout.layoutBox),
                  yM(this.target, this.targetDelta))
                : Vs(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const m = this.getClosestProjectingParent();
            m &&
            !!m.resumingFrom == !!this.resumingFrom &&
            !m.options.layoutScroll &&
            m.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = m),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = _r()),
                (this.relativeTargetOrigin = _r()),
                op(this.relativeTargetOrigin, this.target, m.target),
                Vs(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          Kf && dc.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          uv(this.parent.latestValues) ||
          gM(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var s;
      const a = this.getLead(),
        l = !!this.resumingFrom || this !== a;
      let c = !0;
      if (
        ((this.isProjectionDirty ||
          (!((s = this.parent) === null || s === void 0) &&
            s.isProjectionDirty)) &&
          (c = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (c = !1),
        this.resolvedRelativeTargetAt === zr.timestamp && (c = !1),
        c)
      )
        return;
      const { layout: d, layoutId: p } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(d || p))
      )
        return;
      Vs(this.layoutCorrected, this.layout.layoutBox);
      const m = this.treeScale.x,
        y = this.treeScale.y;
      NC(this.layoutCorrected, this.treeScale, this.path, l),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((a.target = a.layout.layoutBox), (a.targetWithTransforms = _r()));
      const { target: v } = a;
      if (!v) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (yb(this.prevProjectionDelta.x, this.projectionDelta.x),
          yb(this.prevProjectionDelta.y, this.projectionDelta.y)),
        ap(this.projectionDelta, this.layoutCorrected, v, this.latestValues),
        (this.treeScale.x !== m ||
          this.treeScale.y !== y ||
          !Sb(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !Sb(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", v)),
        Kf && dc.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      var a;
      if (
        ((a = this.options.visualElement) === null ||
          a === void 0 ||
          a.scheduleRender(),
        s)
      ) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      (this.prevProjectionDelta = eh()),
        (this.projectionDelta = eh()),
        (this.projectionDeltaWithTransform = eh());
    }
    setAnimationOrigin(s, a = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        d = { ...this.latestValues },
        p = eh();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a);
      const m = _r(),
        y = l ? l.source : void 0,
        v = this.layout ? this.layout.source : void 0,
        A = y !== v,
        M = this.getStack(),
        w = !M || M.members.length <= 1,
        x = !!(A && !w && this.options.crossfade === !0 && !this.path.some(wT));
      this.animationProgress = 0;
      let C;
      (this.mixTargetDelta = (T) => {
        const I = T / 1e3;
        Rb(p.x, s.x, I),
          Rb(p.y, s.y, I),
          this.setTargetDelta(p),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (op(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            AT(this.relativeTarget, this.relativeTargetOrigin, m, I),
            C && aT(this.relativeTarget, C) && (this.isProjectionDirty = !1),
            C || (C = _r()),
            Vs(C, this.relativeTarget)),
          A &&
            ((this.animationValues = d), eT(d, c, this.latestValues, I, x, w)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = I);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Sa(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Pn.update(() => {
          (f0.hasAnimatedSinceResize = !0),
            (this.currentAnimation = YC(0, Eb, {
              ...s,
              onUpdate: (a) => {
                this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a);
              },
              onComplete: () => {
                s.onComplete && s.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const s = this.getStack();
      s && s.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(Eb),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let {
        targetWithTransforms: a,
        target: l,
        layout: c,
        latestValues: d,
      } = s;
      if (!(!a || !l || !c)) {
        if (
          this !== s &&
          this.layout &&
          c &&
          TM(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || _r();
          const p = Ss(this.layout.layoutBox.x);
          (l.x.min = s.target.x.min), (l.x.max = l.x.min + p);
          const m = Ss(this.layout.layoutBox.y);
          (l.y.min = s.target.y.min), (l.y.max = l.y.min + m);
        }
        Vs(a, l),
          nh(a, d),
          ap(this.projectionDeltaWithTransform, this.layoutCorrected, a, d);
      }
    }
    registerSharedNode(s, a) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new oT()),
        this.sharedNodes.get(s).add(a);
      const l = a.options.initialPromotionConfig;
      a.promote({
        transition: l ? l.transition : void 0,
        preserveFollowOpacity:
          l && l.shouldPreserveFollowOpacity
            ? l.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      var s;
      const { layoutId: a } = this.options;
      return a
        ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var s;
      const { layoutId: a } = this.options;
      return a
        ? (s = this.getStack()) === null || s === void 0
          ? void 0
          : s.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s) return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l),
        s && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options;
      if (!s) return;
      let a = !1;
      const { latestValues: l } = s;
      if (
        ((l.z ||
          l.rotate ||
          l.rotateX ||
          l.rotateY ||
          l.rotateZ ||
          l.skewX ||
          l.skewY) &&
          (a = !0),
        !a)
      )
        return;
      const c = {};
      l.z && H2("z", s, c, this.animationValues);
      for (let d = 0; d < z2.length; d++)
        H2(`rotate${z2[d]}`, s, c, this.animationValues),
          H2(`skew${z2[d]}`, s, c, this.animationValues);
      s.render();
      for (const d in c)
        s.setStaticValue(d, c[d]),
          this.animationValues && (this.animationValues[d] = c[d]);
      s.scheduleRender();
    }
    getProjectionStyles(s) {
      var a, l;
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) return uT;
      const c = { visibility: "" },
        d = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (c.opacity = ""),
          (c.pointerEvents = p0(s == null ? void 0 : s.pointerEvents) || ""),
          (c.transform = d ? d(this.latestValues, "") : "none"),
          c
        );
      const p = this.getLead();
      if (!this.projectionDelta || !this.layout || !p.target) {
        const A = {};
        return (
          this.options.layoutId &&
            ((A.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (A.pointerEvents = p0(s == null ? void 0 : s.pointerEvents) || "")),
          this.hasProjected &&
            !cc(this.latestValues) &&
            ((A.transform = d ? d({}, "") : "none"), (this.hasProjected = !1)),
          A
        );
      }
      const m = p.animationValues || p.latestValues;
      this.applyTransformsToTarget(),
        (c.transform = lT(
          this.projectionDeltaWithTransform,
          this.treeScale,
          m,
        )),
        d && (c.transform = d(m, c.transform));
      const { x: y, y: v } = this.projectionDelta;
      (c.transformOrigin = `${y.origin * 100}% ${v.origin * 100}% 0`),
        p.animationValues
          ? (c.opacity =
              p === this
                ? (l =
                    (a = m.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : m.opacityExit)
          : (c.opacity =
              p === this
                ? m.opacity !== void 0
                  ? m.opacity
                  : ""
                : m.opacityExit !== void 0
                  ? m.opacityExit
                  : 0);
      for (const A in S0) {
        if (m[A] === void 0) continue;
        const { correct: M, applyTo: w } = S0[A],
          x = c.transform === "none" ? m[A] : M(m[A], p);
        if (w) {
          const C = w.length;
          for (let T = 0; T < C; T++) c[w[T]] = x;
        } else c[A] = x;
      }
      return (
        this.options.layoutId &&
          (c.pointerEvents =
            p === this
              ? p0(s == null ? void 0 : s.pointerEvents) || ""
              : "none"),
        c
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((s) => {
        var a;
        return (a = s.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop();
      }),
        this.root.nodes.forEach(Cb),
        this.root.sharedNodes.clear();
    }
  };
}
function dT(r) {
  r.updateLayout();
}
function hT(r) {
  var e;
  const t =
    ((e = r.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    r.snapshot;
  if (r.isLead() && r.layout && t && r.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: i } = r.layout,
      { animationType: s } = r.options,
      a = t.source !== r.layout.source;
    s === "size"
      ? js((m) => {
          const y = a ? t.measuredBox[m] : t.layoutBox[m],
            v = Ss(y);
          (y.min = n[m].min), (y.max = y.min + v);
        })
      : TM(s, t.layoutBox, n) &&
        js((m) => {
          const y = a ? t.measuredBox[m] : t.layoutBox[m],
            v = Ss(n[m]);
          (y.max = y.min + v),
            r.relativeTarget &&
              !r.currentAnimation &&
              ((r.isProjectionDirty = !0),
              (r.relativeTarget[m].max = r.relativeTarget[m].min + v));
        });
    const l = eh();
    ap(l, n, t.layoutBox);
    const c = eh();
    a ? ap(c, r.applyTransform(i, !0), t.measuredBox) : ap(c, n, t.layoutBox);
    const d = !MM(l);
    let p = !1;
    if (!r.resumeFrom) {
      const m = r.getClosestProjectingParent();
      if (m && !m.resumeFrom) {
        const { snapshot: y, layout: v } = m;
        if (y && v) {
          const A = _r();
          op(A, t.layoutBox, y.layoutBox);
          const M = _r();
          op(M, n, v.layoutBox),
            SM(A, M) || (p = !0),
            m.options.layoutRoot &&
              ((r.relativeTarget = M),
              (r.relativeTargetOrigin = A),
              (r.relativeParent = m));
        }
      }
    }
    r.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: c,
      layoutDelta: l,
      hasLayoutChanged: d,
      hasRelativeTargetChanged: p,
    });
  } else if (r.isLead()) {
    const { onExitComplete: n } = r.options;
    n && n();
  }
  r.options.transition = void 0;
}
function fT(r) {
  Kf && dc.totalNodes++,
    r.parent &&
      (r.isProjecting() || (r.isProjectionDirty = r.parent.isProjectionDirty),
      r.isSharedProjectionDirty ||
        (r.isSharedProjectionDirty = !!(
          r.isProjectionDirty ||
          r.parent.isProjectionDirty ||
          r.parent.isSharedProjectionDirty
        )),
      r.isTransformDirty || (r.isTransformDirty = r.parent.isTransformDirty));
}
function pT(r) {
  r.isProjectionDirty = r.isSharedProjectionDirty = r.isTransformDirty = !1;
}
function mT(r) {
  r.clearSnapshot();
}
function Cb(r) {
  r.clearMeasurements();
}
function gT(r) {
  r.isLayoutDirty = !1;
}
function yT(r) {
  const { visualElement: e } = r.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    r.resetTransform();
}
function Tb(r) {
  r.finishAnimation(),
    (r.targetDelta = r.relativeTarget = r.target = void 0),
    (r.isProjectionDirty = !0);
}
function vT(r) {
  r.resolveTargetDelta();
}
function xT(r) {
  r.calcProjection();
}
function bT(r) {
  r.resetSkewAndRotation();
}
function _T(r) {
  r.removeLeadSnapshot();
}
function Rb(r, e, t) {
  (r.translate = ir(e.translate, 0, t)),
    (r.scale = ir(e.scale, 1, t)),
    (r.origin = e.origin),
    (r.originPoint = e.originPoint);
}
function Ib(r, e, t, n) {
  (r.min = ir(e.min, t.min, n)), (r.max = ir(e.max, t.max, n));
}
function AT(r, e, t, n) {
  Ib(r.x, e.x, t.x, n), Ib(r.y, e.y, t.y, n);
}
function wT(r) {
  return r.animationValues && r.animationValues.opacityExit !== void 0;
}
const MT = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  Bb = (r) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(r),
  Pb = Bb("applewebkit/") && !Bb("chrome/") ? Math.round : Xi;
function Lb(r) {
  (r.min = Pb(r.min)), (r.max = Pb(r.max));
}
function ST(r) {
  Lb(r.x), Lb(r.y);
}
function TM(r, e, t) {
  return (
    r === "position" || (r === "preserve-aspect" && !EC(Mb(e), Mb(t), 0.2))
  );
}
function ET(r) {
  var e;
  return (
    r !== r.root &&
    ((e = r.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
  );
}
const CT = CM({
    attachResizeListener: (r, e) => Mp(r, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  V2 = { current: void 0 },
  RM = CM({
    measureScroll: (r) => ({ x: r.scrollLeft, y: r.scrollTop }),
    defaultParent: () => {
      if (!V2.current) {
        const r = new CT({});
        r.mount(window), r.setOptions({ layoutScroll: !0 }), (V2.current = r);
      }
      return V2.current;
    },
    resetTransform: (r, e) => {
      r.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (r) => window.getComputedStyle(r).position === "fixed",
  }),
  TT = {
    pan: { Feature: VC },
    drag: { Feature: HC, ProjectionNode: RM, MeasureLayout: _M },
  };
function Db(r, e, t) {
  const { props: n } = r;
  r.animationState &&
    n.whileHover &&
    r.animationState.setActive("whileHover", t === "Start");
  const i = "onHover" + t,
    s = n[i];
  s && Pn.postRender(() => s(e, Xp(e)));
}
class RT extends Yl {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = m8(
        e,
        (t) => (Db(this.node, t, "Start"), (n) => Db(this.node, n, "End")),
      ));
  }
  unmount() {}
}
class IT extends Yl {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = Wp(
      Mp(this.node.current, "focus", () => this.onFocus()),
      Mp(this.node.current, "blur", () => this.onBlur()),
    );
  }
  unmount() {}
}
function Fb(r, e, t) {
  const { props: n } = r;
  r.animationState &&
    n.whileTap &&
    r.animationState.setActive("whileTap", t === "Start");
  const i = "onTap" + (t === "End" ? "" : t),
    s = n[i];
  s && Pn.postRender(() => s(e, Xp(e)));
}
class BT extends Yl {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = x8(
        e,
        (t) => (
          Fb(this.node, t, "Start"),
          (n, { success: i }) => Fb(this.node, n, i ? "End" : "Cancel")
        ),
        { useGlobalTarget: this.node.props.globalTapTarget },
      ));
  }
  unmount() {}
}
const dv = new WeakMap(),
  G2 = new WeakMap(),
  PT = (r) => {
    const e = dv.get(r.target);
    e && e(r);
  },
  LT = (r) => {
    r.forEach(PT);
  };
function DT({ root: r, ...e }) {
  const t = r || document;
  G2.has(t) || G2.set(t, {});
  const n = G2.get(t),
    i = JSON.stringify(e);
  return n[i] || (n[i] = new IntersectionObserver(LT, { root: r, ...e })), n[i];
}
function FT(r, e, t) {
  const n = DT(e);
  return (
    dv.set(r, t),
    n.observe(r),
    () => {
      dv.delete(r), n.unobserve(r);
    }
  );
}
const NT = { some: 0, all: 1 };
class UT extends Yl {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: n, amount: i = "some", once: s } = e,
      a = {
        root: t ? t.current : void 0,
        rootMargin: n,
        threshold: typeof i == "number" ? i : NT[i],
      },
      l = (c) => {
        const { isIntersecting: d } = c;
        if (
          this.isInView === d ||
          ((this.isInView = d), s && !d && this.hasEnteredView)
        )
          return;
        d && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", d);
        const { onViewportEnter: p, onViewportLeave: m } = this.node.getProps(),
          y = d ? p : m;
        y && y(c);
      };
    return FT(this.node.current, a, l);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(OT(e, t)) && this.startObserver();
  }
  unmount() {}
}
function OT({ viewport: r = {} }, { viewport: e = {} } = {}) {
  return (t) => r[t] !== e[t];
}
const kT = {
    inView: { Feature: UT },
    tap: { Feature: BT },
    focus: { Feature: IT },
    hover: { Feature: RT },
  },
  zT = { layout: { ProjectionNode: RM, MeasureLayout: _M } },
  Jp = he.createContext({
    transformPagePoint: (r) => r,
    isStatic: !1,
    reducedMotion: "never",
  }),
  wg = he.createContext({}),
  m3 = typeof window < "u",
  Yp = m3 ? he.useLayoutEffect : he.useEffect,
  IM = he.createContext({ strict: !1 });
function HT(r, e, t, n, i) {
  var s, a;
  const { visualElement: l } = he.useContext(wg),
    c = he.useContext(IM),
    d = he.useContext(Ag),
    p = he.useContext(Jp).reducedMotion,
    m = he.useRef(null);
  (n = n || c.renderer),
    !m.current &&
      n &&
      (m.current = n(r, {
        visualState: e,
        parent: l,
        props: t,
        presenceContext: d,
        blockInitialAnimation: d ? d.initial === !1 : !1,
        reducedMotionConfig: p,
      }));
  const y = m.current,
    v = he.useContext(bM);
  y &&
    !y.projection &&
    i &&
    (y.type === "html" || y.type === "svg") &&
    VT(m.current, t, i, v);
  const A = he.useRef(!1);
  he.useInsertionEffect(() => {
    y && A.current && y.update(t, d);
  });
  const M = t[Rw],
    w = he.useRef(
      !!M &&
        !(
          !((s = window.MotionHandoffIsComplete) === null || s === void 0) &&
          s.call(window, M)
        ) &&
        ((a = window.MotionHasOptimisedAnimation) === null || a === void 0
          ? void 0
          : a.call(window, M)),
    );
  return (
    Yp(() => {
      y &&
        ((A.current = !0),
        (window.MotionIsMounted = !0),
        y.updateFeatures(),
        p3.render(y.render),
        w.current && y.animationState && y.animationState.animateChanges());
    }),
    he.useEffect(() => {
      y &&
        (!w.current && y.animationState && y.animationState.animateChanges(),
        w.current &&
          (queueMicrotask(() => {
            var x;
            (x = window.MotionHandoffMarkAsComplete) === null ||
              x === void 0 ||
              x.call(window, M);
          }),
          (w.current = !1)));
    }),
    y
  );
}
function VT(r, e, t, n) {
  const {
    layoutId: i,
    layout: s,
    drag: a,
    dragConstraints: l,
    layoutScroll: c,
    layoutRoot: d,
  } = e;
  (r.projection = new t(
    r.latestValues,
    e["data-framer-portal-id"] ? void 0 : BM(r.parent),
  )),
    r.projection.setOptions({
      layoutId: i,
      layout: s,
      alwaysMeasureLayout: !!a || (l && $d(l)),
      visualElement: r,
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: n,
      layoutScroll: c,
      layoutRoot: d,
    });
}
function BM(r) {
  if (r) return r.options.allowProjection !== !1 ? r.projection : BM(r.parent);
}
function GT(r, e, t) {
  return he.useCallback(
    (n) => {
      n && r.mount && r.mount(n),
        e && (n ? e.mount(n) : e.unmount()),
        t && (typeof t == "function" ? t(n) : $d(t) && (t.current = n));
    },
    [e],
  );
}
function Mg(r) {
  return vg(r.animate) || Wv.some((e) => _p(r[e]));
}
function PM(r) {
  return !!(Mg(r) || r.variants);
}
function jT(r, e) {
  if (Mg(r)) {
    const { initial: t, animate: n } = r;
    return {
      initial: t === !1 || _p(t) ? t : void 0,
      animate: _p(n) ? n : void 0,
    };
  }
  return r.inherit !== !1 ? e : {};
}
function WT(r) {
  const { initial: e, animate: t } = jT(r, he.useContext(wg));
  return he.useMemo(() => ({ initial: e, animate: t }), [Nb(e), Nb(t)]);
}
function Nb(r) {
  return Array.isArray(r) ? r.join(" ") : r;
}
const Ub = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  dh = {};
for (const r in Ub) dh[r] = { isEnabled: (e) => Ub[r].some((t) => !!e[t]) };
function XT(r) {
  for (const e in r) dh[e] = { ...dh[e], ...r[e] };
}
const JT = Symbol.for("motionComponentSymbol");
function YT({
  preloadedFeatures: r,
  createVisualElement: e,
  useRender: t,
  useVisualState: n,
  Component: i,
}) {
  r && XT(r);
  function s(l, c) {
    let d;
    const p = { ...he.useContext(Jp), ...l, layoutId: ZT(l) },
      { isStatic: m } = p,
      y = WT(l),
      v = n(l, m);
    if (!m && m3) {
      qT();
      const A = KT(p);
      (d = A.MeasureLayout),
        (y.visualElement = HT(i, v, p, e, A.ProjectionNode));
    }
    return H.jsxs(wg.Provider, {
      value: y,
      children: [
        d && y.visualElement
          ? H.jsx(d, { visualElement: y.visualElement, ...p })
          : null,
        t(i, l, GT(v, y.visualElement, c), v, m, y.visualElement),
      ],
    });
  }
  const a = he.forwardRef(s);
  return (a[JT] = i), a;
}
function ZT({ layoutId: r }) {
  const e = he.useContext(f3).id;
  return e && r !== void 0 ? e + "-" + r : r;
}
function qT(r, e) {
  he.useContext(IM).strict;
}
function KT(r) {
  const { drag: e, layout: t } = dh;
  if (!e && !t) return {};
  const n = { ...e, ...t };
  return {
    MeasureLayout:
      (e != null && e.isEnabled(r)) || (t != null && t.isEnabled(r))
        ? n.MeasureLayout
        : void 0,
    ProjectionNode: n.ProjectionNode,
  };
}
const QT = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function g3(r) {
  return typeof r != "string" || r.includes("-")
    ? !1
    : !!(QT.indexOf(r) > -1 || /[A-Z]/u.test(r));
}
function LM(r, { style: e, vars: t }, n, i) {
  Object.assign(r.style, e, i && i.getProjectionStyles(n));
  for (const s in t) r.style.setProperty(s, t[s]);
}
const DM = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function FM(r, e, t, n) {
  LM(r, e, void 0, n);
  for (const i in e.attrs) r.setAttribute(DM.has(i) ? i : t3(i), e.attrs[i]);
}
function NM(r, { layout: e, layoutId: t }) {
  return (
    Hc.has(r) ||
    r.startsWith("origin") ||
    ((e || t !== void 0) && (!!S0[r] || r === "opacity"))
  );
}
function y3(r, e, t) {
  var n;
  const { style: i } = r,
    s = {};
  for (const a in i)
    (Lr(i[a]) ||
      (e.style && Lr(e.style[a])) ||
      NM(a, r) ||
      ((n = t == null ? void 0 : t.getValue(a)) === null || n === void 0
        ? void 0
        : n.liveStyle) !== void 0) &&
      (s[a] = i[a]);
  return s;
}
function UM(r, e, t) {
  const n = y3(r, e, t);
  for (const i in r)
    if (Lr(r[i]) || Lr(e[i])) {
      const s =
        Vp.indexOf(i) !== -1
          ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
          : i;
      n[s] = r[i];
    }
  return n;
}
function wh(r) {
  const e = he.useRef(null);
  return e.current === null && (e.current = r()), e.current;
}
function $T(
  { scrapeMotionValuesFromProps: r, createRenderState: e, onMount: t },
  n,
  i,
  s,
) {
  const a = { latestValues: e7(n, i, s, r), renderState: e() };
  return t && (a.mount = (l) => t(n, l, a)), a;
}
const OM = (r) => (e, t) => {
  const n = he.useContext(wg),
    i = he.useContext(Ag),
    s = () => $T(r, e, n, i);
  return t ? s() : wh(s);
};
function e7(r, e, t, n) {
  const i = {},
    s = n(r, {});
  for (const y in s) i[y] = p0(s[y]);
  let { initial: a, animate: l } = r;
  const c = Mg(r),
    d = PM(r);
  e &&
    d &&
    !c &&
    r.inherit !== !1 &&
    (a === void 0 && (a = e.initial), l === void 0 && (l = e.animate));
  let p = t ? t.initial === !1 : !1;
  p = p || a === !1;
  const m = p ? l : a;
  if (m && typeof m != "boolean" && !vg(m)) {
    const y = Array.isArray(m) ? m : [m];
    for (let v = 0; v < y.length; v++) {
      const A = Gv(r, y[v]);
      if (A) {
        const { transitionEnd: M, transition: w, ...x } = A;
        for (const C in x) {
          let T = x[C];
          if (Array.isArray(T)) {
            const I = p ? T.length - 1 : 0;
            T = T[I];
          }
          T !== null && (i[C] = T);
        }
        for (const C in M) i[C] = M[C];
      }
    }
  }
  return i;
}
const v3 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }),
  kM = () => ({ ...v3(), attrs: {} }),
  zM = (r, e) => (e && typeof r == "number" ? e.transform(r) : r),
  t7 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  n7 = Vp.length;
function r7(r, e, t) {
  let n = "",
    i = !0;
  for (let s = 0; s < n7; s++) {
    const a = Vp[s],
      l = r[a];
    if (l === void 0) continue;
    let c = !0;
    if (
      (typeof l == "number"
        ? (c = l === (a.startsWith("scale") ? 1 : 0))
        : (c = parseFloat(l) === 0),
      !c || t)
    ) {
      const d = zM(l, l3[a]);
      if (!c) {
        i = !1;
        const p = t7[a] || a;
        n += `${p}(${d}) `;
      }
      t && (e[a] = d);
    }
  }
  return (n = n.trim()), t ? (n = t(e, i ? "" : n)) : i && (n = "none"), n;
}
function x3(r, e, t) {
  const { style: n, vars: i, transformOrigin: s } = r;
  let a = !1,
    l = !1;
  for (const c in e) {
    const d = e[c];
    if (Hc.has(c)) {
      a = !0;
      continue;
    } else if (Vw(c)) {
      i[c] = d;
      continue;
    } else {
      const p = zM(d, l3[c]);
      c.startsWith("origin") ? ((l = !0), (s[c] = p)) : (n[c] = p);
    }
  }
  if (
    (e.transform ||
      (a || t
        ? (n.transform = r7(e, r.transform, t))
        : n.transform && (n.transform = "none")),
    l)
  ) {
    const { originX: c = "50%", originY: d = "50%", originZ: p = 0 } = s;
    n.transformOrigin = `${c} ${d} ${p}`;
  }
}
function Ob(r, e, t) {
  return typeof r == "string" ? r : Xt.transform(e + t * r);
}
function i7(r, e, t) {
  const n = Ob(e, r.x, r.width),
    i = Ob(t, r.y, r.height);
  return `${n} ${i}`;
}
const s7 = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  a7 = { offset: "strokeDashoffset", array: "strokeDasharray" };
function o7(r, e, t = 1, n = 0, i = !0) {
  r.pathLength = 1;
  const s = i ? s7 : a7;
  r[s.offset] = Xt.transform(-n);
  const a = Xt.transform(e),
    l = Xt.transform(t);
  r[s.array] = `${a} ${l}`;
}
function b3(
  r,
  {
    attrX: e,
    attrY: t,
    attrScale: n,
    originX: i,
    originY: s,
    pathLength: a,
    pathSpacing: l = 1,
    pathOffset: c = 0,
    ...d
  },
  p,
  m,
) {
  if ((x3(r, d, m), p)) {
    r.style.viewBox && (r.attrs.viewBox = r.style.viewBox);
    return;
  }
  (r.attrs = r.style), (r.style = {});
  const { attrs: y, style: v, dimensions: A } = r;
  y.transform && (A && (v.transform = y.transform), delete y.transform),
    A &&
      (i !== void 0 || s !== void 0 || v.transform) &&
      (v.transformOrigin = i7(
        A,
        i !== void 0 ? i : 0.5,
        s !== void 0 ? s : 0.5,
      )),
    e !== void 0 && (y.x = e),
    t !== void 0 && (y.y = t),
    n !== void 0 && (y.scale = n),
    a !== void 0 && o7(y, a, l, c, !1);
}
const _3 = (r) => typeof r == "string" && r.toLowerCase() === "svg",
  l7 = {
    useVisualState: OM({
      scrapeMotionValuesFromProps: UM,
      createRenderState: kM,
      onMount: (r, e, { renderState: t, latestValues: n }) => {
        Pn.read(() => {
          try {
            t.dimensions =
              typeof e.getBBox == "function"
                ? e.getBBox()
                : e.getBoundingClientRect();
          } catch {
            t.dimensions = { x: 0, y: 0, width: 0, height: 0 };
          }
        }),
          Pn.render(() => {
            b3(t, n, _3(e.tagName), r.transformTemplate), FM(e, t);
          });
      },
    }),
  },
  u7 = {
    useVisualState: OM({
      scrapeMotionValuesFromProps: y3,
      createRenderState: v3,
    }),
  };
function HM(r, e, t) {
  for (const n in e) !Lr(e[n]) && !NM(n, t) && (r[n] = e[n]);
}
function c7({ transformTemplate: r }, e) {
  return he.useMemo(() => {
    const t = v3();
    return x3(t, e, r), Object.assign({}, t.vars, t.style);
  }, [e]);
}
function d7(r, e) {
  const t = r.style || {},
    n = {};
  return HM(n, t, r), Object.assign(n, c7(r, e)), n;
}
function h7(r, e) {
  const t = {},
    n = d7(r, e);
  return (
    r.drag &&
      r.dragListener !== !1 &&
      ((t.draggable = !1),
      (n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none"),
      (n.touchAction =
        r.drag === !0 ? "none" : `pan-${r.drag === "x" ? "y" : "x"}`)),
    r.tabIndex === void 0 &&
      (r.onTap || r.onTapStart || r.whileTap) &&
      (t.tabIndex = 0),
    (t.style = n),
    t
  );
}
const f7 = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function E0(r) {
  return (
    r.startsWith("while") ||
    (r.startsWith("drag") && r !== "draggable") ||
    r.startsWith("layout") ||
    r.startsWith("onTap") ||
    r.startsWith("onPan") ||
    r.startsWith("onLayout") ||
    f7.has(r)
  );
}
let VM = (r) => !E0(r);
function p7(r) {
  r && (VM = (e) => (e.startsWith("on") ? !E0(e) : r(e)));
}
try {
  p7(require("@emotion/is-prop-valid").default);
} catch {}
function m7(r, e, t) {
  const n = {};
  for (const i in r)
    (i === "values" && typeof r.values == "object") ||
      ((VM(i) ||
        (t === !0 && E0(i)) ||
        (!e && !E0(i)) ||
        (r.draggable && i.startsWith("onDrag"))) &&
        (n[i] = r[i]));
  return n;
}
function g7(r, e, t, n) {
  const i = he.useMemo(() => {
    const s = kM();
    return (
      b3(s, e, _3(n), r.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (r.style) {
    const s = {};
    HM(s, r.style, r), (i.style = { ...s, ...i.style });
  }
  return i;
}
function y7(r = !1) {
  return (e, t, n, { latestValues: i }, s) => {
    const a = (g3(e) ? g7 : h7)(t, i, s, e),
      l = m7(t, typeof e == "string", r),
      c = e !== he.Fragment ? { ...l, ...a, ref: n } : {},
      { children: d } = t,
      p = he.useMemo(() => (Lr(d) ? d.get() : d), [d]);
    return he.createElement(e, { ...c, children: p });
  };
}
function v7(r, e) {
  return function (t, { forwardMotionProps: n } = { forwardMotionProps: !1 }) {
    const i = {
      ...(g3(t) ? l7 : u7),
      preloadedFeatures: r,
      useRender: y7(n),
      createVisualElement: e,
      Component: t,
    };
    return YT(i);
  };
}
const hv = { current: null },
  GM = { current: !1 };
function x7() {
  if (((GM.current = !0), !!m3))
    if (window.matchMedia) {
      const r = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (hv.current = r.matches);
      r.addListener(e), e();
    } else hv.current = !1;
}
function b7(r, e, t) {
  for (const n in e) {
    const i = e[n],
      s = t[n];
    if (Lr(i)) r.addValue(n, i);
    else if (Lr(s)) r.addValue(n, qa(i, { owner: r }));
    else if (s !== i)
      if (r.hasValue(n)) {
        const a = r.getValue(n);
        a.liveStyle === !0 ? a.jump(i) : a.hasAnimated || a.set(i);
      } else {
        const a = r.getStaticValue(n);
        r.addValue(n, qa(a !== void 0 ? a : i, { owner: r }));
      }
  }
  for (const n in t) e[n] === void 0 && r.removeValue(n);
  return e;
}
const kb = new WeakMap(),
  _7 = [...Ww, Si, Gl],
  A7 = (r) => _7.find(jw(r)),
  zb = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ];
class w7 {
  scrapeMotionValuesFromProps(e, t, n) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: n,
      reducedMotionConfig: i,
      blockInitialAnimation: s,
      visualState: a,
    },
    l = {},
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = s3),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection,
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const y = Qa.now();
        this.renderScheduledAt < y &&
          ((this.renderScheduledAt = y), Pn.render(this.render, !1, !0));
      });
    const { latestValues: c, renderState: d } = a;
    (this.latestValues = c),
      (this.baseTarget = { ...c }),
      (this.initialValues = t.initial ? { ...c } : {}),
      (this.renderState = d),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = n),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = i),
      (this.options = l),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = Mg(t)),
      (this.isVariantNode = PM(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: p, ...m } = this.scrapeMotionValuesFromProps(
      t,
      {},
      this,
    );
    for (const y in m) {
      const v = m[y];
      c[y] !== void 0 && Lr(v) && v.set(c[y], !1);
    }
  }
  mount(e) {
    (this.current = e),
      kb.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, n) => this.bindToMotionValue(n, t)),
      GM.current || x7(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
            ? !0
            : hv.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    kb.delete(this.current),
      this.projection && this.projection.unmount(),
      Sa(this.notifyUpdate),
      Sa(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) {
      const t = this.features[e];
      t && (t.unmount(), (t.isMounted = !1));
    }
    this.current = null;
  }
  bindToMotionValue(e, t) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const n = Hc.has(e),
      i = t.on("change", (l) => {
        (this.latestValues[e] = l),
          this.props.onUpdate && Pn.preRender(this.notifyUpdate),
          n && this.projection && (this.projection.isTransformDirty = !0);
      }),
      s = t.on("renderRequest", this.scheduleRender);
    let a;
    window.MotionCheckAppearSync &&
      (a = window.MotionCheckAppearSync(this, e, t)),
      this.valueSubscriptions.set(e, () => {
        i(), s(), a && a(), t.owner && t.stop();
      });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in dh) {
      const t = dh[e];
      if (!t) continue;
      const { isEnabled: n, Feature: i } = t;
      if (
        (!this.features[e] &&
          i &&
          n(this.props) &&
          (this.features[e] = new i(this)),
        this.features[e])
      ) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : _r();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let n = 0; n < zb.length; n++) {
      const i = zb[n];
      this.propEventSubscriptions[i] &&
        (this.propEventSubscriptions[i](),
        delete this.propEventSubscriptions[i]);
      const s = "on" + i,
        a = e[s];
      a && (this.propEventSubscriptions[i] = this.on(i, a));
    }
    (this.prevMotionValues = b7(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues,
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    const n = this.values.get(e);
    t !== n &&
      (n && this.removeValue(e),
      this.bindToMotionValue(e, t),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let n = this.values.get(e);
    return (
      n === void 0 &&
        t !== void 0 &&
        ((n = qa(t === null ? void 0 : t, { owner: this })),
        this.addValue(e, n)),
      n
    );
  }
  readValue(e, t) {
    var n;
    let i =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (n = this.getBaseTargetFromProps(this.props, e)) !== null &&
            n !== void 0
          ? n
          : this.readValueFromInstance(this.current, e, this.options);
    return (
      i != null &&
        (typeof i == "string" && (zw(i) || kw(i))
          ? (i = parseFloat(i))
          : !A7(i) && Gl.test(t) && (i = $w(e, t)),
        this.setBaseTarget(e, Lr(i) ? i.get() : i)),
      Lr(i) ? i.get() : i
    );
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const a = Gv(
        this.props,
        n,
        (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom,
      );
      a && (i = a[e]);
    }
    if (n && i !== void 0) return i;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Lr(s)
      ? s
      : this.initialValues[e] !== void 0 && i === void 0
        ? void 0
        : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new $v()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class jM extends w7 {
  constructor() {
    super(...arguments), (this.KeyframeResolver = eM);
  }
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: n }) {
    delete t[e], delete n[e];
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Lr(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
}
function M7(r) {
  return window.getComputedStyle(r);
}
class S7 extends jM {
  constructor() {
    super(...arguments), (this.type = "html"), (this.renderInstance = LM);
  }
  readValueFromInstance(e, t) {
    if (Hc.has(t)) {
      const n = u3(t);
      return (n && n.default) || 0;
    } else {
      const n = M7(e),
        i = (Vw(t) ? n.getPropertyValue(t) : n[t]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return vM(e, t);
  }
  build(e, t, n) {
    x3(e, t, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t, n) {
    return y3(e, t, n);
  }
}
class E7 extends jM {
  constructor() {
    super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = _r);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (Hc.has(t)) {
      const n = u3(t);
      return (n && n.default) || 0;
    }
    return (t = DM.has(t) ? t : t3(t)), e.getAttribute(t);
  }
  scrapeMotionValuesFromProps(e, t, n) {
    return UM(e, t, n);
  }
  build(e, t, n) {
    b3(e, t, this.isSVGTag, n.transformTemplate);
  }
  renderInstance(e, t, n, i) {
    FM(e, t, n, i);
  }
  mount(e) {
    (this.isSVGTag = _3(e.tagName)), super.mount(e);
  }
}
const C7 = (r, e) =>
    g3(r) ? new E7(e) : new S7(e, { allowProjection: r !== he.Fragment }),
  T7 = v7({ ...yC, ...kT, ...TT, ...zT }, C7),
  lt = u8(T7);
class R7 extends he.Component {
  getSnapshotBeforeUpdate(e) {
    const t = this.props.childRef.current;
    if (t && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      (n.height = t.offsetHeight || 0),
        (n.width = t.offsetWidth || 0),
        (n.top = t.offsetTop),
        (n.left = t.offsetLeft);
    }
    return null;
  }
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function I7({ children: r, isPresent: e }) {
  const t = he.useId(),
    n = he.useRef(null),
    i = he.useRef({ width: 0, height: 0, top: 0, left: 0 }),
    { nonce: s } = he.useContext(Jp);
  return (
    he.useInsertionEffect(() => {
      const { width: a, height: l, top: c, left: d } = i.current;
      if (e || !n.current || !a || !l) return;
      n.current.dataset.motionPopId = t;
      const p = document.createElement("style");
      return (
        s && (p.nonce = s),
        document.head.appendChild(p),
        p.sheet &&
          p.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${l}px !important;
            top: ${c}px !important;
            left: ${d}px !important;
          }
        `),
        () => {
          document.head.removeChild(p);
        }
      );
    }, [e]),
    H.jsx(R7, {
      isPresent: e,
      childRef: n,
      sizeRef: i,
      children: he.cloneElement(r, { ref: n }),
    })
  );
}
const B7 = ({
  children: r,
  initial: e,
  isPresent: t,
  onExitComplete: n,
  custom: i,
  presenceAffectsLayout: s,
  mode: a,
}) => {
  const l = wh(P7),
    c = he.useId(),
    d = he.useCallback(
      (m) => {
        l.set(m, !0);
        for (const y of l.values()) if (!y) return;
        n && n();
      },
      [l, n],
    ),
    p = he.useMemo(
      () => ({
        id: c,
        initial: e,
        isPresent: t,
        custom: i,
        onExitComplete: d,
        register: (m) => (l.set(m, !1), () => l.delete(m)),
      }),
      s ? [Math.random(), d] : [t, d],
    );
  return (
    he.useMemo(() => {
      l.forEach((m, y) => l.set(y, !1));
    }, [t]),
    he.useEffect(() => {
      !t && !l.size && n && n();
    }, [t]),
    a === "popLayout" && (r = H.jsx(I7, { isPresent: t, children: r })),
    H.jsx(Ag.Provider, { value: p, children: r })
  );
};
function P7() {
  return new Map();
}
const p1 = (r) => r.key || "";
function Hb(r) {
  const e = [];
  return (
    he.Children.forEach(r, (t) => {
      he.isValidElement(t) && e.push(t);
    }),
    e
  );
}
const fv = ({
  children: r,
  exitBeforeEnter: e,
  custom: t,
  initial: n = !0,
  onExitComplete: i,
  presenceAffectsLayout: s = !0,
  mode: a = "sync",
}) => {
  const l = he.useMemo(() => Hb(r), [r]),
    c = l.map(p1),
    d = he.useRef(!0),
    p = he.useRef(l),
    m = wh(() => new Map()),
    [y, v] = he.useState(l),
    [A, M] = he.useState(l);
  Yp(() => {
    (d.current = !1), (p.current = l);
    for (let C = 0; C < A.length; C++) {
      const T = p1(A[C]);
      c.includes(T) ? m.delete(T) : m.get(T) !== !0 && m.set(T, !1);
    }
  }, [A, c.length, c.join("-")]);
  const w = [];
  if (l !== y) {
    let C = [...l];
    for (let T = 0; T < A.length; T++) {
      const I = A[T],
        U = p1(I);
      c.includes(U) || (C.splice(T, 0, I), w.push(I));
    }
    a === "wait" && w.length && (C = w), M(Hb(C)), v(l);
    return;
  }
  const { forceRender: x } = he.useContext(f3);
  return H.jsx(H.Fragment, {
    children: A.map((C) => {
      const T = p1(C),
        I = l === A || c.includes(T),
        U = () => {
          if (m.has(T)) m.set(T, !0);
          else return;
          let F = !0;
          m.forEach((O) => {
            O || (F = !1);
          }),
            F && (x == null || x(), M(p.current), i && i());
        };
      return H.jsx(
        B7,
        {
          isPresent: I,
          initial: !d.current || n ? void 0 : !1,
          custom: I ? void 0 : t,
          presenceAffectsLayout: s,
          mode: a,
          onExitComplete: I ? void 0 : U,
          children: C,
        },
        T,
      );
    }),
  });
};
function C0(r) {
  const e = wh(() => qa(r)),
    { isStatic: t } = he.useContext(Jp);
  if (t) {
    const [, n] = he.useState(r);
    he.useEffect(() => e.on("change", n), []);
  }
  return e;
}
function A3(r, e) {
  const t = C0(e()),
    n = () => t.set(e());
  return (
    n(),
    Yp(() => {
      const i = () => Pn.preRender(n, !1, !0),
        s = r.map((a) => a.on("change", i));
      return () => {
        s.forEach((a) => a()), Sa(n);
      };
    }),
    t
  );
}
function L7(r, ...e) {
  const t = r.length;
  function n() {
    let i = "";
    for (let s = 0; s < t; s++) {
      i += r[s];
      const a = e[s];
      a && (i += Lr(a) ? a.get() : a);
    }
    return i;
  }
  return A3(e.filter(Lr), n);
}
const D7 = (r) => r && typeof r == "object" && r.mix,
  F7 = (r) => (D7(r) ? r.mix : void 0);
function N7(...r) {
  const e = !Array.isArray(r[0]),
    t = e ? 0 : -1,
    n = r[0 + t],
    i = r[1 + t],
    s = r[2 + t],
    a = r[3 + t],
    l = d3(i, s, { mixer: F7(s[0]), ...a });
  return e ? l(n) : l;
}
function U7(r) {
  (rp.current = []), r();
  const e = A3(rp.current, r);
  return (rp.current = void 0), e;
}
function O7(r, e, t, n) {
  if (typeof r == "function") return U7(r);
  const i = typeof e == "function" ? e : N7(e, t, n);
  return Array.isArray(r) ? Vb(r, i) : Vb([r], ([s]) => i(s));
}
function Vb(r, e) {
  const t = wh(() => []);
  return A3(r, () => {
    t.length = 0;
    const n = r.length;
    for (let i = 0; i < n; i++) t[i] = r[i].get();
    return e(t);
  });
}
function Gb(r) {
  return typeof r == "number" ? r : parseFloat(r);
}
function pv(r, e = {}) {
  const { isStatic: t } = he.useContext(Jp),
    n = he.useRef(null),
    i = C0(Lr(r) ? Gb(r.get()) : r),
    s = he.useRef(i.get()),
    a = he.useRef(() => {}),
    l = () => {
      const d = n.current;
      d && d.time === 0 && d.sample(zr.delta),
        c(),
        (n.current = jE({
          keyframes: [i.get(), s.current],
          velocity: i.getVelocity(),
          type: "spring",
          restDelta: 0.001,
          restSpeed: 0.01,
          ...e,
          onUpdate: a.current,
        }));
    },
    c = () => {
      n.current && n.current.stop();
    };
  return (
    he.useInsertionEffect(
      () =>
        i.attach(
          (d, p) =>
            t
              ? p(d)
              : ((s.current = d), (a.current = p), Pn.update(l), i.get()),
          c,
        ),
      [JSON.stringify(e)],
    ),
    Yp(() => {
      if (Lr(r)) return r.on("change", (d) => i.set(Gb(d)));
    }, [i]),
    i
  );
}
function WM(r, e) {
  let t;
  const n = () => {
    const { currentTime: i } = e,
      s = (i === null ? 0 : i.value) / 100;
    t !== s && r(s), (t = s);
  };
  return Pn.update(n, !0), () => Sa(n);
}
const m0 = new WeakMap();
let Yd;
function k7(r, e) {
  if (e) {
    const { inlineSize: t, blockSize: n } = e[0];
    return { width: t, height: n };
  } else
    return r instanceof SVGElement && "getBBox" in r
      ? r.getBBox()
      : { width: r.offsetWidth, height: r.offsetHeight };
}
function z7({ target: r, contentRect: e, borderBoxSize: t }) {
  var n;
  (n = m0.get(r)) === null ||
    n === void 0 ||
    n.forEach((i) => {
      i({
        target: r,
        contentSize: e,
        get size() {
          return k7(r, t);
        },
      });
    });
}
function H7(r) {
  r.forEach(z7);
}
function V7() {
  typeof ResizeObserver > "u" || (Yd = new ResizeObserver(H7));
}
function G7(r, e) {
  Yd || V7();
  const t = Sw(r);
  return (
    t.forEach((n) => {
      let i = m0.get(n);
      i || ((i = new Set()), m0.set(n, i)),
        i.add(e),
        Yd == null || Yd.observe(n);
    }),
    () => {
      t.forEach((n) => {
        const i = m0.get(n);
        i == null || i.delete(e),
          (i != null && i.size) || Yd == null || Yd.unobserve(n);
      });
    }
  );
}
const g0 = new Set();
let lp;
function j7() {
  (lp = () => {
    const r = { width: window.innerWidth, height: window.innerHeight },
      e = { target: window, size: r, contentSize: r };
    g0.forEach((t) => t(e));
  }),
    window.addEventListener("resize", lp);
}
function W7(r) {
  return (
    g0.add(r),
    lp || j7(),
    () => {
      g0.delete(r), !g0.size && lp && (lp = void 0);
    }
  );
}
function X7(r, e) {
  return typeof r == "function" ? W7(r) : G7(r, e);
}
const J7 = 50,
  jb = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0,
  }),
  Y7 = () => ({ time: 0, x: jb(), y: jb() }),
  Z7 = {
    x: { length: "Width", position: "Left" },
    y: { length: "Height", position: "Top" },
  };
function Wb(r, e, t, n) {
  const i = t[e],
    { length: s, position: a } = Z7[e],
    l = i.current,
    c = t.time;
  (i.current = r[`scroll${a}`]),
    (i.scrollLength = r[`scroll${s}`] - r[`client${s}`]),
    (i.offset.length = 0),
    (i.offset[0] = 0),
    (i.offset[1] = i.scrollLength),
    (i.progress = Bc(0, i.scrollLength, i.current));
  const d = n - c;
  i.velocity = d > J7 ? 0 : e3(i.current - l, d);
}
function q7(r, e, t) {
  Wb(r, "x", e, t), Wb(r, "y", e, t), (e.time = t);
}
function K7(r, e) {
  const t = { x: 0, y: 0 };
  let n = r;
  for (; n && n !== e; )
    if (n instanceof HTMLElement)
      (t.x += n.offsetLeft), (t.y += n.offsetTop), (n = n.offsetParent);
    else if (n.tagName === "svg") {
      const i = n.getBoundingClientRect();
      n = n.parentElement;
      const s = n.getBoundingClientRect();
      (t.x += i.left - s.left), (t.y += i.top - s.top);
    } else if (n instanceof SVGGraphicsElement) {
      const { x: i, y: s } = n.getBBox();
      (t.x += i), (t.y += s);
      let a = null,
        l = n.parentNode;
      for (; !a; ) l.tagName === "svg" && (a = l), (l = n.parentNode);
      n = a;
    } else break;
  return t;
}
const Q7 = {
    Enter: [
      [0, 1],
      [1, 1],
    ],
    Exit: [
      [0, 0],
      [1, 0],
    ],
    Any: [
      [1, 0],
      [0, 1],
    ],
    All: [
      [0, 0],
      [1, 1],
    ],
  },
  mv = { start: 0, center: 0.5, end: 1 };
function Xb(r, e, t = 0) {
  let n = 0;
  if ((r in mv && (r = mv[r]), typeof r == "string")) {
    const i = parseFloat(r);
    r.endsWith("px")
      ? (n = i)
      : r.endsWith("%")
        ? (r = i / 100)
        : r.endsWith("vw")
          ? (n = (i / 100) * document.documentElement.clientWidth)
          : r.endsWith("vh")
            ? (n = (i / 100) * document.documentElement.clientHeight)
            : (r = i);
  }
  return typeof r == "number" && (n = e * r), t + n;
}
const $7 = [0, 0];
function e9(r, e, t, n) {
  let i = Array.isArray(r) ? r : $7,
    s = 0,
    a = 0;
  return (
    typeof r == "number"
      ? (i = [r, r])
      : typeof r == "string" &&
        ((r = r.trim()),
        r.includes(" ") ? (i = r.split(" ")) : (i = [r, mv[r] ? r : "0"])),
    (s = Xb(i[0], t, n)),
    (a = Xb(i[1], e)),
    s - a
  );
}
const t9 = { x: 0, y: 0 };
function n9(r) {
  return "getBBox" in r && r.tagName !== "svg"
    ? r.getBBox()
    : { width: r.clientWidth, height: r.clientHeight };
}
function r9(r, e, t) {
  const { offset: n = Q7.All } = t,
    { target: i = r, axis: s = "y" } = t,
    a = s === "y" ? "height" : "width",
    l = i !== r ? K7(i, r) : t9,
    c = i === r ? { width: r.scrollWidth, height: r.scrollHeight } : n9(i),
    d = { width: r.clientWidth, height: r.clientHeight };
  e[s].offset.length = 0;
  let p = !e[s].interpolate;
  const m = n.length;
  for (let y = 0; y < m; y++) {
    const v = e9(n[y], d[a], c[a], l[s]);
    !p && v !== e[s].interpolatorOffsets[y] && (p = !0), (e[s].offset[y] = v);
  }
  p &&
    ((e[s].interpolate = d3(e[s].offset, oM(n))),
    (e[s].interpolatorOffsets = [...e[s].offset])),
    (e[s].progress = e[s].interpolate(e[s].current));
}
function i9(r, e = r, t) {
  if (((t.x.targetOffset = 0), (t.y.targetOffset = 0), e !== r)) {
    let n = e;
    for (; n && n !== r; )
      (t.x.targetOffset += n.offsetLeft),
        (t.y.targetOffset += n.offsetTop),
        (n = n.offsetParent);
  }
  (t.x.targetLength = e === r ? e.scrollWidth : e.clientWidth),
    (t.y.targetLength = e === r ? e.scrollHeight : e.clientHeight),
    (t.x.containerLength = r.clientWidth),
    (t.y.containerLength = r.clientHeight);
}
function s9(r, e, t, n = {}) {
  return {
    measure: () => i9(r, n.target, t),
    update: (i) => {
      q7(r, t, i), (n.offset || n.target) && r9(r, t, n);
    },
    notify: () => e(t),
  };
}
const Bf = new WeakMap(),
  Jb = new WeakMap(),
  j2 = new WeakMap(),
  Yb = (r) => (r === document.documentElement ? window : r);
function w3(r, { container: e = document.documentElement, ...t } = {}) {
  let n = j2.get(e);
  n || ((n = new Set()), j2.set(e, n));
  const i = Y7(),
    s = s9(e, r, i, t);
  if ((n.add(s), !Bf.has(e))) {
    const l = () => {
        for (const y of n) y.measure();
      },
      c = () => {
        for (const y of n) y.update(zr.timestamp);
      },
      d = () => {
        for (const y of n) y.notify();
      },
      p = () => {
        Pn.read(l, !1, !0), Pn.read(c, !1, !0), Pn.update(d, !1, !0);
      };
    Bf.set(e, p);
    const m = Yb(e);
    window.addEventListener("resize", p, { passive: !0 }),
      e !== document.documentElement && Jb.set(e, X7(e, p)),
      m.addEventListener("scroll", p, { passive: !0 });
  }
  const a = Bf.get(e);
  return (
    Pn.read(a, !1, !0),
    () => {
      var l;
      Sa(a);
      const c = j2.get(e);
      if (!c || (c.delete(s), c.size)) return;
      const d = Bf.get(e);
      Bf.delete(e),
        d &&
          (Yb(e).removeEventListener("scroll", d),
          (l = Jb.get(e)) === null || l === void 0 || l(),
          window.removeEventListener("resize", d));
    }
  );
}
function a9({ source: r, container: e, axis: t = "y" }) {
  r && (e = r);
  const n = { value: 0 },
    i = w3(
      (s) => {
        n.value = s[t].progress * 100;
      },
      { container: e, axis: t },
    );
  return { currentTime: n, cancel: i };
}
const W2 = new Map();
function XM({
  source: r,
  container: e = document.documentElement,
  axis: t = "y",
} = {}) {
  r && (e = r), W2.has(e) || W2.set(e, {});
  const n = W2.get(e);
  return (
    n[t] ||
      (n[t] = xw()
        ? new ScrollTimeline({ source: e, axis: t })
        : a9({ source: e, axis: t })),
    n[t]
  );
}
function o9(r) {
  return r.length === 2;
}
function JM(r) {
  return r && (r.target || r.offset);
}
function l9(r, e) {
  return o9(r) || JM(e)
    ? w3((t) => {
        r(t[e.axis].progress, t);
      }, e)
    : WM(r, XM(e));
}
function u9(r, e) {
  if ((r.flatten(), JM(e)))
    return (
      r.pause(),
      w3((t) => {
        r.time = r.duration * t[e.axis].progress;
      }, e)
    );
  {
    const t = XM(e);
    return r.attachTimeline
      ? r.attachTimeline(
          t,
          (n) => (
            n.pause(),
            WM((i) => {
              n.time = n.duration * i;
            }, t)
          ),
        )
      : Xi;
  }
}
function c9(r, { axis: e = "y", ...t } = {}) {
  const n = { axis: e, ...t };
  return typeof r == "function" ? l9(r, n) : u9(r, n);
}
function Zb(r, e) {
  c8(!!(!e || e.current));
}
const d9 = () => ({
  scrollX: qa(0),
  scrollY: qa(0),
  scrollXProgress: qa(0),
  scrollYProgress: qa(0),
});
function h9({ container: r, target: e, layoutEffect: t = !0, ...n } = {}) {
  const i = wh(d9);
  return (
    (t ? Yp : he.useEffect)(
      () => (
        Zb("target", e),
        Zb("container", r),
        c9(
          (s, { x: a, y: l }) => {
            i.scrollX.set(a.current),
              i.scrollXProgress.set(a.progress),
              i.scrollY.set(l.current),
              i.scrollYProgress.set(l.progress);
          },
          {
            ...n,
            container: (r == null ? void 0 : r.current) || void 0,
            target: (e == null ? void 0 : e.current) || void 0,
          },
        )
      ),
      [r, e, JSON.stringify(n.offset)],
    ),
    i
  );
}
const gv = 25,
  qb = gv / 2;
function f9({ children: r, className: e = "" }) {
  const t = he.useRef(null),
    [n, i] = he.useState(!1),
    [s, a] = he.useState(!1),
    l = C0(0),
    c = C0(0),
    d = pv(l, { stiffness: 300, damping: 30 }),
    p = pv(c, { stiffness: 300, damping: 30 }),
    m = L7`perspective(1000px) rotateX(${d}deg) rotateY(${p}deg)`;
  he.useEffect(() => {
    const x = () => {
      i(window.matchMedia("(max-width: 768px)").matches);
    };
    return (
      x(),
      window.addEventListener("resize", x),
      () => window.removeEventListener("resize", x)
    );
  }, []);
  const y = (x) => {
      if (!t.current || n) return;
      const C = t.current.getBoundingClientRect(),
        T = C.width,
        I = C.height,
        U = (x.clientX - C.left) * gv,
        F = (((x.clientY - C.top) * gv) / I - qb) * -1,
        O = U / T - qb;
      l.set(F), c.set(O);
      const z = t.current.querySelector(".shine");
      if (z) {
        const L = ((x.clientX - C.left) / C.width) * 1e3,
          N = ((x.clientY - C.top) / C.height) * 100;
        z.style.background = `
    radial-gradient(
      circle at ${L}% ${N}%, 
      rgba(255, 255, 255, 1) 0%,
      rgba(236, 192, 120, 1) 25%,
      rgba(216, 177, 72, 1) 50%, 
      rgba(226, 213, 126, 1) 75%,  
      rgba(153, 43, 13, 1) 100%  
    )
      `;
      }
    },
    v = () => {
      var x;
      if (n) return;
      l.set(0), c.set(0);
      const C = (x = t.current) == null ? void 0 : x.querySelector(".shine");
      C && (C.style.background = "none");
    },
    A = () => {
      n && a(!0);
    },
    M = () => {
      n && a(!1);
    },
    w = n
      ? {
          animate: {
            y: [-5, 5, -5],
            rotate: [-1, 1, -1],
            transition: { duration: 6, repeat: 1 / 0, easings: ["easeInOut"] },
          },
          whileTap: { scale: 0.95, y: 5 },
        }
      : {};
  return H.jsxs(lt.div, {
    ref: t,
    className: `relative ${e}`,
    onMouseMove: y,
    onMouseLeave: v,
    onTouchStart: A,
    onTouchEnd: M,
    style: { transformStyle: "preserve-3d", transform: n ? void 0 : m },
    ...w,
    children: [
      H.jsx("div", {
        className: `
          shine absolute inset-0 pointer-events-none rounded-lg
          ${n ? "bg-gradient-to-br from-transparent via-white/10 to-transparent" : ""}
        `,
      }),
      r,
    ],
  });
}
function p9() {
  return H.jsx("div", {
    className: "w-full h-full",
    children: H.jsx(f9, {
      className: "relative w-full h-full md:h-[300px] group",
      children: H.jsxs("div", {
        className: "relative w-full h-full flex items-center justify-center",
        children: [
          H.jsx("div", {
            className:
              "absolute inset-0 bg-gradient-to-br from-purple-500/20 via-transparent to-orange-500/20 opacity-0 group-hover:opacity-100 transition-opacity duration-500 rounded-lg",
          }),
          H.jsx("div", {
            className: "relative w-full h-full aspect-video",
            children: H.jsxs("video", {
              className:
                "absolute inset-0 w-full h-full object-contain rounded-lg transition-transform duration-300 ease-in-out group-hover:scale-[1.02]",
              controls: !0,
              preload: "metadata",
              poster: "/src/components/mshaadi_skit_final.mp4?t=0",
              children: [
                H.jsx("source", {
                  src: "/src/components/mshaadi_skit_final.mp4",
                  type: "video/mp4",
                }),
                "Your browser does not support the video tag.",
              ],
            }),
          }),
        ],
      }),
    }),
  });
}
const m9 = ({ className: r = "", intensity: e = 70 }) => {
    const [t, n] = he.useState("");
    return (
      he.useEffect(() => {
        const i = encodeURIComponent(`
      <svg viewBox="0 0 200 200" xmlns='http://www.w3.org/2000/svg'>
        <filter id='noiseFilter'>
          <feTurbulence 
            type='fractalNoise' 
            baseFrequency='0.50' 
            numOctaves='1' 
            stitchTiles='stitch'/>
          <feColorMatrix type="saturate" values="0.2"/>
        </filter>
        <rect width='100%' height='100%' filter='url(#noiseFilter)'/>
      </svg>
    `);
        n(`url("data:image/svg+xml,${i}")`);
      }, []),
      H.jsx(lt.div, {
        className: `absolute inset-0 mix-blend-overlay opacity-50 ${r}`,
        style: { backgroundImage: t },
        animate: {
          filter: [
            `contrast(${e}%) brightness(800%)`,
            `contrast(${e + 30}%) brightness(1000%)`,
            `contrast(${e}%) brightness(800%)`,
          ],
        },
        transition: { duration: 4, ease: "easeInOut", repeat: 1 / 0 },
      })
    );
  },
  Qf = ({
    children: r,
    className: e = "",
    withNoise: t = !0,
    colorFrom: n = "from-[#992b0d]",
    colorTo: i = "to-[#d8b148]",
  }) =>
    H.jsxs(lt.div, {
      className: `relative overflow-hidden rounded-xl bg-gradient-to-br ${n} ${i} ${e}`,
      whileHover: { scale: 1.02 },
      transition: { type: "spring", stiffness: 300, damping: 20 },
      children: [
        t && H.jsx(m9, {}),
        H.jsx("div", { className: "relative z-10", children: r }),
      ],
    }),
  g9 = () => {
    const r = {
        hidden: { opacity: 0 },
        show: {
          opacity: 1,
          transition: { staggerChildren: 0.15, delayChildren: 0 },
        },
      },
      e = {
        hidden: { y: 20, opacity: 0 },
        show: {
          y: 0,
          opacity: 1,
          transition: { type: "spring", stiffness: 100, damping: 12 },
        },
      };
    return H.jsx("div", {
      className: "relative overflow-hidden -translate-y-5",
      children: H.jsx("div", {
        className: "relative h-full",
        children: H.jsxs(lt.div, {
          initial: "hidden",
          animate: "show",
          whileHover: "hover",
          variants: r,
          className: "h-full w-full relative group rounded-lg",
          children: [
            H.jsx(lt.div, {
              className:
                "absolute inset-0 bg-gradient-to-r from-[#992b0d] via-[#d8b148] to-[#992b0d] opacity-0 group-hover:opacity-100 transition-all duration-500 rounded-lg",
              animate: {
                background: [
                  "radial-gradient(circle at 0% 0%, #992b0d44, #d8b14844, #992b0d44)",
                  "radial-gradient(circle at 100% 100%, #992b0d44, #d8b14844, #992b0d44)",
                  "radial-gradient(circle at 0% 0%, #992b0d44, #d8b14844, #992b0d44)",
                ],
              },
              transition: { duration: 3, repeat: 1 / 0, ease: "linear" },
            }),
            H.jsx(lt.div, {
              className:
                "absolute inset-0 opacity-0 group-hover:opacity-100 bg-gradient-to-r from-transparent via-white/20 to-transparent rounded-lg",
              animate: { x: ["-200%", "200%"] },
              transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" },
            }),
            H.jsx(lt.div, {
              className:
                "absolute inset-0 opacity-0 group-hover:opacity-40 bg-gradient-radial from-[#ecc078]/30 via-transparent to-transparent rounded-lg",
              animate: { scale: [1, 1.2, 1], opacity: [0, 0.4, 0] },
              transition: { duration: 2.5, repeat: 1 / 0, ease: "easeInOut" },
            }),
            H.jsxs("div", {
              className:
                "relative z-10 flex flex-col justify-center items-center p-6 md:p-8",
              children: [
                H.jsx(lt.div, {
                  variants: e,
                  className:
                    "text-4xl sm:text-5xl md:text-6xl font-quattrocento font-black mb-4 md:mb-6 tracking-wide",
                  style: {
                    WebkitTextStroke: "1px #992b0d",
                    textShadow:
                      "3px 3px 0 #992b0d, -1px -1px 0 #992b0d, 1px -1px 0 #992b0d, -1px 1px 0 #992b0d, 1px 1px 0 #992b0d",
                  },
                  children: H.jsx("span", {
                    className:
                      "text-[#ecc078] hover:text-white transition-colors duration-300",
                    children: "SLC Ballroom",
                  }),
                }),
                H.jsx(lt.div, {
                  variants: e,
                  className:
                    "text-3xl font-black sm:text-4xl md:text-5xl font-playfair  mb-3 md:mb-4",
                  style: { WebkitTextStroke: "1px #d8b148" },
                  children: H.jsx("span", {
                    className:
                      "text-white hover:text-[#e2d57e] transition-colors duration-300",
                    children: "January 10th, 2025",
                  }),
                }),
                H.jsxs(lt.div, {
                  variants: e,
                  className:
                    "flex font-black stroke-black items-center gap-3 text-2xl md:text-3xl text-carmine font-quattrocento",
                  children: [
                    H.jsx("span", { className: "text-carmine", children: "✧" }),
                    "7:00 PM",
                    H.jsx("span", { className: "text-carmine", children: "✧" }),
                  ],
                }),
              ],
            }),
            [...Array(10)].map((t, n) =>
              H.jsx(
                lt.div,
                {
                  className:
                    "absolute w-2 h-2 sm:w-2.5 sm:h-2.5 md:w-3 md:h-3 rounded-full",
                  style: {
                    background: n % 2 === 0 ? "#ecc078" : "#e2d57e",
                    filter: "blur(2px)",
                    boxShadow: "0 0 12px rgba(236,192,120,0.5)",
                  },
                  animate: {
                    y: [-20, -40, -20],
                    x: [-10, 10, -10],
                    opacity: [0, 1, 0],
                    scale: [1, 1.3, 1],
                  },
                  transition: {
                    duration: 3,
                    delay: n * 0.4,
                    repeat: 1 / 0,
                    ease: "easeInOut",
                  },
                  initial: { left: `${20 + n * 10}%`, bottom: "15%" },
                },
                n,
              ),
            ),
          ],
        }),
      }),
    });
  };
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Mh = "171",
  y9 = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  v9 = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  YM = 0,
  yv = 1,
  ZM = 2,
  x9 = 3,
  qM = 0,
  Sg = 1,
  up = 2,
  _a = 3,
  ro = 0,
  Ji = 1,
  Xs = 2,
  eo = 0,
  Sc = 1,
  vv = 2,
  xv = 3,
  bv = 4,
  KM = 5,
  Hl = 100,
  QM = 101,
  $M = 102,
  e5 = 103,
  t5 = 104,
  n5 = 200,
  r5 = 201,
  i5 = 202,
  s5 = 203,
  T0 = 204,
  R0 = 205,
  a5 = 206,
  o5 = 207,
  l5 = 208,
  u5 = 209,
  c5 = 210,
  d5 = 211,
  h5 = 212,
  f5 = 213,
  p5 = 214,
  I0 = 0,
  B0 = 1,
  P0 = 2,
  Pc = 3,
  L0 = 4,
  D0 = 5,
  F0 = 6,
  N0 = 7,
  Zp = 0,
  m5 = 1,
  g5 = 2,
  to = 0,
  y5 = 1,
  v5 = 2,
  x5 = 3,
  Eg = 4,
  b5 = 5,
  _5 = 6,
  A5 = 7,
  _v = "attached",
  w5 = "detached",
  jl = 300,
  io = 301,
  Wl = 302,
  hh = 303,
  Sp = 304,
  Sh = 306,
  Xl = 1e3,
  Ar = 1001,
  fh = 1002,
  Qr = 1003,
  Cg = 1004,
  b9 = 1004,
  gc = 1005,
  _9 = 1005,
  Un = 1006,
  ah = 1007,
  A9 = 1007,
  Ys = 1008,
  Av = 1008,
  hs = 1009,
  Tg = 1010,
  Rg = 1011,
  ph = 1012,
  qp = 1013,
  so = 1014,
  or = 1015,
  Kr = 1016,
  Ig = 1017,
  Bg = 1018,
  Lc = 1020,
  M3 = 35902,
  S3 = 1021,
  E3 = 1022,
  wr = 1023,
  C3 = 1024,
  T3 = 1025,
  Ec = 1026,
  Dc = 1027,
  Kp = 1028,
  Qp = 1029,
  R3 = 1030,
  Pg = 1031,
  w9 = 1032,
  Lg = 1033,
  cp = 33776,
  dp = 33777,
  hp = 33778,
  fp = 33779,
  U0 = 35840,
  O0 = 35841,
  k0 = 35842,
  z0 = 35843,
  H0 = 36196,
  V0 = 37492,
  G0 = 37496,
  j0 = 37808,
  W0 = 37809,
  X0 = 37810,
  J0 = 37811,
  Y0 = 37812,
  Z0 = 37813,
  q0 = 37814,
  K0 = 37815,
  Q0 = 37816,
  $0 = 37817,
  eg = 37818,
  tg = 37819,
  ng = 37820,
  rg = 37821,
  pp = 36492,
  ig = 36494,
  sg = 36495,
  I3 = 36283,
  ag = 36284,
  og = 36285,
  lg = 36286,
  M5 = 2200,
  S5 = 2201,
  E5 = 2202,
  mh = 2300,
  gh = 2301,
  y0 = 2302,
  yc = 2400,
  vc = 2401,
  Ep = 2402,
  Dg = 2500,
  B3 = 2501,
  C5 = 0,
  P3 = 1,
  ug = 2,
  T5 = 3200,
  R5 = 3201,
  M9 = 3202,
  S9 = 3203,
  Zl = 0,
  I5 = 1,
  Vo = "",
  Ei = "srgb",
  ao = "srgb-linear",
  Cp = "linear",
  Hn = "srgb",
  E9 = 0,
  hc = 7680,
  C9 = 7681,
  T9 = 7682,
  R9 = 7683,
  I9 = 34055,
  B9 = 34056,
  P9 = 5386,
  L9 = 512,
  D9 = 513,
  F9 = 514,
  N9 = 515,
  U9 = 516,
  O9 = 517,
  k9 = 518,
  wv = 519,
  B5 = 512,
  P5 = 513,
  L5 = 514,
  L3 = 515,
  D5 = 516,
  F5 = 517,
  N5 = 518,
  U5 = 519,
  Tp = 35044,
  z9 = 35048,
  H9 = 35040,
  V9 = 35045,
  G9 = 35049,
  j9 = 35041,
  W9 = 35046,
  X9 = 35050,
  J9 = 35042,
  Y9 = "100",
  Mv = "300 es",
  Ka = 2e3,
  Rp = 2001;
class oo {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const i = n.indexOf(t);
      i !== -1 && n.splice(i, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const t = this._listeners[e.type];
    if (t !== void 0) {
      e.target = this;
      const n = t.slice(0);
      for (let i = 0, s = n.length; i < s; i++) n[i].call(this, e);
      e.target = null;
    }
  }
}
const Ai = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Kb = 1234567;
const Cc = Math.PI / 180,
  yh = 180 / Math.PI;
function Ms() {
  const r = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Ai[r & 255] +
    Ai[(r >> 8) & 255] +
    Ai[(r >> 16) & 255] +
    Ai[(r >> 24) & 255] +
    "-" +
    Ai[e & 255] +
    Ai[(e >> 8) & 255] +
    "-" +
    Ai[((e >> 16) & 15) | 64] +
    Ai[(e >> 24) & 255] +
    "-" +
    Ai[(t & 63) | 128] +
    Ai[(t >> 8) & 255] +
    "-" +
    Ai[(t >> 16) & 255] +
    Ai[(t >> 24) & 255] +
    Ai[n & 255] +
    Ai[(n >> 8) & 255] +
    Ai[(n >> 16) & 255] +
    Ai[(n >> 24) & 255]
  ).toLowerCase();
}
function en(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function D3(r, e) {
  return ((r % e) + e) % e;
}
function Z9(r, e, t, n, i) {
  return n + ((r - e) * (i - n)) / (t - e);
}
function q9(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function mp(r, e, t) {
  return (1 - t) * r + t * e;
}
function K9(r, e, t, n) {
  return mp(r, e, 1 - Math.exp(-t * n));
}
function Q9(r, e = 1) {
  return e - Math.abs(D3(r, e * 2) - e);
}
function $9(r, e, t) {
  return r <= e
    ? 0
    : r >= t
      ? 1
      : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function eR(r, e, t) {
  return r <= e
    ? 0
    : r >= t
      ? 1
      : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function tR(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function nR(r, e) {
  return r + Math.random() * (e - r);
}
function rR(r) {
  return r * (0.5 - Math.random());
}
function iR(r) {
  r !== void 0 && (Kb = r);
  let e = (Kb += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function sR(r) {
  return r * Cc;
}
function aR(r) {
  return r * yh;
}
function oR(r) {
  return (r & (r - 1)) === 0 && r !== 0;
}
function lR(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function uR(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function cR(r, e, t, n, i) {
  const s = Math.cos,
    a = Math.sin,
    l = s(t / 2),
    c = a(t / 2),
    d = s((e + n) / 2),
    p = a((e + n) / 2),
    m = s((e - n) / 2),
    y = a((e - n) / 2),
    v = s((n - e) / 2),
    A = a((n - e) / 2);
  switch (i) {
    case "XYX":
      r.set(l * p, c * m, c * y, l * d);
      break;
    case "YZY":
      r.set(c * y, l * p, c * m, l * d);
      break;
    case "ZXZ":
      r.set(c * m, c * y, l * p, l * d);
      break;
    case "XZX":
      r.set(l * p, c * A, c * v, l * d);
      break;
    case "YXY":
      r.set(c * v, l * p, c * A, l * d);
      break;
    case "ZYZ":
      r.set(c * A, c * v, l * p, l * d);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i,
      );
  }
}
function Wi(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function on(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const gp = {
  DEG2RAD: Cc,
  RAD2DEG: yh,
  generateUUID: Ms,
  clamp: en,
  euclideanModulo: D3,
  mapLinear: Z9,
  inverseLerp: q9,
  lerp: mp,
  damp: K9,
  pingpong: Q9,
  smoothstep: $9,
  smootherstep: eR,
  randInt: tR,
  randFloat: nR,
  randFloatSpread: rR,
  seededRandom: iR,
  degToRad: sR,
  radToDeg: aR,
  isPowerOfTwo: oR,
  ceilPowerOfTwo: lR,
  floorPowerOfTwo: uR,
  setQuaternionFromProperEuler: cR,
  normalize: on,
  denormalize: Wi,
};
class je {
  constructor(e = 0, t = 0) {
    (je.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = en(this.x, e.x, t.x)), (this.y = en(this.y, e.y, t.y)), this
    );
  }
  clampScalar(e, t) {
    return (this.x = en(this.x, e, t)), (this.y = en(this.y, e, t)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(en(n, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(en(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * n - a * i + e.x), (this.y = s * i + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class an {
  constructor(e, t, n, i, s, a, l, c, d) {
    (an.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, s, a, l, c, d);
  }
  set(e, t, n, i, s, a, l, c, d) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[1] = i),
      (p[2] = l),
      (p[3] = t),
      (p[4] = s),
      (p[5] = c),
      (p[6] = n),
      (p[7] = a),
      (p[8] = d),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      a = n[0],
      l = n[3],
      c = n[6],
      d = n[1],
      p = n[4],
      m = n[7],
      y = n[2],
      v = n[5],
      A = n[8],
      M = i[0],
      w = i[3],
      x = i[6],
      C = i[1],
      T = i[4],
      I = i[7],
      U = i[2],
      F = i[5],
      O = i[8];
    return (
      (s[0] = a * M + l * C + c * U),
      (s[3] = a * w + l * T + c * F),
      (s[6] = a * x + l * I + c * O),
      (s[1] = d * M + p * C + m * U),
      (s[4] = d * w + p * T + m * F),
      (s[7] = d * x + p * I + m * O),
      (s[2] = y * M + v * C + A * U),
      (s[5] = y * w + v * T + A * F),
      (s[8] = y * x + v * I + A * O),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      l = e[5],
      c = e[6],
      d = e[7],
      p = e[8];
    return (
      t * a * p - t * l * d - n * s * p + n * l * c + i * s * d - i * a * c
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      l = e[5],
      c = e[6],
      d = e[7],
      p = e[8],
      m = p * a - l * d,
      y = l * c - p * s,
      v = d * s - a * c,
      A = t * m + n * y + i * v;
    if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / A;
    return (
      (e[0] = m * M),
      (e[1] = (i * d - p * n) * M),
      (e[2] = (l * n - i * a) * M),
      (e[3] = y * M),
      (e[4] = (p * t - i * c) * M),
      (e[5] = (i * s - l * t) * M),
      (e[6] = v * M),
      (e[7] = (n * c - d * t) * M),
      (e[8] = (a * t - n * s) * M),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, s, a, l) {
    const c = Math.cos(s),
      d = Math.sin(s);
    return (
      this.set(
        n * c,
        n * d,
        -n * (c * a + d * l) + a + e,
        -i * d,
        i * c,
        -i * (-d * a + c * l) + l + t,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(X2.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(X2.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(X2.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const X2 = new an();
function O5(r) {
  for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return !0;
  return !1;
}
const dR = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function rh(r, e) {
  return new dR[r](e);
}
function Ip(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function k5() {
  const r = Ip("canvas");
  return (r.style.display = "block"), r;
}
const Qb = {};
function Zd(r) {
  r in Qb || ((Qb[r] = !0), console.warn(r));
}
function hR(r, e, t) {
  return new Promise(function (n, i) {
    function s() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          i();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          n();
      }
    }
    setTimeout(s, t);
  });
}
function fR(r) {
  const e = r.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function pR(r) {
  const e = r.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const $b = new an().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  e_ = new an().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  );
function mR() {
  const r = {
      enabled: !0,
      workingColorSpace: ao,
      spaces: {},
      convert: function (i, s, a) {
        return (
          this.enabled === !1 ||
            s === a ||
            !s ||
            !a ||
            (this.spaces[s].transfer === Hn &&
              ((i.r = Yo(i.r)), (i.g = Yo(i.g)), (i.b = Yo(i.b))),
            this.spaces[s].primaries !== this.spaces[a].primaries &&
              (i.applyMatrix3(this.spaces[s].toXYZ),
              i.applyMatrix3(this.spaces[a].fromXYZ)),
            this.spaces[a].transfer === Hn &&
              ((i.r = oh(i.r)), (i.g = oh(i.g)), (i.b = oh(i.b)))),
          i
        );
      },
      fromWorkingColorSpace: function (i, s) {
        return this.convert(i, this.workingColorSpace, s);
      },
      toWorkingColorSpace: function (i, s) {
        return this.convert(i, s, this.workingColorSpace);
      },
      getPrimaries: function (i) {
        return this.spaces[i].primaries;
      },
      getTransfer: function (i) {
        return i === Vo ? Cp : this.spaces[i].transfer;
      },
      getLuminanceCoefficients: function (i, s = this.workingColorSpace) {
        return i.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (i) {
        Object.assign(this.spaces, i);
      },
      _getMatrix: function (i, s, a) {
        return i.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (i) {
        return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (i = this.workingColorSpace) {
        return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    n = [0.3127, 0.329];
  return (
    r.define({
      [ao]: {
        primaries: e,
        whitePoint: n,
        transfer: Cp,
        toXYZ: $b,
        fromXYZ: e_,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: Ei },
        outputColorSpaceConfig: { drawingBufferColorSpace: Ei },
      },
      [Ei]: {
        primaries: e,
        whitePoint: n,
        transfer: Hn,
        toXYZ: $b,
        fromXYZ: e_,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: Ei },
      },
    }),
    r
  );
}
const Sn = mR();
function Yo(r) {
  return r < 0.04045
    ? r * 0.0773993808
    : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function oh(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
let Rd;
class z5 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Rd === void 0 && (Rd = Ip("canvas")),
        (Rd.width = e.width),
        (Rd.height = e.height);
      const n = Rd.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = Rd);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e,
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Ip("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let a = 0; a < s.length; a++) s[a] = Yo(s[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Yo(t[n] / 255) * 255))
          : (t[n] = Yo(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
        e
      );
  }
}
let gR = 0;
class xc {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: gR++ }),
      (this.uuid = Ms()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let a = 0, l = i.length; a < l; a++)
          i[a].isDataTexture ? s.push(J2(i[a].image)) : s.push(J2(i[a]));
      } else s = J2(i);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function J2(r) {
  return (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && r instanceof ImageBitmap)
    ? z5.getDataURL(r)
    : r.data
      ? {
          data: Array.from(r.data),
          width: r.width,
          height: r.height,
          type: r.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let yR = 0;
class Ln extends oo {
  constructor(
    e = Ln.DEFAULT_IMAGE,
    t = Ln.DEFAULT_MAPPING,
    n = Ar,
    i = Ar,
    s = Un,
    a = Ys,
    l = wr,
    c = hs,
    d = Ln.DEFAULT_ANISOTROPY,
    p = Vo,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: yR++ }),
      (this.uuid = Ms()),
      (this.name = ""),
      (this.source = new xc(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = d),
      (this.format = l),
      (this.internalFormat = null),
      (this.type = c),
      (this.offset = new je(0, 0)),
      (this.repeat = new je(1, 1)),
      (this.center = new je(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new an()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = p),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== jl) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Xl:
          e.x = e.x - Math.floor(e.x);
          break;
        case Ar:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case fh:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Xl:
          e.y = e.y - Math.floor(e.y);
          break;
        case Ar:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case fh:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ln.DEFAULT_IMAGE = null;
Ln.DEFAULT_MAPPING = jl;
Ln.DEFAULT_ANISOTROPY = 1;
class Cn {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (Cn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * s),
      (this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * s),
      (this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * s),
      (this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, s;
    const a = e.elements,
      l = a[0],
      c = a[4],
      d = a[8],
      p = a[1],
      m = a[5],
      y = a[9],
      v = a[2],
      A = a[6],
      M = a[10];
    if (
      Math.abs(c - p) < 0.01 &&
      Math.abs(d - v) < 0.01 &&
      Math.abs(y - A) < 0.01
    ) {
      if (
        Math.abs(c + p) < 0.1 &&
        Math.abs(d + v) < 0.1 &&
        Math.abs(y + A) < 0.1 &&
        Math.abs(l + m + M - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const x = (l + 1) / 2,
        C = (m + 1) / 2,
        T = (M + 1) / 2,
        I = (c + p) / 4,
        U = (d + v) / 4,
        F = (y + A) / 4;
      return (
        x > C && x > T
          ? x < 0.01
            ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(x)), (i = I / n), (s = U / n))
          : C > T
            ? C < 0.01
              ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
              : ((i = Math.sqrt(C)), (n = I / i), (s = F / i))
            : T < 0.01
              ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
              : ((s = Math.sqrt(T)), (n = U / s), (i = F / s)),
        this.set(n, i, s, t),
        this
      );
    }
    let w = Math.sqrt(
      (A - y) * (A - y) + (d - v) * (d - v) + (p - c) * (p - c),
    );
    return (
      Math.abs(w) < 0.001 && (w = 1),
      (this.x = (A - y) / w),
      (this.y = (d - v) / w),
      (this.z = (p - c) / w),
      (this.w = Math.acos((l + m + M - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = en(this.x, e.x, t.x)),
      (this.y = en(this.y, e.y, t.y)),
      (this.z = en(this.z, e.z, t.z)),
      (this.w = en(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = en(this.x, e, t)),
      (this.y = en(this.y, e, t)),
      (this.z = en(this.z, e, t)),
      (this.w = en(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(en(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class H5 extends oo {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Cn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Cn(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Un,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      n,
    );
    const s = new Ln(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace,
    );
    (s.flipY = !1),
      (s.generateMipmaps = n.generateMipmaps),
      (s.internalFormat = n.internalFormat),
      (this.textures = []);
    const a = n.count;
    for (let l = 0; l < a; l++)
      (this.textures[l] = s.clone()),
        (this.textures[l].isRenderTargetTexture = !0);
    (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let i = 0, s = this.textures.length; i < s; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = n);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let n = 0, i = e.textures.length; n < i; n++)
      (this.textures[n] = e.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new xc(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Es extends H5 {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), (this.isWebGLRenderTarget = !0);
  }
}
class Fg extends Ln {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Qr),
      (this.minFilter = Qr),
      (this.wrapR = Ar),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class vR extends Es {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Fg(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class F3 extends Ln {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Qr),
      (this.minFilter = Qr),
      (this.wrapR = Ar),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class xR extends Es {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new F3(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Ci {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, s, a, l) {
    let c = n[i + 0],
      d = n[i + 1],
      p = n[i + 2],
      m = n[i + 3];
    const y = s[a + 0],
      v = s[a + 1],
      A = s[a + 2],
      M = s[a + 3];
    if (l === 0) {
      (e[t + 0] = c), (e[t + 1] = d), (e[t + 2] = p), (e[t + 3] = m);
      return;
    }
    if (l === 1) {
      (e[t + 0] = y), (e[t + 1] = v), (e[t + 2] = A), (e[t + 3] = M);
      return;
    }
    if (m !== M || c !== y || d !== v || p !== A) {
      let w = 1 - l;
      const x = c * y + d * v + p * A + m * M,
        C = x >= 0 ? 1 : -1,
        T = 1 - x * x;
      if (T > Number.EPSILON) {
        const U = Math.sqrt(T),
          F = Math.atan2(U, x * C);
        (w = Math.sin(w * F) / U), (l = Math.sin(l * F) / U);
      }
      const I = l * C;
      if (
        ((c = c * w + y * I),
        (d = d * w + v * I),
        (p = p * w + A * I),
        (m = m * w + M * I),
        w === 1 - l)
      ) {
        const U = 1 / Math.sqrt(c * c + d * d + p * p + m * m);
        (c *= U), (d *= U), (p *= U), (m *= U);
      }
    }
    (e[t] = c), (e[t + 1] = d), (e[t + 2] = p), (e[t + 3] = m);
  }
  static multiplyQuaternionsFlat(e, t, n, i, s, a) {
    const l = n[i],
      c = n[i + 1],
      d = n[i + 2],
      p = n[i + 3],
      m = s[a],
      y = s[a + 1],
      v = s[a + 2],
      A = s[a + 3];
    return (
      (e[t] = l * A + p * m + c * v - d * y),
      (e[t + 1] = c * A + p * y + d * m - l * v),
      (e[t + 2] = d * A + p * v + l * y - c * m),
      (e[t + 3] = p * A - l * m - c * y - d * v),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const n = e._x,
      i = e._y,
      s = e._z,
      a = e._order,
      l = Math.cos,
      c = Math.sin,
      d = l(n / 2),
      p = l(i / 2),
      m = l(s / 2),
      y = c(n / 2),
      v = c(i / 2),
      A = c(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = y * p * m + d * v * A),
          (this._y = d * v * m - y * p * A),
          (this._z = d * p * A + y * v * m),
          (this._w = d * p * m - y * v * A);
        break;
      case "YXZ":
        (this._x = y * p * m + d * v * A),
          (this._y = d * v * m - y * p * A),
          (this._z = d * p * A - y * v * m),
          (this._w = d * p * m + y * v * A);
        break;
      case "ZXY":
        (this._x = y * p * m - d * v * A),
          (this._y = d * v * m + y * p * A),
          (this._z = d * p * A + y * v * m),
          (this._w = d * p * m - y * v * A);
        break;
      case "ZYX":
        (this._x = y * p * m - d * v * A),
          (this._y = d * v * m + y * p * A),
          (this._z = d * p * A - y * v * m),
          (this._w = d * p * m + y * v * A);
        break;
      case "YZX":
        (this._x = y * p * m + d * v * A),
          (this._y = d * v * m + y * p * A),
          (this._z = d * p * A - y * v * m),
          (this._w = d * p * m - y * v * A);
        break;
      case "XZY":
        (this._x = y * p * m - d * v * A),
          (this._y = d * v * m - y * p * A),
          (this._z = d * p * A + y * v * m),
          (this._w = d * p * m + y * v * A);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            a,
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      s = t[8],
      a = t[1],
      l = t[5],
      c = t[9],
      d = t[2],
      p = t[6],
      m = t[10],
      y = n + l + m;
    if (y > 0) {
      const v = 0.5 / Math.sqrt(y + 1);
      (this._w = 0.25 / v),
        (this._x = (p - c) * v),
        (this._y = (s - d) * v),
        (this._z = (a - i) * v);
    } else if (n > l && n > m) {
      const v = 2 * Math.sqrt(1 + n - l - m);
      (this._w = (p - c) / v),
        (this._x = 0.25 * v),
        (this._y = (i + a) / v),
        (this._z = (s + d) / v);
    } else if (l > m) {
      const v = 2 * Math.sqrt(1 + l - n - m);
      (this._w = (s - d) / v),
        (this._x = (i + a) / v),
        (this._y = 0.25 * v),
        (this._z = (c + p) / v);
    } else {
      const v = 2 * Math.sqrt(1 + m - n - l);
      (this._w = (a - i) / v),
        (this._x = (s + d) / v),
        (this._y = (c + p) / v),
        (this._z = 0.25 * v);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(en(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      a = e._w,
      l = t._x,
      c = t._y,
      d = t._z,
      p = t._w;
    return (
      (this._x = n * p + a * l + i * d - s * c),
      (this._y = i * p + a * c + s * l - n * d),
      (this._z = s * p + a * d + n * c - i * l),
      (this._w = a * p - n * l - i * c - s * d),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      s = this._z,
      a = this._w;
    let l = a * e._w + n * e._x + i * e._y + s * e._z;
    if (
      (l < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (l = -l))
        : this.copy(e),
      l >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = i), (this._z = s), this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const v = 1 - t;
      return (
        (this._w = v * a + t * this._w),
        (this._x = v * n + t * this._x),
        (this._y = v * i + t * this._y),
        (this._z = v * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const d = Math.sqrt(c),
      p = Math.atan2(d, l),
      m = Math.sin((1 - t) * p) / d,
      y = Math.sin(t * p) / d;
    return (
      (this._w = a * m + this._w * y),
      (this._x = n * m + this._x * y),
      (this._y = i * m + this._y * y),
      (this._z = s * m + this._z * y),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      n = Math.random(),
      i = Math.sqrt(1 - n),
      s = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t),
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Y {
  constructor(e = 0, t = 0, n = 0) {
    (Y.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(t_.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(t_.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * n + s[6] * i),
      (this.y = s[1] * t + s[4] * n + s[7] * i),
      (this.z = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements,
      a = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * a),
      (this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * a),
      (this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.x,
      a = e.y,
      l = e.z,
      c = e.w,
      d = 2 * (a * i - l * n),
      p = 2 * (l * t - s * i),
      m = 2 * (s * n - a * t);
    return (
      (this.x = t + c * d + a * m - l * p),
      (this.y = n + c * p + l * d - s * m),
      (this.z = i + c * m + s * p - a * d),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix,
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld,
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * i),
      (this.y = s[1] * t + s[5] * n + s[9] * i),
      (this.z = s[2] * t + s[6] * n + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = en(this.x, e.x, t.x)),
      (this.y = en(this.y, e.y, t.y)),
      (this.z = en(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = en(this.x, e, t)),
      (this.y = en(this.y, e, t)),
      (this.z = en(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(en(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = t.x,
      l = t.y,
      c = t.z;
    return (
      (this.x = i * c - s * l),
      (this.y = s * a - n * c),
      (this.z = n * l - i * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Y2.copy(this).projectOnVector(e), this.sub(Y2);
  }
  reflect(e) {
    return this.sub(Y2.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(en(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      n = Math.sqrt(1 - t * t);
    return (
      (this.x = n * Math.cos(e)), (this.y = t), (this.z = n * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Y2 = new Y(),
  t_ = new Ci();
class Ti {
  constructor(
    e = new Y(1 / 0, 1 / 0, 1 / 0),
    t = new Y(-1 / 0, -1 / 0, -1 / 0),
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(ga.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(ga.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = ga.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const s = n.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, l = s.count; a < l; a++)
          e.isMesh === !0
            ? e.getVertexPosition(a, ga)
            : ga.fromBufferAttribute(s, a),
            ga.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ga);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            m1.copy(e.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            m1.copy(n.boundingBox)),
          m1.applyMatrix4(e.matrixWorld),
          this.union(m1);
    }
    const i = e.children;
    for (let s = 0, a = i.length; s < a; s++) this.expandByObject(i[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ga),
      ga.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Pf),
      g1.subVectors(this.max, Pf),
      Id.subVectors(e.a, Pf),
      Bd.subVectors(e.b, Pf),
      Pd.subVectors(e.c, Pf),
      Rl.subVectors(Bd, Id),
      Il.subVectors(Pd, Bd),
      Zu.subVectors(Id, Pd);
    let t = [
      0,
      -Rl.z,
      Rl.y,
      0,
      -Il.z,
      Il.y,
      0,
      -Zu.z,
      Zu.y,
      Rl.z,
      0,
      -Rl.x,
      Il.z,
      0,
      -Il.x,
      Zu.z,
      0,
      -Zu.x,
      -Rl.y,
      Rl.x,
      0,
      -Il.y,
      Il.x,
      0,
      -Zu.y,
      Zu.x,
      0,
    ];
    return !Z2(t, Id, Bd, Pd, g1) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Z2(t, Id, Bd, Pd, g1))
      ? !1
      : (y1.crossVectors(Rl, Il),
        (t = [y1.x, y1.y, y1.z]),
        Z2(t, Id, Bd, Pd, g1));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ga).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(ga).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Fo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Fo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Fo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Fo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Fo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Fo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Fo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Fo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Fo),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Fo = [
    new Y(),
    new Y(),
    new Y(),
    new Y(),
    new Y(),
    new Y(),
    new Y(),
    new Y(),
  ],
  ga = new Y(),
  m1 = new Ti(),
  Id = new Y(),
  Bd = new Y(),
  Pd = new Y(),
  Rl = new Y(),
  Il = new Y(),
  Zu = new Y(),
  Pf = new Y(),
  g1 = new Y(),
  y1 = new Y(),
  qu = new Y();
function Z2(r, e, t, n, i) {
  for (let s = 0, a = r.length - 3; s <= a; s += 3) {
    qu.fromArray(r, s);
    const l =
        i.x * Math.abs(qu.x) + i.y * Math.abs(qu.y) + i.z * Math.abs(qu.z),
      c = e.dot(qu),
      d = t.dot(qu),
      p = n.dot(qu);
    if (Math.max(-Math.max(c, d, p), Math.min(c, d, p)) > l) return !1;
  }
  return !0;
}
const bR = new Ti(),
  Lf = new Y(),
  q2 = new Y();
class ui {
  constructor(e = new Y(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : bR.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let s = 0, a = e.length; s < a; s++)
      i = Math.max(i, n.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Lf.subVectors(e, this.center);
    const t = Lf.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Lf, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (q2.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(Lf.copy(e.center).add(q2)),
              this.expandByPoint(Lf.copy(e.center).sub(q2))),
          this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const No = new Y(),
  K2 = new Y(),
  v1 = new Y(),
  Bl = new Y(),
  Q2 = new Y(),
  x1 = new Y(),
  $2 = new Y();
class Eh {
  constructor(e = new Y(), t = new Y(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, No)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = No.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (No.copy(this.origin).addScaledVector(this.direction, t),
        No.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    K2.copy(e).add(t).multiplyScalar(0.5),
      v1.copy(t).sub(e).normalize(),
      Bl.copy(this.origin).sub(K2);
    const s = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(v1),
      l = Bl.dot(this.direction),
      c = -Bl.dot(v1),
      d = Bl.lengthSq(),
      p = Math.abs(1 - a * a);
    let m, y, v, A;
    if (p > 0)
      if (((m = a * c - l), (y = a * l - c), (A = s * p), m >= 0))
        if (y >= -A)
          if (y <= A) {
            const M = 1 / p;
            (m *= M),
              (y *= M),
              (v = m * (m + a * y + 2 * l) + y * (a * m + y + 2 * c) + d);
          } else
            (y = s),
              (m = Math.max(0, -(a * y + l))),
              (v = -m * m + y * (y + 2 * c) + d);
        else
          (y = -s),
            (m = Math.max(0, -(a * y + l))),
            (v = -m * m + y * (y + 2 * c) + d);
      else
        y <= -A
          ? ((m = Math.max(0, -(-a * s + l))),
            (y = m > 0 ? -s : Math.min(Math.max(-s, -c), s)),
            (v = -m * m + y * (y + 2 * c) + d))
          : y <= A
            ? ((m = 0),
              (y = Math.min(Math.max(-s, -c), s)),
              (v = y * (y + 2 * c) + d))
            : ((m = Math.max(0, -(a * s + l))),
              (y = m > 0 ? s : Math.min(Math.max(-s, -c), s)),
              (v = -m * m + y * (y + 2 * c) + d));
    else
      (y = a > 0 ? -s : s),
        (m = Math.max(0, -(a * y + l))),
        (v = -m * m + y * (y + 2 * c) + d);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, m),
      i && i.copy(K2).addScaledVector(v1, y),
      v
    );
  }
  intersectSphere(e, t) {
    No.subVectors(e.center, this.origin);
    const n = No.dot(this.direction),
      i = No.dot(No) - n * n,
      s = e.radius * e.radius;
    if (i > s) return null;
    const a = Math.sqrt(s - i),
      l = n - a,
      c = n + a;
    return c < 0 ? null : l < 0 ? this.at(c, t) : this.at(l, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, s, a, l, c;
    const d = 1 / this.direction.x,
      p = 1 / this.direction.y,
      m = 1 / this.direction.z,
      y = this.origin;
    return (
      d >= 0
        ? ((n = (e.min.x - y.x) * d), (i = (e.max.x - y.x) * d))
        : ((n = (e.max.x - y.x) * d), (i = (e.min.x - y.x) * d)),
      p >= 0
        ? ((s = (e.min.y - y.y) * p), (a = (e.max.y - y.y) * p))
        : ((s = (e.max.y - y.y) * p), (a = (e.min.y - y.y) * p)),
      n > a ||
      s > i ||
      ((s > n || isNaN(n)) && (n = s),
      (a < i || isNaN(i)) && (i = a),
      m >= 0
        ? ((l = (e.min.z - y.z) * m), (c = (e.max.z - y.z) * m))
        : ((l = (e.max.z - y.z) * m), (c = (e.min.z - y.z) * m)),
      n > c || l > i) ||
      ((l > n || n !== n) && (n = l), (c < i || i !== i) && (i = c), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, No) !== null;
  }
  intersectTriangle(e, t, n, i, s) {
    Q2.subVectors(t, e), x1.subVectors(n, e), $2.crossVectors(Q2, x1);
    let a = this.direction.dot($2),
      l;
    if (a > 0) {
      if (i) return null;
      l = 1;
    } else if (a < 0) (l = -1), (a = -a);
    else return null;
    Bl.subVectors(this.origin, e);
    const c = l * this.direction.dot(x1.crossVectors(Bl, x1));
    if (c < 0) return null;
    const d = l * this.direction.dot(Q2.cross(Bl));
    if (d < 0 || c + d > a) return null;
    const p = -l * Bl.dot($2);
    return p < 0 ? null : this.at(p / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class jt {
  constructor(e, t, n, i, s, a, l, c, d, p, m, y, v, A, M, w) {
    (jt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, s, a, l, c, d, p, m, y, v, A, M, w);
  }
  set(e, t, n, i, s, a, l, c, d, p, m, y, v, A, M, w) {
    const x = this.elements;
    return (
      (x[0] = e),
      (x[4] = t),
      (x[8] = n),
      (x[12] = i),
      (x[1] = s),
      (x[5] = a),
      (x[9] = l),
      (x[13] = c),
      (x[2] = d),
      (x[6] = p),
      (x[10] = m),
      (x[14] = y),
      (x[3] = v),
      (x[7] = A),
      (x[11] = M),
      (x[15] = w),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new jt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / Ld.setFromMatrixColumn(e, 0).length(),
      s = 1 / Ld.setFromMatrixColumn(e, 1).length(),
      a = 1 / Ld.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * s),
      (t[5] = n[5] * s),
      (t[6] = n[6] * s),
      (t[7] = 0),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z,
      a = Math.cos(n),
      l = Math.sin(n),
      c = Math.cos(i),
      d = Math.sin(i),
      p = Math.cos(s),
      m = Math.sin(s);
    if (e.order === "XYZ") {
      const y = a * p,
        v = a * m,
        A = l * p,
        M = l * m;
      (t[0] = c * p),
        (t[4] = -c * m),
        (t[8] = d),
        (t[1] = v + A * d),
        (t[5] = y - M * d),
        (t[9] = -l * c),
        (t[2] = M - y * d),
        (t[6] = A + v * d),
        (t[10] = a * c);
    } else if (e.order === "YXZ") {
      const y = c * p,
        v = c * m,
        A = d * p,
        M = d * m;
      (t[0] = y + M * l),
        (t[4] = A * l - v),
        (t[8] = a * d),
        (t[1] = a * m),
        (t[5] = a * p),
        (t[9] = -l),
        (t[2] = v * l - A),
        (t[6] = M + y * l),
        (t[10] = a * c);
    } else if (e.order === "ZXY") {
      const y = c * p,
        v = c * m,
        A = d * p,
        M = d * m;
      (t[0] = y - M * l),
        (t[4] = -a * m),
        (t[8] = A + v * l),
        (t[1] = v + A * l),
        (t[5] = a * p),
        (t[9] = M - y * l),
        (t[2] = -a * d),
        (t[6] = l),
        (t[10] = a * c);
    } else if (e.order === "ZYX") {
      const y = a * p,
        v = a * m,
        A = l * p,
        M = l * m;
      (t[0] = c * p),
        (t[4] = A * d - v),
        (t[8] = y * d + M),
        (t[1] = c * m),
        (t[5] = M * d + y),
        (t[9] = v * d - A),
        (t[2] = -d),
        (t[6] = l * c),
        (t[10] = a * c);
    } else if (e.order === "YZX") {
      const y = a * c,
        v = a * d,
        A = l * c,
        M = l * d;
      (t[0] = c * p),
        (t[4] = M - y * m),
        (t[8] = A * m + v),
        (t[1] = m),
        (t[5] = a * p),
        (t[9] = -l * p),
        (t[2] = -d * p),
        (t[6] = v * m + A),
        (t[10] = y - M * m);
    } else if (e.order === "XZY") {
      const y = a * c,
        v = a * d,
        A = l * c,
        M = l * d;
      (t[0] = c * p),
        (t[4] = -m),
        (t[8] = d * p),
        (t[1] = y * m + M),
        (t[5] = a * p),
        (t[9] = v * m - A),
        (t[2] = A * m - v),
        (t[6] = l * p),
        (t[10] = M * m + y);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_R, e, AR);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      As.subVectors(e, t),
      As.lengthSq() === 0 && (As.z = 1),
      As.normalize(),
      Pl.crossVectors(n, As),
      Pl.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (As.x += 1e-4) : (As.z += 1e-4),
        As.normalize(),
        Pl.crossVectors(n, As)),
      Pl.normalize(),
      b1.crossVectors(As, Pl),
      (i[0] = Pl.x),
      (i[4] = b1.x),
      (i[8] = As.x),
      (i[1] = Pl.y),
      (i[5] = b1.y),
      (i[9] = As.y),
      (i[2] = Pl.z),
      (i[6] = b1.z),
      (i[10] = As.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      a = n[0],
      l = n[4],
      c = n[8],
      d = n[12],
      p = n[1],
      m = n[5],
      y = n[9],
      v = n[13],
      A = n[2],
      M = n[6],
      w = n[10],
      x = n[14],
      C = n[3],
      T = n[7],
      I = n[11],
      U = n[15],
      F = i[0],
      O = i[4],
      z = i[8],
      L = i[12],
      N = i[1],
      X = i[5],
      ie = i[9],
      re = i[13],
      me = i[2],
      _e = i[6],
      ge = i[10],
      Re = i[14],
      J = i[3],
      oe = i[7],
      ae = i[11],
      q = i[15];
    return (
      (s[0] = a * F + l * N + c * me + d * J),
      (s[4] = a * O + l * X + c * _e + d * oe),
      (s[8] = a * z + l * ie + c * ge + d * ae),
      (s[12] = a * L + l * re + c * Re + d * q),
      (s[1] = p * F + m * N + y * me + v * J),
      (s[5] = p * O + m * X + y * _e + v * oe),
      (s[9] = p * z + m * ie + y * ge + v * ae),
      (s[13] = p * L + m * re + y * Re + v * q),
      (s[2] = A * F + M * N + w * me + x * J),
      (s[6] = A * O + M * X + w * _e + x * oe),
      (s[10] = A * z + M * ie + w * ge + x * ae),
      (s[14] = A * L + M * re + w * Re + x * q),
      (s[3] = C * F + T * N + I * me + U * J),
      (s[7] = C * O + T * X + I * _e + U * oe),
      (s[11] = C * z + T * ie + I * ge + U * ae),
      (s[15] = C * L + T * re + I * Re + U * q),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      s = e[12],
      a = e[1],
      l = e[5],
      c = e[9],
      d = e[13],
      p = e[2],
      m = e[6],
      y = e[10],
      v = e[14],
      A = e[3],
      M = e[7],
      w = e[11],
      x = e[15];
    return (
      A *
        (+s * c * m -
          i * d * m -
          s * l * y +
          n * d * y +
          i * l * v -
          n * c * v) +
      M *
        (+t * c * v -
          t * d * y +
          s * a * y -
          i * a * v +
          i * d * p -
          s * c * p) +
      w *
        (+t * d * m -
          t * l * v -
          s * a * m +
          n * a * v +
          s * l * p -
          n * d * p) +
      x *
        (-i * l * p - t * c * m + t * l * y + i * a * m - n * a * y + n * c * p)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      l = e[5],
      c = e[6],
      d = e[7],
      p = e[8],
      m = e[9],
      y = e[10],
      v = e[11],
      A = e[12],
      M = e[13],
      w = e[14],
      x = e[15],
      C = m * w * d - M * y * d + M * c * v - l * w * v - m * c * x + l * y * x,
      T = A * y * d - p * w * d - A * c * v + a * w * v + p * c * x - a * y * x,
      I = p * M * d - A * m * d + A * l * v - a * M * v - p * l * x + a * m * x,
      U = A * m * c - p * M * c - A * l * y + a * M * y + p * l * w - a * m * w,
      F = t * C + n * T + i * I + s * U;
    if (F === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const O = 1 / F;
    return (
      (e[0] = C * O),
      (e[1] =
        (M * y * s -
          m * w * s -
          M * i * v +
          n * w * v +
          m * i * x -
          n * y * x) *
        O),
      (e[2] =
        (l * w * s -
          M * c * s +
          M * i * d -
          n * w * d -
          l * i * x +
          n * c * x) *
        O),
      (e[3] =
        (m * c * s -
          l * y * s -
          m * i * d +
          n * y * d +
          l * i * v -
          n * c * v) *
        O),
      (e[4] = T * O),
      (e[5] =
        (p * w * s -
          A * y * s +
          A * i * v -
          t * w * v -
          p * i * x +
          t * y * x) *
        O),
      (e[6] =
        (A * c * s -
          a * w * s -
          A * i * d +
          t * w * d +
          a * i * x -
          t * c * x) *
        O),
      (e[7] =
        (a * y * s -
          p * c * s +
          p * i * d -
          t * y * d -
          a * i * v +
          t * c * v) *
        O),
      (e[8] = I * O),
      (e[9] =
        (A * m * s -
          p * M * s -
          A * n * v +
          t * M * v +
          p * n * x -
          t * m * x) *
        O),
      (e[10] =
        (a * M * s -
          A * l * s +
          A * n * d -
          t * M * d -
          a * n * x +
          t * l * x) *
        O),
      (e[11] =
        (p * l * s -
          a * m * s -
          p * n * d +
          t * m * d +
          a * n * v -
          t * l * v) *
        O),
      (e[12] = U * O),
      (e[13] =
        (p * M * i -
          A * m * i +
          A * n * y -
          t * M * y -
          p * n * w +
          t * m * w) *
        O),
      (e[14] =
        (A * l * i -
          a * M * i -
          A * n * c +
          t * M * c +
          a * n * w -
          t * l * w) *
        O),
      (e[15] =
        (a * m * i -
          p * l * i +
          p * n * c -
          t * m * c -
          a * n * y +
          t * l * y) *
        O),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = 1 - n,
      a = e.x,
      l = e.y,
      c = e.z,
      d = s * a,
      p = s * l;
    return (
      this.set(
        d * a + n,
        d * l - i * c,
        d * c + i * l,
        0,
        d * l + i * c,
        p * l + n,
        p * c - i * a,
        0,
        d * c - i * l,
        p * c + i * a,
        s * c * c + n,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, s, a) {
    return this.set(1, n, s, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      s = t._x,
      a = t._y,
      l = t._z,
      c = t._w,
      d = s + s,
      p = a + a,
      m = l + l,
      y = s * d,
      v = s * p,
      A = s * m,
      M = a * p,
      w = a * m,
      x = l * m,
      C = c * d,
      T = c * p,
      I = c * m,
      U = n.x,
      F = n.y,
      O = n.z;
    return (
      (i[0] = (1 - (M + x)) * U),
      (i[1] = (v + I) * U),
      (i[2] = (A - T) * U),
      (i[3] = 0),
      (i[4] = (v - I) * F),
      (i[5] = (1 - (y + x)) * F),
      (i[6] = (w + C) * F),
      (i[7] = 0),
      (i[8] = (A + T) * O),
      (i[9] = (w - C) * O),
      (i[10] = (1 - (y + M)) * O),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let s = Ld.set(i[0], i[1], i[2]).length();
    const a = Ld.set(i[4], i[5], i[6]).length(),
      l = Ld.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      ya.copy(this);
    const c = 1 / s,
      d = 1 / a,
      p = 1 / l;
    return (
      (ya.elements[0] *= c),
      (ya.elements[1] *= c),
      (ya.elements[2] *= c),
      (ya.elements[4] *= d),
      (ya.elements[5] *= d),
      (ya.elements[6] *= d),
      (ya.elements[8] *= p),
      (ya.elements[9] *= p),
      (ya.elements[10] *= p),
      t.setFromRotationMatrix(ya),
      (n.x = s),
      (n.y = a),
      (n.z = l),
      this
    );
  }
  makePerspective(e, t, n, i, s, a, l = Ka) {
    const c = this.elements,
      d = (2 * s) / (t - e),
      p = (2 * s) / (n - i),
      m = (t + e) / (t - e),
      y = (n + i) / (n - i);
    let v, A;
    if (l === Ka) (v = -(a + s) / (a - s)), (A = (-2 * a * s) / (a - s));
    else if (l === Rp) (v = -a / (a - s)), (A = (-a * s) / (a - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l,
      );
    return (
      (c[0] = d),
      (c[4] = 0),
      (c[8] = m),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = p),
      (c[9] = y),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = v),
      (c[14] = A),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, s, a, l = Ka) {
    const c = this.elements,
      d = 1 / (t - e),
      p = 1 / (n - i),
      m = 1 / (a - s),
      y = (t + e) * d,
      v = (n + i) * p;
    let A, M;
    if (l === Ka) (A = (a + s) * m), (M = -2 * m);
    else if (l === Rp) (A = s * m), (M = -1 * m);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l,
      );
    return (
      (c[0] = 2 * d),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = -y),
      (c[1] = 0),
      (c[5] = 2 * p),
      (c[9] = 0),
      (c[13] = -v),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = M),
      (c[14] = -A),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const Ld = new Y(),
  ya = new jt(),
  _R = new Y(0, 0, 0),
  AR = new Y(1, 1, 1),
  Pl = new Y(),
  b1 = new Y(),
  As = new Y(),
  n_ = new jt(),
  r_ = new Ci();
class Cs {
  constructor(e = 0, t = 0, n = 0, i = Cs.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      s = i[0],
      a = i[4],
      l = i[8],
      c = i[1],
      d = i[5],
      p = i[9],
      m = i[2],
      y = i[6],
      v = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(en(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-p, v)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(y, d)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-en(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(l, v)), (this._z = Math.atan2(c, d)))
            : ((this._y = Math.atan2(-m, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(en(y, -1, 1))),
          Math.abs(y) < 0.9999999
            ? ((this._y = Math.atan2(-m, v)), (this._z = Math.atan2(-a, d)))
            : ((this._y = 0), (this._z = Math.atan2(c, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-en(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(y, v)), (this._z = Math.atan2(c, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, d)));
        break;
      case "YZX":
        (this._z = Math.asin(en(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-p, d)), (this._y = Math.atan2(-m, s)))
            : ((this._x = 0), (this._y = Math.atan2(l, v)));
        break;
      case "XZY":
        (this._z = Math.asin(-en(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(y, d)), (this._y = Math.atan2(l, s)))
            : ((this._x = Math.atan2(-p, v)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t,
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      n_.makeRotationFromQuaternion(e), this.setFromRotationMatrix(n_, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return r_.setFromEuler(this), this.setFromQuaternion(r_, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Cs.DEFAULT_ORDER = "XYZ";
class Tc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let wR = 0;
const i_ = new Y(),
  Dd = new Ci(),
  Uo = new jt(),
  _1 = new Y(),
  Df = new Y(),
  MR = new Y(),
  SR = new Ci(),
  s_ = new Y(1, 0, 0),
  a_ = new Y(0, 1, 0),
  o_ = new Y(0, 0, 1),
  l_ = { type: "added" },
  ER = { type: "removed" },
  Fd = { type: "childadded", child: null },
  ey = { type: "childremoved", child: null };
class _n extends oo {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: wR++ }),
      (this.uuid = Ms()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = _n.DEFAULT_UP.clone());
    const e = new Y(),
      t = new Cs(),
      n = new Ci(),
      i = new Y(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new jt() },
        normalMatrix: { value: new an() },
      }),
      (this.matrix = new jt()),
      (this.matrixWorld = new jt()),
      (this.matrixAutoUpdate = _n.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = _n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Tc()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Dd.setFromAxisAngle(e, t), this.quaternion.multiply(Dd), this;
  }
  rotateOnWorldAxis(e, t) {
    return Dd.setFromAxisAngle(e, t), this.quaternion.premultiply(Dd), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(s_, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(a_, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(o_, e);
  }
  translateOnAxis(e, t) {
    return (
      i_.copy(e).applyQuaternion(this.quaternion),
      this.position.add(i_.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(s_, e);
  }
  translateY(e) {
    return this.translateOnAxis(a_, e);
  }
  translateZ(e) {
    return this.translateOnAxis(o_, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Uo.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? _1.copy(e) : _1.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Df.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Uo.lookAt(Df, _1, this.up)
        : Uo.lookAt(_1, Df, this.up),
      this.quaternion.setFromRotationMatrix(Uo),
      i &&
        (Uo.extractRotation(i.matrixWorld),
        Dd.setFromRotationMatrix(Uo),
        this.quaternion.premultiply(Dd.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e,
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(l_),
            (Fd.child = e),
            this.dispatchEvent(Fd),
            (Fd.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e,
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(ER),
        (ey.child = e),
        this.dispatchEvent(ey),
        (ey.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Uo.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Uo.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Uo),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(l_),
      (Fd.child = e),
      this.dispatchEvent(Fd),
      (Fd.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const s = this.children[n].getObjectByProperty(e, t);
      if (s !== void 0) return s;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let s = 0, a = i.length; s < a; s++)
      i[s].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Df, e, MR), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Df, SR, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, a = i.length; s < a; s++) i[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((l) => ({
          boxInitialized: l.boxInitialized,
          boxMin: l.box.min.toArray(),
          boxMax: l.box.max.toArray(),
          sphereInitialized: l.sphereInitialized,
          sphereRadius: l.sphere.radius,
          sphereCenter: l.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function s(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let d = 0, p = c.length; d < p; d++) {
            const m = c[d];
            s(e.shapes, m);
          }
        else s(e.shapes, c);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, d = this.material.length; c < d; c++)
          l.push(s(e.materials, this.material[c]));
        i.material = l;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let l = 0; l < this.children.length; l++)
        i.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        i.animations.push(s(e.animations, c));
      }
    }
    if (t) {
      const l = a(e.geometries),
        c = a(e.materials),
        d = a(e.textures),
        p = a(e.images),
        m = a(e.shapes),
        y = a(e.skeletons),
        v = a(e.animations),
        A = a(e.nodes);
      l.length > 0 && (n.geometries = l),
        c.length > 0 && (n.materials = c),
        d.length > 0 && (n.textures = d),
        p.length > 0 && (n.images = p),
        m.length > 0 && (n.shapes = m),
        y.length > 0 && (n.skeletons = y),
        v.length > 0 && (n.animations = v),
        A.length > 0 && (n.nodes = A);
    }
    return (n.object = i), n;
    function a(l) {
      const c = [];
      for (const d in l) {
        const p = l[d];
        delete p.metadata, c.push(p);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
_n.DEFAULT_UP = new Y(0, 1, 0);
_n.DEFAULT_MATRIX_AUTO_UPDATE = !0;
_n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const va = new Y(),
  Oo = new Y(),
  ty = new Y(),
  ko = new Y(),
  Nd = new Y(),
  Ud = new Y(),
  u_ = new Y(),
  ny = new Y(),
  ry = new Y(),
  iy = new Y(),
  sy = new Cn(),
  ay = new Cn(),
  oy = new Cn();
class cs {
  constructor(e = new Y(), t = new Y(), n = new Y()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), va.subVectors(e, t), i.cross(va);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, s) {
    va.subVectors(i, t), Oo.subVectors(n, t), ty.subVectors(e, t);
    const a = va.dot(va),
      l = va.dot(Oo),
      c = va.dot(ty),
      d = Oo.dot(Oo),
      p = Oo.dot(ty),
      m = a * d - l * l;
    if (m === 0) return s.set(0, 0, 0), null;
    const y = 1 / m,
      v = (d * c - l * p) * y,
      A = (a * p - l * c) * y;
    return s.set(1 - v - A, A, v);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, ko) === null
      ? !1
      : ko.x >= 0 && ko.y >= 0 && ko.x + ko.y <= 1;
  }
  static getInterpolation(e, t, n, i, s, a, l, c) {
    return this.getBarycoord(e, t, n, i, ko) === null
      ? ((c.x = 0),
        (c.y = 0),
        "z" in c && (c.z = 0),
        "w" in c && (c.w = 0),
        null)
      : (c.setScalar(0),
        c.addScaledVector(s, ko.x),
        c.addScaledVector(a, ko.y),
        c.addScaledVector(l, ko.z),
        c);
  }
  static getInterpolatedAttribute(e, t, n, i, s, a) {
    return (
      sy.setScalar(0),
      ay.setScalar(0),
      oy.setScalar(0),
      sy.fromBufferAttribute(e, t),
      ay.fromBufferAttribute(e, n),
      oy.fromBufferAttribute(e, i),
      a.setScalar(0),
      a.addScaledVector(sy, s.x),
      a.addScaledVector(ay, s.y),
      a.addScaledVector(oy, s.z),
      a
    );
  }
  static isFrontFacing(e, t, n, i) {
    return va.subVectors(n, t), Oo.subVectors(e, t), va.cross(Oo).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      va.subVectors(this.c, this.b),
      Oo.subVectors(this.a, this.b),
      va.cross(Oo).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return cs.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return cs.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, s) {
    return cs.getInterpolation(e, this.a, this.b, this.c, t, n, i, s);
  }
  containsPoint(e) {
    return cs.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return cs.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      s = this.c;
    let a, l;
    Nd.subVectors(i, n), Ud.subVectors(s, n), ny.subVectors(e, n);
    const c = Nd.dot(ny),
      d = Ud.dot(ny);
    if (c <= 0 && d <= 0) return t.copy(n);
    ry.subVectors(e, i);
    const p = Nd.dot(ry),
      m = Ud.dot(ry);
    if (p >= 0 && m <= p) return t.copy(i);
    const y = c * m - p * d;
    if (y <= 0 && c >= 0 && p <= 0)
      return (a = c / (c - p)), t.copy(n).addScaledVector(Nd, a);
    iy.subVectors(e, s);
    const v = Nd.dot(iy),
      A = Ud.dot(iy);
    if (A >= 0 && v <= A) return t.copy(s);
    const M = v * d - c * A;
    if (M <= 0 && d >= 0 && A <= 0)
      return (l = d / (d - A)), t.copy(n).addScaledVector(Ud, l);
    const w = p * A - v * m;
    if (w <= 0 && m - p >= 0 && v - A >= 0)
      return (
        u_.subVectors(s, i),
        (l = (m - p) / (m - p + (v - A))),
        t.copy(i).addScaledVector(u_, l)
      );
    const x = 1 / (w + M + y);
    return (
      (a = M * x),
      (l = y * x),
      t.copy(n).addScaledVector(Nd, a).addScaledVector(Ud, l)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const V5 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ll = { h: 0, s: 0, l: 0 },
  A1 = { h: 0, s: 0, l: 0 };
function ly(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? r + (e - r) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? r + (e - r) * 6 * (2 / 3 - t)
          : r
  );
}
class dt {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
          ? this.setHex(i)
          : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Ei) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Sn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = Sn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      Sn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = Sn.workingColorSpace) {
    if (((e = D3(e, 1)), (t = en(t, 0, 1)), (n = en(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - s;
      (this.r = ly(a, s, e + 1 / 3)),
        (this.g = ly(a, s, e)),
        (this.b = ly(a, s, e - 1 / 3));
    }
    return Sn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Ei) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored.",
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = i[1],
        l = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l,
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t,
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l,
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t,
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                l,
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t,
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t,
        );
      if (a === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Ei) {
    const n = V5[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Yo(e.r)), (this.g = Yo(e.g)), (this.b = Yo(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = oh(e.r)), (this.g = oh(e.g)), (this.b = oh(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ei) {
    return (
      Sn.fromWorkingColorSpace(wi.copy(this), e),
      Math.round(en(wi.r * 255, 0, 255)) * 65536 +
        Math.round(en(wi.g * 255, 0, 255)) * 256 +
        Math.round(en(wi.b * 255, 0, 255))
    );
  }
  getHexString(e = Ei) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Sn.workingColorSpace) {
    Sn.fromWorkingColorSpace(wi.copy(this), t);
    const n = wi.r,
      i = wi.g,
      s = wi.b,
      a = Math.max(n, i, s),
      l = Math.min(n, i, s);
    let c, d;
    const p = (l + a) / 2;
    if (l === a) (c = 0), (d = 0);
    else {
      const m = a - l;
      switch (((d = p <= 0.5 ? m / (a + l) : m / (2 - a - l)), a)) {
        case n:
          c = (i - s) / m + (i < s ? 6 : 0);
          break;
        case i:
          c = (s - n) / m + 2;
          break;
        case s:
          c = (n - i) / m + 4;
          break;
      }
      c /= 6;
    }
    return (e.h = c), (e.s = d), (e.l = p), e;
  }
  getRGB(e, t = Sn.workingColorSpace) {
    return (
      Sn.fromWorkingColorSpace(wi.copy(this), t),
      (e.r = wi.r),
      (e.g = wi.g),
      (e.b = wi.b),
      e
    );
  }
  getStyle(e = Ei) {
    Sn.fromWorkingColorSpace(wi.copy(this), e);
    const t = wi.r,
      n = wi.g,
      i = wi.b;
    return e !== Ei
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(Ll), this.setHSL(Ll.h + e, Ll.s + t, Ll.l + n);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Ll), e.getHSL(A1);
    const n = mp(Ll.h, A1.h, t),
      i = mp(Ll.s, A1.s, t),
      s = mp(Ll.l, A1.l, t);
    return this.setHSL(n, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * n + s[6] * i),
      (this.g = s[1] * t + s[4] * n + s[7] * i),
      (this.b = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const wi = new dt();
dt.NAMES = V5;
let CR = 0;
class Dr extends oo {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: CR++ }),
      (this.uuid = Ms()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Sc),
      (this.side = ro),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = T0),
      (this.blendDst = R0),
      (this.blendEquation = Hl),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new dt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Pc),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = wv),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = hc),
      (this.stencilZFail = hc),
      (this.stencilZPass = hc),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`,
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`,
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
            ? i.copy(n)
            : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Sc && (n.blending = this.blending),
      this.side !== ro && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== T0 && (n.blendSrc = this.blendSrc),
      this.blendDst !== R0 && (n.blendDst = this.blendDst),
      this.blendEquation !== Hl && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== Pc && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== wv && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== hc && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== hc && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== hc && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(s) {
      const a = [];
      for (const l in s) {
        const c = s[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (t) {
      const s = i(e.textures),
        a = i(e.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class ds extends Dr {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Cs()),
      (this.combine = Zp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Go = TR();
function TR() {
  const r = new ArrayBuffer(4),
    e = new Float32Array(r),
    t = new Uint32Array(r),
    n = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const d = c - 127;
    d < -27
      ? ((n[c] = 0), (n[c | 256] = 32768), (i[c] = 24), (i[c | 256] = 24))
      : d < -14
        ? ((n[c] = 1024 >> (-d - 14)),
          (n[c | 256] = (1024 >> (-d - 14)) | 32768),
          (i[c] = -d - 1),
          (i[c | 256] = -d - 1))
        : d <= 15
          ? ((n[c] = (d + 15) << 10),
            (n[c | 256] = ((d + 15) << 10) | 32768),
            (i[c] = 13),
            (i[c | 256] = 13))
          : d < 128
            ? ((n[c] = 31744),
              (n[c | 256] = 64512),
              (i[c] = 24),
              (i[c | 256] = 24))
            : ((n[c] = 31744),
              (n[c | 256] = 64512),
              (i[c] = 13),
              (i[c | 256] = 13));
  }
  const s = new Uint32Array(2048),
    a = new Uint32Array(64),
    l = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let d = c << 13,
      p = 0;
    for (; !(d & 8388608); ) (d <<= 1), (p -= 8388608);
    (d &= -8388609), (p += 947912704), (s[c] = d | p);
  }
  for (let c = 1024; c < 2048; ++c) s[c] = 939524096 + ((c - 1024) << 13);
  for (let c = 1; c < 31; ++c) a[c] = c << 23;
  (a[31] = 1199570944), (a[32] = 2147483648);
  for (let c = 33; c < 63; ++c) a[c] = 2147483648 + ((c - 32) << 23);
  a[63] = 3347054592;
  for (let c = 1; c < 64; ++c) c !== 32 && (l[c] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: a,
    offsetTable: l,
  };
}
function us(r) {
  Math.abs(r) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (r = en(r, -65504, 65504)),
    (Go.floatView[0] = r);
  const e = Go.uint32View[0],
    t = (e >> 23) & 511;
  return Go.baseTable[t] + ((e & 8388607) >> Go.shiftTable[t]);
}
function $f(r) {
  const e = r >> 10;
  return (
    (Go.uint32View[0] =
      Go.mantissaTable[Go.offsetTable[e] + (r & 1023)] + Go.exponentTable[e]),
    Go.floatView[0]
  );
}
const bc = { toHalfFloat: us, fromHalfFloat: $f },
  Pr = new Y(),
  w1 = new je();
class Tn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = Tp),
      (this.updateRanges = []),
      (this.gpuType = or),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        w1.fromBufferAttribute(this, t),
          w1.applyMatrix3(e),
          this.setXY(t, w1.x, w1.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Pr.fromBufferAttribute(this, t),
          Pr.applyMatrix3(e),
          this.setXYZ(t, Pr.x, Pr.y, Pr.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Pr.fromBufferAttribute(this, t),
        Pr.applyMatrix4(e),
        this.setXYZ(t, Pr.x, Pr.y, Pr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Pr.fromBufferAttribute(this, t),
        Pr.applyNormalMatrix(e),
        this.setXYZ(t, Pr.x, Pr.y, Pr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Pr.fromBufferAttribute(this, t),
        Pr.transformDirection(e),
        this.setXYZ(t, Pr.x, Pr.y, Pr.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Wi(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = on(n, this.array)),
      (this.array[e * this.itemSize + t] = n),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = on(t, this.array)), (n = on(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (n = on(n, this.array)),
        (i = on(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (n = on(n, this.array)),
        (i = on(i, this.array)),
        (s = on(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Tp && (e.usage = this.usage),
      e
    );
  }
}
class RR extends Tn {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class IR extends Tn {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class BR extends Tn {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class PR extends Tn {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class N3 extends Tn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class LR extends Tn {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class U3 extends Tn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class DR extends Tn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = $f(this.array[e * this.itemSize]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize] = us(t)),
      this
    );
  }
  getY(e) {
    let t = $f(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 1] = us(t)),
      this
    );
  }
  getZ(e) {
    let t = $f(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 2] = us(t)),
      this
    );
  }
  getW(e) {
    let t = $f(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.array[e * this.itemSize + 3] = us(t)),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = on(t, this.array)), (n = on(n, this.array))),
      (this.array[e + 0] = us(t)),
      (this.array[e + 1] = us(n)),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (n = on(n, this.array)),
        (i = on(i, this.array))),
      (this.array[e + 0] = us(t)),
      (this.array[e + 1] = us(n)),
      (this.array[e + 2] = us(i)),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = on(t, this.array)),
        (n = on(n, this.array)),
        (i = on(i, this.array)),
        (s = on(s, this.array))),
      (this.array[e + 0] = us(t)),
      (this.array[e + 1] = us(n)),
      (this.array[e + 2] = us(i)),
      (this.array[e + 3] = us(s)),
      this
    );
  }
}
class Lt extends Tn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let FR = 0;
const Gs = new jt(),
  uy = new _n(),
  Od = new Y(),
  ws = new Ti(),
  Ff = new Ti(),
  qr = new Y();
class tn extends oo {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: FR++ }),
      (this.uuid = Ms()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (O5(e) ? U3 : N3)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new an().getNormalMatrix(e);
      n.applyNormalMatrix(s), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Gs.makeRotationFromQuaternion(e), this.applyMatrix4(Gs), this;
  }
  rotateX(e) {
    return Gs.makeRotationX(e), this.applyMatrix4(Gs), this;
  }
  rotateY(e) {
    return Gs.makeRotationY(e), this.applyMatrix4(Gs), this;
  }
  rotateZ(e) {
    return Gs.makeRotationZ(e), this.applyMatrix4(Gs), this;
  }
  translate(e, t, n) {
    return Gs.makeTranslation(e, t, n), this.applyMatrix4(Gs), this;
  }
  scale(e, t, n) {
    return Gs.makeScale(e, t, n), this.applyMatrix4(Gs), this;
  }
  lookAt(e) {
    return uy.lookAt(e), uy.updateMatrix(), this.applyMatrix4(uy.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Od).negate(),
      this.translate(Od.x, Od.y, Od.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let i = 0, s = e.length; i < s; i++) {
        const a = e[i];
        n.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Lt(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let i = 0; i < n; i++) {
        const s = e[i];
        t.setXYZ(i, s.x, s.y, s.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.",
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ti());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this,
      ),
        this.boundingBox.set(
          new Y(-1 / 0, -1 / 0, -1 / 0),
          new Y(1 / 0, 1 / 0, 1 / 0),
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const s = t[n];
          ws.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (qr.addVectors(this.boundingBox.min, ws.min),
                this.boundingBox.expandByPoint(qr),
                qr.addVectors(this.boundingBox.max, ws.max),
                this.boundingBox.expandByPoint(qr))
              : (this.boundingBox.expandByPoint(ws.min),
                this.boundingBox.expandByPoint(ws.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ui());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this,
      ),
        this.boundingSphere.set(new Y(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((ws.setFromBufferAttribute(e), t))
        for (let s = 0, a = t.length; s < a; s++) {
          const l = t[s];
          Ff.setFromBufferAttribute(l),
            this.morphTargetsRelative
              ? (qr.addVectors(ws.min, Ff.min),
                ws.expandByPoint(qr),
                qr.addVectors(ws.max, Ff.max),
                ws.expandByPoint(qr))
              : (ws.expandByPoint(Ff.min), ws.expandByPoint(Ff.max));
        }
      ws.getCenter(n);
      let i = 0;
      for (let s = 0, a = e.count; s < a; s++)
        qr.fromBufferAttribute(e, s),
          (i = Math.max(i, n.distanceToSquared(qr)));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const l = t[s],
            c = this.morphTargetsRelative;
          for (let d = 0, p = l.count; d < p; d++)
            qr.fromBufferAttribute(l, d),
              c && (Od.fromBufferAttribute(e, d), qr.add(Od)),
              (i = Math.max(i, n.distanceToSquared(qr)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
      );
      return;
    }
    const n = t.position,
      i = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Tn(new Float32Array(4 * n.count), 4));
    const a = this.getAttribute("tangent"),
      l = [],
      c = [];
    for (let z = 0; z < n.count; z++) (l[z] = new Y()), (c[z] = new Y());
    const d = new Y(),
      p = new Y(),
      m = new Y(),
      y = new je(),
      v = new je(),
      A = new je(),
      M = new Y(),
      w = new Y();
    function x(z, L, N) {
      d.fromBufferAttribute(n, z),
        p.fromBufferAttribute(n, L),
        m.fromBufferAttribute(n, N),
        y.fromBufferAttribute(s, z),
        v.fromBufferAttribute(s, L),
        A.fromBufferAttribute(s, N),
        p.sub(d),
        m.sub(d),
        v.sub(y),
        A.sub(y);
      const X = 1 / (v.x * A.y - A.x * v.y);
      isFinite(X) &&
        (M.copy(p)
          .multiplyScalar(A.y)
          .addScaledVector(m, -v.y)
          .multiplyScalar(X),
        w
          .copy(m)
          .multiplyScalar(v.x)
          .addScaledVector(p, -A.x)
          .multiplyScalar(X),
        l[z].add(M),
        l[L].add(M),
        l[N].add(M),
        c[z].add(w),
        c[L].add(w),
        c[N].add(w));
    }
    let C = this.groups;
    C.length === 0 && (C = [{ start: 0, count: e.count }]);
    for (let z = 0, L = C.length; z < L; ++z) {
      const N = C[z],
        X = N.start,
        ie = N.count;
      for (let re = X, me = X + ie; re < me; re += 3)
        x(e.getX(re + 0), e.getX(re + 1), e.getX(re + 2));
    }
    const T = new Y(),
      I = new Y(),
      U = new Y(),
      F = new Y();
    function O(z) {
      U.fromBufferAttribute(i, z), F.copy(U);
      const L = l[z];
      T.copy(L),
        T.sub(U.multiplyScalar(U.dot(L))).normalize(),
        I.crossVectors(F, L);
      const N = I.dot(c[z]) < 0 ? -1 : 1;
      a.setXYZW(z, T.x, T.y, T.z, N);
    }
    for (let z = 0, L = C.length; z < L; ++z) {
      const N = C[z],
        X = N.start,
        ie = N.count;
      for (let re = X, me = X + ie; re < me; re += 3)
        O(e.getX(re + 0)), O(e.getX(re + 1)), O(e.getX(re + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new Tn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let y = 0, v = n.count; y < v; y++) n.setXYZ(y, 0, 0, 0);
      const i = new Y(),
        s = new Y(),
        a = new Y(),
        l = new Y(),
        c = new Y(),
        d = new Y(),
        p = new Y(),
        m = new Y();
      if (e)
        for (let y = 0, v = e.count; y < v; y += 3) {
          const A = e.getX(y + 0),
            M = e.getX(y + 1),
            w = e.getX(y + 2);
          i.fromBufferAttribute(t, A),
            s.fromBufferAttribute(t, M),
            a.fromBufferAttribute(t, w),
            p.subVectors(a, s),
            m.subVectors(i, s),
            p.cross(m),
            l.fromBufferAttribute(n, A),
            c.fromBufferAttribute(n, M),
            d.fromBufferAttribute(n, w),
            l.add(p),
            c.add(p),
            d.add(p),
            n.setXYZ(A, l.x, l.y, l.z),
            n.setXYZ(M, c.x, c.y, c.z),
            n.setXYZ(w, d.x, d.y, d.z);
        }
      else
        for (let y = 0, v = t.count; y < v; y += 3)
          i.fromBufferAttribute(t, y + 0),
            s.fromBufferAttribute(t, y + 1),
            a.fromBufferAttribute(t, y + 2),
            p.subVectors(a, s),
            m.subVectors(i, s),
            p.cross(m),
            n.setXYZ(y + 0, p.x, p.y, p.z),
            n.setXYZ(y + 1, p.x, p.y, p.z),
            n.setXYZ(y + 2, p.x, p.y, p.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      qr.fromBufferAttribute(e, t),
        qr.normalize(),
        e.setXYZ(t, qr.x, qr.y, qr.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const d = l.array,
        p = l.itemSize,
        m = l.normalized,
        y = new d.constructor(c.length * p);
      let v = 0,
        A = 0;
      for (let M = 0, w = c.length; M < w; M++) {
        l.isInterleavedBufferAttribute
          ? (v = c[M] * l.data.stride + l.offset)
          : (v = c[M] * p);
        for (let x = 0; x < p; x++) y[A++] = d[v++];
      }
      return new Tn(y, p, m);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
        ),
        this
      );
    const t = new tn(),
      n = this.index.array,
      i = this.attributes;
    for (const l in i) {
      const c = i[l],
        d = e(c, n);
      t.setAttribute(l, d);
    }
    const s = this.morphAttributes;
    for (const l in s) {
      const c = [],
        d = s[l];
      for (let p = 0, m = d.length; p < m; p++) {
        const y = d[p],
          v = e(y, n);
        c.push(v);
      }
      t.morphAttributes[l] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let l = 0, c = a.length; l < c; l++) {
      const d = a[l];
      t.addGroup(d.start, d.count, d.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const c = this.parameters;
      for (const d in c) c[d] !== void 0 && (e[d] = c[d]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const c in n) {
      const d = n[c];
      e.data.attributes[c] = d.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const c in this.morphAttributes) {
      const d = this.morphAttributes[c],
        p = [];
      for (let m = 0, y = d.length; m < y; m++) {
        const v = d[m];
        p.push(v.toJSON(e.data));
      }
      p.length > 0 && ((i[c] = p), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const l = this.boundingSphere;
    return (
      l !== null &&
        (e.data.boundingSphere = {
          center: l.center.toArray(),
          radius: l.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const d in i) {
      const p = i[d];
      this.setAttribute(d, p.clone(t));
    }
    const s = e.morphAttributes;
    for (const d in s) {
      const p = [],
        m = s[d];
      for (let y = 0, v = m.length; y < v; y++) p.push(m[y].clone(t));
      this.morphAttributes[d] = p;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let d = 0, p = a.length; d < p; d++) {
      const m = a[d];
      this.addGroup(m.start, m.count, m.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return (
      c !== null && (this.boundingSphere = c.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const c_ = new jt(),
  Ku = new Eh(),
  M1 = new ui(),
  d_ = new Y(),
  S1 = new Y(),
  E1 = new Y(),
  C1 = new Y(),
  cy = new Y(),
  T1 = new Y(),
  h_ = new Y(),
  R1 = new Y();
class nr extends _n {
  constructor(e = new tn(), t = new ds()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (n !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let i = 0, s = n.length; i < s; i++) {
          const a = n[i].name || String(i);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = i);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      s = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const l = this.morphTargetInfluences;
    if (s && l) {
      T1.set(0, 0, 0);
      for (let c = 0, d = s.length; c < d; c++) {
        const p = l[c],
          m = s[c];
        p !== 0 &&
          (cy.fromBufferAttribute(m, e),
          a ? T1.addScaledVector(cy, p) : T1.addScaledVector(cy.sub(t), p));
      }
      t.add(T1);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      M1.copy(n.boundingSphere),
      M1.applyMatrix4(s),
      Ku.copy(e.ray).recast(e.near),
      !(
        M1.containsPoint(Ku.origin) === !1 &&
        (Ku.intersectSphere(M1, d_) === null ||
          Ku.origin.distanceToSquared(d_) > (e.far - e.near) ** 2)
      ) &&
        (c_.copy(s).invert(),
        Ku.copy(e.ray).applyMatrix4(c_),
        !(n.boundingBox !== null && Ku.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, Ku)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const s = this.geometry,
      a = this.material,
      l = s.index,
      c = s.attributes.position,
      d = s.attributes.uv,
      p = s.attributes.uv1,
      m = s.attributes.normal,
      y = s.groups,
      v = s.drawRange;
    if (l !== null)
      if (Array.isArray(a))
        for (let A = 0, M = y.length; A < M; A++) {
          const w = y[A],
            x = a[w.materialIndex],
            C = Math.max(w.start, v.start),
            T = Math.min(
              l.count,
              Math.min(w.start + w.count, v.start + v.count),
            );
          for (let I = C, U = T; I < U; I += 3) {
            const F = l.getX(I),
              O = l.getX(I + 1),
              z = l.getX(I + 2);
            (i = I1(this, x, e, n, d, p, m, F, O, z)),
              i &&
                ((i.faceIndex = Math.floor(I / 3)),
                (i.face.materialIndex = w.materialIndex),
                t.push(i));
          }
        }
      else {
        const A = Math.max(0, v.start),
          M = Math.min(l.count, v.start + v.count);
        for (let w = A, x = M; w < x; w += 3) {
          const C = l.getX(w),
            T = l.getX(w + 1),
            I = l.getX(w + 2);
          (i = I1(this, a, e, n, d, p, m, C, T, I)),
            i && ((i.faceIndex = Math.floor(w / 3)), t.push(i));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let A = 0, M = y.length; A < M; A++) {
          const w = y[A],
            x = a[w.materialIndex],
            C = Math.max(w.start, v.start),
            T = Math.min(
              c.count,
              Math.min(w.start + w.count, v.start + v.count),
            );
          for (let I = C, U = T; I < U; I += 3) {
            const F = I,
              O = I + 1,
              z = I + 2;
            (i = I1(this, x, e, n, d, p, m, F, O, z)),
              i &&
                ((i.faceIndex = Math.floor(I / 3)),
                (i.face.materialIndex = w.materialIndex),
                t.push(i));
          }
        }
      else {
        const A = Math.max(0, v.start),
          M = Math.min(c.count, v.start + v.count);
        for (let w = A, x = M; w < x; w += 3) {
          const C = w,
            T = w + 1,
            I = w + 2;
          (i = I1(this, a, e, n, d, p, m, C, T, I)),
            i && ((i.faceIndex = Math.floor(w / 3)), t.push(i));
        }
      }
  }
}
function NR(r, e, t, n, i, s, a, l) {
  let c;
  if (
    (e.side === Ji
      ? (c = n.intersectTriangle(a, s, i, !0, l))
      : (c = n.intersectTriangle(i, s, a, e.side === ro, l)),
    c === null)
  )
    return null;
  R1.copy(l), R1.applyMatrix4(r.matrixWorld);
  const d = t.ray.origin.distanceTo(R1);
  return d < t.near || d > t.far
    ? null
    : { distance: d, point: R1.clone(), object: r };
}
function I1(r, e, t, n, i, s, a, l, c, d) {
  r.getVertexPosition(l, S1),
    r.getVertexPosition(c, E1),
    r.getVertexPosition(d, C1);
  const p = NR(r, e, t, n, S1, E1, C1, h_);
  if (p) {
    const m = new Y();
    cs.getBarycoord(h_, S1, E1, C1, m),
      i && (p.uv = cs.getInterpolatedAttribute(i, l, c, d, m, new je())),
      s && (p.uv1 = cs.getInterpolatedAttribute(s, l, c, d, m, new je())),
      a &&
        ((p.normal = cs.getInterpolatedAttribute(a, l, c, d, m, new Y())),
        p.normal.dot(n.direction) > 0 && p.normal.multiplyScalar(-1));
    const y = { a: l, b: c, c: d, normal: new Y(), materialIndex: 0 };
    cs.getNormal(S1, E1, C1, y.normal), (p.face = y), (p.barycoord = m);
  }
  return p;
}
class Vc extends tn {
  constructor(e = 1, t = 1, n = 1, i = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: a,
      });
    const l = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (a = Math.floor(a));
    const c = [],
      d = [],
      p = [],
      m = [];
    let y = 0,
      v = 0;
    A("z", "y", "x", -1, -1, n, t, e, a, s, 0),
      A("z", "y", "x", 1, -1, n, t, -e, a, s, 1),
      A("x", "z", "y", 1, 1, e, n, t, i, a, 2),
      A("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
      A("x", "y", "z", 1, -1, e, t, n, i, s, 4),
      A("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
      this.setIndex(c),
      this.setAttribute("position", new Lt(d, 3)),
      this.setAttribute("normal", new Lt(p, 3)),
      this.setAttribute("uv", new Lt(m, 2));
    function A(M, w, x, C, T, I, U, F, O, z, L) {
      const N = I / O,
        X = U / z,
        ie = I / 2,
        re = U / 2,
        me = F / 2,
        _e = O + 1,
        ge = z + 1;
      let Re = 0,
        J = 0;
      const oe = new Y();
      for (let ae = 0; ae < ge; ae++) {
        const q = ae * X - re;
        for (let ce = 0; ce < _e; ce++) {
          const Xe = ce * N - ie;
          (oe[M] = Xe * C),
            (oe[w] = q * T),
            (oe[x] = me),
            d.push(oe.x, oe.y, oe.z),
            (oe[M] = 0),
            (oe[w] = 0),
            (oe[x] = F > 0 ? 1 : -1),
            p.push(oe.x, oe.y, oe.z),
            m.push(ce / O),
            m.push(1 - ae / z),
            (Re += 1);
        }
      }
      for (let ae = 0; ae < z; ae++)
        for (let q = 0; q < O; q++) {
          const ce = y + q + _e * ae,
            Xe = y + q + _e * (ae + 1),
            ye = y + (q + 1) + _e * (ae + 1),
            Pe = y + (q + 1) + _e * ae;
          c.push(ce, Xe, Pe), c.push(Xe, ye, Pe), (J += 6);
        }
      l.addGroup(v, J, L), (v += J), (y += Re);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Vc(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    );
  }
}
function vh(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const n in r[t]) {
      const i = r[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
          ? (e[t][n] = i.slice())
          : (e[t][n] = i);
    }
  }
  return e;
}
function ji(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const n = vh(r[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function UR(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) e.push(r[t].clone());
  return e;
}
function G5(r) {
  const e = r.getRenderTarget();
  return e === null
    ? r.outputColorSpace
    : e.isXRRenderTarget === !0
      ? e.texture.colorSpace
      : Sn.workingColorSpace;
}
const j5 = { clone: vh, merge: ji };
var OR = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  kR = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class fs extends Dr {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = OR),
      (this.fragmentShader = kR),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = vh(e.uniforms)),
      (this.uniformsGroups = UR(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const s = this.uniforms[i].value;
      s && s.isTexture
        ? (t.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
        : s && s.isColor
          ? (t.uniforms[i] = { type: "c", value: s.getHex() })
          : s && s.isVector2
            ? (t.uniforms[i] = { type: "v2", value: s.toArray() })
            : s && s.isVector3
              ? (t.uniforms[i] = { type: "v3", value: s.toArray() })
              : s && s.isVector4
                ? (t.uniforms[i] = { type: "v4", value: s.toArray() })
                : s && s.isMatrix3
                  ? (t.uniforms[i] = { type: "m3", value: s.toArray() })
                  : s && s.isMatrix4
                    ? (t.uniforms[i] = { type: "m4", value: s.toArray() })
                    : (t.uniforms[i] = { value: s });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class $p extends _n {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new jt()),
      (this.projectionMatrix = new jt()),
      (this.projectionMatrixInverse = new jt()),
      (this.coordinateSystem = Ka);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Dl = new Y(),
  f_ = new je(),
  p_ = new je();
class Hr extends $p {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = yh * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Cc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return yh * 2 * Math.atan(Math.tan(Cc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    Dl.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Dl.x, Dl.y).multiplyScalar(-e / Dl.z),
      Dl.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(Dl.x, Dl.y).multiplyScalar(-e / Dl.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, f_, p_), t.subVectors(p_, f_);
  }
  setViewOffset(e, t, n, i, s, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Cc * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      s = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth,
        d = a.fullHeight;
      (s += (a.offsetX * i) / c),
        (t -= (a.offsetY * n) / d),
        (i *= a.width / c),
        (n *= a.height / d);
    }
    const l = this.filmOffset;
    l !== 0 && (s += (e * l) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const kd = -90,
  zd = 1;
class W5 extends _n {
  constructor(e, t, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Hr(kd, zd, e, t);
    (i.layers = this.layers), this.add(i);
    const s = new Hr(kd, zd, e, t);
    (s.layers = this.layers), this.add(s);
    const a = new Hr(kd, zd, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new Hr(kd, zd, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new Hr(kd, zd, e, t);
    (c.layers = this.layers), this.add(c);
    const d = new Hr(kd, zd, e, t);
    (d.layers = this.layers), this.add(d);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, i, s, a, l, c] = t;
    for (const d of t) this.remove(d);
    if (e === Ka)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1);
    else if (e === Rp)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, 1),
        c.up.set(0, -1, 0),
        c.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e,
      );
    for (const d of t) this.add(d), d.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, a, l, c, d, p] = this.children,
      m = e.getRenderTarget(),
      y = e.getActiveCubeFace(),
      v = e.getActiveMipmapLevel(),
      A = e.xr.enabled;
    e.xr.enabled = !1;
    const M = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0, i),
      e.render(t, s),
      e.setRenderTarget(n, 1, i),
      e.render(t, a),
      e.setRenderTarget(n, 2, i),
      e.render(t, l),
      e.setRenderTarget(n, 3, i),
      e.render(t, c),
      e.setRenderTarget(n, 4, i),
      e.render(t, d),
      (n.texture.generateMipmaps = M),
      e.setRenderTarget(n, 5, i),
      e.render(t, p),
      e.setRenderTarget(m, y, v),
      (e.xr.enabled = A),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class em extends Ln {
  constructor(e, t, n, i, s, a, l, c, d, p) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : io),
      super(e, t, n, i, s, a, l, c, d, p),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class O3 extends Es {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    (this.texture = new em(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Un);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Vc(5, 5, 5),
      s = new fs({
        name: "CubemapFromEquirect",
        uniforms: vh(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Ji,
        blending: eo,
      });
    s.uniforms.tEquirect.value = t;
    const a = new nr(i, s),
      l = t.minFilter;
    return (
      t.minFilter === Ys && (t.minFilter = Un),
      new W5(1, 10, this).update(e, a),
      (t.minFilter = l),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(s);
  }
}
class Ng {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new dt(e)),
      (this.density = t);
  }
  clone() {
    return new Ng(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Ug {
  constructor(e, t = 1, n = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new dt(e)),
      (this.near = t),
      (this.far = n);
  }
  clone() {
    return new Ug(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
let xh = class extends _n {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Cs()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Cs()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
  }
  copy(r, e) {
    return (
      super.copy(r, e),
      r.background !== null && (this.background = r.background.clone()),
      r.environment !== null && (this.environment = r.environment.clone()),
      r.fog !== null && (this.fog = r.fog.clone()),
      (this.backgroundBlurriness = r.backgroundBlurriness),
      (this.backgroundIntensity = r.backgroundIntensity),
      this.backgroundRotation.copy(r.backgroundRotation),
      (this.environmentIntensity = r.environmentIntensity),
      this.environmentRotation.copy(r.environmentRotation),
      r.overrideMaterial !== null &&
        (this.overrideMaterial = r.overrideMaterial.clone()),
      (this.matrixAutoUpdate = r.matrixAutoUpdate),
      this
    );
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return (
      this.fog !== null && (e.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (e.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (e.object.backgroundIntensity = this.backgroundIntensity),
      (e.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (e.object.environmentIntensity = this.environmentIntensity),
      (e.object.environmentRotation = this.environmentRotation.toArray()),
      e
    );
  }
};
class tm {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Tp),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Ms());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ms()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid],
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ms()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Gi = new Y();
class Jl {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Gi.fromBufferAttribute(this, t),
        Gi.applyMatrix4(e),
        this.setXYZ(t, Gi.x, Gi.y, Gi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Gi.fromBufferAttribute(this, t),
        Gi.applyNormalMatrix(e),
        this.setXYZ(t, Gi.x, Gi.y, Gi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Gi.fromBufferAttribute(this, t),
        Gi.transformDirection(e),
        this.setXYZ(t, Gi.x, Gi.y, Gi.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = Wi(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = on(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = n),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = on(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = on(t, this.array)), (n = on(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = on(t, this.array)),
        (n = on(n, this.array)),
        (i = on(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = on(t, this.array)),
        (n = on(n, this.array)),
        (i = on(i, this.array)),
        (s = on(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new Tn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized,
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Jl(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class k3 extends Dr {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Hd;
const Nf = new Y(),
  Vd = new Y(),
  Gd = new Y(),
  jd = new je(),
  Uf = new je(),
  X5 = new jt(),
  B1 = new Y(),
  Of = new Y(),
  P1 = new Y(),
  m_ = new je(),
  dy = new je(),
  g_ = new je();
class J5 extends _n {
  constructor(e = new k3()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Hd === void 0)
    ) {
      Hd = new tn();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new tm(t, 5);
      Hd.setIndex([0, 1, 2, 0, 2, 3]),
        Hd.setAttribute("position", new Jl(n, 3, 0, !1)),
        Hd.setAttribute("uv", new Jl(n, 2, 3, !1));
    }
    (this.geometry = Hd), (this.material = e), (this.center = new je(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      Vd.setFromMatrixScale(this.matrixWorld),
      X5.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld,
      ),
      Gd.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Vd.multiplyScalar(-Gd.z);
    const n = this.material.rotation;
    let i, s;
    n !== 0 && ((s = Math.cos(n)), (i = Math.sin(n)));
    const a = this.center;
    L1(B1.set(-0.5, -0.5, 0), Gd, a, Vd, i, s),
      L1(Of.set(0.5, -0.5, 0), Gd, a, Vd, i, s),
      L1(P1.set(0.5, 0.5, 0), Gd, a, Vd, i, s),
      m_.set(0, 0),
      dy.set(1, 0),
      g_.set(1, 1);
    let l = e.ray.intersectTriangle(B1, Of, P1, !1, Nf);
    if (
      l === null &&
      (L1(Of.set(-0.5, 0.5, 0), Gd, a, Vd, i, s),
      dy.set(0, 1),
      (l = e.ray.intersectTriangle(B1, P1, Of, !1, Nf)),
      l === null)
    )
      return;
    const c = e.ray.origin.distanceTo(Nf);
    c < e.near ||
      c > e.far ||
      t.push({
        distance: c,
        point: Nf.clone(),
        uv: cs.getInterpolation(Nf, B1, Of, P1, m_, dy, g_, new je()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function L1(r, e, t, n, i, s) {
  jd.subVectors(r, t).addScalar(0.5).multiply(n),
    i !== void 0
      ? ((Uf.x = s * jd.x - i * jd.y), (Uf.y = i * jd.x + s * jd.y))
      : Uf.copy(jd),
    r.copy(e),
    (r.x += Uf.x),
    (r.y += Uf.y),
    r.applyMatrix4(X5);
}
const D1 = new Y(),
  y_ = new Y();
class Y5 extends _n {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let s;
    for (s = 0; s < i.length && !(t < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: t, hysteresis: n, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let n = 0; n < t.length; n++)
      if (t[n].distance === e) {
        const i = t.splice(n, 1);
        return this.remove(i[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let s = t[n].distance;
        if ((t[n].object.visible && (s -= s * t[n].hysteresis), e < s)) break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      D1.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(D1);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      D1.setFromMatrixPosition(e.matrixWorld),
        y_.setFromMatrixPosition(this.matrixWorld);
      const n = D1.distanceTo(y_) / e.zoom;
      t[0].object.visible = !0;
      let i, s;
      for (i = 1, s = t.length; i < s; i++) {
        let a = t[i].distance;
        if ((t[i].object.visible && (a -= a * t[i].hysteresis), n >= a))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const n = this.levels;
    for (let i = 0, s = n.length; i < s; i++) {
      const a = n[i];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis,
      });
    }
    return t;
  }
}
const v_ = new Y(),
  x_ = new Cn(),
  b_ = new Cn(),
  zR = new Y(),
  __ = new jt(),
  F1 = new Y(),
  hy = new ui(),
  A_ = new jt(),
  fy = new Eh();
class z3 extends nr {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = _v),
      (this.bindMatrix = new jt()),
      (this.bindMatrixInverse = new jt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Ti()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, F1), this.boundingBox.expandByPoint(F1);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new ui()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, F1), this.boundingSphere.expandByPoint(F1);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      i = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      hy.copy(this.boundingSphere),
      hy.applyMatrix4(i),
      e.ray.intersectsSphere(hy) !== !1 &&
        (A_.copy(i).invert(),
        fy.copy(e.ray).applyMatrix4(A_),
        !(
          this.boundingBox !== null && fy.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, fy)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Cn(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === _v
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === w5
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
            );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    x_.fromBufferAttribute(i.attributes.skinIndex, e),
      b_.fromBufferAttribute(i.attributes.skinWeight, e),
      v_.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = b_.getComponent(s);
      if (a !== 0) {
        const l = x_.getComponent(s);
        __.multiplyMatrices(n.bones[l].matrixWorld, n.boneInverses[l]),
          t.addScaledVector(zR.copy(v_).applyMatrix4(__), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Og extends _n {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class wa extends Ln {
  constructor(e = null, t = 1, n = 1, i, s, a, l, c, d = Qr, p = Qr, m, y) {
    super(null, a, l, c, d, p, i, s, m, y),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const w_ = new jt(),
  HR = new jt();
class nm {
  constructor(e = [], t = []) {
    (this.uuid = Ms()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.",
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new jt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new jt();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s] ? e[s].matrixWorld : HR;
      w_.multiplyMatrices(l, t[s]), w_.toArray(n, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new nm(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new wa(t, e, e, wr, or);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const s = e.bones[n];
      let a = t[s];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (a = new Og())),
        this.bones.push(a),
        this.boneInverses.push(new jt().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const l = n[i];
      e.boneInverses.push(l.toArray());
    }
    return e;
  }
}
class Fc extends Tn {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Wd = new jt(),
  M_ = new jt(),
  N1 = [],
  S_ = new Ti(),
  VR = new jt(),
  kf = new nr(),
  zf = new ui();
class H3 extends nr {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Fc(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, VR);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Ti()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Wd),
        S_.copy(e.boundingBox).applyMatrix4(Wd),
        this.boundingBox.union(S_);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new ui()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Wd),
        zf.copy(e.boundingSphere).applyMatrix4(Wd),
        this.boundingSphere.union(zf);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      s = n.length + 1,
      a = e * s + 1;
    for (let l = 0; l < n.length; l++) n[l] = i[a + l];
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((kf.geometry = this.geometry),
      (kf.material = this.material),
      kf.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        zf.copy(this.boundingSphere),
        zf.applyMatrix4(n),
        e.ray.intersectsSphere(zf) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, Wd),
          M_.multiplyMatrices(n, Wd),
          (kf.matrixWorld = M_),
          kf.raycast(e, N1);
        for (let a = 0, l = N1.length; a < l; a++) {
          const c = N1[a];
          (c.instanceId = s), (c.object = this), t.push(c);
        }
        N1.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Fc(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3,
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = n.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new wa(
        new Float32Array(i * this.count),
        i,
        this.count,
        Kp,
        or,
      ));
    const s = this.morphTexture.source.data.data;
    let a = 0;
    for (let d = 0; d < n.length; d++) a += n[d];
    const l = this.geometry.morphTargetsRelative ? 1 : 1 - a,
      c = i * e;
    (s[c] = l), s.set(n, c + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
const py = new Y(),
  GR = new Y(),
  jR = new an();
class kl {
  constructor(e = new Y(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = py.subVectors(n, t).cross(GR.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(py),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || jR.getNormalMatrix(e),
      i = this.coplanarPoint(py).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Qu = new ui(),
  U1 = new Y();
class rm {
  constructor(
    e = new kl(),
    t = new kl(),
    n = new kl(),
    i = new kl(),
    s = new kl(),
    a = new kl(),
  ) {
    this.planes = [e, t, n, i, s, a];
  }
  set(e, t, n, i, s, a) {
    const l = this.planes;
    return (
      l[0].copy(e),
      l[1].copy(t),
      l[2].copy(n),
      l[3].copy(i),
      l[4].copy(s),
      l[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ka) {
    const n = this.planes,
      i = e.elements,
      s = i[0],
      a = i[1],
      l = i[2],
      c = i[3],
      d = i[4],
      p = i[5],
      m = i[6],
      y = i[7],
      v = i[8],
      A = i[9],
      M = i[10],
      w = i[11],
      x = i[12],
      C = i[13],
      T = i[14],
      I = i[15];
    if (
      (n[0].setComponents(c - s, y - d, w - v, I - x).normalize(),
      n[1].setComponents(c + s, y + d, w + v, I + x).normalize(),
      n[2].setComponents(c + a, y + p, w + A, I + C).normalize(),
      n[3].setComponents(c - a, y - p, w - A, I - C).normalize(),
      n[4].setComponents(c - l, y - m, w - M, I - T).normalize(),
      t === Ka)
    )
      n[5].setComponents(c + l, y + m, w + M, I + T).normalize();
    else if (t === Rp) n[5].setComponents(l, m, M, T).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t,
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Qu.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Qu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Qu);
  }
  intersectsSprite(e) {
    return (
      Qu.center.set(0, 0, 0),
      (Qu.radius = 0.7071067811865476),
      Qu.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Qu)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((U1.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (U1.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (U1.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(U1) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function my(r, e) {
  return r - e;
}
function WR(r, e) {
  return r.z - e.z;
}
function XR(r, e) {
  return e.z - r.z;
}
class JR {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, n, i) {
    const s = this.pool,
      a = this.list;
    this.index >= s.length &&
      s.push({ start: -1, count: -1, z: -1, index: -1 });
    const l = s[this.index];
    a.push(l),
      this.index++,
      (l.start = e),
      (l.count = t),
      (l.z = n),
      (l.index = i);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const ls = new jt(),
  YR = new dt(1, 1, 1),
  gy = new rm(),
  O1 = new Ti(),
  $u = new ui(),
  Hf = new Y(),
  E_ = new Y(),
  ZR = new Y(),
  yy = new JR(),
  Mi = new nr(),
  k1 = [];
function qR(r, e, t = 0) {
  const n = e.itemSize;
  if (
    r.isInterleavedBufferAttribute ||
    r.array.constructor !== e.array.constructor
  ) {
    const i = r.count;
    for (let s = 0; s < i; s++)
      for (let a = 0; a < n; a++)
        e.setComponent(s + t, a, r.getComponent(s, a));
  } else e.array.set(r.array, t * n);
  e.needsUpdate = !0;
}
function ec(r, e) {
  if (r.constructor !== e.constructor) {
    const t = Math.min(r.length, e.length);
    for (let n = 0; n < t; n++) e[n] = r[n];
  } else {
    const t = Math.min(r.length, e.length);
    e.set(new r.constructor(r.buffer, 0, t));
  }
}
class Z5 extends nr {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(e, t, n = t * 2, i) {
    super(new tn(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = n),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      n = new wa(t, e, e, wr, or);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      n = new wa(t, e, e, Qp, so);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      n = new wa(t, e, e, wr, or);
    (n.colorSpace = Sn.workingColorSpace), (this._colorsTexture = n);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      n = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const a = e.getAttribute(s),
          { array: l, itemSize: c, normalized: d } = a,
          p = new l.constructor(n * c),
          m = new Tn(p, c, d);
        t.setAttribute(s, m);
      }
      if (e.getIndex() !== null) {
        const s = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new Tn(s, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".',
      );
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`,
        );
      const i = e.getAttribute(n),
        s = t.getAttribute(n);
      if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.",
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`,
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`,
      );
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ti());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const s = t[n].geometryIndex;
      this.getMatrixAt(n, ls),
        this.getBoundingBoxAt(s, O1).applyMatrix4(ls),
        e.union(O1);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ui());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const s = t[n].geometryIndex;
      this.getMatrixAt(n, ls),
        this.getBoundingSphereAt(s, $u).applyMatrix4(ls),
        e.union($u);
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const t = { visible: !0, active: !0, geometryIndex: e };
    let n = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(my),
        (n = this._availableInstanceIds.shift()),
        (this._instanceInfo[n] = t))
      : ((n = this._instanceInfo.length), this._instanceInfo.push(t));
    const i = this._matricesTexture;
    ls.identity().toArray(i.image.data, n * 16), (i.needsUpdate = !0);
    const s = this._colorsTexture;
    return (
      s && (YR.toArray(s.image.data, n * 4), (s.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      n
    );
  }
  addGeometry(e, t = -1, n = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const i = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      s = this._geometryInfo;
    (i.vertexStart = this._nextVertexStart),
      (i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t);
    const a = e.getIndex();
    if (
      (a !== null &&
        ((i.indexStart = this._nextIndexStart),
        (i.reservedIndexCount = n === -1 ? a.count : n)),
      (i.indexStart !== -1 &&
        i.indexStart + i.reservedIndexCount > this._maxIndexCount) ||
        i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.",
      );
    let l;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(my),
          (l = this._availableGeometryIds.shift()),
          (s[l] = i))
        : ((l = this._geometryCount), this._geometryCount++, s.push(i)),
      this.setGeometryAt(l, e),
      (this._nextIndexStart = i.indexStart + i.reservedIndexCount),
      (this._nextVertexStart = i.vertexStart + i.reservedVertexCount),
      l
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry,
      i = n.getIndex() !== null,
      s = n.getIndex(),
      a = t.getIndex(),
      l = this._geometryInfo[e];
    if (
      (i && a.count > l.reservedIndexCount) ||
      t.attributes.position.count > l.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry.",
      );
    const c = l.vertexStart,
      d = l.reservedVertexCount;
    l.vertexCount = t.getAttribute("position").count;
    for (const p in n.attributes) {
      const m = t.getAttribute(p),
        y = n.getAttribute(p);
      qR(m, y, c);
      const v = m.itemSize;
      for (let A = m.count, M = d; A < M; A++) {
        const w = c + A;
        for (let x = 0; x < v; x++) y.setComponent(w, x, 0);
      }
      (y.needsUpdate = !0), y.addUpdateRange(c * v, d * v);
    }
    if (i) {
      const p = l.indexStart,
        m = l.reservedIndexCount;
      l.indexCount = t.getIndex().count;
      for (let y = 0; y < a.count; y++) s.setX(p + y, c + a.getX(y));
      for (let y = a.count, v = m; y < v; y++) s.setX(p + y, c);
      (s.needsUpdate = !0), s.addUpdateRange(p, l.reservedIndexCount);
    }
    return (
      (l.start = i ? l.indexStart : l.vertexStart),
      (l.count = i ? l.indexCount : l.vertexCount),
      (l.boundingBox = null),
      t.boundingBox !== null && (l.boundingBox = t.boundingBox.clone()),
      (l.boundingSphere = null),
      t.boundingSphere !== null &&
        (l.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const n = this._instanceInfo;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].geometryIndex === e && this.deleteInstance(i);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const n = this._geometryInfo,
      i = n
        .map((a, l) => l)
        .sort((a, l) => n[a].vertexStart - n[l].vertexStart),
      s = this.geometry;
    for (let a = 0, l = n.length; a < l; a++) {
      const c = i[a],
        d = n[c];
      if (d.active !== !1) {
        if (s.index !== null) {
          if (d.indexStart !== t) {
            const { indexStart: p, vertexStart: m, reservedIndexCount: y } = d,
              v = s.index,
              A = v.array,
              M = e - m;
            for (let w = p; w < p + y; w++) A[w] = A[w] + M;
            v.array.copyWithin(t, p, p + y),
              v.addUpdateRange(t, y),
              (d.indexStart = t);
          }
          t += d.reservedIndexCount;
        }
        if (d.vertexStart !== e) {
          const { vertexStart: p, reservedVertexCount: m } = d,
            y = s.attributes;
          for (const v in y) {
            const A = y[v],
              { array: M, itemSize: w } = A;
            M.copyWithin(e * w, p * w, (p + m) * w),
              A.addUpdateRange(e * w, m * w);
          }
          d.vertexStart = e;
        }
        (e += d.reservedVertexCount),
          (d.start = s.index ? d.indexStart : d.vertexStart),
          (this._nextIndexStart = s.index
            ? d.indexStart + d.reservedIndexCount
            : 0),
          (this._nextVertexStart = d.vertexStart + d.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingBox === null) {
      const s = new Ti(),
        a = n.index,
        l = n.attributes.position;
      for (let c = i.start, d = i.start + i.count; c < d; c++) {
        let p = c;
        a && (p = a.getX(p)), s.expandByPoint(Hf.fromBufferAttribute(l, p));
      }
      i.boundingBox = s;
    }
    return t.copy(i.boundingBox), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingSphere === null) {
      const s = new ui();
      this.getBoundingBoxAt(e, O1), O1.getCenter(s.center);
      const a = n.index,
        l = n.attributes.position;
      let c = 0;
      for (let d = i.start, p = i.start + i.count; d < p; d++) {
        let m = d;
        a && (m = a.getX(m)),
          Hf.fromBufferAttribute(l, m),
          (c = Math.max(c, s.center.distanceToSquared(Hf)));
      }
      (s.radius = Math.sqrt(c)), (i.boundingSphere = s);
    }
    return t.copy(i.boundingSphere), t;
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const n = this._matricesTexture,
      i = this._matricesTexture.image.data;
    return t.toArray(i, e * 16), (n.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const n = this._geometryInfo[e];
    return (
      (t.vertexStart = n.vertexStart),
      (t.vertexCount = n.vertexCount),
      (t.reservedVertexCount = n.reservedVertexCount),
      (t.indexStart = n.indexStart),
      (t.indexCount = n.indexCount),
      (t.reservedIndexCount = n.reservedIndexCount),
      (t.start = n.start),
      (t.count = n.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      n = this._instanceInfo;
    for (t.sort(my); t[t.length - 1] === n.length; ) n.pop(), t.pop();
    if (e < n.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`,
      );
    const i = new Int32Array(e),
      s = new Int32Array(e);
    ec(this._multiDrawCounts, i),
      ec(this._multiDrawStarts, s),
      (this._multiDrawCounts = i),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = e);
    const a = this._indirectTexture,
      l = this._matricesTexture,
      c = this._colorsTexture;
    a.dispose(),
      this._initIndirectTexture(),
      ec(a.image.data, this._indirectTexture.image.data),
      l.dispose(),
      this._initMatricesTexture(),
      ec(l.image.data, this._matricesTexture.image.data),
      c &&
        (c.dispose(),
        this._initColorsTexture(),
        ec(c.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(e, t) {
    const n = [...this._geometryInfo].filter((a) => a.active);
    if (Math.max(...n.map((a) => a.vertexStart + a.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`,
      );
    if (
      this.geometry.index &&
      Math.max(...n.map((a) => a.indexStart + a.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`,
      );
    const i = this.geometry;
    i.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new tn()),
        this._initializeGeometry(i));
    const s = this.geometry;
    i.index && ec(i.index.array, s.index.array);
    for (const a in i.attributes)
      ec(i.attributes[a].array, s.attributes[a].array);
  }
  raycast(e, t) {
    const n = this._instanceInfo,
      i = this._geometryInfo,
      s = this.matrixWorld,
      a = this.geometry;
    (Mi.material = this.material),
      (Mi.geometry.index = a.index),
      (Mi.geometry.attributes = a.attributes),
      Mi.geometry.boundingBox === null && (Mi.geometry.boundingBox = new Ti()),
      Mi.geometry.boundingSphere === null &&
        (Mi.geometry.boundingSphere = new ui());
    for (let l = 0, c = n.length; l < c; l++) {
      if (!n[l].visible || !n[l].active) continue;
      const d = n[l].geometryIndex,
        p = i[d];
      Mi.geometry.setDrawRange(p.start, p.count),
        this.getMatrixAt(l, Mi.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(d, Mi.geometry.boundingBox),
        this.getBoundingSphereAt(d, Mi.geometry.boundingSphere),
        Mi.raycast(e, k1);
      for (let m = 0, y = k1.length; m < y; m++) {
        const v = k1[m];
        (v.object = this), (v.batchId = l), t.push(v);
      }
      k1.length = 0;
    }
    (Mi.material = null),
      (Mi.geometry.index = null),
      (Mi.geometry.attributes = {}),
      Mi.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, n, i, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const a = i.getIndex(),
      l = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
      c = this._instanceInfo,
      d = this._multiDrawStarts,
      p = this._multiDrawCounts,
      m = this._geometryInfo,
      y = this.perObjectFrustumCulled,
      v = this._indirectTexture,
      A = v.image.data;
    y &&
      (ls
        .multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse)
        .multiply(this.matrixWorld),
      gy.setFromProjectionMatrix(ls, e.coordinateSystem));
    let M = 0;
    if (this.sortObjects) {
      ls.copy(this.matrixWorld).invert(),
        Hf.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ls),
        E_.set(0, 0, -1)
          .transformDirection(n.matrixWorld)
          .transformDirection(ls);
      for (let C = 0, T = c.length; C < T; C++)
        if (c[C].visible && c[C].active) {
          const I = c[C].geometryIndex;
          this.getMatrixAt(C, ls),
            this.getBoundingSphereAt(I, $u).applyMatrix4(ls);
          let U = !1;
          if ((y && (U = !gy.intersectsSphere($u)), !U)) {
            const F = m[I],
              O = ZR.subVectors($u.center, Hf).dot(E_);
            yy.push(F.start, F.count, O, C);
          }
        }
      const w = yy.list,
        x = this.customSort;
      x === null ? w.sort(s.transparent ? XR : WR) : x.call(this, w, n);
      for (let C = 0, T = w.length; C < T; C++) {
        const I = w[C];
        (d[M] = I.start * l), (p[M] = I.count), (A[M] = I.index), M++;
      }
      yy.reset();
    } else
      for (let w = 0, x = c.length; w < x; w++)
        if (c[w].visible && c[w].active) {
          const C = c[w].geometryIndex;
          let T = !1;
          if (
            (y &&
              (this.getMatrixAt(w, ls),
              this.getBoundingSphereAt(C, $u).applyMatrix4(ls),
              (T = !gy.intersectsSphere($u))),
            !T)
          ) {
            const I = m[C];
            (d[M] = I.start * l), (p[M] = I.count), (A[M] = w), M++;
          }
        }
    (v.needsUpdate = !0),
      (this._multiDrawCount = M),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, n, i, s, a) {
    this.onBeforeRender(e, null, i, s, a);
  }
}
class Ii extends Dr {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const cg = new Y(),
  dg = new Y(),
  C_ = new jt(),
  Vf = new Eh(),
  z1 = new ui(),
  vy = new Y(),
  T_ = new Y();
class Ko extends _n {
  constructor(e = new tn(), t = new Ii()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, s = t.count; i < s; i++)
        cg.fromBufferAttribute(t, i - 1),
          dg.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += cg.distanceTo(dg));
      e.setAttribute("lineDistance", new Lt(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      z1.copy(n.boundingSphere),
      z1.applyMatrix4(i),
      (z1.radius += s),
      e.ray.intersectsSphere(z1) === !1)
    )
      return;
    C_.copy(i).invert(), Vf.copy(e.ray).applyMatrix4(C_);
    const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = l * l,
      d = this.isLineSegments ? 2 : 1,
      p = n.index,
      m = n.attributes.position;
    if (p !== null) {
      const y = Math.max(0, a.start),
        v = Math.min(p.count, a.start + a.count);
      for (let A = y, M = v - 1; A < M; A += d) {
        const w = p.getX(A),
          x = p.getX(A + 1),
          C = H1(this, e, Vf, c, w, x);
        C && t.push(C);
      }
      if (this.isLineLoop) {
        const A = p.getX(v - 1),
          M = p.getX(y),
          w = H1(this, e, Vf, c, A, M);
        w && t.push(w);
      }
    } else {
      const y = Math.max(0, a.start),
        v = Math.min(m.count, a.start + a.count);
      for (let A = y, M = v - 1; A < M; A += d) {
        const w = H1(this, e, Vf, c, A, A + 1);
        w && t.push(w);
      }
      if (this.isLineLoop) {
        const A = H1(this, e, Vf, c, v - 1, y);
        A && t.push(A);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (n !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let i = 0, s = n.length; i < s; i++) {
          const a = n[i].name || String(i);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = i);
        }
      }
    }
  }
}
function H1(r, e, t, n, i, s) {
  const a = r.geometry.attributes.position;
  if (
    (cg.fromBufferAttribute(a, i),
    dg.fromBufferAttribute(a, s),
    t.distanceSqToSegment(cg, dg, vy, T_) > n)
  )
    return;
  vy.applyMatrix4(r.matrixWorld);
  const l = e.ray.origin.distanceTo(vy);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      point: T_.clone().applyMatrix4(r.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r,
    };
}
const R_ = new Y(),
  I_ = new Y();
class Ea extends Ko {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        R_.fromBufferAttribute(t, i),
          I_.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + R_.distanceTo(I_));
      e.setAttribute("lineDistance", new Lt(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
}
class V3 extends Ko {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class kg extends Dr {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const B_ = new jt(),
  Sv = new Eh(),
  V1 = new ui(),
  G1 = new Y();
class G3 extends _n {
  constructor(e = new tn(), t = new kg()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      V1.copy(n.boundingSphere),
      V1.applyMatrix4(i),
      (V1.radius += s),
      e.ray.intersectsSphere(V1) === !1)
    )
      return;
    B_.copy(i).invert(), Sv.copy(e.ray).applyMatrix4(B_);
    const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = l * l,
      d = n.index,
      p = n.attributes.position;
    if (d !== null) {
      const m = Math.max(0, a.start),
        y = Math.min(d.count, a.start + a.count);
      for (let v = m, A = y; v < A; v++) {
        const M = d.getX(v);
        G1.fromBufferAttribute(p, M), P_(G1, M, c, i, e, t, this);
      }
    } else {
      const m = Math.max(0, a.start),
        y = Math.min(p.count, a.start + a.count);
      for (let v = m, A = y; v < A; v++)
        G1.fromBufferAttribute(p, v), P_(G1, v, c, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      const n = e[t[0]];
      if (n !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let i = 0, s = n.length; i < s; i++) {
          const a = n[i].name || String(i);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = i);
        }
      }
    }
  }
}
function P_(r, e, t, n, i, s, a) {
  const l = Sv.distanceSqToPoint(r);
  if (l < t) {
    const c = new Y();
    Sv.closestPointToPoint(r, c), c.applyMatrix4(n);
    const d = i.ray.origin.distanceTo(c);
    if (d < i.near || d > i.far) return;
    s.push({
      distance: d,
      distanceToRay: Math.sqrt(l),
      point: c,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a,
    });
  }
}
class jo extends _n {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
class KR extends Ln {
  constructor(e, t, n, i, s, a, l, c, d) {
    super(e, t, n, i, s, a, l, c, d),
      (this.isVideoTexture = !0),
      (this.minFilter = a !== void 0 ? a : Un),
      (this.magFilter = s !== void 0 ? s : Un),
      (this.generateMipmaps = !1);
    const p = this;
    function m() {
      (p.needsUpdate = !0), e.requestVideoFrameCallback(m);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(m);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    !("requestVideoFrameCallback" in e) &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class QR extends Ln {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Qr),
      (this.minFilter = Qr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class zg extends Ln {
  constructor(e, t, n, i, s, a, l, c, d, p, m, y) {
    super(null, a, l, c, d, p, i, s, m, y),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class $R extends zg {
  constructor(e, t, n, i, s, a) {
    super(e, t, n, s, a),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Ar),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class eI extends zg {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, io),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class tI extends Ln {
  constructor(e, t, n, i, s, a, l, c, d) {
    super(e, t, n, i, s, a, l, c, d),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class j3 extends Ln {
  constructor(e, t, n, i, s, a, l, c, d, p = Ec) {
    if (p !== Ec && p !== Dc)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
      );
    n === void 0 && p === Ec && (n = so),
      n === void 0 && p === Dc && (n = Lc),
      super(null, i, s, a, l, c, p, n, d),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = l !== void 0 ? l : Qr),
      (this.minFilter = c !== void 0 ? c : Qr),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class Ca {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      i = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      (n = this.getPoint(a / e)), (s += n.distanceTo(i)), t.push(s), (i = n);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const s = n.length;
    let a;
    t ? (a = t) : (a = e * n[s - 1]);
    let l = 0,
      c = s - 1,
      d;
    for (; l <= c; )
      if (((i = Math.floor(l + (c - l) / 2)), (d = n[i] - a), d < 0)) l = i + 1;
      else if (d > 0) c = i - 1;
      else {
        c = i;
        break;
      }
    if (((i = c), n[i] === a)) return i / (s - 1);
    const p = n[i],
      m = n[i + 1] - p,
      y = (a - p) / m;
    return (i + y) / (s - 1);
  }
  getTangent(e, t) {
    let n = e - 1e-4,
      i = e + 1e-4;
    n < 0 && (n = 0), i > 1 && (i = 1);
    const s = this.getPoint(n),
      a = this.getPoint(i),
      l = t || (s.isVector2 ? new je() : new Y());
    return l.copy(a).sub(s).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new Y(),
      i = [],
      s = [],
      a = [],
      l = new Y(),
      c = new jt();
    for (let v = 0; v <= e; v++) {
      const A = v / e;
      i[v] = this.getTangentAt(A, new Y());
    }
    (s[0] = new Y()), (a[0] = new Y());
    let d = Number.MAX_VALUE;
    const p = Math.abs(i[0].x),
      m = Math.abs(i[0].y),
      y = Math.abs(i[0].z);
    p <= d && ((d = p), n.set(1, 0, 0)),
      m <= d && ((d = m), n.set(0, 1, 0)),
      y <= d && n.set(0, 0, 1),
      l.crossVectors(i[0], n).normalize(),
      s[0].crossVectors(i[0], l),
      a[0].crossVectors(i[0], s[0]);
    for (let v = 1; v <= e; v++) {
      if (
        ((s[v] = s[v - 1].clone()),
        (a[v] = a[v - 1].clone()),
        l.crossVectors(i[v - 1], i[v]),
        l.length() > Number.EPSILON)
      ) {
        l.normalize();
        const A = Math.acos(en(i[v - 1].dot(i[v]), -1, 1));
        s[v].applyMatrix4(c.makeRotationAxis(l, A));
      }
      a[v].crossVectors(i[v], s[v]);
    }
    if (t === !0) {
      let v = Math.acos(en(s[0].dot(s[e]), -1, 1));
      (v /= e), i[0].dot(l.crossVectors(s[0], s[e])) > 0 && (v = -v);
      for (let A = 1; A <= e; A++)
        s[A].applyMatrix4(c.makeRotationAxis(i[A], v * A)),
          a[A].crossVectors(i[A], s[A]);
    }
    return { tangents: i, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Hg extends Ca {
  constructor(
    e = 0,
    t = 0,
    n = 1,
    i = 1,
    s = 0,
    a = Math.PI * 2,
    l = !1,
    c = 0,
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = a),
      (this.aClockwise = l),
      (this.aRotation = c);
  }
  getPoint(e, t = new je()) {
    const n = t,
      i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += i;
    for (; s > i; ) s -= i;
    s < Number.EPSILON && (a ? (s = 0) : (s = i)),
      this.aClockwise === !0 && !a && (s === i ? (s = -i) : (s = s - i));
    const l = this.aStartAngle + e * s;
    let c = this.aX + this.xRadius * Math.cos(l),
      d = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const p = Math.cos(this.aRotation),
        m = Math.sin(this.aRotation),
        y = c - this.aX,
        v = d - this.aY;
      (c = y * p - v * m + this.aX), (d = y * m + v * p + this.aY);
    }
    return n.set(c, d);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class q5 extends Hg {
  constructor(e, t, n, i, s, a) {
    super(e, t, n, n, i, s, a),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function W3() {
  let r = 0,
    e = 0,
    t = 0,
    n = 0;
  function i(s, a, l, c) {
    (r = s),
      (e = l),
      (t = -3 * s + 3 * a - 2 * l - c),
      (n = 2 * s - 2 * a + l + c);
  }
  return {
    initCatmullRom: function (s, a, l, c, d) {
      i(a, l, d * (l - s), d * (c - a));
    },
    initNonuniformCatmullRom: function (s, a, l, c, d, p, m) {
      let y = (a - s) / d - (l - s) / (d + p) + (l - a) / p,
        v = (l - a) / p - (c - a) / (p + m) + (c - l) / m;
      (y *= p), (v *= p), i(a, l, y, v);
    },
    calc: function (s) {
      const a = s * s,
        l = a * s;
      return r + e * s + t * a + n * l;
    },
  };
}
const j1 = new Y(),
  xy = new W3(),
  by = new W3(),
  _y = new W3();
class K5 extends Ca {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(e, t = new Y()) {
    const n = t,
      i = this.points,
      s = i.length,
      a = (s - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(a),
      c = a - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
      : c === 0 && l === s - 1 && ((l = s - 2), (c = 1));
    let d, p;
    this.closed || l > 0
      ? (d = i[(l - 1) % s])
      : (j1.subVectors(i[0], i[1]).add(i[0]), (d = j1));
    const m = i[l % s],
      y = i[(l + 1) % s];
    if (
      (this.closed || l + 2 < s
        ? (p = i[(l + 2) % s])
        : (j1.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (p = j1)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const v = this.curveType === "chordal" ? 0.5 : 0.25;
      let A = Math.pow(d.distanceToSquared(m), v),
        M = Math.pow(m.distanceToSquared(y), v),
        w = Math.pow(y.distanceToSquared(p), v);
      M < 1e-4 && (M = 1),
        A < 1e-4 && (A = M),
        w < 1e-4 && (w = M),
        xy.initNonuniformCatmullRom(d.x, m.x, y.x, p.x, A, M, w),
        by.initNonuniformCatmullRom(d.y, m.y, y.y, p.y, A, M, w),
        _y.initNonuniformCatmullRom(d.z, m.z, y.z, p.z, A, M, w);
    } else
      this.curveType === "catmullrom" &&
        (xy.initCatmullRom(d.x, m.x, y.x, p.x, this.tension),
        by.initCatmullRom(d.y, m.y, y.y, p.y, this.tension),
        _y.initCatmullRom(d.z, m.z, y.z, p.z, this.tension));
    return n.set(xy.calc(c), by.calc(c), _y.calc(c)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new Y().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function L_(r, e, t, n, i) {
  const s = (n - e) * 0.5,
    a = (i - t) * 0.5,
    l = r * r,
    c = r * l;
  return (
    (2 * t - 2 * n + s + a) * c + (-3 * t + 3 * n - 2 * s - a) * l + s * r + t
  );
}
function nI(r, e) {
  const t = 1 - r;
  return t * t * e;
}
function rI(r, e) {
  return 2 * (1 - r) * r * e;
}
function iI(r, e) {
  return r * r * e;
}
function yp(r, e, t, n) {
  return nI(r, e) + rI(r, t) + iI(r, n);
}
function sI(r, e) {
  const t = 1 - r;
  return t * t * t * e;
}
function aI(r, e) {
  const t = 1 - r;
  return 3 * t * t * r * e;
}
function oI(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function lI(r, e) {
  return r * r * r * e;
}
function vp(r, e, t, n, i) {
  return sI(r, e) + aI(r, t) + oI(r, n) + lI(r, i);
}
class X3 extends Ca {
  constructor(e = new je(), t = new je(), n = new je(), i = new je()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new je()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2,
      l = this.v3;
    return n.set(vp(e, i.x, s.x, a.x, l.x), vp(e, i.y, s.y, a.y, l.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Q5 extends Ca {
  constructor(e = new Y(), t = new Y(), n = new Y(), i = new Y()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new Y()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2,
      l = this.v3;
    return (
      n.set(
        vp(e, i.x, s.x, a.x, l.x),
        vp(e, i.y, s.y, a.y, l.y),
        vp(e, i.z, s.z, a.z, l.z),
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class J3 extends Ca {
  constructor(e = new je(), t = new je()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new je()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new je()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class $5 extends Ca {
  constructor(e = new Y(), t = new Y()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new Y()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Y()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Y3 extends Ca {
  constructor(e = new je(), t = new je(), n = new je()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new je()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2;
    return n.set(yp(e, i.x, s.x, a.x), yp(e, i.y, s.y, a.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class Z3 extends Ca {
  constructor(e = new Y(), t = new Y(), n = new Y()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new Y()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2;
    return (
      n.set(yp(e, i.x, s.x, a.x), yp(e, i.y, s.y, a.y), yp(e, i.z, s.z, a.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class q3 extends Ca {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new je()) {
    const n = t,
      i = this.points,
      s = (i.length - 1) * e,
      a = Math.floor(s),
      l = s - a,
      c = i[a === 0 ? a : a - 1],
      d = i[a],
      p = i[a > i.length - 2 ? i.length - 1 : a + 1],
      m = i[a > i.length - 3 ? i.length - 1 : a + 2];
    return n.set(L_(l, c.x, d.x, p.x, m.x), L_(l, c.y, d.y, p.y, m.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new je().fromArray(i));
    }
    return this;
  }
}
var hg = Object.freeze({
  __proto__: null,
  ArcCurve: q5,
  CatmullRomCurve3: K5,
  CubicBezierCurve: X3,
  CubicBezierCurve3: Q5,
  EllipseCurve: Hg,
  LineCurve: J3,
  LineCurve3: $5,
  QuadraticBezierCurve: Y3,
  QuadraticBezierCurve3: Z3,
  SplineCurve: q3,
});
class eS extends Ca {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new hg[n](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= n) {
        const a = i[s] - n,
          l = this.curves[s],
          c = l.getLength(),
          d = c === 0 ? 0 : 1 - a / c;
        return l.getPointAt(d, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const a = s[i],
        l = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
            ? 1
            : a.isSplineCurve
              ? e * a.points.length
              : e,
        c = a.getPoints(l);
      for (let d = 0; d < c.length; d++) {
        const p = c[d];
        (n && n.equals(p)) || (t.push(p), (n = p));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new hg[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Bp extends eS {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new je()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new J3(this.currentPoint.clone(), new je(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const s = new Y3(this.currentPoint.clone(), new je(e, t), new je(n, i));
    return this.curves.push(s), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, s, a) {
    const l = new X3(
      this.currentPoint.clone(),
      new je(e, t),
      new je(n, i),
      new je(s, a),
    );
    return this.curves.push(l), this.currentPoint.set(s, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      n = new q3(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, s, a) {
    const l = this.currentPoint.x,
      c = this.currentPoint.y;
    return this.absarc(e + l, t + c, n, i, s, a), this;
  }
  absarc(e, t, n, i, s, a) {
    return this.absellipse(e, t, n, n, i, s, a), this;
  }
  ellipse(e, t, n, i, s, a, l, c) {
    const d = this.currentPoint.x,
      p = this.currentPoint.y;
    return this.absellipse(e + d, t + p, n, i, s, a, l, c), this;
  }
  absellipse(e, t, n, i, s, a, l, c) {
    const d = new Hg(e, t, n, i, s, a, l, c);
    if (this.curves.length > 0) {
      const m = d.getPoint(0);
      m.equals(this.currentPoint) || this.lineTo(m.x, m.y);
    }
    this.curves.push(d);
    const p = d.getPoint(1);
    return this.currentPoint.copy(p), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class im extends tn {
  constructor(
    e = [new je(0, -0.5), new je(0.5, 0), new je(0, 0.5)],
    t = 12,
    n = 0,
    i = Math.PI * 2,
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }),
      (t = Math.floor(t)),
      (i = en(i, 0, Math.PI * 2));
    const s = [],
      a = [],
      l = [],
      c = [],
      d = [],
      p = 1 / t,
      m = new Y(),
      y = new je(),
      v = new Y(),
      A = new Y(),
      M = new Y();
    let w = 0,
      x = 0;
    for (let C = 0; C <= e.length - 1; C++)
      switch (C) {
        case 0:
          (w = e[C + 1].x - e[C].x),
            (x = e[C + 1].y - e[C].y),
            (v.x = x * 1),
            (v.y = -w),
            (v.z = x * 0),
            M.copy(v),
            v.normalize(),
            c.push(v.x, v.y, v.z);
          break;
        case e.length - 1:
          c.push(M.x, M.y, M.z);
          break;
        default:
          (w = e[C + 1].x - e[C].x),
            (x = e[C + 1].y - e[C].y),
            (v.x = x * 1),
            (v.y = -w),
            (v.z = x * 0),
            A.copy(v),
            (v.x += M.x),
            (v.y += M.y),
            (v.z += M.z),
            v.normalize(),
            c.push(v.x, v.y, v.z),
            M.copy(A);
      }
    for (let C = 0; C <= t; C++) {
      const T = n + C * p * i,
        I = Math.sin(T),
        U = Math.cos(T);
      for (let F = 0; F <= e.length - 1; F++) {
        (m.x = e[F].x * I),
          (m.y = e[F].y),
          (m.z = e[F].x * U),
          a.push(m.x, m.y, m.z),
          (y.x = C / t),
          (y.y = F / (e.length - 1)),
          l.push(y.x, y.y);
        const O = c[3 * F + 0] * I,
          z = c[3 * F + 1],
          L = c[3 * F + 0] * U;
        d.push(O, z, L);
      }
    }
    for (let C = 0; C < t; C++)
      for (let T = 0; T < e.length - 1; T++) {
        const I = T + C * e.length,
          U = I,
          F = I + e.length,
          O = I + e.length + 1,
          z = I + 1;
        s.push(U, F, z), s.push(O, z, F);
      }
    this.setIndex(s),
      this.setAttribute("position", new Lt(a, 3)),
      this.setAttribute("uv", new Lt(l, 2)),
      this.setAttribute("normal", new Lt(d, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new im(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Vg extends im {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const s = new Bp();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(n), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: n,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new Vg(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Gg extends tn {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const s = [],
      a = [],
      l = [],
      c = [],
      d = new Y(),
      p = new je();
    a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let m = 0, y = 3; m <= t; m++, y += 3) {
      const v = n + (m / t) * i;
      (d.x = e * Math.cos(v)),
        (d.y = e * Math.sin(v)),
        a.push(d.x, d.y, d.z),
        l.push(0, 0, 1),
        (p.x = (a[y] / e + 1) / 2),
        (p.y = (a[y + 1] / e + 1) / 2),
        c.push(p.x, p.y);
    }
    for (let m = 1; m <= t; m++) s.push(m, m + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new Lt(a, 3)),
      this.setAttribute("normal", new Lt(l, 3)),
      this.setAttribute("uv", new Lt(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Gg(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ch extends tn {
  constructor(
    e = 1,
    t = 1,
    n = 1,
    i = 32,
    s = 1,
    a = !1,
    l = 0,
    c = Math.PI * 2,
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: s,
        openEnded: a,
        thetaStart: l,
        thetaLength: c,
      });
    const d = this;
    (i = Math.floor(i)), (s = Math.floor(s));
    const p = [],
      m = [],
      y = [],
      v = [];
    let A = 0;
    const M = [],
      w = n / 2;
    let x = 0;
    C(),
      a === !1 && (e > 0 && T(!0), t > 0 && T(!1)),
      this.setIndex(p),
      this.setAttribute("position", new Lt(m, 3)),
      this.setAttribute("normal", new Lt(y, 3)),
      this.setAttribute("uv", new Lt(v, 2));
    function C() {
      const I = new Y(),
        U = new Y();
      let F = 0;
      const O = (t - e) / n;
      for (let z = 0; z <= s; z++) {
        const L = [],
          N = z / s,
          X = N * (t - e) + e;
        for (let ie = 0; ie <= i; ie++) {
          const re = ie / i,
            me = re * c + l,
            _e = Math.sin(me),
            ge = Math.cos(me);
          (U.x = X * _e),
            (U.y = -N * n + w),
            (U.z = X * ge),
            m.push(U.x, U.y, U.z),
            I.set(_e, O, ge).normalize(),
            y.push(I.x, I.y, I.z),
            v.push(re, 1 - N),
            L.push(A++);
        }
        M.push(L);
      }
      for (let z = 0; z < i; z++)
        for (let L = 0; L < s; L++) {
          const N = M[L][z],
            X = M[L + 1][z],
            ie = M[L + 1][z + 1],
            re = M[L][z + 1];
          (e > 0 || L !== 0) && (p.push(N, X, re), (F += 3)),
            (t > 0 || L !== s - 1) && (p.push(X, ie, re), (F += 3));
        }
      d.addGroup(x, F, 0), (x += F);
    }
    function T(I) {
      const U = A,
        F = new je(),
        O = new Y();
      let z = 0;
      const L = I === !0 ? e : t,
        N = I === !0 ? 1 : -1;
      for (let ie = 1; ie <= i; ie++)
        m.push(0, w * N, 0), y.push(0, N, 0), v.push(0.5, 0.5), A++;
      const X = A;
      for (let ie = 0; ie <= i; ie++) {
        const re = (ie / i) * c + l,
          me = Math.cos(re),
          _e = Math.sin(re);
        (O.x = L * _e),
          (O.y = w * N),
          (O.z = L * me),
          m.push(O.x, O.y, O.z),
          y.push(0, N, 0),
          (F.x = me * 0.5 + 0.5),
          (F.y = _e * 0.5 * N + 0.5),
          v.push(F.x, F.y),
          A++;
      }
      for (let ie = 0; ie < i; ie++) {
        const re = U + ie,
          me = X + ie;
        I === !0 ? p.push(me, me + 1, re) : p.push(me + 1, me, re), (z += 3);
      }
      d.addGroup(x, z, I === !0 ? 1 : 2), (x += z);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ch(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class jg extends Ch {
  constructor(e = 1, t = 1, n = 32, i = 1, s = !1, a = 0, l = Math.PI * 2) {
    super(0, e, t, n, i, s, a, l),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: s,
        thetaStart: a,
        thetaLength: l,
      });
  }
  static fromJSON(e) {
    return new jg(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class ql extends tn {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: n, detail: i });
    const s = [],
      a = [];
    l(i),
      d(n),
      p(),
      this.setAttribute("position", new Lt(s, 3)),
      this.setAttribute("normal", new Lt(s.slice(), 3)),
      this.setAttribute("uv", new Lt(a, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(C) {
      const T = new Y(),
        I = new Y(),
        U = new Y();
      for (let F = 0; F < t.length; F += 3)
        v(t[F + 0], T), v(t[F + 1], I), v(t[F + 2], U), c(T, I, U, C);
    }
    function c(C, T, I, U) {
      const F = U + 1,
        O = [];
      for (let z = 0; z <= F; z++) {
        O[z] = [];
        const L = C.clone().lerp(I, z / F),
          N = T.clone().lerp(I, z / F),
          X = F - z;
        for (let ie = 0; ie <= X; ie++)
          ie === 0 && z === F
            ? (O[z][ie] = L)
            : (O[z][ie] = L.clone().lerp(N, ie / X));
      }
      for (let z = 0; z < F; z++)
        for (let L = 0; L < 2 * (F - z) - 1; L++) {
          const N = Math.floor(L / 2);
          L % 2 === 0
            ? (y(O[z][N + 1]), y(O[z + 1][N]), y(O[z][N]))
            : (y(O[z][N + 1]), y(O[z + 1][N + 1]), y(O[z + 1][N]));
        }
    }
    function d(C) {
      const T = new Y();
      for (let I = 0; I < s.length; I += 3)
        (T.x = s[I + 0]),
          (T.y = s[I + 1]),
          (T.z = s[I + 2]),
          T.normalize().multiplyScalar(C),
          (s[I + 0] = T.x),
          (s[I + 1] = T.y),
          (s[I + 2] = T.z);
    }
    function p() {
      const C = new Y();
      for (let T = 0; T < s.length; T += 3) {
        (C.x = s[T + 0]), (C.y = s[T + 1]), (C.z = s[T + 2]);
        const I = w(C) / 2 / Math.PI + 0.5,
          U = x(C) / Math.PI + 0.5;
        a.push(I, 1 - U);
      }
      A(), m();
    }
    function m() {
      for (let C = 0; C < a.length; C += 6) {
        const T = a[C + 0],
          I = a[C + 2],
          U = a[C + 4],
          F = Math.max(T, I, U),
          O = Math.min(T, I, U);
        F > 0.9 &&
          O < 0.1 &&
          (T < 0.2 && (a[C + 0] += 1),
          I < 0.2 && (a[C + 2] += 1),
          U < 0.2 && (a[C + 4] += 1));
      }
    }
    function y(C) {
      s.push(C.x, C.y, C.z);
    }
    function v(C, T) {
      const I = C * 3;
      (T.x = e[I + 0]), (T.y = e[I + 1]), (T.z = e[I + 2]);
    }
    function A() {
      const C = new Y(),
        T = new Y(),
        I = new Y(),
        U = new Y(),
        F = new je(),
        O = new je(),
        z = new je();
      for (let L = 0, N = 0; L < s.length; L += 9, N += 6) {
        C.set(s[L + 0], s[L + 1], s[L + 2]),
          T.set(s[L + 3], s[L + 4], s[L + 5]),
          I.set(s[L + 6], s[L + 7], s[L + 8]),
          F.set(a[N + 0], a[N + 1]),
          O.set(a[N + 2], a[N + 3]),
          z.set(a[N + 4], a[N + 5]),
          U.copy(C).add(T).add(I).divideScalar(3);
        const X = w(U);
        M(F, N + 0, C, X), M(O, N + 2, T, X), M(z, N + 4, I, X);
      }
    }
    function M(C, T, I, U) {
      U < 0 && C.x === 1 && (a[T] = C.x - 1),
        I.x === 0 && I.z === 0 && (a[T] = U / 2 / Math.PI + 0.5);
    }
    function w(C) {
      return Math.atan2(C.z, -C.x);
    }
    function x(C) {
      return Math.atan2(-C.y, Math.sqrt(C.x * C.x + C.z * C.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ql(e.vertices, e.indices, e.radius, e.details);
  }
}
class Wg extends ql {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, a, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Wg(e.radius, e.detail);
  }
}
const W1 = new Y(),
  X1 = new Y(),
  Ay = new Y(),
  J1 = new cs();
class tS extends tn {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const n = Math.pow(10, 4),
        i = Math.cos(Cc * t),
        s = e.getIndex(),
        a = e.getAttribute("position"),
        l = s ? s.count : a.count,
        c = [0, 0, 0],
        d = ["a", "b", "c"],
        p = new Array(3),
        m = {},
        y = [];
      for (let v = 0; v < l; v += 3) {
        s
          ? ((c[0] = s.getX(v)), (c[1] = s.getX(v + 1)), (c[2] = s.getX(v + 2)))
          : ((c[0] = v), (c[1] = v + 1), (c[2] = v + 2));
        const { a: A, b: M, c: w } = J1;
        if (
          (A.fromBufferAttribute(a, c[0]),
          M.fromBufferAttribute(a, c[1]),
          w.fromBufferAttribute(a, c[2]),
          J1.getNormal(Ay),
          (p[0] = `${Math.round(A.x * n)},${Math.round(A.y * n)},${Math.round(A.z * n)}`),
          (p[1] = `${Math.round(M.x * n)},${Math.round(M.y * n)},${Math.round(M.z * n)}`),
          (p[2] = `${Math.round(w.x * n)},${Math.round(w.y * n)},${Math.round(w.z * n)}`),
          !(p[0] === p[1] || p[1] === p[2] || p[2] === p[0]))
        )
          for (let x = 0; x < 3; x++) {
            const C = (x + 1) % 3,
              T = p[x],
              I = p[C],
              U = J1[d[x]],
              F = J1[d[C]],
              O = `${T}_${I}`,
              z = `${I}_${T}`;
            z in m && m[z]
              ? (Ay.dot(m[z].normal) <= i &&
                  (y.push(U.x, U.y, U.z), y.push(F.x, F.y, F.z)),
                (m[z] = null))
              : O in m ||
                (m[O] = { index0: c[x], index1: c[C], normal: Ay.clone() });
          }
      }
      for (const v in m)
        if (m[v]) {
          const { index0: A, index1: M } = m[v];
          W1.fromBufferAttribute(a, A),
            X1.fromBufferAttribute(a, M),
            y.push(W1.x, W1.y, W1.z),
            y.push(X1.x, X1.y, X1.z);
        }
      this.setAttribute("position", new Lt(y, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Rc extends Bp {
  constructor(e) {
    super(e), (this.uuid = Ms()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Bp().fromJSON(i));
    }
    return this;
  }
}
const uI = {
  triangulate: function (r, e, t = 2) {
    const n = e && e.length,
      i = n ? e[0] * t : r.length;
    let s = nS(r, 0, i, t, !0);
    const a = [];
    if (!s || s.next === s.prev) return a;
    let l, c, d, p, m, y, v;
    if ((n && (s = pI(r, e, s, t)), r.length > 80 * t)) {
      (l = d = r[0]), (c = p = r[1]);
      for (let A = t; A < i; A += t)
        (m = r[A]),
          (y = r[A + 1]),
          m < l && (l = m),
          y < c && (c = y),
          m > d && (d = m),
          y > p && (p = y);
      (v = Math.max(d - l, p - c)), (v = v !== 0 ? 32767 / v : 0);
    }
    return Pp(s, a, t, l, c, v, 0), a;
  },
};
function nS(r, e, t, n, i) {
  let s, a;
  if (i === SI(r, e, t, n) > 0)
    for (s = e; s < t; s += n) a = D_(s, r[s], r[s + 1], a);
  else for (s = t - n; s >= e; s -= n) a = D_(s, r[s], r[s + 1], a);
  return a && Xg(a, a.next) && (Dp(a), (a = a.next)), a;
}
function Nc(r, e) {
  if (!r) return r;
  e || (e = r);
  let t = r,
    n;
  do
    if (
      ((n = !1), !t.steiner && (Xg(t, t.next) || sr(t.prev, t, t.next) === 0))
    ) {
      if ((Dp(t), (t = e = t.prev), t === t.next)) break;
      n = !0;
    } else t = t.next;
  while (n || t !== e);
  return e;
}
function Pp(r, e, t, n, i, s, a) {
  if (!r) return;
  !a && s && xI(r, n, i, s);
  let l = r,
    c,
    d;
  for (; r.prev !== r.next; ) {
    if (((c = r.prev), (d = r.next), s ? dI(r, n, i, s) : cI(r))) {
      e.push((c.i / t) | 0),
        e.push((r.i / t) | 0),
        e.push((d.i / t) | 0),
        Dp(r),
        (r = d.next),
        (l = d.next);
      continue;
    }
    if (((r = d), r === l)) {
      a
        ? a === 1
          ? ((r = hI(Nc(r), e, t)), Pp(r, e, t, n, i, s, 2))
          : a === 2 && fI(r, e, t, n, i, s)
        : Pp(Nc(r), e, t, n, i, s, 1);
      break;
    }
  }
}
function cI(r) {
  const e = r.prev,
    t = r,
    n = r.next;
  if (sr(e, t, n) >= 0) return !1;
  const i = e.x,
    s = t.x,
    a = n.x,
    l = e.y,
    c = t.y,
    d = n.y,
    p = i < s ? (i < a ? i : a) : s < a ? s : a,
    m = l < c ? (l < d ? l : d) : c < d ? c : d,
    y = i > s ? (i > a ? i : a) : s > a ? s : a,
    v = l > c ? (l > d ? l : d) : c > d ? c : d;
  let A = n.next;
  for (; A !== e; ) {
    if (
      A.x >= p &&
      A.x <= y &&
      A.y >= m &&
      A.y <= v &&
      ih(i, l, s, c, a, d, A.x, A.y) &&
      sr(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.next;
  }
  return !0;
}
function dI(r, e, t, n) {
  const i = r.prev,
    s = r,
    a = r.next;
  if (sr(i, s, a) >= 0) return !1;
  const l = i.x,
    c = s.x,
    d = a.x,
    p = i.y,
    m = s.y,
    y = a.y,
    v = l < c ? (l < d ? l : d) : c < d ? c : d,
    A = p < m ? (p < y ? p : y) : m < y ? m : y,
    M = l > c ? (l > d ? l : d) : c > d ? c : d,
    w = p > m ? (p > y ? p : y) : m > y ? m : y,
    x = Ev(v, A, e, t, n),
    C = Ev(M, w, e, t, n);
  let T = r.prevZ,
    I = r.nextZ;
  for (; T && T.z >= x && I && I.z <= C; ) {
    if (
      (T.x >= v &&
        T.x <= M &&
        T.y >= A &&
        T.y <= w &&
        T !== i &&
        T !== a &&
        ih(l, p, c, m, d, y, T.x, T.y) &&
        sr(T.prev, T, T.next) >= 0) ||
      ((T = T.prevZ),
      I.x >= v &&
        I.x <= M &&
        I.y >= A &&
        I.y <= w &&
        I !== i &&
        I !== a &&
        ih(l, p, c, m, d, y, I.x, I.y) &&
        sr(I.prev, I, I.next) >= 0)
    )
      return !1;
    I = I.nextZ;
  }
  for (; T && T.z >= x; ) {
    if (
      T.x >= v &&
      T.x <= M &&
      T.y >= A &&
      T.y <= w &&
      T !== i &&
      T !== a &&
      ih(l, p, c, m, d, y, T.x, T.y) &&
      sr(T.prev, T, T.next) >= 0
    )
      return !1;
    T = T.prevZ;
  }
  for (; I && I.z <= C; ) {
    if (
      I.x >= v &&
      I.x <= M &&
      I.y >= A &&
      I.y <= w &&
      I !== i &&
      I !== a &&
      ih(l, p, c, m, d, y, I.x, I.y) &&
      sr(I.prev, I, I.next) >= 0
    )
      return !1;
    I = I.nextZ;
  }
  return !0;
}
function hI(r, e, t) {
  let n = r;
  do {
    const i = n.prev,
      s = n.next.next;
    !Xg(i, s) &&
      rS(i, n, n.next, s) &&
      Lp(i, s) &&
      Lp(s, i) &&
      (e.push((i.i / t) | 0),
      e.push((n.i / t) | 0),
      e.push((s.i / t) | 0),
      Dp(n),
      Dp(n.next),
      (n = r = s)),
      (n = n.next);
  } while (n !== r);
  return Nc(n);
}
function fI(r, e, t, n, i, s) {
  let a = r;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && AI(a, l)) {
        let c = iS(a, l);
        (a = Nc(a, a.next)),
          (c = Nc(c, c.next)),
          Pp(a, e, t, n, i, s, 0),
          Pp(c, e, t, n, i, s, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== r);
}
function pI(r, e, t, n) {
  const i = [];
  let s, a, l, c, d;
  for (s = 0, a = e.length; s < a; s++)
    (l = e[s] * n),
      (c = s < a - 1 ? e[s + 1] * n : r.length),
      (d = nS(r, l, c, n, !1)),
      d === d.next && (d.steiner = !0),
      i.push(_I(d));
  for (i.sort(mI), s = 0; s < i.length; s++) t = gI(i[s], t);
  return t;
}
function mI(r, e) {
  return r.x - e.x;
}
function gI(r, e) {
  const t = yI(r, e);
  if (!t) return e;
  const n = iS(t, r);
  return Nc(n, n.next), Nc(t, t.next);
}
function yI(r, e) {
  let t = e,
    n = -1 / 0,
    i;
  const s = r.x,
    a = r.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const y = t.x + ((a - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        y <= s &&
        y > n &&
        ((n = y), (i = t.x < t.next.x ? t : t.next), y === s)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const l = i,
    c = i.x,
    d = i.y;
  let p = 1 / 0,
    m;
  t = i;
  do
    s >= t.x &&
      t.x >= c &&
      s !== t.x &&
      ih(a < d ? s : n, a, c, d, a < d ? n : s, a, t.x, t.y) &&
      ((m = Math.abs(a - t.y) / (s - t.x)),
      Lp(t, r) &&
        (m < p || (m === p && (t.x > i.x || (t.x === i.x && vI(i, t))))) &&
        ((i = t), (p = m))),
      (t = t.next);
  while (t !== l);
  return i;
}
function vI(r, e) {
  return sr(r.prev, r, e.prev) < 0 && sr(e.next, r, r.next) < 0;
}
function xI(r, e, t, n) {
  let i = r;
  do
    i.z === 0 && (i.z = Ev(i.x, i.y, e, t, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== r);
  (i.prevZ.nextZ = null), (i.prevZ = null), bI(i);
}
function bI(r) {
  let e,
    t,
    n,
    i,
    s,
    a,
    l,
    c,
    d = 1;
  do {
    for (t = r, r = null, s = null, a = 0; t; ) {
      for (a++, n = t, l = 0, e = 0; e < d && (l++, (n = n.nextZ), !!n); e++);
      for (c = d; l > 0 || (c > 0 && n); )
        l !== 0 && (c === 0 || !n || t.z <= n.z)
          ? ((i = t), (t = t.nextZ), l--)
          : ((i = n), (n = n.nextZ), c--),
          s ? (s.nextZ = i) : (r = i),
          (i.prevZ = s),
          (s = i);
      t = n;
    }
    (s.nextZ = null), (d *= 2);
  } while (a > 1);
  return r;
}
function Ev(r, e, t, n, i) {
  return (
    (r = ((r - t) * i) | 0),
    (e = ((e - n) * i) | 0),
    (r = (r | (r << 8)) & 16711935),
    (r = (r | (r << 4)) & 252645135),
    (r = (r | (r << 2)) & 858993459),
    (r = (r | (r << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    r | (e << 1)
  );
}
function _I(r) {
  let e = r,
    t = r;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== r);
  return t;
}
function ih(r, e, t, n, i, s, a, l) {
  return (
    (i - a) * (e - l) >= (r - a) * (s - l) &&
    (r - a) * (n - l) >= (t - a) * (e - l) &&
    (t - a) * (s - l) >= (i - a) * (n - l)
  );
}
function AI(r, e) {
  return (
    r.next.i !== e.i &&
    r.prev.i !== e.i &&
    !wI(r, e) &&
    ((Lp(r, e) &&
      Lp(e, r) &&
      MI(r, e) &&
      (sr(r.prev, r, e.prev) || sr(r, e.prev, e))) ||
      (Xg(r, e) && sr(r.prev, r, r.next) > 0 && sr(e.prev, e, e.next) > 0))
  );
}
function sr(r, e, t) {
  return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function Xg(r, e) {
  return r.x === e.x && r.y === e.y;
}
function rS(r, e, t, n) {
  const i = Z1(sr(r, e, t)),
    s = Z1(sr(r, e, n)),
    a = Z1(sr(t, n, r)),
    l = Z1(sr(t, n, e));
  return !!(
    (i !== s && a !== l) ||
    (i === 0 && Y1(r, t, e)) ||
    (s === 0 && Y1(r, n, e)) ||
    (a === 0 && Y1(t, r, n)) ||
    (l === 0 && Y1(t, e, n))
  );
}
function Y1(r, e, t) {
  return (
    e.x <= Math.max(r.x, t.x) &&
    e.x >= Math.min(r.x, t.x) &&
    e.y <= Math.max(r.y, t.y) &&
    e.y >= Math.min(r.y, t.y)
  );
}
function Z1(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function wI(r, e) {
  let t = r;
  do {
    if (
      t.i !== r.i &&
      t.next.i !== r.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      rS(t, t.next, r, e)
    )
      return !0;
    t = t.next;
  } while (t !== r);
  return !1;
}
function Lp(r, e) {
  return sr(r.prev, r, r.next) < 0
    ? sr(r, e, r.next) >= 0 && sr(r, r.prev, e) >= 0
    : sr(r, e, r.prev) < 0 || sr(r, r.next, e) < 0;
}
function MI(r, e) {
  let t = r,
    n = !1;
  const i = (r.x + e.x) / 2,
    s = (r.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (n = !n),
      (t = t.next);
  while (t !== r);
  return n;
}
function iS(r, e) {
  const t = new Cv(r.i, r.x, r.y),
    n = new Cv(e.i, e.x, e.y),
    i = r.next,
    s = e.prev;
  return (
    (r.next = e),
    (e.prev = r),
    (t.next = i),
    (i.prev = t),
    (n.next = t),
    (t.prev = n),
    (s.next = n),
    (n.prev = s),
    n
  );
}
function D_(r, e, t, n) {
  const i = new Cv(r, e, t);
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Dp(r) {
  (r.next.prev = r.prev),
    (r.prev.next = r.next),
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function Cv(r, e, t) {
  (this.i = r),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function SI(r, e, t, n) {
  let i = 0;
  for (let s = e, a = t - n; s < t; s += n)
    (i += (r[a] - r[s]) * (r[s + 1] + r[a + 1])), (a = s);
  return i;
}
class no {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, s = 0; s < t; i = s++)
      n += e[i].x * e[s].y - e[s].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return no.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [],
      i = [],
      s = [];
    F_(e), N_(n, e);
    let a = e.length;
    t.forEach(F_);
    for (let c = 0; c < t.length; c++)
      i.push(a), (a += t[c].length), N_(n, t[c]);
    const l = uI.triangulate(n, i);
    for (let c = 0; c < l.length; c += 3) s.push(l.slice(c, c + 3));
    return s;
  }
}
function F_(r) {
  const e = r.length;
  e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function N_(r, e) {
  for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
}
class Jg extends tn {
  constructor(
    e = new Rc([
      new je(0.5, 0.5),
      new je(-0.5, 0.5),
      new je(-0.5, -0.5),
      new je(0.5, -0.5),
    ]),
    t = {},
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const n = this,
      i = [],
      s = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const d = e[l];
      a(d);
    }
    this.setAttribute("position", new Lt(i, 3)),
      this.setAttribute("uv", new Lt(s, 2)),
      this.computeVertexNormals();
    function a(l) {
      const c = [],
        d = t.curveSegments !== void 0 ? t.curveSegments : 12,
        p = t.steps !== void 0 ? t.steps : 1,
        m = t.depth !== void 0 ? t.depth : 1;
      let y = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        A = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1,
        M = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        w = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const x = t.extrudePath,
        C = t.UVGenerator !== void 0 ? t.UVGenerator : EI;
      let T,
        I = !1,
        U,
        F,
        O,
        z;
      x &&
        ((T = x.getSpacedPoints(p)),
        (I = !0),
        (y = !1),
        (U = x.computeFrenetFrames(p, !1)),
        (F = new Y()),
        (O = new Y()),
        (z = new Y())),
        y || ((w = 0), (v = 0), (A = 0), (M = 0));
      const L = l.extractPoints(d);
      let N = L.shape;
      const X = L.holes;
      if (!no.isClockWise(N)) {
        N = N.reverse();
        for (let be = 0, Te = X.length; be < Te; be++) {
          const Ne = X[be];
          no.isClockWise(Ne) && (X[be] = Ne.reverse());
        }
      }
      const ie = no.triangulateShape(N, X),
        re = N;
      for (let be = 0, Te = X.length; be < Te; be++) {
        const Ne = X[be];
        N = N.concat(Ne);
      }
      function me(be, Te, Ne) {
        return (
          Te || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          be.clone().addScaledVector(Te, Ne)
        );
      }
      const _e = N.length,
        ge = ie.length;
      function Re(be, Te, Ne) {
        let K, qe, ct;
        const Be = be.x - Te.x,
          nt = be.y - Te.y,
          Dt = Ne.x - be.x,
          it = Ne.y - be.y,
          Z = Be * Be + nt * nt,
          G = Be * it - nt * Dt;
        if (Math.abs(G) > Number.EPSILON) {
          const xe = Math.sqrt(Z),
            ze = Math.sqrt(Dt * Dt + it * it),
            We = Te.x - nt / xe,
            Oe = Te.y + Be / xe,
            Mt = Ne.x - it / ze,
            ot = Ne.y + Dt / ze,
            ft = ((Mt - We) * it - (ot - Oe) * Dt) / (Be * it - nt * Dt);
          (K = We + Be * ft - be.x), (qe = Oe + nt * ft - be.y);
          const Ot = K * K + qe * qe;
          if (Ot <= 2) return new je(K, qe);
          ct = Math.sqrt(Ot / 2);
        } else {
          let xe = !1;
          Be > Number.EPSILON
            ? Dt > Number.EPSILON && (xe = !0)
            : Be < -Number.EPSILON
              ? Dt < -Number.EPSILON && (xe = !0)
              : Math.sign(nt) === Math.sign(it) && (xe = !0),
            xe
              ? ((K = -nt), (qe = Be), (ct = Math.sqrt(Z)))
              : ((K = Be), (qe = nt), (ct = Math.sqrt(Z / 2)));
        }
        return new je(K / ct, qe / ct);
      }
      const J = [];
      for (
        let be = 0, Te = re.length, Ne = Te - 1, K = be + 1;
        be < Te;
        be++, Ne++, K++
      )
        Ne === Te && (Ne = 0),
          K === Te && (K = 0),
          (J[be] = Re(re[be], re[Ne], re[K]));
      const oe = [];
      let ae,
        q = J.concat();
      for (let be = 0, Te = X.length; be < Te; be++) {
        const Ne = X[be];
        ae = [];
        for (
          let K = 0, qe = Ne.length, ct = qe - 1, Be = K + 1;
          K < qe;
          K++, ct++, Be++
        )
          ct === qe && (ct = 0),
            Be === qe && (Be = 0),
            (ae[K] = Re(Ne[K], Ne[ct], Ne[Be]));
        oe.push(ae), (q = q.concat(ae));
      }
      for (let be = 0; be < w; be++) {
        const Te = be / w,
          Ne = v * Math.cos((Te * Math.PI) / 2),
          K = A * Math.sin((Te * Math.PI) / 2) + M;
        for (let qe = 0, ct = re.length; qe < ct; qe++) {
          const Be = me(re[qe], J[qe], K);
          Ue(Be.x, Be.y, -Ne);
        }
        for (let qe = 0, ct = X.length; qe < ct; qe++) {
          const Be = X[qe];
          ae = oe[qe];
          for (let nt = 0, Dt = Be.length; nt < Dt; nt++) {
            const it = me(Be[nt], ae[nt], K);
            Ue(it.x, it.y, -Ne);
          }
        }
      }
      const ce = A + M;
      for (let be = 0; be < _e; be++) {
        const Te = y ? me(N[be], q[be], ce) : N[be];
        I
          ? (O.copy(U.normals[0]).multiplyScalar(Te.x),
            F.copy(U.binormals[0]).multiplyScalar(Te.y),
            z.copy(T[0]).add(O).add(F),
            Ue(z.x, z.y, z.z))
          : Ue(Te.x, Te.y, 0);
      }
      for (let be = 1; be <= p; be++)
        for (let Te = 0; Te < _e; Te++) {
          const Ne = y ? me(N[Te], q[Te], ce) : N[Te];
          I
            ? (O.copy(U.normals[be]).multiplyScalar(Ne.x),
              F.copy(U.binormals[be]).multiplyScalar(Ne.y),
              z.copy(T[be]).add(O).add(F),
              Ue(z.x, z.y, z.z))
            : Ue(Ne.x, Ne.y, (m / p) * be);
        }
      for (let be = w - 1; be >= 0; be--) {
        const Te = be / w,
          Ne = v * Math.cos((Te * Math.PI) / 2),
          K = A * Math.sin((Te * Math.PI) / 2) + M;
        for (let qe = 0, ct = re.length; qe < ct; qe++) {
          const Be = me(re[qe], J[qe], K);
          Ue(Be.x, Be.y, m + Ne);
        }
        for (let qe = 0, ct = X.length; qe < ct; qe++) {
          const Be = X[qe];
          ae = oe[qe];
          for (let nt = 0, Dt = Be.length; nt < Dt; nt++) {
            const it = me(Be[nt], ae[nt], K);
            I
              ? Ue(it.x, it.y + T[p - 1].y, T[p - 1].x + Ne)
              : Ue(it.x, it.y, m + Ne);
          }
        }
      }
      Xe(), ye();
      function Xe() {
        const be = i.length / 3;
        if (y) {
          let Te = 0,
            Ne = _e * Te;
          for (let K = 0; K < ge; K++) {
            const qe = ie[K];
            Fe(qe[2] + Ne, qe[1] + Ne, qe[0] + Ne);
          }
          (Te = p + w * 2), (Ne = _e * Te);
          for (let K = 0; K < ge; K++) {
            const qe = ie[K];
            Fe(qe[0] + Ne, qe[1] + Ne, qe[2] + Ne);
          }
        } else {
          for (let Te = 0; Te < ge; Te++) {
            const Ne = ie[Te];
            Fe(Ne[2], Ne[1], Ne[0]);
          }
          for (let Te = 0; Te < ge; Te++) {
            const Ne = ie[Te];
            Fe(Ne[0] + _e * p, Ne[1] + _e * p, Ne[2] + _e * p);
          }
        }
        n.addGroup(be, i.length / 3 - be, 0);
      }
      function ye() {
        const be = i.length / 3;
        let Te = 0;
        Pe(re, Te), (Te += re.length);
        for (let Ne = 0, K = X.length; Ne < K; Ne++) {
          const qe = X[Ne];
          Pe(qe, Te), (Te += qe.length);
        }
        n.addGroup(be, i.length / 3 - be, 1);
      }
      function Pe(be, Te) {
        let Ne = be.length;
        for (; --Ne >= 0; ) {
          const K = Ne;
          let qe = Ne - 1;
          qe < 0 && (qe = be.length - 1);
          for (let ct = 0, Be = p + w * 2; ct < Be; ct++) {
            const nt = _e * ct,
              Dt = _e * (ct + 1),
              it = Te + K + nt,
              Z = Te + qe + nt,
              G = Te + qe + Dt,
              xe = Te + K + Dt;
            Je(it, Z, G, xe);
          }
        }
      }
      function Ue(be, Te, Ne) {
        c.push(be), c.push(Te), c.push(Ne);
      }
      function Fe(be, Te, Ne) {
        et(be), et(Te), et(Ne);
        const K = i.length / 3,
          qe = C.generateTopUV(n, i, K - 3, K - 2, K - 1);
        tt(qe[0]), tt(qe[1]), tt(qe[2]);
      }
      function Je(be, Te, Ne, K) {
        et(be), et(Te), et(K), et(Te), et(Ne), et(K);
        const qe = i.length / 3,
          ct = C.generateSideWallUV(n, i, qe - 6, qe - 3, qe - 2, qe - 1);
        tt(ct[0]), tt(ct[1]), tt(ct[3]), tt(ct[1]), tt(ct[2]), tt(ct[3]);
      }
      function et(be) {
        i.push(c[be * 3 + 0]), i.push(c[be * 3 + 1]), i.push(c[be * 3 + 2]);
      }
      function tt(be) {
        s.push(be.x), s.push(be.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      n = this.parameters.options;
    return CI(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, a = e.shapes.length; s < a; s++) {
      const l = t[e.shapes[s]];
      n.push(l);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new hg[i.type]().fromJSON(i)),
      new Jg(n, e.options)
    );
  }
}
const EI = {
  generateTopUV: function (r, e, t, n, i) {
    const s = e[t * 3],
      a = e[t * 3 + 1],
      l = e[n * 3],
      c = e[n * 3 + 1],
      d = e[i * 3],
      p = e[i * 3 + 1];
    return [new je(s, a), new je(l, c), new je(d, p)];
  },
  generateSideWallUV: function (r, e, t, n, i, s) {
    const a = e[t * 3],
      l = e[t * 3 + 1],
      c = e[t * 3 + 2],
      d = e[n * 3],
      p = e[n * 3 + 1],
      m = e[n * 3 + 2],
      y = e[i * 3],
      v = e[i * 3 + 1],
      A = e[i * 3 + 2],
      M = e[s * 3],
      w = e[s * 3 + 1],
      x = e[s * 3 + 2];
    return Math.abs(l - p) < Math.abs(a - d)
      ? [new je(a, 1 - c), new je(d, 1 - m), new je(y, 1 - A), new je(M, 1 - x)]
      : [
          new je(l, 1 - c),
          new je(p, 1 - m),
          new je(v, 1 - A),
          new je(w, 1 - x),
        ];
  },
};
function CI(r, e, t) {
  if (((t.shapes = []), Array.isArray(r)))
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(r.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class sm extends ql {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new sm(e.radius, e.detail);
  }
}
class am extends ql {
  constructor(e = 1, t = 0) {
    const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(n, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new am(e.radius, e.detail);
  }
}
class Kl extends tn {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const s = e / 2,
      a = t / 2,
      l = Math.floor(n),
      c = Math.floor(i),
      d = l + 1,
      p = c + 1,
      m = e / l,
      y = t / c,
      v = [],
      A = [],
      M = [],
      w = [];
    for (let x = 0; x < p; x++) {
      const C = x * y - a;
      for (let T = 0; T < d; T++) {
        const I = T * m - s;
        A.push(I, -C, 0), M.push(0, 0, 1), w.push(T / l), w.push(1 - x / c);
      }
    }
    for (let x = 0; x < c; x++)
      for (let C = 0; C < l; C++) {
        const T = C + d * x,
          I = C + d * (x + 1),
          U = C + 1 + d * (x + 1),
          F = C + 1 + d * x;
        v.push(T, I, F), v.push(I, U, F);
      }
    this.setIndex(v),
      this.setAttribute("position", new Lt(A, 3)),
      this.setAttribute("normal", new Lt(M, 3)),
      this.setAttribute("uv", new Lt(w, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Kl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Yg extends tn {
  constructor(e = 0.5, t = 1, n = 32, i = 1, s = 0, a = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: s,
        thetaLength: a,
      }),
      (n = Math.max(3, n)),
      (i = Math.max(1, i));
    const l = [],
      c = [],
      d = [],
      p = [];
    let m = e;
    const y = (t - e) / i,
      v = new Y(),
      A = new je();
    for (let M = 0; M <= i; M++) {
      for (let w = 0; w <= n; w++) {
        const x = s + (w / n) * a;
        (v.x = m * Math.cos(x)),
          (v.y = m * Math.sin(x)),
          c.push(v.x, v.y, v.z),
          d.push(0, 0, 1),
          (A.x = (v.x / t + 1) / 2),
          (A.y = (v.y / t + 1) / 2),
          p.push(A.x, A.y);
      }
      m += y;
    }
    for (let M = 0; M < i; M++) {
      const w = M * (n + 1);
      for (let x = 0; x < n; x++) {
        const C = x + w,
          T = C,
          I = C + n + 1,
          U = C + n + 2,
          F = C + 1;
        l.push(T, I, F), l.push(I, U, F);
      }
    }
    this.setIndex(l),
      this.setAttribute("position", new Lt(c, 3)),
      this.setAttribute("normal", new Lt(d, 3)),
      this.setAttribute("uv", new Lt(p, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yg(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Zg extends tn {
  constructor(
    e = new Rc([new je(0, 0.5), new je(-0.5, -0.5), new je(0.5, -0.5)]),
    t = 12,
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const n = [],
      i = [],
      s = [],
      a = [];
    let l = 0,
      c = 0;
    if (Array.isArray(e) === !1) d(e);
    else
      for (let p = 0; p < e.length; p++)
        d(e[p]), this.addGroup(l, c, p), (l += c), (c = 0);
    this.setIndex(n),
      this.setAttribute("position", new Lt(i, 3)),
      this.setAttribute("normal", new Lt(s, 3)),
      this.setAttribute("uv", new Lt(a, 2));
    function d(p) {
      const m = i.length / 3,
        y = p.extractPoints(t);
      let v = y.shape;
      const A = y.holes;
      no.isClockWise(v) === !1 && (v = v.reverse());
      for (let w = 0, x = A.length; w < x; w++) {
        const C = A[w];
        no.isClockWise(C) === !0 && (A[w] = C.reverse());
      }
      const M = no.triangulateShape(v, A);
      for (let w = 0, x = A.length; w < x; w++) {
        const C = A[w];
        v = v.concat(C);
      }
      for (let w = 0, x = v.length; w < x; w++) {
        const C = v[w];
        i.push(C.x, C.y, 0), s.push(0, 0, 1), a.push(C.x, C.y);
      }
      for (let w = 0, x = M.length; w < x; w++) {
        const C = M[w],
          T = C[0] + m,
          I = C[1] + m,
          U = C[2] + m;
        n.push(T, I, U), (c += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return TI(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const a = t[e.shapes[i]];
      n.push(a);
    }
    return new Zg(n, e.curveSegments);
  }
}
function TI(r, e) {
  if (((e.shapes = []), Array.isArray(r)))
    for (let t = 0, n = r.length; t < n; t++) {
      const i = r[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(r.uuid);
  return e;
}
class om extends tn {
  constructor(
    e = 1,
    t = 32,
    n = 16,
    i = 0,
    s = Math.PI * 2,
    a = 0,
    l = Math.PI,
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: s,
        thetaStart: a,
        thetaLength: l,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n)));
    const c = Math.min(a + l, Math.PI);
    let d = 0;
    const p = [],
      m = new Y(),
      y = new Y(),
      v = [],
      A = [],
      M = [],
      w = [];
    for (let x = 0; x <= n; x++) {
      const C = [],
        T = x / n;
      let I = 0;
      x === 0 && a === 0
        ? (I = 0.5 / t)
        : x === n && c === Math.PI && (I = -0.5 / t);
      for (let U = 0; U <= t; U++) {
        const F = U / t;
        (m.x = -e * Math.cos(i + F * s) * Math.sin(a + T * l)),
          (m.y = e * Math.cos(a + T * l)),
          (m.z = e * Math.sin(i + F * s) * Math.sin(a + T * l)),
          A.push(m.x, m.y, m.z),
          y.copy(m).normalize(),
          M.push(y.x, y.y, y.z),
          w.push(F + I, 1 - T),
          C.push(d++);
      }
      p.push(C);
    }
    for (let x = 0; x < n; x++)
      for (let C = 0; C < t; C++) {
        const T = p[x][C + 1],
          I = p[x][C],
          U = p[x + 1][C],
          F = p[x + 1][C + 1];
        (x !== 0 || a > 0) && v.push(T, I, F),
          (x !== n - 1 || c < Math.PI) && v.push(I, U, F);
      }
    this.setIndex(v),
      this.setAttribute("position", new Lt(A, 3)),
      this.setAttribute("normal", new Lt(M, 3)),
      this.setAttribute("uv", new Lt(w, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new om(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class qg extends ql {
  constructor(e = 1, t = 0) {
    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(n, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new qg(e.radius, e.detail);
  }
}
class Kg extends tn {
  constructor(e = 1, t = 0.4, n = 12, i = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: i,
        arc: s,
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const a = [],
      l = [],
      c = [],
      d = [],
      p = new Y(),
      m = new Y(),
      y = new Y();
    for (let v = 0; v <= n; v++)
      for (let A = 0; A <= i; A++) {
        const M = (A / i) * s,
          w = (v / n) * Math.PI * 2;
        (m.x = (e + t * Math.cos(w)) * Math.cos(M)),
          (m.y = (e + t * Math.cos(w)) * Math.sin(M)),
          (m.z = t * Math.sin(w)),
          l.push(m.x, m.y, m.z),
          (p.x = e * Math.cos(M)),
          (p.y = e * Math.sin(M)),
          y.subVectors(m, p).normalize(),
          c.push(y.x, y.y, y.z),
          d.push(A / i),
          d.push(v / n);
      }
    for (let v = 1; v <= n; v++)
      for (let A = 1; A <= i; A++) {
        const M = (i + 1) * v + A - 1,
          w = (i + 1) * (v - 1) + A - 1,
          x = (i + 1) * (v - 1) + A,
          C = (i + 1) * v + A;
        a.push(M, w, C), a.push(w, x, C);
      }
    this.setIndex(a),
      this.setAttribute("position", new Lt(l, 3)),
      this.setAttribute("normal", new Lt(c, 3)),
      this.setAttribute("uv", new Lt(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Kg(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Qg extends tn {
  constructor(e = 1, t = 0.4, n = 64, i = 8, s = 2, a = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: i,
        p: s,
        q: a,
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const l = [],
      c = [],
      d = [],
      p = [],
      m = new Y(),
      y = new Y(),
      v = new Y(),
      A = new Y(),
      M = new Y(),
      w = new Y(),
      x = new Y();
    for (let T = 0; T <= n; ++T) {
      const I = (T / n) * s * Math.PI * 2;
      C(I, s, a, e, v),
        C(I + 0.01, s, a, e, A),
        w.subVectors(A, v),
        x.addVectors(A, v),
        M.crossVectors(w, x),
        x.crossVectors(M, w),
        M.normalize(),
        x.normalize();
      for (let U = 0; U <= i; ++U) {
        const F = (U / i) * Math.PI * 2,
          O = -t * Math.cos(F),
          z = t * Math.sin(F);
        (m.x = v.x + (O * x.x + z * M.x)),
          (m.y = v.y + (O * x.y + z * M.y)),
          (m.z = v.z + (O * x.z + z * M.z)),
          c.push(m.x, m.y, m.z),
          y.subVectors(m, v).normalize(),
          d.push(y.x, y.y, y.z),
          p.push(T / n),
          p.push(U / i);
      }
    }
    for (let T = 1; T <= n; T++)
      for (let I = 1; I <= i; I++) {
        const U = (i + 1) * (T - 1) + (I - 1),
          F = (i + 1) * T + (I - 1),
          O = (i + 1) * T + I,
          z = (i + 1) * (T - 1) + I;
        l.push(U, F, z), l.push(F, O, z);
      }
    this.setIndex(l),
      this.setAttribute("position", new Lt(c, 3)),
      this.setAttribute("normal", new Lt(d, 3)),
      this.setAttribute("uv", new Lt(p, 2));
    function C(T, I, U, F, O) {
      const z = Math.cos(T),
        L = Math.sin(T),
        N = (U / I) * T,
        X = Math.cos(N);
      (O.x = F * (2 + X) * 0.5 * z),
        (O.y = F * (2 + X) * L * 0.5),
        (O.z = F * Math.sin(N) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Qg(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q,
    );
  }
}
class $g extends tn {
  constructor(
    e = new Z3(new Y(-1, -1, 0), new Y(-1, 1, 0), new Y(1, 1, 0)),
    t = 64,
    n = 1,
    i = 8,
    s = !1,
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: n,
        radialSegments: i,
        closed: s,
      });
    const a = e.computeFrenetFrames(t, s);
    (this.tangents = a.tangents),
      (this.normals = a.normals),
      (this.binormals = a.binormals);
    const l = new Y(),
      c = new Y(),
      d = new je();
    let p = new Y();
    const m = [],
      y = [],
      v = [],
      A = [];
    M(),
      this.setIndex(A),
      this.setAttribute("position", new Lt(m, 3)),
      this.setAttribute("normal", new Lt(y, 3)),
      this.setAttribute("uv", new Lt(v, 2));
    function M() {
      for (let T = 0; T < t; T++) w(T);
      w(s === !1 ? t : 0), C(), x();
    }
    function w(T) {
      p = e.getPointAt(T / t, p);
      const I = a.normals[T],
        U = a.binormals[T];
      for (let F = 0; F <= i; F++) {
        const O = (F / i) * Math.PI * 2,
          z = Math.sin(O),
          L = -Math.cos(O);
        (c.x = L * I.x + z * U.x),
          (c.y = L * I.y + z * U.y),
          (c.z = L * I.z + z * U.z),
          c.normalize(),
          y.push(c.x, c.y, c.z),
          (l.x = p.x + n * c.x),
          (l.y = p.y + n * c.y),
          (l.z = p.z + n * c.z),
          m.push(l.x, l.y, l.z);
      }
    }
    function x() {
      for (let T = 1; T <= t; T++)
        for (let I = 1; I <= i; I++) {
          const U = (i + 1) * (T - 1) + (I - 1),
            F = (i + 1) * T + (I - 1),
            O = (i + 1) * T + I,
            z = (i + 1) * (T - 1) + I;
          A.push(U, F, z), A.push(F, O, z);
        }
    }
    function C() {
      for (let T = 0; T <= t; T++)
        for (let I = 0; I <= i; I++)
          (d.x = T / t), (d.y = I / i), v.push(d.x, d.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new $g(
      new hg[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed,
    );
  }
}
class sS extends tn {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        n = new Set(),
        i = new Y(),
        s = new Y();
      if (e.index !== null) {
        const a = e.attributes.position,
          l = e.index;
        let c = e.groups;
        c.length === 0 &&
          (c = [{ start: 0, count: l.count, materialIndex: 0 }]);
        for (let d = 0, p = c.length; d < p; ++d) {
          const m = c[d],
            y = m.start,
            v = m.count;
          for (let A = y, M = y + v; A < M; A += 3)
            for (let w = 0; w < 3; w++) {
              const x = l.getX(A + w),
                C = l.getX(A + ((w + 1) % 3));
              i.fromBufferAttribute(a, x),
                s.fromBufferAttribute(a, C),
                U_(i, s, n) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let l = 0, c = a.count / 3; l < c; l++)
          for (let d = 0; d < 3; d++) {
            const p = 3 * l + d,
              m = 3 * l + ((d + 1) % 3);
            i.fromBufferAttribute(a, p),
              s.fromBufferAttribute(a, m),
              U_(i, s, n) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Lt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function U_(r, e, t) {
  const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var O_ = Object.freeze({
  __proto__: null,
  BoxGeometry: Vc,
  CapsuleGeometry: Vg,
  CircleGeometry: Gg,
  ConeGeometry: jg,
  CylinderGeometry: Ch,
  DodecahedronGeometry: Wg,
  EdgesGeometry: tS,
  ExtrudeGeometry: Jg,
  IcosahedronGeometry: sm,
  LatheGeometry: im,
  OctahedronGeometry: am,
  PlaneGeometry: Kl,
  PolyhedronGeometry: ql,
  RingGeometry: Yg,
  ShapeGeometry: Zg,
  SphereGeometry: om,
  TetrahedronGeometry: qg,
  TorusGeometry: Kg,
  TorusKnotGeometry: Qg,
  TubeGeometry: $g,
  WireframeGeometry: sS,
});
class aS extends Dr {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new dt(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class oS extends fs {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class lm extends Dr {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new dt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zl),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Cs()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Ri extends lm {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new je(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return en((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new dt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new dt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new dt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class lS extends Dr {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new dt(16777215)),
      (this.specular = new dt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zl),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Cs()),
      (this.combine = Zp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class uS extends Dr {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zl),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class cS extends Dr {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zl),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class dS extends Dr {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zl),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Cs()),
      (this.combine = Zp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class K3 extends Dr {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = T5),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Q3 extends Dr {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class hS extends Dr {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new dt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zl),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class fS extends Ii {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function _c(r, e, t) {
  return !r || (!t && r.constructor === e)
    ? r
    : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(r)
      : Array.prototype.slice.call(r);
}
function pS(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function mS(r) {
  function e(i, s) {
    return r[i] - r[s];
  }
  const t = r.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function Tv(r, e, t) {
  const n = r.length,
    i = new r.constructor(n);
  for (let s = 0, a = 0; a !== n; ++s) {
    const l = t[s] * e;
    for (let c = 0; c !== e; ++c) i[a++] = r[l + c];
  }
  return i;
}
function $3(r, e, t, n) {
  let i = 1,
    s = r[0];
  for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
  if (s === void 0) return;
  let a = s[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = s[n]),
          a !== void 0 && (e.push(s.time), t.push.apply(t, a)),
          (s = r[i++]);
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = s[n]),
          a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
          (s = r[i++]);
      while (s !== void 0);
    else
      do (a = s[n]), a !== void 0 && (e.push(s.time), t.push(a)), (s = r[i++]);
      while (s !== void 0);
}
function RI(r, e, t, n, i = 30) {
  const s = r.clone();
  s.name = e;
  const a = [];
  for (let c = 0; c < s.tracks.length; ++c) {
    const d = s.tracks[c],
      p = d.getValueSize(),
      m = [],
      y = [];
    for (let v = 0; v < d.times.length; ++v) {
      const A = d.times[v] * i;
      if (!(A < t || A >= n)) {
        m.push(d.times[v]);
        for (let M = 0; M < p; ++M) y.push(d.values[v * p + M]);
      }
    }
    m.length !== 0 &&
      ((d.times = _c(m, d.times.constructor)),
      (d.values = _c(y, d.values.constructor)),
      a.push(d));
  }
  s.tracks = a;
  let l = 1 / 0;
  for (let c = 0; c < s.tracks.length; ++c)
    l > s.tracks[c].times[0] && (l = s.tracks[c].times[0]);
  for (let c = 0; c < s.tracks.length; ++c) s.tracks[c].shift(-1 * l);
  return s.resetDuration(), s;
}
function II(r, e = 0, t = r, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length,
    s = e / n;
  for (let a = 0; a < i; ++a) {
    const l = t.tracks[a],
      c = l.ValueTypeName;
    if (c === "bool" || c === "string") continue;
    const d = r.tracks.find(function (x) {
      return x.name === l.name && x.ValueTypeName === c;
    });
    if (d === void 0) continue;
    let p = 0;
    const m = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    let y = 0;
    const v = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (y = v / 3);
    const A = l.times.length - 1;
    let M;
    if (s <= l.times[0]) {
      const x = p,
        C = m - p;
      M = l.values.slice(x, C);
    } else if (s >= l.times[A]) {
      const x = A * m + p,
        C = x + m - p;
      M = l.values.slice(x, C);
    } else {
      const x = l.createInterpolant(),
        C = p,
        T = m - p;
      x.evaluate(s), (M = x.resultBuffer.slice(C, T));
    }
    c === "quaternion" &&
      new Ci().fromArray(M).normalize().conjugate().toArray(M);
    const w = d.times.length;
    for (let x = 0; x < w; ++x) {
      const C = x * v + y;
      if (c === "quaternion")
        Ci.multiplyQuaternionsFlat(d.values, C, M, 0, d.values, C);
      else {
        const T = v - y * 2;
        for (let I = 0; I < T; ++I) d.values[C + I] -= M[I];
      }
    }
  }
  return (r.blendMode = B3), r;
}
const BI = {
  convertArray: _c,
  isTypedArray: pS,
  getKeyframeOrder: mS,
  sortedArray: Tv,
  flattenJSON: $3,
  subclip: RI,
  makeClipAdditive: II,
};
class Th {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      s = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          r: if (!(e < i)) {
            for (let l = n + 2; ; ) {
              if (i === void 0) {
                if (e < s) break r;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === l) break;
              if (((s = i), (i = t[++n]), e < i)) break t;
            }
            a = t.length;
            break n;
          }
          if (!(e >= s)) {
            const l = t[1];
            e < l && ((n = 2), (s = l));
            for (let c = n - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === c) break;
              if (((i = s), (s = t[--n - 1]), e >= s)) break t;
            }
            (a = n), (n = 0);
            break n;
          }
          break e;
        }
        for (; n < a; ) {
          const l = (n + a) >>> 1;
          e < t[l] ? (a = l) : (n = l + 1);
        }
        if (((i = t[n]), (s = t[n - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, s, i);
    }
    return this.interpolate_(n, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let a = 0; a !== i; ++a) t[a] = n[s + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class gS extends Th {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: yc, endingEnd: yc });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let s = e - 2,
      a = e + 1,
      l = i[s],
      c = i[a];
    if (l === void 0)
      switch (this.getSettings_().endingStart) {
        case vc:
          (s = e), (l = 2 * t - n);
          break;
        case Ep:
          (s = i.length - 2), (l = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (l = n);
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case vc:
          (a = e), (c = 2 * n - t);
          break;
        case Ep:
          (a = 1), (c = n + i[1] - i[0]);
          break;
        default:
          (a = e - 1), (c = t);
      }
    const d = (n - t) * 0.5,
      p = this.valueSize;
    (this._weightPrev = d / (t - l)),
      (this._weightNext = d / (c - n)),
      (this._offsetPrev = s * p),
      (this._offsetNext = a * p);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = e * l,
      d = c - l,
      p = this._offsetPrev,
      m = this._offsetNext,
      y = this._weightPrev,
      v = this._weightNext,
      A = (n - t) / (i - t),
      M = A * A,
      w = M * A,
      x = -y * w + 2 * y * M - y * A,
      C = (1 + y) * w + (-1.5 - 2 * y) * M + (-0.5 + y) * A + 1,
      T = (-1 - v) * w + (1.5 + v) * M + 0.5 * A,
      I = v * w - v * M;
    for (let U = 0; U !== l; ++U)
      s[U] = x * a[p + U] + C * a[d + U] + T * a[c + U] + I * a[m + U];
    return s;
  }
}
class ex extends Th {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = e * l,
      d = c - l,
      p = (n - t) / (i - t),
      m = 1 - p;
    for (let y = 0; y !== l; ++y) s[y] = a[d + y] * m + a[c + y] * p;
    return s;
  }
}
class yS extends Th {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Ta {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = _c(t, this.TimeBufferType)),
      (this.values = _c(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: _c(e.times, Array),
        values: _c(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new yS(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new ex(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new gS(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case mh:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case gh:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case y0:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return mh;
      case this.InterpolantFactoryMethodLinear:
        return gh;
      case this.InterpolantFactoryMethodSmooth:
        return y0;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let s = 0,
      a = i - 1;
    for (; s !== i && n[s] < e; ) ++s;
    for (; a !== -1 && n[a] > t; ) --a;
    if ((++a, s !== 0 || a !== i)) {
      s >= a && ((a = Math.max(a, 1)), (s = a - 1));
      const l = this.getValueSize();
      (this.times = n.slice(s, a)),
        (this.values = this.values.slice(s * l, a * l));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      s = n.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let l = 0; l !== s; l++) {
      const c = n[l];
      if (typeof c == "number" && isNaN(c)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          l,
          c,
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, l, c, a),
          (e = !1);
        break;
      }
      a = c;
    }
    if (i !== void 0 && pS(i))
      for (let l = 0, c = i.length; l !== c; ++l) {
        const d = i[l];
        if (isNaN(d)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            l,
            d,
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.getValueSize(),
      i = this.getInterpolation() === y0,
      s = e.length - 1;
    let a = 1;
    for (let l = 1; l < s; ++l) {
      let c = !1;
      const d = e[l],
        p = e[l + 1];
      if (d !== p && (l !== 1 || d !== e[0]))
        if (i) c = !0;
        else {
          const m = l * n,
            y = m - n,
            v = m + n;
          for (let A = 0; A !== n; ++A) {
            const M = t[m + A];
            if (M !== t[y + A] || M !== t[v + A]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (l !== a) {
          e[a] = e[l];
          const m = l * n,
            y = a * n;
          for (let v = 0; v !== n; ++v) t[y + v] = t[m + v];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let l = s * n, c = a * n, d = 0; d !== n; ++d) t[c + d] = t[l + d];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = e.slice(0, a)), (this.values = t.slice(0, a * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Ta.prototype.TimeBufferType = Float32Array;
Ta.prototype.ValueBufferType = Float32Array;
Ta.prototype.DefaultInterpolation = gh;
class Gc extends Ta {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
Gc.prototype.ValueTypeName = "bool";
Gc.prototype.ValueBufferType = Array;
Gc.prototype.DefaultInterpolation = mh;
Gc.prototype.InterpolantFactoryMethodLinear = void 0;
Gc.prototype.InterpolantFactoryMethodSmooth = void 0;
class tx extends Ta {}
tx.prototype.ValueTypeName = "color";
class Uc extends Ta {}
Uc.prototype.ValueTypeName = "number";
class vS extends Th {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = (n - t) / (i - t);
    let d = e * l;
    for (let p = d + l; d !== p; d += 4) Ci.slerpFlat(s, 0, a, d - l, a, d, c);
    return s;
  }
}
class Oc extends Ta {
  InterpolantFactoryMethodLinear(e) {
    return new vS(this.times, this.values, this.getValueSize(), e);
  }
}
Oc.prototype.ValueTypeName = "quaternion";
Oc.prototype.InterpolantFactoryMethodSmooth = void 0;
class jc extends Ta {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
jc.prototype.ValueTypeName = "string";
jc.prototype.ValueBufferType = Array;
jc.prototype.DefaultInterpolation = mh;
jc.prototype.InterpolantFactoryMethodLinear = void 0;
jc.prototype.InterpolantFactoryMethodSmooth = void 0;
class kc extends Ta {}
kc.prototype.ValueTypeName = "vector";
class bh {
  constructor(e = "", t = -1, n = [], i = Dg) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = Ms()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let a = 0, l = n.length; a !== l; ++a) t.push(LI(n[a]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, a = n.length; s !== a; ++s) t.push(Ta.toJSON(n[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const s = t.length,
      a = [];
    for (let l = 0; l < s; l++) {
      let c = [],
        d = [];
      c.push((l + s - 1) % s, l, (l + 1) % s), d.push(0, 1, 0);
      const p = mS(c);
      (c = Tv(c, 1, p)),
        (d = Tv(d, 1, p)),
        !i && c[0] === 0 && (c.push(s), d.push(d[0])),
        a.push(
          new Uc(".morphTargetInfluences[" + t[l].name + "]", c, d).scale(
            1 / n,
          ),
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let l = 0, c = e.length; l < c; l++) {
      const d = e[l],
        p = d.name.match(s);
      if (p && p.length > 1) {
        const m = p[1];
        let y = i[m];
        y || (i[m] = y = []), y.push(d);
      }
    }
    const a = [];
    for (const l in i)
      a.push(this.CreateFromMorphTargetSequence(l, i[l], t, n));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (p, m, y, v, A) {
        if (y.length !== 0) {
          const M = [],
            w = [];
          $3(y, M, w, v), M.length !== 0 && A.push(new p(m, M, w));
        }
      },
      i = [],
      s = e.name || "default",
      a = e.fps || 30,
      l = e.blendMode;
    let c = e.length || -1;
    const d = e.hierarchy || [];
    for (let p = 0; p < d.length; p++) {
      const m = d[p].keys;
      if (!(!m || m.length === 0))
        if (m[0].morphTargets) {
          const y = {};
          let v;
          for (v = 0; v < m.length; v++)
            if (m[v].morphTargets)
              for (let A = 0; A < m[v].morphTargets.length; A++)
                y[m[v].morphTargets[A]] = -1;
          for (const A in y) {
            const M = [],
              w = [];
            for (let x = 0; x !== m[v].morphTargets.length; ++x) {
              const C = m[v];
              M.push(C.time), w.push(C.morphTarget === A ? 1 : 0);
            }
            i.push(new Uc(".morphTargetInfluence[" + A + "]", M, w));
          }
          c = y.length * a;
        } else {
          const y = ".bones[" + t[p].name + "]";
          n(kc, y + ".position", m, "pos", i),
            n(Oc, y + ".quaternion", m, "rot", i),
            n(kc, y + ".scale", m, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, c, i, l);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function PI(r) {
  switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Uc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return kc;
    case "color":
      return tx;
    case "quaternion":
      return Oc;
    case "bool":
    case "boolean":
      return Gc;
    case "string":
      return jc;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function LI(r) {
  if (r.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = PI(r.type);
  if (r.times === void 0) {
    const t = [],
      n = [];
    $3(r.keys, t, n, "value"), (r.times = t), (r.values = n);
  }
  return e.parse !== void 0
    ? e.parse(r)
    : new e(r.name, r.times, r.values, r.interpolation);
}
const Wo = {
  enabled: !1,
  files: {},
  add: function (r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r];
  },
  remove: function (r) {
    delete this.files[r];
  },
  clear: function () {
    this.files = {};
  },
};
class e2 {
  constructor(e, t, n) {
    const i = this;
    let s = !1,
      a = 0,
      l = 0,
      c;
    const d = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (p) {
        l++, s === !1 && i.onStart !== void 0 && i.onStart(p, a, l), (s = !0);
      }),
      (this.itemEnd = function (p) {
        a++,
          i.onProgress !== void 0 && i.onProgress(p, a, l),
          a === l && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (p) {
        i.onError !== void 0 && i.onError(p);
      }),
      (this.resolveURL = function (p) {
        return c ? c(p) : p;
      }),
      (this.setURLModifier = function (p) {
        return (c = p), this;
      }),
      (this.addHandler = function (p, m) {
        return d.push(p, m), this;
      }),
      (this.removeHandler = function (p) {
        const m = d.indexOf(p);
        return m !== -1 && d.splice(m, 2), this;
      }),
      (this.getHandler = function (p) {
        for (let m = 0, y = d.length; m < y; m += 2) {
          const v = d[m],
            A = d[m + 1];
          if ((v.global && (v.lastIndex = 0), v.test(p))) return A;
        }
        return null;
      });
  }
}
const xS = new e2();
class di {
  constructor(e) {
    (this.manager = e !== void 0 ? e : xS),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
di.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const zo = {};
class DI extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class ci extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Wo.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (zo[e] !== void 0) {
      zo[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (zo[e] = []), zo[e].push({ onLoad: t, onProgress: n, onError: i });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      l = this.mimeType,
      c = this.responseType;
    fetch(a)
      .then((d) => {
        if (d.status === 200 || d.status === 0) {
          if (
            (d.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              d.body === void 0 ||
              d.body.getReader === void 0)
          )
            return d;
          const p = zo[e],
            m = d.body.getReader(),
            y = d.headers.get("X-File-Size") || d.headers.get("Content-Length"),
            v = y ? parseInt(y) : 0,
            A = v !== 0;
          let M = 0;
          const w = new ReadableStream({
            start(x) {
              C();
              function C() {
                m.read().then(
                  ({ done: T, value: I }) => {
                    if (T) x.close();
                    else {
                      M += I.byteLength;
                      const U = new ProgressEvent("progress", {
                        lengthComputable: A,
                        loaded: M,
                        total: v,
                      });
                      for (let F = 0, O = p.length; F < O; F++) {
                        const z = p[F];
                        z.onProgress && z.onProgress(U);
                      }
                      x.enqueue(I), C();
                    }
                  },
                  (T) => {
                    x.error(T);
                  },
                );
              }
            },
          });
          return new Response(w);
        } else
          throw new DI(
            `fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,
            d,
          );
      })
      .then((d) => {
        switch (c) {
          case "arraybuffer":
            return d.arrayBuffer();
          case "blob":
            return d.blob();
          case "document":
            return d.text().then((p) => new DOMParser().parseFromString(p, l));
          case "json":
            return d.json();
          default:
            if (l === void 0) return d.text();
            {
              const p = /charset="?([^;"\s]*)"?/i.exec(l),
                m = p && p[1] ? p[1].toLowerCase() : void 0,
                y = new TextDecoder(m);
              return d.arrayBuffer().then((v) => y.decode(v));
            }
        }
      })
      .then((d) => {
        Wo.add(e, d);
        const p = zo[e];
        delete zo[e];
        for (let m = 0, y = p.length; m < y; m++) {
          const v = p[m];
          v.onLoad && v.onLoad(d);
        }
      })
      .catch((d) => {
        const p = zo[e];
        if (p === void 0) throw (this.manager.itemError(e), d);
        delete zo[e];
        for (let m = 0, y = p.length; m < y; m++) {
          const v = p[m];
          v.onError && v.onError(d);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class FI extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new ci(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(s.parse(JSON.parse(l)));
          } catch (c) {
            i ? i(c) : console.error(c), s.manager.itemError(e);
          }
        },
        n,
        i,
      );
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = bh.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class NI extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = [],
      l = new zg(),
      c = new ci(this.manager);
    c.setPath(this.path),
      c.setResponseType("arraybuffer"),
      c.setRequestHeader(this.requestHeader),
      c.setWithCredentials(s.withCredentials);
    let d = 0;
    function p(m) {
      c.load(
        e[m],
        function (y) {
          const v = s.parse(y, !0);
          (a[m] = {
            width: v.width,
            height: v.height,
            format: v.format,
            mipmaps: v.mipmaps,
          }),
            (d += 1),
            d === 6 &&
              (v.mipmapCount === 1 && (l.minFilter = Un),
              (l.image = a),
              (l.format = v.format),
              (l.needsUpdate = !0),
              t && t(l));
        },
        n,
        i,
      );
    }
    if (Array.isArray(e)) for (let m = 0, y = e.length; m < y; ++m) p(m);
    else
      c.load(
        e,
        function (m) {
          const y = s.parse(m, !0);
          if (y.isCubemap) {
            const v = y.mipmaps.length / y.mipmapCount;
            for (let A = 0; A < v; A++) {
              a[A] = { mipmaps: [] };
              for (let M = 0; M < y.mipmapCount; M++)
                a[A].mipmaps.push(y.mipmaps[A * y.mipmapCount + M]),
                  (a[A].format = y.format),
                  (a[A].width = y.width),
                  (a[A].height = y.height);
            }
            l.image = a;
          } else
            (l.image.width = y.width),
              (l.image.height = y.height),
              (l.mipmaps = y.mipmaps);
          y.mipmapCount === 1 && (l.minFilter = Un),
            (l.format = y.format),
            (l.needsUpdate = !0),
            t && t(l);
        },
        n,
        i,
      );
    return l;
  }
}
class Fp extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = Wo.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const l = Ip("img");
    function c() {
      p(), Wo.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function d(m) {
      p(), i && i(m), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function p() {
      l.removeEventListener("load", c, !1),
        l.removeEventListener("error", d, !1);
    }
    return (
      l.addEventListener("load", c, !1),
      l.addEventListener("error", d, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (l.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (l.src = e),
      l
    );
  }
}
class bS extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = new em();
    s.colorSpace = Ei;
    const a = new Fp(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let l = 0;
    function c(d) {
      a.load(
        e[d],
        function (p) {
          (s.images[d] = p), l++, l === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        i,
      );
    }
    for (let d = 0; d < e.length; ++d) c(d);
    return s;
  }
}
class nx extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new wa(),
      l = new ci(this.manager);
    return (
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setPath(this.path),
      l.setWithCredentials(s.withCredentials),
      l.load(
        e,
        function (c) {
          let d;
          try {
            d = s.parse(c);
          } catch (p) {
            if (i !== void 0) i(p);
            else {
              console.error(p);
              return;
            }
          }
          d.image !== void 0
            ? (a.image = d.image)
            : d.data !== void 0 &&
              ((a.image.width = d.width),
              (a.image.height = d.height),
              (a.image.data = d.data)),
            (a.wrapS = d.wrapS !== void 0 ? d.wrapS : Ar),
            (a.wrapT = d.wrapT !== void 0 ? d.wrapT : Ar),
            (a.magFilter = d.magFilter !== void 0 ? d.magFilter : Un),
            (a.minFilter = d.minFilter !== void 0 ? d.minFilter : Un),
            (a.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1),
            d.colorSpace !== void 0 && (a.colorSpace = d.colorSpace),
            d.flipY !== void 0 && (a.flipY = d.flipY),
            d.format !== void 0 && (a.format = d.format),
            d.type !== void 0 && (a.type = d.type),
            d.mipmaps !== void 0 &&
              ((a.mipmaps = d.mipmaps), (a.minFilter = Ys)),
            d.mipmapCount === 1 && (a.minFilter = Un),
            d.generateMipmaps !== void 0 &&
              (a.generateMipmaps = d.generateMipmaps),
            (a.needsUpdate = !0),
            t && t(a, d);
        },
        n,
        i,
      ),
      a
    );
  }
}
class rx extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = new Ln(),
      a = new Fp(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (l) {
          (s.image = l), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        n,
        i,
      ),
      s
    );
  }
}
class Ql extends _n {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new dt(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class _S extends Ql {
  constructor(e, t, n) {
    super(e, n),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(_n.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new dt(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const wy = new jt(),
  k_ = new Y(),
  z_ = new Y();
class ix {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new je(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new jt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new rm()),
      (this._frameExtents = new je(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Cn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    k_.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(k_),
      z_.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(z_),
      t.updateMatrixWorld(),
      wy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(wy),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(wy);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class UI extends ix {
  constructor() {
    super(new Hr(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = yh * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class sx extends Ql {
  constructor(e, t, n = 0, i = Math.PI / 3, s = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(_n.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new _n()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new UI());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const H_ = new jt(),
  Gf = new Y(),
  My = new Y();
class OI extends ix {
  constructor() {
    super(new Hr(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new je(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Cn(2, 1, 1, 1),
        new Cn(0, 1, 1, 1),
        new Cn(3, 1, 1, 1),
        new Cn(1, 1, 1, 1),
        new Cn(3, 0, 1, 1),
        new Cn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Y(1, 0, 0),
        new Y(-1, 0, 0),
        new Y(0, 0, 1),
        new Y(0, 0, -1),
        new Y(0, 1, 0),
        new Y(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Y(0, 1, 0),
        new Y(0, 1, 0),
        new Y(0, 1, 0),
        new Y(0, 1, 0),
        new Y(0, 0, 1),
        new Y(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      s = e.distance || n.far;
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      Gf.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(Gf),
      My.copy(n.position),
      My.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(My),
      n.updateMatrixWorld(),
      i.makeTranslation(-Gf.x, -Gf.y, -Gf.z),
      H_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(H_);
  }
}
class ax extends Ql {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new OI());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Wc extends $p {
  constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = n - e,
      a = n + e,
      l = i + t,
      c = i - t;
    if (this.view !== null && this.view.enabled) {
      const d = (this.right - this.left) / this.view.fullWidth / this.zoom,
        p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += d * this.view.offsetX),
        (a = s + d * this.view.width),
        (l -= p * this.view.offsetY),
        (c = l - p * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      a,
      l,
      c,
      this.near,
      this.far,
      this.coordinateSystem,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class kI extends ix {
  constructor() {
    super(new Wc(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class ox extends Ql {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(_n.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new _n()),
      (this.shadow = new kI());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class AS extends Ql {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class wS extends Ql {
  constructor(e, t, n = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = n),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class MS {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new Y());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.282095),
      t.addScaledVector(a[1], 0.488603 * i),
      t.addScaledVector(a[2], 0.488603 * s),
      t.addScaledVector(a[3], 0.488603 * n),
      t.addScaledVector(a[4], 1.092548 * (n * i)),
      t.addScaledVector(a[5], 1.092548 * (i * s)),
      t.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(a[7], 1.092548 * (n * s)),
      t.addScaledVector(a[8], 0.546274 * (n * n - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.886227),
      t.addScaledVector(a[1], 2 * 0.511664 * i),
      t.addScaledVector(a[2], 2 * 0.511664 * s),
      t.addScaledVector(a[3], 2 * 0.511664 * n),
      t.addScaledVector(a[4], 2 * 0.429043 * n * i),
      t.addScaledVector(a[5], 2 * 0.429043 * i * s),
      t.addScaledVector(a[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(a[7], 2 * 0.429043 * n * s),
      t.addScaledVector(a[8], 0.429043 * (n * n - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * n),
      (t[4] = 1.092548 * n * i),
      (t[5] = 1.092548 * i * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * n * s),
      (t[8] = 0.546274 * (n * n - i * i));
  }
}
class SS extends Ql {
  constructor(e = new MS(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class t2 extends di {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, n, i) {
    const s = this,
      a = new ci(s.manager);
    a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(s.parse(JSON.parse(l)));
          } catch (c) {
            i ? i(c) : console.error(c), s.manager.itemError(e);
          }
        },
        n,
        i,
      );
  }
  parse(e) {
    const t = this.textures;
    function n(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const i = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new dt().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const a = e.uniforms[s];
        switch (((i.uniforms[s] = {}), a.type)) {
          case "t":
            i.uniforms[s].value = n(a.value);
            break;
          case "c":
            i.uniforms[s].value = new dt().setHex(a.value);
            break;
          case "v2":
            i.uniforms[s].value = new je().fromArray(a.value);
            break;
          case "v3":
            i.uniforms[s].value = new Y().fromArray(a.value);
            break;
          case "v4":
            i.uniforms[s].value = new Cn().fromArray(a.value);
            break;
          case "m3":
            i.uniforms[s].value = new an().fromArray(a.value);
            break;
          case "m4":
            i.uniforms[s].value = new jt().fromArray(a.value);
            break;
          default:
            i.uniforms[s].value = a.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) i.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = n(e.map)),
      e.matcap !== void 0 && (i.matcap = n(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (i.normalScale = new je().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = n(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = n(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = n(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = n(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new je().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = n(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  createMaterialFromType(e) {
    return t2.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: aS,
      SpriteMaterial: k3,
      RawShaderMaterial: oS,
      ShaderMaterial: fs,
      PointsMaterial: kg,
      MeshPhysicalMaterial: Ri,
      MeshStandardMaterial: lm,
      MeshPhongMaterial: lS,
      MeshToonMaterial: uS,
      MeshNormalMaterial: cS,
      MeshLambertMaterial: dS,
      MeshDepthMaterial: K3,
      MeshDistanceMaterial: Q3,
      MeshBasicMaterial: ds,
      MeshMatcapMaterial: hS,
      LineDashedMaterial: fS,
      LineBasicMaterial: Ii,
      Material: Dr,
    };
    return new t[e]();
  }
}
class Vl {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.",
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class ES extends tn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class CS extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new ci(s.manager);
    a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            t(s.parse(JSON.parse(l)));
          } catch (c) {
            i ? i(c) : console.error(c), s.manager.itemError(e);
          }
        },
        n,
        i,
      );
  }
  parse(e) {
    const t = {},
      n = {};
    function i(y, v) {
      if (t[v] !== void 0) return t[v];
      const A = y.interleavedBuffers[v],
        M = s(y, A.buffer),
        w = rh(A.type, M),
        x = new tm(w, A.stride);
      return (x.uuid = A.uuid), (t[v] = x), x;
    }
    function s(y, v) {
      if (n[v] !== void 0) return n[v];
      const A = y.arrayBuffers[v],
        M = new Uint32Array(A).buffer;
      return (n[v] = M), M;
    }
    const a = e.isInstancedBufferGeometry ? new ES() : new tn(),
      l = e.data.index;
    if (l !== void 0) {
      const y = rh(l.type, l.array);
      a.setIndex(new Tn(y, 1));
    }
    const c = e.data.attributes;
    for (const y in c) {
      const v = c[y];
      let A;
      if (v.isInterleavedBufferAttribute) {
        const M = i(e.data, v.data);
        A = new Jl(M, v.itemSize, v.offset, v.normalized);
      } else {
        const M = rh(v.type, v.array),
          w = v.isInstancedBufferAttribute ? Fc : Tn;
        A = new w(M, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (A.name = v.name),
        v.usage !== void 0 && A.setUsage(v.usage),
        a.setAttribute(y, A);
    }
    const d = e.data.morphAttributes;
    if (d)
      for (const y in d) {
        const v = d[y],
          A = [];
        for (let M = 0, w = v.length; M < w; M++) {
          const x = v[M];
          let C;
          if (x.isInterleavedBufferAttribute) {
            const T = i(e.data, x.data);
            C = new Jl(T, x.itemSize, x.offset, x.normalized);
          } else {
            const T = rh(x.type, x.array);
            C = new Tn(T, x.itemSize, x.normalized);
          }
          x.name !== void 0 && (C.name = x.name), A.push(C);
        }
        a.morphAttributes[y] = A;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const p = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (p !== void 0)
      for (let y = 0, v = p.length; y !== v; ++y) {
        const A = p[y];
        a.addGroup(A.start, A.count, A.materialIndex);
      }
    const m = e.data.boundingSphere;
    if (m !== void 0) {
      const y = new Y();
      m.center !== void 0 && y.fromArray(m.center),
        (a.boundingSphere = new ui(y, m.radius));
    }
    return (
      e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
    );
  }
}
class zI extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = this.path === "" ? Vl.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const l = new ci(this.manager);
    l.setPath(this.path),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          let d = null;
          try {
            d = JSON.parse(c);
          } catch (m) {
            i !== void 0 && i(m),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                m.message,
              );
            return;
          }
          const p = d.metadata;
          if (
            p === void 0 ||
            p.type === void 0 ||
            p.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(d, t);
        },
        n,
        i,
      );
  }
  async loadAsync(e, t) {
    const n = this,
      i = this.path === "" ? Vl.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new ci(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const a = await s.loadAsync(e, t),
      l = JSON.parse(a),
      c = l.metadata;
    if (
      c === void 0 ||
      c.type === void 0 ||
      c.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(l);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, i),
      a = this.parseImages(e.images, function () {
        t !== void 0 && t(d);
      }),
      l = this.parseTextures(e.textures, a),
      c = this.parseMaterials(e.materials, l),
      d = this.parseObject(e.object, s, c, l, n),
      p = this.parseSkeletons(e.skeletons, d);
    if ((this.bindSkeletons(d, p), this.bindLightTargets(d), t !== void 0)) {
      let m = !1;
      for (const y in a)
        if (a[y].data instanceof HTMLImageElement) {
          m = !0;
          break;
        }
      m === !1 && t(d);
    }
    return d;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      n = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, n),
      s = await this.parseImagesAsync(e.images),
      a = this.parseTextures(e.textures, s),
      l = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, i, l, a, t),
      d = this.parseSkeletons(e.skeletons, c);
    return this.bindSkeletons(c, d), this.bindLightTargets(c), c;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const s = new Rc().fromJSON(e[n]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {},
      i = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (i[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, a = e.length; s < a; s++) {
        const l = new nm().fromJSON(e[s], i);
        n[l.uuid] = l;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new CS();
      for (let s = 0, a = e.length; s < a; s++) {
        let l;
        const c = e[s];
        switch (c.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            l = i.parse(c);
            break;
          default:
            c.type in O_
              ? (l = O_[c.type].fromJSON(c, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${c.type}"`,
                );
        }
        (l.uuid = c.uuid),
          c.name !== void 0 && (l.name = c.name),
          c.userData !== void 0 && (l.userData = c.userData),
          (n[c.uuid] = l);
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {},
      i = {};
    if (e !== void 0) {
      const s = new t2();
      s.setTextures(t);
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a];
        n[c.uuid] === void 0 && (n[c.uuid] = s.parse(c)),
          (i[c.uuid] = n[c.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n],
          s = bh.parse(i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this,
      i = {};
    let s;
    function a(c) {
      return (
        n.manager.itemStart(c),
        s.load(
          c,
          function () {
            n.manager.itemEnd(c);
          },
          void 0,
          function () {
            n.manager.itemError(c), n.manager.itemEnd(c);
          },
        )
      );
    }
    function l(c) {
      if (typeof c == "string") {
        const d = c,
          p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
        return a(p);
      } else
        return c.data
          ? { data: rh(c.type, c.data), width: c.width, height: c.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const c = new e2(t);
      (s = new Fp(c)), s.setCrossOrigin(this.crossOrigin);
      for (let d = 0, p = e.length; d < p; d++) {
        const m = e[d],
          y = m.url;
        if (Array.isArray(y)) {
          const v = [];
          for (let A = 0, M = y.length; A < M; A++) {
            const w = y[A],
              x = l(w);
            x !== null &&
              (x instanceof HTMLImageElement
                ? v.push(x)
                : v.push(new wa(x.data, x.width, x.height)));
          }
          i[m.uuid] = new xc(v);
        } else {
          const v = l(m.url);
          i[m.uuid] = new xc(v);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      n = {};
    let i;
    async function s(a) {
      if (typeof a == "string") {
        const l = a,
          c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
        return await i.loadAsync(c);
      } else
        return a.data
          ? { data: rh(a.type, a.data), width: a.width, height: a.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Fp(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a],
          d = c.url;
        if (Array.isArray(d)) {
          const p = [];
          for (let m = 0, y = d.length; m < y; m++) {
            const v = d[m],
              A = await s(v);
            A !== null &&
              (A instanceof HTMLImageElement
                ? p.push(A)
                : p.push(new wa(A.data, A.width, A.height)));
          }
          n[c.uuid] = new xc(p);
        } else {
          const p = await s(c.url);
          n[c.uuid] = new xc(p);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(s, a) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s,
          ),
          a[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, a = e.length; s < a; s++) {
        const l = e[s];
        l.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
          t[l.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", l.image);
        const c = t[l.image],
          d = c.data;
        let p;
        Array.isArray(d)
          ? ((p = new em()), d.length === 6 && (p.needsUpdate = !0))
          : (d && d.data ? (p = new wa()) : (p = new Ln()),
            d && (p.needsUpdate = !0)),
          (p.source = c),
          (p.uuid = l.uuid),
          l.name !== void 0 && (p.name = l.name),
          l.mapping !== void 0 && (p.mapping = n(l.mapping, HI)),
          l.channel !== void 0 && (p.channel = l.channel),
          l.offset !== void 0 && p.offset.fromArray(l.offset),
          l.repeat !== void 0 && p.repeat.fromArray(l.repeat),
          l.center !== void 0 && p.center.fromArray(l.center),
          l.rotation !== void 0 && (p.rotation = l.rotation),
          l.wrap !== void 0 &&
            ((p.wrapS = n(l.wrap[0], V_)), (p.wrapT = n(l.wrap[1], V_))),
          l.format !== void 0 && (p.format = l.format),
          l.internalFormat !== void 0 && (p.internalFormat = l.internalFormat),
          l.type !== void 0 && (p.type = l.type),
          l.colorSpace !== void 0 && (p.colorSpace = l.colorSpace),
          l.minFilter !== void 0 && (p.minFilter = n(l.minFilter, G_)),
          l.magFilter !== void 0 && (p.magFilter = n(l.magFilter, G_)),
          l.anisotropy !== void 0 && (p.anisotropy = l.anisotropy),
          l.flipY !== void 0 && (p.flipY = l.flipY),
          l.generateMipmaps !== void 0 &&
            (p.generateMipmaps = l.generateMipmaps),
          l.premultiplyAlpha !== void 0 &&
            (p.premultiplyAlpha = l.premultiplyAlpha),
          l.unpackAlignment !== void 0 &&
            (p.unpackAlignment = l.unpackAlignment),
          l.compareFunction !== void 0 &&
            (p.compareFunction = l.compareFunction),
          l.userData !== void 0 && (p.userData = l.userData),
          (i[l.uuid] = p);
      }
    return i;
  }
  parseObject(e, t, n, i, s) {
    let a;
    function l(y) {
      return (
        t[y] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", y),
        t[y]
      );
    }
    function c(y) {
      if (y !== void 0) {
        if (Array.isArray(y)) {
          const v = [];
          for (let A = 0, M = y.length; A < M; A++) {
            const w = y[A];
            n[w] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", w),
              v.push(n[w]);
          }
          return v;
        }
        return (
          n[y] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", y),
          n[y]
        );
      }
    }
    function d(y) {
      return (
        i[y] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", y),
        i[y]
      );
    }
    let p, m;
    switch (e.type) {
      case "Scene":
        (a = new xh()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (a.background = new dt(e.background))
              : (a.background = d(e.background))),
          e.environment !== void 0 && (a.environment = d(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (a.fog = new Ug(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (a.fog = new Ng(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (a.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (a.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (a.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            a.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (a.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            a.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (a = new Hr(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (a.focus = e.focus),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (a = new Wc(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new AS(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (a = new ox(e.color, e.intensity)), (a.target = e.target || "");
        break;
      case "PointLight":
        a = new ax(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new wS(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (a = new sx(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay,
        )),
          (a.target = e.target || "");
        break;
      case "HemisphereLight":
        a = new _S(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new SS().fromJSON(e);
        break;
      case "SkinnedMesh":
        (p = l(e.geometry)),
          (m = c(e.material)),
          (a = new z3(p, m)),
          e.bindMode !== void 0 && (a.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        (p = l(e.geometry)), (m = c(e.material)), (a = new nr(p, m));
        break;
      case "InstancedMesh":
        (p = l(e.geometry)), (m = c(e.material));
        const y = e.count,
          v = e.instanceMatrix,
          A = e.instanceColor;
        (a = new H3(p, m, y)),
          (a.instanceMatrix = new Fc(new Float32Array(v.array), 16)),
          A !== void 0 &&
            (a.instanceColor = new Fc(new Float32Array(A.array), A.itemSize));
        break;
      case "BatchedMesh":
        (p = l(e.geometry)),
          (m = c(e.material)),
          (a = new Z5(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            m,
          )),
          (a.geometry = p),
          (a.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (a.sortObjects = e.sortObjects),
          (a._drawRanges = e.drawRanges),
          (a._reservedRanges = e.reservedRanges),
          (a._visibility = e.visibility),
          (a._active = e.active),
          (a._bounds = e.bounds.map((M) => {
            const w = new Ti();
            w.min.fromArray(M.boxMin), w.max.fromArray(M.boxMax);
            const x = new ui();
            return (
              (x.radius = M.sphereRadius),
              x.center.fromArray(M.sphereCenter),
              {
                boxInitialized: M.boxInitialized,
                box: w,
                sphereInitialized: M.sphereInitialized,
                sphere: x,
              }
            );
          })),
          (a._maxInstanceCount = e.maxInstanceCount),
          (a._maxVertexCount = e.maxVertexCount),
          (a._maxIndexCount = e.maxIndexCount),
          (a._geometryInitialized = e.geometryInitialized),
          (a._geometryCount = e.geometryCount),
          (a._matricesTexture = d(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (a._colorsTexture = d(e.colorsTexture.uuid));
        break;
      case "LOD":
        a = new Y5();
        break;
      case "Line":
        a = new Ko(l(e.geometry), c(e.material));
        break;
      case "LineLoop":
        a = new V3(l(e.geometry), c(e.material));
        break;
      case "LineSegments":
        a = new Ea(l(e.geometry), c(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new G3(l(e.geometry), c(e.material));
        break;
      case "Sprite":
        a = new J5(c(e.material));
        break;
      case "Group":
        a = new jo();
        break;
      case "Bone":
        a = new Og();
        break;
      default:
        a = new _n();
    }
    if (
      ((a.uuid = e.uuid),
      e.name !== void 0 && (a.name = e.name),
      e.matrix !== void 0
        ? (a.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (a.matrixAutoUpdate = e.matrixAutoUpdate),
          a.matrixAutoUpdate &&
            a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (e.position !== void 0 && a.position.fromArray(e.position),
          e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && a.scale.fromArray(e.scale)),
      e.up !== void 0 && a.up.fromArray(e.up),
      e.castShadow !== void 0 && (a.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (a.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (a.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          a.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (a.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (a.visible = e.visible),
      e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
      e.userData !== void 0 && (a.userData = e.userData),
      e.layers !== void 0 && (a.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const y = e.children;
      for (let v = 0; v < y.length; v++)
        a.add(this.parseObject(y[v], t, n, i, s));
    }
    if (e.animations !== void 0) {
      const y = e.animations;
      for (let v = 0; v < y.length; v++) {
        const A = y[v];
        a.animations.push(s[A]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const y = e.levels;
      for (let v = 0; v < y.length; v++) {
        const A = y[v],
          M = a.getObjectByProperty("uuid", A.object);
        M !== void 0 && a.addLevel(M, A.distance, A.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (n) {
        if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
          const i = t[n.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                n.skeleton,
              )
            : n.bind(i, n.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target,
          i = e.getObjectByProperty("uuid", n);
        i !== void 0 ? (t.target = i) : (t.target = new _n());
      }
    });
  }
}
const HI = {
    UVMapping: jl,
    CubeReflectionMapping: io,
    CubeRefractionMapping: Wl,
    EquirectangularReflectionMapping: hh,
    EquirectangularRefractionMapping: Sp,
    CubeUVReflectionMapping: Sh,
  },
  V_ = {
    RepeatWrapping: Xl,
    ClampToEdgeWrapping: Ar,
    MirroredRepeatWrapping: fh,
  },
  G_ = {
    NearestFilter: Qr,
    NearestMipmapNearestFilter: Cg,
    NearestMipmapLinearFilter: gc,
    LinearFilter: Un,
    LinearMipmapNearestFilter: ah,
    LinearMipmapLinearFilter: Ys,
  };
class TS extends di {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported.",
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = Wo.get(e);
    if (a !== void 0) {
      if ((s.manager.itemStart(e), a.then)) {
        a.then((d) => {
          t && t(d), s.manager.itemEnd(e);
        }).catch((d) => {
          i && i(d);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    }
    const l = {};
    (l.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (l.headers = this.requestHeader);
    const c = fetch(e, l)
      .then(function (d) {
        return d.blob();
      })
      .then(function (d) {
        return createImageBitmap(
          d,
          Object.assign(s.options, { colorSpaceConversion: "none" }),
        );
      })
      .then(function (d) {
        return Wo.add(e, d), t && t(d), s.manager.itemEnd(e), d;
      })
      .catch(function (d) {
        i && i(d), Wo.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
      });
    Wo.add(e, c), s.manager.itemStart(e);
  }
}
let q1;
class lx {
  static getContext() {
    return (
      q1 === void 0 &&
        (q1 = new (window.AudioContext || window.webkitAudioContext)()),
      q1
    );
  }
  static setContext(e) {
    q1 = e;
  }
}
class VI extends di {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new ci(this.manager);
    a.setResponseType("arraybuffer"),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (c) {
          try {
            const d = c.slice(0);
            lx.getContext()
              .decodeAudioData(d, function (p) {
                t(p);
              })
              .catch(l);
          } catch (d) {
            l(d);
          }
        },
        n,
        i,
      );
    function l(c) {
      i ? i(c) : console.error(c), s.manager.itemError(e);
    }
  }
}
const j_ = new jt(),
  W_ = new jt(),
  tc = new jt();
class GI {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Hr()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Hr()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        tc.copy(e.projectionMatrix);
      const n = t.eyeSep / 2,
        i = (n * t.near) / t.focus,
        s = (t.near * Math.tan(Cc * t.fov * 0.5)) / t.zoom;
      let a, l;
      (W_.elements[12] = -n),
        (j_.elements[12] = n),
        (a = -s * t.aspect + i),
        (l = s * t.aspect + i),
        (tc.elements[0] = (2 * t.near) / (l - a)),
        (tc.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(tc),
        (a = -s * t.aspect - i),
        (l = s * t.aspect - i),
        (tc.elements[0] = (2 * t.near) / (l - a)),
        (tc.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(tc);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(W_),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(j_);
  }
}
class RS extends Hr {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ux {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = X_()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = X_();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function X_() {
  return performance.now();
}
const nc = new Y(),
  J_ = new Ci(),
  jI = new Y(),
  rc = new Y();
class WI extends _n {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = lx.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new ux());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      n = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(nc, J_, jI),
      rc.set(0, 0, -1).applyQuaternion(J_),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(nc.x, i),
        t.positionY.linearRampToValueAtTime(nc.y, i),
        t.positionZ.linearRampToValueAtTime(nc.z, i),
        t.forwardX.linearRampToValueAtTime(rc.x, i),
        t.forwardY.linearRampToValueAtTime(rc.y, i),
        t.forwardZ.linearRampToValueAtTime(rc.z, i),
        t.upX.linearRampToValueAtTime(n.x, i),
        t.upY.linearRampToValueAtTime(n.y, i),
        t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(nc.x, nc.y, nc.z),
        t.setOrientation(rc.x, rc.y, rc.z, n.x, n.y, n.z);
  }
}
class IS extends _n {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01,
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01,
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== "buffer"
        ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
          this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const ic = new Y(),
  Y_ = new Ci(),
  XI = new Y(),
  sc = new Y();
class JI extends IS {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, n) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = n),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(ic, Y_, XI), sc.set(0, 0, 1).applyQuaternion(Y_);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(ic.x, n),
        t.positionY.linearRampToValueAtTime(ic.y, n),
        t.positionZ.linearRampToValueAtTime(ic.z, n),
        t.orientationX.linearRampToValueAtTime(sc.x, n),
        t.orientationY.linearRampToValueAtTime(sc.y, n),
        t.orientationZ.linearRampToValueAtTime(sc.z, n);
    } else t.setPosition(ic.x, ic.y, ic.z), t.setOrientation(sc.x, sc.y, sc.z);
  }
}
class YI {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++) e += t[n];
    return e / t.length;
  }
}
class BS {
  constructor(e, t, n) {
    (this.binding = e), (this.valueSize = n);
    let i, s, a;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (s = this._slerpAdditive),
          (a = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (s = this._select),
          (a = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (i = this._lerp),
          (s = this._lerpAdditive),
          (a = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = a),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const n = this.buffer,
      i = this.valueSize,
      s = e * i + i;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let l = 0; l !== i; ++l) n[s + l] = n[l];
      a = t;
    } else {
      a += t;
      const l = t / a;
      this._mixBufferRegion(n, s, 0, l, i);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, n),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      n = this.buffer,
      i = e * t + t,
      s = this.cumulativeWeight,
      a = this.cumulativeWeightAdditive,
      l = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const c = t * this._origIndex;
      this._mixBufferRegion(n, i, c, 1 - s, t);
    }
    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let c = t, d = t + t; c !== d; ++c)
      if (n[c] !== n[c + t]) {
        l.setValue(n, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    e.getValue(t, i);
    for (let s = n, a = i; s !== a; ++s) t[s] = t[i + (s % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, i, s) {
    if (i >= 0.5) for (let a = 0; a !== s; ++a) e[t + a] = e[n + a];
  }
  _slerp(e, t, n, i) {
    Ci.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, s) {
    const a = this._workIndex * s;
    Ci.multiplyQuaternionsFlat(e, a, e, t, e, n),
      Ci.slerpFlat(e, t, e, t, e, a, i);
  }
  _lerp(e, t, n, i, s) {
    const a = 1 - i;
    for (let l = 0; l !== s; ++l) {
      const c = t + l;
      e[c] = e[c] * a + e[n + l] * i;
    }
  }
  _lerpAdditive(e, t, n, i, s) {
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] + e[n + a] * i;
    }
  }
}
const cx = "\\[\\]\\.:\\/",
  ZI = new RegExp("[" + cx + "]", "g"),
  dx = "[^" + cx + "]",
  qI = "[^" + cx.replace("\\.", "") + "]",
  KI = /((?:WC+[\/:])*)/.source.replace("WC", dx),
  QI = /(WCOD+)?/.source.replace("WCOD", qI),
  $I = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", dx),
  eB = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", dx),
  tB = new RegExp("^" + KI + QI + $I + eB + "$"),
  nB = ["material", "materials", "bones", "map"];
class rB {
  constructor(e, t, n) {
    const i = n || Mn.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Mn {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || Mn.parseTrackName(t)),
      (this.node = Mn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new Mn.Composite(e, t, n)
      : new Mn(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(ZI, "");
  }
  static parseTrackName(e) {
    const t = tB.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = n.nodeName.substring(i + 1);
      nB.indexOf(s) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = s));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e,
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (s) {
          for (let a = 0; a < s.length; a++) {
            const l = s[a];
            if (l.name === t || l.uuid === t) return l;
            const c = n(l.children);
            if (c) return c;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Mn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          ".",
      );
      return;
    }
    if (n) {
      let d = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this,
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this,
            );
            return;
          }
          e = e.skeleton.bones;
          for (let p = 0; p < e.length; p++)
            if (e[p].name === d) {
              d = p;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this,
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this,
            );
            return;
          }
          e = e[n];
      }
      if (d !== void 0) {
        if (e[d] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e,
          );
          return;
        }
        e = e[d];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const d = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          d +
          "." +
          i +
          " but it wasn't found.",
        e,
      );
      return;
    }
    let l = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (l = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (l = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this,
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this,
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (c = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = s);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((c = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
          ? ((c = this.BindingType.EntireArray), (this.resolvedProperty = a))
          : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[c]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[c][l]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Mn.Composite = rB;
Mn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Mn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Mn.prototype.GetterByBindingType = [
  Mn.prototype._getValue_direct,
  Mn.prototype._getValue_array,
  Mn.prototype._getValue_arrayElement,
  Mn.prototype._getValue_toArray,
];
Mn.prototype.SetterByBindingTypeAndVersioning = [
  [
    Mn.prototype._setValue_direct,
    Mn.prototype._setValue_direct_setNeedsUpdate,
    Mn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Mn.prototype._setValue_array,
    Mn.prototype._setValue_array_setNeedsUpdate,
    Mn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Mn.prototype._setValue_arrayElement,
    Mn.prototype._setValue_arrayElement_setNeedsUpdate,
    Mn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Mn.prototype._setValue_fromArray,
    Mn.prototype._setValue_fromArray_setNeedsUpdate,
    Mn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class iB {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = Ms()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      a = s.length;
    let l,
      c = e.length,
      d = this.nCachedObjects_;
    for (let p = 0, m = arguments.length; p !== m; ++p) {
      const y = arguments[p],
        v = y.uuid;
      let A = t[v];
      if (A === void 0) {
        (A = c++), (t[v] = A), e.push(y);
        for (let M = 0, w = a; M !== w; ++M) s[M].push(new Mn(y, n[M], i[M]));
      } else if (A < d) {
        l = e[A];
        const M = --d,
          w = e[M];
        (t[w.uuid] = A), (e[A] = w), (t[v] = M), (e[M] = y);
        for (let x = 0, C = a; x !== C; ++x) {
          const T = s[x],
            I = T[M];
          let U = T[A];
          (T[A] = I), U === void 0 && (U = new Mn(y, n[x], i[x])), (T[M] = U);
        }
      } else
        e[A] !== l &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.",
          );
    }
    this.nCachedObjects_ = d;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let s = this.nCachedObjects_;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a],
        d = c.uuid,
        p = t[d];
      if (p !== void 0 && p >= s) {
        const m = s++,
          y = e[m];
        (t[y.uuid] = p), (e[p] = y), (t[d] = m), (e[m] = c);
        for (let v = 0, A = i; v !== A; ++v) {
          const M = n[v],
            w = M[m],
            x = M[p];
          (M[p] = w), (M[m] = x);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let s = this.nCachedObjects_,
      a = e.length;
    for (let l = 0, c = arguments.length; l !== c; ++l) {
      const d = arguments[l],
        p = d.uuid,
        m = t[p];
      if (m !== void 0)
        if ((delete t[p], m < s)) {
          const y = --s,
            v = e[y],
            A = --a,
            M = e[A];
          (t[v.uuid] = m), (e[m] = v), (t[M.uuid] = y), (e[y] = M), e.pop();
          for (let w = 0, x = i; w !== x; ++w) {
            const C = n[w],
              T = C[y],
              I = C[A];
            (C[m] = T), (C[y] = I), C.pop();
          }
        } else {
          const y = --a,
            v = e[y];
          y > 0 && (t[v.uuid] = m), (e[m] = v), e.pop();
          for (let A = 0, M = i; A !== M; ++A) {
            const w = n[A];
            (w[m] = w[y]), w.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const s = this._bindings;
    if (i !== void 0) return s[i];
    const a = this._paths,
      l = this._parsedPaths,
      c = this._objects,
      d = c.length,
      p = this.nCachedObjects_,
      m = new Array(d);
    (i = s.length), (n[e] = i), a.push(e), l.push(t), s.push(m);
    for (let y = p, v = c.length; y !== v; ++y) {
      const A = c[y];
      m[y] = new Mn(A, e, t);
    }
    return m;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      n = t[e];
    if (n !== void 0) {
      const i = this._paths,
        s = this._parsedPaths,
        a = this._bindings,
        l = a.length - 1,
        c = a[l],
        d = e[l];
      (t[d] = n),
        (a[n] = c),
        a.pop(),
        (s[n] = s[l]),
        s.pop(),
        (i[n] = i[l]),
        i.pop();
    }
  }
}
class PS {
  constructor(e, t, n = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = n),
      (this.blendMode = i);
    const s = t.tracks,
      a = s.length,
      l = new Array(a),
      c = { endingStart: yc, endingEnd: yc };
    for (let d = 0; d !== a; ++d) {
      const p = s[d].createInterpolant(null);
      (l[d] = p), (p.settings = c);
    }
    (this._interpolantSettings = c),
      (this._interpolants = l),
      (this._propertyBindings = new Array(a)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = S5),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if ((e.fadeOut(t), this.fadeIn(t), n)) {
      const i = this._clip.duration,
        s = e._clip.duration,
        a = s / i,
        l = i / s;
      e.warp(1, a, t), this.warp(l, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer,
      s = i.time,
      a = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null &&
      ((l = i._lendControlInterpolant()), (this._timeScaleInterpolant = l));
    const c = l.parameterPositions,
      d = l.sampleValues;
    return (c[0] = s), (c[1] = s + n), (d[0] = e / a), (d[1] = t / a), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const c = (e - s) * n;
      c < 0 || n === 0 ? (t = 0) : ((this._startTime = null), (t = n * c));
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t),
      l = this._updateWeight(e);
    if (l > 0) {
      const c = this._interpolants,
        d = this._propertyBindings;
      switch (this.blendMode) {
        case B3:
          for (let p = 0, m = c.length; p !== m; ++p)
            c[p].evaluate(a), d[p].accumulateAdditive(l);
          break;
        case Dg:
        default:
          for (let p = 0, m = c.length; p !== m; ++p)
            c[p].evaluate(a), d[p].accumulate(i, l);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      n = this.loop;
    let i = this.time + e,
      s = this._loopCount;
    const a = n === E5;
    if (e === 0) return s === -1 ? i : a && (s & 1) === 1 ? t - i : i;
    if (n === M5) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, a))
            : this._setEndings(this.repetitions === 0, !0, a)),
        i >= t || i < 0)
      ) {
        const l = Math.floor(i / t);
        (i -= t * l), (s += Math.abs(l));
        const c = this.repetitions - s;
        if (c <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (c === 1) {
            const d = e < 0;
            this._setEndings(d, !d, a);
          } else this._setEndings(!1, !1, a);
          (this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: l,
            });
        }
      } else this.time = i;
      if (a && (s & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = vc), (i.endingEnd = vc))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? vc : yc)
          : (i.endingStart = Ep),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? vc : yc) : (i.endingEnd = Ep));
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer,
      s = i.time;
    let a = this._weightInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = s), (c[0] = t), (l[1] = s + e), (c[1] = n), this;
  }
}
const sB = new Float32Array(1);
class aB extends oo {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root,
      i = e._clip.tracks,
      s = i.length,
      a = e._propertyBindings,
      l = e._interpolants,
      c = n.uuid,
      d = this._bindingsByRootAndName;
    let p = d[c];
    p === void 0 && ((p = {}), (d[c] = p));
    for (let m = 0; m !== s; ++m) {
      const y = i[m],
        v = y.name;
      let A = p[v];
      if (A !== void 0) ++A.referenceCount, (a[m] = A);
      else {
        if (((A = a[m]), A !== void 0)) {
          A._cacheIndex === null &&
            (++A.referenceCount, this._addInactiveBinding(A, c, v));
          continue;
        }
        const M = t && t._propertyBindings[m].binding.parsedPath;
        (A = new BS(Mn.create(n, v, M), y.ValueTypeName, y.getValueSize())),
          ++A.referenceCount,
          this._addInactiveBinding(A, c, v),
          (a[m] = A);
      }
      l[m].resultBuffer = A.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          s = this._actionsByClip[i];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const s = t[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const s = t[n];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions,
      s = this._actionsByClip;
    let a = s[t];
    if (a === void 0)
      (a = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = a);
    else {
      const l = a.knownActions;
      (e._byClipCacheIndex = l.length), l.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (a.actionByRoot[n] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      n = t[t.length - 1],
      i = e._cacheIndex;
    (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      a = this._actionsByClip,
      l = a[s],
      c = l.knownActions,
      d = c[c.length - 1],
      p = e._byClipCacheIndex;
    (d._byClipCacheIndex = p),
      (c[p] = d),
      c.pop(),
      (e._byClipCacheIndex = null);
    const m = l.actionByRoot,
      y = (e._localRoot || this._root).uuid;
    delete m[y],
      c.length === 0 && delete a[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const s = t[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = this._nActiveActions++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = --this._nActiveActions,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName,
      s = this._bindings;
    let a = i[t];
    a === void 0 && ((a = {}), (i[t] = a)),
      (a[n] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      n = e.binding,
      i = n.rootNode.uuid,
      s = n.path,
      a = this._bindingsByRootAndName,
      l = a[i],
      c = t[t.length - 1],
      d = e._cacheIndex;
    (c._cacheIndex = d),
      (t[d] = c),
      t.pop(),
      delete l[s],
      Object.keys(l).length === 0 && delete a[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = this._nActiveBindings++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = --this._nActiveBindings,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let n = e[t];
    return (
      n === void 0 &&
        ((n = new ex(new Float32Array(2), new Float32Array(2), 1, sB)),
        (n.__cacheIndex = t),
        (e[t] = n)),
      n
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      n = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = t[i];
    (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = n), (t[n] = s);
  }
  clipAction(e, t, n) {
    const i = t || this._root,
      s = i.uuid;
    let a = typeof e == "string" ? bh.findByName(i, e) : e;
    const l = a !== null ? a.uuid : e,
      c = this._actionsByClip[l];
    let d = null;
    if (
      (n === void 0 && (a !== null ? (n = a.blendMode) : (n = Dg)),
      c !== void 0)
    ) {
      const m = c.actionByRoot[s];
      if (m !== void 0 && m.blendMode === n) return m;
      (d = c.knownActions[0]), a === null && (a = d._clip);
    }
    if (a === null) return null;
    const p = new PS(this, a, t, n);
    return this._bindAction(p, d), this._addInactiveAction(p, l, s), p;
  }
  existingAction(e, t) {
    const n = t || this._root,
      i = n.uuid,
      s = typeof e == "string" ? bh.findByName(n, e) : e,
      a = s ? s.uuid : e,
      l = this._actionsByClip[a];
    return (l !== void 0 && l.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n) e[n].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      n = this._nActiveActions,
      i = (this.time += e),
      s = Math.sign(e),
      a = (this._accuIndex ^= 1);
    for (let d = 0; d !== n; ++d) t[d]._update(i, e, s, a);
    const l = this._bindings,
      c = this._nActiveBindings;
    for (let d = 0; d !== c; ++d) l[d].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      n = e.uuid,
      i = this._actionsByClip,
      s = i[n];
    if (s !== void 0) {
      const a = s.knownActions;
      for (let l = 0, c = a.length; l !== c; ++l) {
        const d = a[l];
        this._deactivateAction(d);
        const p = d._cacheIndex,
          m = t[t.length - 1];
        (d._cacheIndex = null),
          (d._byClipCacheIndex = null),
          (m._cacheIndex = p),
          (t[p] = m),
          t.pop(),
          this._removeInactiveBindingsForAction(d);
      }
      delete i[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      n = this._actionsByClip;
    for (const a in n) {
      const l = n[a].actionByRoot,
        c = l[t];
      c !== void 0 &&
        (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const i = this._bindingsByRootAndName,
      s = i[t];
    if (s !== void 0)
      for (const a in s) {
        const l = s[a];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class hx {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new hx(
      this.value.clone === void 0 ? this.value : this.value.clone(),
    );
  }
}
let oB = 0;
class lB extends oo {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: oB++ }),
      (this.name = ""),
      (this.usage = Tp),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const s = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let a = 0; a < s.length; a++) this.uniforms.push(s[a].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class uB extends tm {
  constructor(e, t, n = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class cB {
  constructor(e, t, n, i, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = n),
      (this.elementSize = i),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const Z_ = new jt();
class fx {
  constructor(e, t, n = 0, i = 1 / 0) {
    (this.ray = new Eh(e, t)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Tc()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      Z_.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(Z_),
      this
    );
  }
  intersectObject(e, t = !0, n = []) {
    return Rv(e, this, n, t), n.sort(q_), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, s = e.length; i < s; i++) Rv(e[i], this, n, t);
    return n.sort(q_), n;
  }
}
function q_(r, e) {
  return r.distance - e.distance;
}
function Rv(r, e, t, n) {
  let i = !0;
  if (
    (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1),
    i === !0 && n === !0)
  ) {
    const s = r.children;
    for (let a = 0, l = s.length; a < l; a++) Rv(s[a], e, t, !0);
  }
}
class dB {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (this.phi = en(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos(en(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class hB {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + n * n)),
      (this.theta = Math.atan2(e, n)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class px {
  constructor(e, t, n, i) {
    (px.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++) this.elements[n] = e[n + t];
    return this;
  }
  set(e, t, n, i) {
    const s = this.elements;
    return (s[0] = e), (s[2] = t), (s[1] = n), (s[3] = i), this;
  }
}
const K_ = new je();
class fB {
  constructor(e = new je(1 / 0, 1 / 0), t = new je(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = K_.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, K_).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Q_ = new Y(),
  K1 = new Y();
class pB {
  constructor(e = new Y(), t = new Y()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Q_.subVectors(e, this.start), K1.subVectors(this.end, this.start);
    const n = K1.dot(K1);
    let i = K1.dot(Q_) / n;
    return t && (i = en(i, 0, 1)), i;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $_ = new Y();
class mB extends _n {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const n = new tn(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
      const d = (a / c) * Math.PI * 2,
        p = (l / c) * Math.PI * 2;
      i.push(Math.cos(d), Math.sin(d), 1, Math.cos(p), Math.sin(p), 1);
    }
    n.setAttribute("position", new Lt(i, 3));
    const s = new Ii({ fog: !1, toneMapped: !1 });
    (this.cone = new Ea(n, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      $_.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt($_),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const Fl = new Y(),
  Q1 = new jt(),
  Sy = new jt();
class gB extends Ea {
  constructor(e) {
    const t = LS(e),
      n = new tn(),
      i = [],
      s = [],
      a = new dt(0, 0, 1),
      l = new dt(0, 1, 0);
    for (let d = 0; d < t.length; d++) {
      const p = t[d];
      p.parent &&
        p.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        s.push(a.r, a.g, a.b),
        s.push(l.r, l.g, l.b));
    }
    n.setAttribute("position", new Lt(i, 3)),
      n.setAttribute("color", new Lt(s, 3));
    const c = new Ii({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, c),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      n = this.geometry,
      i = n.getAttribute("position");
    Sy.copy(this.root.matrixWorld).invert();
    for (let s = 0, a = 0; s < t.length; s++) {
      const l = t[s];
      l.parent &&
        l.parent.isBone &&
        (Q1.multiplyMatrices(Sy, l.matrixWorld),
        Fl.setFromMatrixPosition(Q1),
        i.setXYZ(a, Fl.x, Fl.y, Fl.z),
        Q1.multiplyMatrices(Sy, l.parent.matrixWorld),
        Fl.setFromMatrixPosition(Q1),
        i.setXYZ(a + 1, Fl.x, Fl.y, Fl.z),
        (a += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function LS(r) {
  const e = [];
  r.isBone === !0 && e.push(r);
  for (let t = 0; t < r.children.length; t++)
    e.push.apply(e, LS(r.children[t]));
  return e;
}
class yB extends nr {
  constructor(e, t, n) {
    const i = new om(t, 4, 2),
      s = new ds({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s),
      (this.light = e),
      (this.color = n),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const vB = new Y(),
  eA = new dt(),
  tA = new dt();
class xB extends _n {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "HemisphereLightHelper");
    const i = new am(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new ds({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"),
      a = new Float32Array(s.count * 3);
    i.setAttribute("color", new Tn(a, 3)),
      this.add(new nr(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      eA.copy(this.light.color), tA.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const s = n < i / 2 ? eA : tA;
        t.setXYZ(n, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(vB.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class bB extends Ea {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    (n = new dt(n)), (i = new dt(i));
    const s = t / 2,
      a = e / t,
      l = e / 2,
      c = [],
      d = [];
    for (let y = 0, v = 0, A = -l; y <= t; y++, A += a) {
      c.push(-l, 0, A, l, 0, A), c.push(A, 0, -l, A, 0, l);
      const M = y === s ? n : i;
      M.toArray(d, v),
        (v += 3),
        M.toArray(d, v),
        (v += 3),
        M.toArray(d, v),
        (v += 3),
        M.toArray(d, v),
        (v += 3);
    }
    const p = new tn();
    p.setAttribute("position", new Lt(c, 3)),
      p.setAttribute("color", new Lt(d, 3));
    const m = new Ii({ vertexColors: !0, toneMapped: !1 });
    super(p, m), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class _B extends Ea {
  constructor(e = 10, t = 16, n = 8, i = 64, s = 4473924, a = 8947848) {
    (s = new dt(s)), (a = new dt(a));
    const l = [],
      c = [];
    if (t > 1)
      for (let m = 0; m < t; m++) {
        const y = (m / t) * (Math.PI * 2),
          v = Math.sin(y) * e,
          A = Math.cos(y) * e;
        l.push(0, 0, 0), l.push(v, 0, A);
        const M = m & 1 ? s : a;
        c.push(M.r, M.g, M.b), c.push(M.r, M.g, M.b);
      }
    for (let m = 0; m < n; m++) {
      const y = m & 1 ? s : a,
        v = e - (e / n) * m;
      for (let A = 0; A < i; A++) {
        let M = (A / i) * (Math.PI * 2),
          w = Math.sin(M) * v,
          x = Math.cos(M) * v;
        l.push(w, 0, x),
          c.push(y.r, y.g, y.b),
          (M = ((A + 1) / i) * (Math.PI * 2)),
          (w = Math.sin(M) * v),
          (x = Math.cos(M) * v),
          l.push(w, 0, x),
          c.push(y.r, y.g, y.b);
      }
    }
    const d = new tn();
    d.setAttribute("position", new Lt(l, 3)),
      d.setAttribute("color", new Lt(c, 3));
    const p = new Ii({ vertexColors: !0, toneMapped: !1 });
    super(d, p), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const nA = new Y(),
  $1 = new Y(),
  rA = new Y();
class AB extends _n {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new tn();
    i.setAttribute(
      "position",
      new Lt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3),
    );
    const s = new Ii({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Ko(i, s)),
      this.add(this.lightPlane),
      (i = new tn()),
      i.setAttribute("position", new Lt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Ko(i, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      nA.setFromMatrixPosition(this.light.matrixWorld),
      $1.setFromMatrixPosition(this.light.target.matrixWorld),
      rA.subVectors($1, nA),
      this.lightPlane.lookAt($1),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt($1),
      (this.targetLine.scale.z = rA.length());
  }
}
const e0 = new Y(),
  gr = new $p();
class wB extends Ea {
  constructor(e) {
    const t = new tn(),
      n = new Ii({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      s = [],
      a = {};
    l("n1", "n2"),
      l("n2", "n4"),
      l("n4", "n3"),
      l("n3", "n1"),
      l("f1", "f2"),
      l("f2", "f4"),
      l("f4", "f3"),
      l("f3", "f1"),
      l("n1", "f1"),
      l("n2", "f2"),
      l("n3", "f3"),
      l("n4", "f4"),
      l("p", "n1"),
      l("p", "n2"),
      l("p", "n3"),
      l("p", "n4"),
      l("u1", "u2"),
      l("u2", "u3"),
      l("u3", "u1"),
      l("c", "t"),
      l("p", "c"),
      l("cn1", "cn2"),
      l("cn3", "cn4"),
      l("cf1", "cf2"),
      l("cf3", "cf4");
    function l(A, M) {
      c(A), c(M);
    }
    function c(A) {
      i.push(0, 0, 0),
        s.push(0, 0, 0),
        a[A] === void 0 && (a[A] = []),
        a[A].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Lt(i, 3)),
      t.setAttribute("color", new Lt(s, 3)),
      super(t, n),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const d = new dt(16755200),
      p = new dt(16711680),
      m = new dt(43775),
      y = new dt(16777215),
      v = new dt(3355443);
    this.setColors(d, p, m, y, v);
  }
  setColors(e, t, n, i, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, n.r, n.g, n.b),
      a.setXYZ(33, n.r, n.g, n.b),
      a.setXYZ(34, n.r, n.g, n.b),
      a.setXYZ(35, n.r, n.g, n.b),
      a.setXYZ(36, n.r, n.g, n.b),
      a.setXYZ(37, n.r, n.g, n.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      n = 1,
      i = 1;
    gr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      br("c", t, e, gr, 0, 0, -1),
      br("t", t, e, gr, 0, 0, 1),
      br("n1", t, e, gr, -1, -1, -1),
      br("n2", t, e, gr, n, -1, -1),
      br("n3", t, e, gr, -1, i, -1),
      br("n4", t, e, gr, n, i, -1),
      br("f1", t, e, gr, -1, -1, 1),
      br("f2", t, e, gr, n, -1, 1),
      br("f3", t, e, gr, -1, i, 1),
      br("f4", t, e, gr, n, i, 1),
      br("u1", t, e, gr, n * 0.7, i * 1.1, -1),
      br("u2", t, e, gr, -1 * 0.7, i * 1.1, -1),
      br("u3", t, e, gr, 0, i * 2, -1),
      br("cf1", t, e, gr, -1, 0, 1),
      br("cf2", t, e, gr, n, 0, 1),
      br("cf3", t, e, gr, 0, -1, 1),
      br("cf4", t, e, gr, 0, i, 1),
      br("cn1", t, e, gr, -1, 0, -1),
      br("cn2", t, e, gr, n, 0, -1),
      br("cn3", t, e, gr, 0, -1, -1),
      br("cn4", t, e, gr, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function br(r, e, t, n, i, s, a) {
  e0.set(i, s, a).unproject(n);
  const l = e[r];
  if (l !== void 0) {
    const c = t.getAttribute("position");
    for (let d = 0, p = l.length; d < p; d++) c.setXYZ(l[d], e0.x, e0.y, e0.z);
  }
}
const t0 = new Ti();
class MB extends Ea {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      s = new tn();
    s.setIndex(new Tn(n, 1)),
      s.setAttribute("position", new Tn(i, 3)),
      super(s, new Ii({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && t0.setFromObject(this.object),
      t0.isEmpty())
    )
      return;
    const t = t0.min,
      n = t0.max,
      i = this.geometry.attributes.position,
      s = i.array;
    (s[0] = n.x),
      (s[1] = n.y),
      (s[2] = n.z),
      (s[3] = t.x),
      (s[4] = n.y),
      (s[5] = n.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = n.z),
      (s[9] = n.x),
      (s[10] = t.y),
      (s[11] = n.z),
      (s[12] = n.x),
      (s[13] = n.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = n.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = n.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class SB extends Ea {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new tn();
    s.setIndex(new Tn(n, 1)),
      s.setAttribute("position", new Lt(i, 3)),
      super(s, new Ii({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class EB extends Ko {
  constructor(e, t = 1, n = 16776960) {
    const i = n,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      a = new tn();
    a.setAttribute("position", new Lt(s, 3)),
      a.computeBoundingSphere(),
      super(a, new Ii({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      c = new tn();
    c.setAttribute("position", new Lt(l, 3)),
      c.computeBoundingSphere(),
      this.add(
        new nr(
          c,
          new ds({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          }),
        ),
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const iA = new Y();
let n0, Ey;
class CB extends _n {
  constructor(
    e = new Y(0, 0, 1),
    t = new Y(0, 0, 0),
    n = 1,
    i = 16776960,
    s = n * 0.2,
    a = s * 0.2,
  ) {
    super(),
      (this.type = "ArrowHelper"),
      n0 === void 0 &&
        ((n0 = new tn()),
        n0.setAttribute("position", new Lt([0, 0, 0, 0, 1, 0], 3)),
        (Ey = new Ch(0, 0.5, 1, 5, 1)),
        Ey.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Ko(n0, new Ii({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new nr(Ey, new ds({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(n, s, a);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      iA.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(iA, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, t, n),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class TB extends Ea {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new tn();
    i.setAttribute("position", new Lt(t, 3)),
      i.setAttribute("color", new Lt(n, 3));
    const s = new Ii({ vertexColors: !0, toneMapped: !1 });
    super(i, s), (this.type = "AxesHelper");
  }
  setColors(e, t, n) {
    const i = new dt(),
      s = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(t),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(n),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class RB {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new dt()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Bp()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, s, a) {
    return this.currentPath.bezierCurveTo(e, t, n, i, s, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(x) {
      const C = [];
      for (let T = 0, I = x.length; T < I; T++) {
        const U = x[T],
          F = new Rc();
        (F.curves = U.curves), C.push(F);
      }
      return C;
    }
    function n(x, C) {
      const T = C.length;
      let I = !1;
      for (let U = T - 1, F = 0; F < T; U = F++) {
        let O = C[U],
          z = C[F],
          L = z.x - O.x,
          N = z.y - O.y;
        if (Math.abs(N) > Number.EPSILON) {
          if (
            (N < 0 && ((O = C[F]), (L = -L), (z = C[U]), (N = -N)),
            x.y < O.y || x.y > z.y)
          )
            continue;
          if (x.y === O.y) {
            if (x.x === O.x) return !0;
          } else {
            const X = N * (x.x - O.x) - L * (x.y - O.y);
            if (X === 0) return !0;
            if (X < 0) continue;
            I = !I;
          }
        } else {
          if (x.y !== O.y) continue;
          if ((z.x <= x.x && x.x <= O.x) || (O.x <= x.x && x.x <= z.x))
            return !0;
        }
      }
      return I;
    }
    const i = no.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let a, l, c;
    const d = [];
    if (s.length === 1)
      return (l = s[0]), (c = new Rc()), (c.curves = l.curves), d.push(c), d;
    let p = !i(s[0].getPoints());
    p = e ? !p : p;
    const m = [],
      y = [];
    let v = [],
      A = 0,
      M;
    (y[A] = void 0), (v[A] = []);
    for (let x = 0, C = s.length; x < C; x++)
      (l = s[x]),
        (M = l.getPoints()),
        (a = i(M)),
        (a = e ? !a : a),
        a
          ? (!p && y[A] && A++,
            (y[A] = { s: new Rc(), p: M }),
            (y[A].s.curves = l.curves),
            p && A++,
            (v[A] = []))
          : v[A].push({ h: l, p: M[0] });
    if (!y[0]) return t(s);
    if (y.length > 1) {
      let x = !1,
        C = 0;
      for (let T = 0, I = y.length; T < I; T++) m[T] = [];
      for (let T = 0, I = y.length; T < I; T++) {
        const U = v[T];
        for (let F = 0; F < U.length; F++) {
          const O = U[F];
          let z = !0;
          for (let L = 0; L < y.length; L++)
            n(O.p, y[L].p) &&
              (T !== L && C++, z ? ((z = !1), m[L].push(O)) : (x = !0));
          z && m[T].push(O);
        }
      }
      C > 0 && x === !1 && (v = m);
    }
    let w;
    for (let x = 0, C = y.length; x < C; x++) {
      (c = y[x].s), d.push(c), (w = v[x]);
      for (let T = 0, I = w.length; T < I; T++) c.holes.push(w[T].h);
    }
    return d;
  }
}
class IB extends oo {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
function BB(r, e) {
  const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return (
    t > e
      ? ((r.repeat.x = 1),
        (r.repeat.y = t / e),
        (r.offset.x = 0),
        (r.offset.y = (1 - r.repeat.y) / 2))
      : ((r.repeat.x = e / t),
        (r.repeat.y = 1),
        (r.offset.x = (1 - r.repeat.x) / 2),
        (r.offset.y = 0)),
    r
  );
}
function PB(r, e) {
  const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return (
    t > e
      ? ((r.repeat.x = e / t),
        (r.repeat.y = 1),
        (r.offset.x = (1 - r.repeat.x) / 2),
        (r.offset.y = 0))
      : ((r.repeat.x = 1),
        (r.repeat.y = t / e),
        (r.offset.x = 0),
        (r.offset.y = (1 - r.repeat.y) / 2)),
    r
  );
}
function LB(r) {
  return (
    (r.repeat.x = 1), (r.repeat.y = 1), (r.offset.x = 0), (r.offset.y = 0), r
  );
}
function Iv(r, e, t, n) {
  const i = DB(n);
  switch (t) {
    case S3:
      return r * e;
    case C3:
      return r * e;
    case T3:
      return r * e * 2;
    case Kp:
      return ((r * e) / i.components) * i.byteLength;
    case Qp:
      return ((r * e) / i.components) * i.byteLength;
    case R3:
      return ((r * e * 2) / i.components) * i.byteLength;
    case Pg:
      return ((r * e * 2) / i.components) * i.byteLength;
    case E3:
      return ((r * e * 3) / i.components) * i.byteLength;
    case wr:
      return ((r * e * 4) / i.components) * i.byteLength;
    case Lg:
      return ((r * e * 4) / i.components) * i.byteLength;
    case cp:
    case dp:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case hp:
    case fp:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case O0:
    case z0:
      return (Math.max(r, 16) * Math.max(e, 8)) / 4;
    case U0:
    case k0:
      return (Math.max(r, 8) * Math.max(e, 8)) / 2;
    case H0:
    case V0:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case G0:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case j0:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case W0:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case X0:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case J0:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Y0:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Z0:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case q0:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case K0:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Q0:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case $0:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case eg:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case tg:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case ng:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case rg:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case pp:
    case ig:
    case sg:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case I3:
    case ag:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case og:
    case lg:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function DB(r) {
  switch (r) {
    case hs:
    case Tg:
      return { byteLength: 1, components: 1 };
    case ph:
    case Rg:
    case Kr:
      return { byteLength: 2, components: 1 };
    case Ig:
    case Bg:
      return { byteLength: 2, components: 4 };
    case so:
    case qp:
    case or:
      return { byteLength: 4, components: 1 };
    case M3:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
const FB = { contain: BB, cover: PB, fill: LB, getByteLength: Iv };
class NB extends Es {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.',
    ),
      super(e, t, { ...i, count: n }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Mh } }),
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Mh));
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function DS() {
  let r = null,
    e = !1,
    t = null,
    n = null;
  function i(s, a) {
    t(s, a), (n = r.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = r.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      r.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      r = s;
    },
  };
}
function UB(r) {
  const e = new WeakMap();
  function t(l, c) {
    const d = l.array,
      p = l.usage,
      m = d.byteLength,
      y = r.createBuffer();
    r.bindBuffer(c, y), r.bufferData(c, d, p), l.onUploadCallback();
    let v;
    if (d instanceof Float32Array) v = r.FLOAT;
    else if (d instanceof Uint16Array)
      l.isFloat16BufferAttribute ? (v = r.HALF_FLOAT) : (v = r.UNSIGNED_SHORT);
    else if (d instanceof Int16Array) v = r.SHORT;
    else if (d instanceof Uint32Array) v = r.UNSIGNED_INT;
    else if (d instanceof Int32Array) v = r.INT;
    else if (d instanceof Int8Array) v = r.BYTE;
    else if (d instanceof Uint8Array) v = r.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) v = r.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d,
      );
    return {
      buffer: y,
      type: v,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: l.version,
      size: m,
    };
  }
  function n(l, c, d) {
    const p = c.array,
      m = c.updateRanges;
    if ((r.bindBuffer(d, l), m.length === 0)) r.bufferSubData(d, 0, p);
    else {
      m.sort((v, A) => v.start - A.start);
      let y = 0;
      for (let v = 1; v < m.length; v++) {
        const A = m[y],
          M = m[v];
        M.start <= A.start + A.count + 1
          ? (A.count = Math.max(A.count, M.start + M.count - A.start))
          : (++y, (m[y] = M));
      }
      m.length = y + 1;
      for (let v = 0, A = m.length; v < A; v++) {
        const M = m[v];
        r.bufferSubData(d, M.start * p.BYTES_PER_ELEMENT, p, M.start, M.count);
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function i(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function s(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (r.deleteBuffer(c.buffer), e.delete(l));
  }
  function a(l, c) {
    if (
      (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute)
    ) {
      const p = e.get(l);
      (!p || p.version < l.version) &&
        e.set(l, {
          buffer: l.buffer,
          type: l.type,
          bytesPerElement: l.elementSize,
          version: l.version,
        });
      return;
    }
    const d = e.get(l);
    if (d === void 0) e.set(l, t(l, c));
    else if (d.version < l.version) {
      if (d.size !== l.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      n(d.buffer, l, c), (d.version = l.version);
    }
  }
  return { get: i, remove: s, update: a };
}
var OB = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  kB = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  zB = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  HB = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  VB = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  GB = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  jB = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  WB = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  XB = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  JB = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  YB = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  ZB = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  qB = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  KB = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  QB = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  $B = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  eP = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  tP = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  nP = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  rP = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  iP = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  sP = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  aP = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  oP = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  lP = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  uP = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  cP = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  dP = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  hP = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  fP = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  pP = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  mP = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  gP = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  yP = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  vP = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  xP = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  bP = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  _P = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  AP = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  wP = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  MP = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  SP = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  EP = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  CP = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  TP = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  RP = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  IP = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  BP = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  PP = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  LP = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  DP = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  FP = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  NP = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  UP = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  OP = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  kP = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  zP = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  HP = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  VP = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  GP = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  jP = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  WP = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  XP = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  JP = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  YP = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  ZP = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  qP = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  KP = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  QP = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  $P = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  eL = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  tL = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  nL = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  rL = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  iL = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  sL = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  aL = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  oL = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  lL = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  uL = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  cL = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  dL = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  hL = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  fL = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  pL = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  mL = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  gL = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  yL = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  vL = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  xL = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  bL = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  _L = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  AL = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  wL = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  ML = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  SL = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  EL = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  CL = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  TL = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  RL = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  IL = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  BL = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  PL = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  LL = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  DL = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  FL = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  NL = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const UL = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  OL = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  kL = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  zL = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  HL = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  VL = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  GL = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  jL = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  WL = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  XL = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  JL = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  YL = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  ZL = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  qL = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  KL = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  QL = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  $L = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  eD = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  tD = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  nD = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  rD = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  iD = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  sD = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  aD = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  oD = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  lD = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  uD = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  cD = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  dD = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  hD = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  fD = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  pD = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  mD = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  gD = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  un = {
    alphahash_fragment: OB,
    alphahash_pars_fragment: kB,
    alphamap_fragment: zB,
    alphamap_pars_fragment: HB,
    alphatest_fragment: VB,
    alphatest_pars_fragment: GB,
    aomap_fragment: jB,
    aomap_pars_fragment: WB,
    batching_pars_vertex: XB,
    batching_vertex: JB,
    begin_vertex: YB,
    beginnormal_vertex: ZB,
    bsdfs: qB,
    iridescence_fragment: KB,
    bumpmap_pars_fragment: QB,
    clipping_planes_fragment: $B,
    clipping_planes_pars_fragment: eP,
    clipping_planes_pars_vertex: tP,
    clipping_planes_vertex: nP,
    color_fragment: rP,
    color_pars_fragment: iP,
    color_pars_vertex: sP,
    color_vertex: aP,
    common: oP,
    cube_uv_reflection_fragment: lP,
    defaultnormal_vertex: uP,
    displacementmap_pars_vertex: cP,
    displacementmap_vertex: dP,
    emissivemap_fragment: hP,
    emissivemap_pars_fragment: fP,
    colorspace_fragment: pP,
    colorspace_pars_fragment: mP,
    envmap_fragment: gP,
    envmap_common_pars_fragment: yP,
    envmap_pars_fragment: vP,
    envmap_pars_vertex: xP,
    envmap_physical_pars_fragment: IP,
    envmap_vertex: bP,
    fog_vertex: _P,
    fog_pars_vertex: AP,
    fog_fragment: wP,
    fog_pars_fragment: MP,
    gradientmap_pars_fragment: SP,
    lightmap_pars_fragment: EP,
    lights_lambert_fragment: CP,
    lights_lambert_pars_fragment: TP,
    lights_pars_begin: RP,
    lights_toon_fragment: BP,
    lights_toon_pars_fragment: PP,
    lights_phong_fragment: LP,
    lights_phong_pars_fragment: DP,
    lights_physical_fragment: FP,
    lights_physical_pars_fragment: NP,
    lights_fragment_begin: UP,
    lights_fragment_maps: OP,
    lights_fragment_end: kP,
    logdepthbuf_fragment: zP,
    logdepthbuf_pars_fragment: HP,
    logdepthbuf_pars_vertex: VP,
    logdepthbuf_vertex: GP,
    map_fragment: jP,
    map_pars_fragment: WP,
    map_particle_fragment: XP,
    map_particle_pars_fragment: JP,
    metalnessmap_fragment: YP,
    metalnessmap_pars_fragment: ZP,
    morphinstance_vertex: qP,
    morphcolor_vertex: KP,
    morphnormal_vertex: QP,
    morphtarget_pars_vertex: $P,
    morphtarget_vertex: eL,
    normal_fragment_begin: tL,
    normal_fragment_maps: nL,
    normal_pars_fragment: rL,
    normal_pars_vertex: iL,
    normal_vertex: sL,
    normalmap_pars_fragment: aL,
    clearcoat_normal_fragment_begin: oL,
    clearcoat_normal_fragment_maps: lL,
    clearcoat_pars_fragment: uL,
    iridescence_pars_fragment: cL,
    opaque_fragment: dL,
    packing: hL,
    premultiplied_alpha_fragment: fL,
    project_vertex: pL,
    dithering_fragment: mL,
    dithering_pars_fragment: gL,
    roughnessmap_fragment: yL,
    roughnessmap_pars_fragment: vL,
    shadowmap_pars_fragment: xL,
    shadowmap_pars_vertex: bL,
    shadowmap_vertex: _L,
    shadowmask_pars_fragment: AL,
    skinbase_vertex: wL,
    skinning_pars_vertex: ML,
    skinning_vertex: SL,
    skinnormal_vertex: EL,
    specularmap_fragment: CL,
    specularmap_pars_fragment: TL,
    tonemapping_fragment: RL,
    tonemapping_pars_fragment: IL,
    transmission_fragment: BL,
    transmission_pars_fragment: PL,
    uv_pars_fragment: LL,
    uv_pars_vertex: DL,
    uv_vertex: FL,
    worldpos_vertex: NL,
    background_vert: UL,
    background_frag: OL,
    backgroundCube_vert: kL,
    backgroundCube_frag: zL,
    cube_vert: HL,
    cube_frag: VL,
    depth_vert: GL,
    depth_frag: jL,
    distanceRGBA_vert: WL,
    distanceRGBA_frag: XL,
    equirect_vert: JL,
    equirect_frag: YL,
    linedashed_vert: ZL,
    linedashed_frag: qL,
    meshbasic_vert: KL,
    meshbasic_frag: QL,
    meshlambert_vert: $L,
    meshlambert_frag: eD,
    meshmatcap_vert: tD,
    meshmatcap_frag: nD,
    meshnormal_vert: rD,
    meshnormal_frag: iD,
    meshphong_vert: sD,
    meshphong_frag: aD,
    meshphysical_vert: oD,
    meshphysical_frag: lD,
    meshtoon_vert: uD,
    meshtoon_frag: cD,
    points_vert: dD,
    points_frag: hD,
    shadow_vert: fD,
    shadow_frag: pD,
    sprite_vert: mD,
    sprite_frag: gD,
  },
  mt = {
    common: {
      diffuse: { value: new dt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new an() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new an() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new an() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new an() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new an() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new an() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new an() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new an() },
      normalScale: { value: new je(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new an() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new an() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new an() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new an() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new dt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new dt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new an() },
      alphaTest: { value: 0 },
      uvTransform: { value: new an() },
    },
    sprite: {
      diffuse: { value: new dt(16777215) },
      opacity: { value: 1 },
      center: { value: new je(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new an() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new an() },
      alphaTest: { value: 0 },
    },
  },
  Aa = {
    basic: {
      uniforms: ji([
        mt.common,
        mt.specularmap,
        mt.envmap,
        mt.aomap,
        mt.lightmap,
        mt.fog,
      ]),
      vertexShader: un.meshbasic_vert,
      fragmentShader: un.meshbasic_frag,
    },
    lambert: {
      uniforms: ji([
        mt.common,
        mt.specularmap,
        mt.envmap,
        mt.aomap,
        mt.lightmap,
        mt.emissivemap,
        mt.bumpmap,
        mt.normalmap,
        mt.displacementmap,
        mt.fog,
        mt.lights,
        { emissive: { value: new dt(0) } },
      ]),
      vertexShader: un.meshlambert_vert,
      fragmentShader: un.meshlambert_frag,
    },
    phong: {
      uniforms: ji([
        mt.common,
        mt.specularmap,
        mt.envmap,
        mt.aomap,
        mt.lightmap,
        mt.emissivemap,
        mt.bumpmap,
        mt.normalmap,
        mt.displacementmap,
        mt.fog,
        mt.lights,
        {
          emissive: { value: new dt(0) },
          specular: { value: new dt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: un.meshphong_vert,
      fragmentShader: un.meshphong_frag,
    },
    standard: {
      uniforms: ji([
        mt.common,
        mt.envmap,
        mt.aomap,
        mt.lightmap,
        mt.emissivemap,
        mt.bumpmap,
        mt.normalmap,
        mt.displacementmap,
        mt.roughnessmap,
        mt.metalnessmap,
        mt.fog,
        mt.lights,
        {
          emissive: { value: new dt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: un.meshphysical_vert,
      fragmentShader: un.meshphysical_frag,
    },
    toon: {
      uniforms: ji([
        mt.common,
        mt.aomap,
        mt.lightmap,
        mt.emissivemap,
        mt.bumpmap,
        mt.normalmap,
        mt.displacementmap,
        mt.gradientmap,
        mt.fog,
        mt.lights,
        { emissive: { value: new dt(0) } },
      ]),
      vertexShader: un.meshtoon_vert,
      fragmentShader: un.meshtoon_frag,
    },
    matcap: {
      uniforms: ji([
        mt.common,
        mt.bumpmap,
        mt.normalmap,
        mt.displacementmap,
        mt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: un.meshmatcap_vert,
      fragmentShader: un.meshmatcap_frag,
    },
    points: {
      uniforms: ji([mt.points, mt.fog]),
      vertexShader: un.points_vert,
      fragmentShader: un.points_frag,
    },
    dashed: {
      uniforms: ji([
        mt.common,
        mt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: un.linedashed_vert,
      fragmentShader: un.linedashed_frag,
    },
    depth: {
      uniforms: ji([mt.common, mt.displacementmap]),
      vertexShader: un.depth_vert,
      fragmentShader: un.depth_frag,
    },
    normal: {
      uniforms: ji([
        mt.common,
        mt.bumpmap,
        mt.normalmap,
        mt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: un.meshnormal_vert,
      fragmentShader: un.meshnormal_frag,
    },
    sprite: {
      uniforms: ji([mt.sprite, mt.fog]),
      vertexShader: un.sprite_vert,
      fragmentShader: un.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new an() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: un.background_vert,
      fragmentShader: un.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new an() },
      },
      vertexShader: un.backgroundCube_vert,
      fragmentShader: un.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: un.cube_vert,
      fragmentShader: un.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: un.equirect_vert,
      fragmentShader: un.equirect_frag,
    },
    distanceRGBA: {
      uniforms: ji([
        mt.common,
        mt.displacementmap,
        {
          referencePosition: { value: new Y() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: un.distanceRGBA_vert,
      fragmentShader: un.distanceRGBA_frag,
    },
    shadow: {
      uniforms: ji([
        mt.lights,
        mt.fog,
        { color: { value: new dt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: un.shadow_vert,
      fragmentShader: un.shadow_frag,
    },
  };
Aa.physical = {
  uniforms: ji([
    Aa.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new an() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new an() },
      clearcoatNormalScale: { value: new je(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new an() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new an() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new an() },
      sheen: { value: 0 },
      sheenColor: { value: new dt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new an() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new an() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new an() },
      transmissionSamplerSize: { value: new je() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new an() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new dt(0) },
      specularColor: { value: new dt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new an() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new an() },
      anisotropyVector: { value: new je() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new an() },
    },
  ]),
  vertexShader: un.meshphysical_vert,
  fragmentShader: un.meshphysical_frag,
};
const r0 = { r: 0, b: 0, g: 0 },
  ac = new Cs(),
  yD = new jt();
function vD(r, e, t, n, i, s, a) {
  const l = new dt(0);
  let c = s === !0 ? 0 : 1,
    d,
    p,
    m = null,
    y = 0,
    v = null;
  function A(T) {
    let I = T.isScene === !0 ? T.background : null;
    return (
      I && I.isTexture && (I = (T.backgroundBlurriness > 0 ? t : e).get(I)), I
    );
  }
  function M(T) {
    let I = !1;
    const U = A(T);
    U === null ? x(l, c) : U && U.isColor && (x(U, 1), (I = !0));
    const F = r.xr.getEnvironmentBlendMode();
    F === "additive"
      ? n.buffers.color.setClear(0, 0, 0, 1, a)
      : F === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a),
      (r.autoClear || I) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function w(T, I) {
    const U = A(I);
    U && (U.isCubeTexture || U.mapping === Sh)
      ? (p === void 0 &&
          ((p = new nr(
            new Vc(1, 1, 1),
            new fs({
              name: "BackgroundCubeMaterial",
              uniforms: vh(Aa.backgroundCube.uniforms),
              vertexShader: Aa.backgroundCube.vertexShader,
              fragmentShader: Aa.backgroundCube.fragmentShader,
              side: Ji,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          p.geometry.deleteAttribute("normal"),
          p.geometry.deleteAttribute("uv"),
          (p.onBeforeRender = function (F, O, z) {
            this.matrixWorld.copyPosition(z.matrixWorld);
          }),
          Object.defineProperty(p.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(p)),
        ac.copy(I.backgroundRotation),
        (ac.x *= -1),
        (ac.y *= -1),
        (ac.z *= -1),
        U.isCubeTexture &&
          U.isRenderTargetTexture === !1 &&
          ((ac.y *= -1), (ac.z *= -1)),
        (p.material.uniforms.envMap.value = U),
        (p.material.uniforms.flipEnvMap.value =
          U.isCubeTexture && U.isRenderTargetTexture === !1 ? -1 : 1),
        (p.material.uniforms.backgroundBlurriness.value =
          I.backgroundBlurriness),
        (p.material.uniforms.backgroundIntensity.value = I.backgroundIntensity),
        p.material.uniforms.backgroundRotation.value.setFromMatrix4(
          yD.makeRotationFromEuler(ac),
        ),
        (p.material.toneMapped = Sn.getTransfer(U.colorSpace) !== Hn),
        (m !== U || y !== U.version || v !== r.toneMapping) &&
          ((p.material.needsUpdate = !0),
          (m = U),
          (y = U.version),
          (v = r.toneMapping)),
        p.layers.enableAll(),
        T.unshift(p, p.geometry, p.material, 0, 0, null))
      : U &&
        U.isTexture &&
        (d === void 0 &&
          ((d = new nr(
            new Kl(2, 2),
            new fs({
              name: "BackgroundMaterial",
              uniforms: vh(Aa.background.uniforms),
              vertexShader: Aa.background.vertexShader,
              fragmentShader: Aa.background.fragmentShader,
              side: ro,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          d.geometry.deleteAttribute("normal"),
          Object.defineProperty(d.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(d)),
        (d.material.uniforms.t2D.value = U),
        (d.material.uniforms.backgroundIntensity.value = I.backgroundIntensity),
        (d.material.toneMapped = Sn.getTransfer(U.colorSpace) !== Hn),
        U.matrixAutoUpdate === !0 && U.updateMatrix(),
        d.material.uniforms.uvTransform.value.copy(U.matrix),
        (m !== U || y !== U.version || v !== r.toneMapping) &&
          ((d.material.needsUpdate = !0),
          (m = U),
          (y = U.version),
          (v = r.toneMapping)),
        d.layers.enableAll(),
        T.unshift(d, d.geometry, d.material, 0, 0, null));
  }
  function x(T, I) {
    T.getRGB(r0, G5(r)), n.buffers.color.setClear(r0.r, r0.g, r0.b, I, a);
  }
  function C() {
    p !== void 0 && (p.geometry.dispose(), p.material.dispose()),
      d !== void 0 && (d.geometry.dispose(), d.material.dispose());
  }
  return {
    getClearColor: function () {
      return l;
    },
    setClearColor: function (T, I = 1) {
      l.set(T), (c = I), x(l, c);
    },
    getClearAlpha: function () {
      return c;
    },
    setClearAlpha: function (T) {
      (c = T), x(l, c);
    },
    render: M,
    addToRenderList: w,
    dispose: C,
  };
}
function xD(r, e) {
  const t = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    n = {},
    i = y(null);
  let s = i,
    a = !1;
  function l(N, X, ie, re, me) {
    let _e = !1;
    const ge = m(re, ie, X);
    s !== ge && ((s = ge), d(s.object)),
      (_e = v(N, re, ie, me)),
      _e && A(N, re, ie, me),
      me !== null && e.update(me, r.ELEMENT_ARRAY_BUFFER),
      (_e || a) &&
        ((a = !1),
        I(N, X, ie, re),
        me !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(me).buffer));
  }
  function c() {
    return r.createVertexArray();
  }
  function d(N) {
    return r.bindVertexArray(N);
  }
  function p(N) {
    return r.deleteVertexArray(N);
  }
  function m(N, X, ie) {
    const re = ie.wireframe === !0;
    let me = n[N.id];
    me === void 0 && ((me = {}), (n[N.id] = me));
    let _e = me[X.id];
    _e === void 0 && ((_e = {}), (me[X.id] = _e));
    let ge = _e[re];
    return ge === void 0 && ((ge = y(c())), (_e[re] = ge)), ge;
  }
  function y(N) {
    const X = [],
      ie = [],
      re = [];
    for (let me = 0; me < t; me++) (X[me] = 0), (ie[me] = 0), (re[me] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: X,
      enabledAttributes: ie,
      attributeDivisors: re,
      object: N,
      attributes: {},
      index: null,
    };
  }
  function v(N, X, ie, re) {
    const me = s.attributes,
      _e = X.attributes;
    let ge = 0;
    const Re = ie.getAttributes();
    for (const J in Re)
      if (Re[J].location >= 0) {
        const oe = me[J];
        let ae = _e[J];
        if (
          (ae === void 0 &&
            (J === "instanceMatrix" &&
              N.instanceMatrix &&
              (ae = N.instanceMatrix),
            J === "instanceColor" && N.instanceColor && (ae = N.instanceColor)),
          oe === void 0 || oe.attribute !== ae || (ae && oe.data !== ae.data))
        )
          return !0;
        ge++;
      }
    return s.attributesNum !== ge || s.index !== re;
  }
  function A(N, X, ie, re) {
    const me = {},
      _e = X.attributes;
    let ge = 0;
    const Re = ie.getAttributes();
    for (const J in Re)
      if (Re[J].location >= 0) {
        let oe = _e[J];
        oe === void 0 &&
          (J === "instanceMatrix" &&
            N.instanceMatrix &&
            (oe = N.instanceMatrix),
          J === "instanceColor" && N.instanceColor && (oe = N.instanceColor));
        const ae = {};
        (ae.attribute = oe),
          oe && oe.data && (ae.data = oe.data),
          (me[J] = ae),
          ge++;
      }
    (s.attributes = me), (s.attributesNum = ge), (s.index = re);
  }
  function M() {
    const N = s.newAttributes;
    for (let X = 0, ie = N.length; X < ie; X++) N[X] = 0;
  }
  function w(N) {
    x(N, 0);
  }
  function x(N, X) {
    const ie = s.newAttributes,
      re = s.enabledAttributes,
      me = s.attributeDivisors;
    (ie[N] = 1),
      re[N] === 0 && (r.enableVertexAttribArray(N), (re[N] = 1)),
      me[N] !== X && (r.vertexAttribDivisor(N, X), (me[N] = X));
  }
  function C() {
    const N = s.newAttributes,
      X = s.enabledAttributes;
    for (let ie = 0, re = X.length; ie < re; ie++)
      X[ie] !== N[ie] && (r.disableVertexAttribArray(ie), (X[ie] = 0));
  }
  function T(N, X, ie, re, me, _e, ge) {
    ge === !0
      ? r.vertexAttribIPointer(N, X, ie, me, _e)
      : r.vertexAttribPointer(N, X, ie, re, me, _e);
  }
  function I(N, X, ie, re) {
    M();
    const me = re.attributes,
      _e = ie.getAttributes(),
      ge = X.defaultAttributeValues;
    for (const Re in _e) {
      const J = _e[Re];
      if (J.location >= 0) {
        let oe = me[Re];
        if (
          (oe === void 0 &&
            (Re === "instanceMatrix" &&
              N.instanceMatrix &&
              (oe = N.instanceMatrix),
            Re === "instanceColor" &&
              N.instanceColor &&
              (oe = N.instanceColor)),
          oe !== void 0)
        ) {
          const ae = oe.normalized,
            q = oe.itemSize,
            ce = e.get(oe);
          if (ce === void 0) continue;
          const Xe = ce.buffer,
            ye = ce.type,
            Pe = ce.bytesPerElement,
            Ue = ye === r.INT || ye === r.UNSIGNED_INT || oe.gpuType === qp;
          if (oe.isInterleavedBufferAttribute) {
            const Fe = oe.data,
              Je = Fe.stride,
              et = oe.offset;
            if (Fe.isInstancedInterleavedBuffer) {
              for (let tt = 0; tt < J.locationSize; tt++)
                x(J.location + tt, Fe.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                re._maxInstanceCount === void 0 &&
                (re._maxInstanceCount = Fe.meshPerAttribute * Fe.count);
            } else
              for (let tt = 0; tt < J.locationSize; tt++) w(J.location + tt);
            r.bindBuffer(r.ARRAY_BUFFER, Xe);
            for (let tt = 0; tt < J.locationSize; tt++)
              T(
                J.location + tt,
                q / J.locationSize,
                ye,
                ae,
                Je * Pe,
                (et + (q / J.locationSize) * tt) * Pe,
                Ue,
              );
          } else {
            if (oe.isInstancedBufferAttribute) {
              for (let Fe = 0; Fe < J.locationSize; Fe++)
                x(J.location + Fe, oe.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                re._maxInstanceCount === void 0 &&
                (re._maxInstanceCount = oe.meshPerAttribute * oe.count);
            } else
              for (let Fe = 0; Fe < J.locationSize; Fe++) w(J.location + Fe);
            r.bindBuffer(r.ARRAY_BUFFER, Xe);
            for (let Fe = 0; Fe < J.locationSize; Fe++)
              T(
                J.location + Fe,
                q / J.locationSize,
                ye,
                ae,
                q * Pe,
                (q / J.locationSize) * Fe * Pe,
                Ue,
              );
          }
        } else if (ge !== void 0) {
          const ae = ge[Re];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                r.vertexAttrib2fv(J.location, ae);
                break;
              case 3:
                r.vertexAttrib3fv(J.location, ae);
                break;
              case 4:
                r.vertexAttrib4fv(J.location, ae);
                break;
              default:
                r.vertexAttrib1fv(J.location, ae);
            }
        }
      }
    }
    C();
  }
  function U() {
    z();
    for (const N in n) {
      const X = n[N];
      for (const ie in X) {
        const re = X[ie];
        for (const me in re) p(re[me].object), delete re[me];
        delete X[ie];
      }
      delete n[N];
    }
  }
  function F(N) {
    if (n[N.id] === void 0) return;
    const X = n[N.id];
    for (const ie in X) {
      const re = X[ie];
      for (const me in re) p(re[me].object), delete re[me];
      delete X[ie];
    }
    delete n[N.id];
  }
  function O(N) {
    for (const X in n) {
      const ie = n[X];
      if (ie[N.id] === void 0) continue;
      const re = ie[N.id];
      for (const me in re) p(re[me].object), delete re[me];
      delete ie[N.id];
    }
  }
  function z() {
    L(), (a = !0), s !== i && ((s = i), d(s.object));
  }
  function L() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: l,
    reset: z,
    resetDefaultState: L,
    dispose: U,
    releaseStatesOfGeometry: F,
    releaseStatesOfProgram: O,
    initAttributes: M,
    enableAttribute: w,
    disableUnusedAttributes: C,
  };
}
function bD(r, e, t) {
  let n;
  function i(d) {
    n = d;
  }
  function s(d, p) {
    r.drawArrays(n, d, p), t.update(p, n, 1);
  }
  function a(d, p, m) {
    m !== 0 && (r.drawArraysInstanced(n, d, p, m), t.update(p, n, m));
  }
  function l(d, p, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, d, 0, p, 0, m);
    let y = 0;
    for (let v = 0; v < m; v++) y += p[v];
    t.update(y, n, 1);
  }
  function c(d, p, m, y) {
    if (m === 0) return;
    const v = e.get("WEBGL_multi_draw");
    if (v === null) for (let A = 0; A < d.length; A++) a(d[A], p[A], y[A]);
    else {
      v.multiDrawArraysInstancedWEBGL(n, d, 0, p, 0, y, 0, m);
      let A = 0;
      for (let M = 0; M < m; M++) A += p[M] * y[M];
      t.update(A, n, 1);
    }
  }
  (this.setMode = i),
    (this.render = s),
    (this.renderInstances = a),
    (this.renderMultiDraw = l),
    (this.renderMultiDrawInstances = c);
}
function _D(r, e, t, n) {
  let i;
  function s() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const O = e.get("EXT_texture_filter_anisotropic");
      i = r.getParameter(O.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function a(O) {
    return !(
      O !== wr &&
      n.convert(O) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function l(O) {
    const z =
      O === Kr &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      O !== hs &&
      n.convert(O) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) &&
      O !== or &&
      !z
    );
  }
  function c(O) {
    if (O === "highp") {
      if (
        r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision >
          0 &&
        r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      O = "mediump";
    }
    return O === "mediump" &&
      r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision >
        0 &&
      r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let d = t.precision !== void 0 ? t.precision : "highp";
  const p = c(d);
  p !== d &&
    (console.warn(
      "THREE.WebGLRenderer:",
      d,
      "not supported, using",
      p,
      "instead.",
    ),
    (d = p));
  const m = t.logarithmicDepthBuffer === !0,
    y = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    v = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
    A = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    M = r.getParameter(r.MAX_TEXTURE_SIZE),
    w = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
    x = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    C = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
    T = r.getParameter(r.MAX_VARYING_VECTORS),
    I = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
    U = A > 0,
    F = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: c,
    textureFormatReadable: a,
    textureTypeReadable: l,
    precision: d,
    logarithmicDepthBuffer: m,
    reverseDepthBuffer: y,
    maxTextures: v,
    maxVertexTextures: A,
    maxTextureSize: M,
    maxCubemapSize: w,
    maxAttributes: x,
    maxVertexUniforms: C,
    maxVaryings: T,
    maxFragmentUniforms: I,
    vertexTextures: U,
    maxSamples: F,
  };
}
function AD(r) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    s = !1;
  const a = new kl(),
    l = new an(),
    c = { value: null, needsUpdate: !1 };
  (this.uniform = c),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (m, y) {
      const v = m.length !== 0 || y || n !== 0 || i;
      return (i = y), (n = m.length), v;
    }),
    (this.beginShadows = function () {
      (s = !0), p(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (m, y) {
      t = p(m, y, 0);
    }),
    (this.setState = function (m, y, v) {
      const A = m.clippingPlanes,
        M = m.clipIntersection,
        w = m.clipShadows,
        x = r.get(m);
      if (!i || A === null || A.length === 0 || (s && !w)) s ? p(null) : d();
      else {
        const C = s ? 0 : n,
          T = C * 4;
        let I = x.clippingState || null;
        (c.value = I), (I = p(A, y, T, v));
        for (let U = 0; U !== T; ++U) I[U] = t[U];
        (x.clippingState = I),
          (this.numIntersection = M ? this.numPlanes : 0),
          (this.numPlanes += C);
      }
    });
  function d() {
    c.value !== t && ((c.value = t), (c.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function p(m, y, v, A) {
    const M = m !== null ? m.length : 0;
    let w = null;
    if (M !== 0) {
      if (((w = c.value), A !== !0 || w === null)) {
        const x = v + M * 4,
          C = y.matrixWorldInverse;
        l.getNormalMatrix(C),
          (w === null || w.length < x) && (w = new Float32Array(x));
        for (let T = 0, I = v; T !== M; ++T, I += 4)
          a.copy(m[T]).applyMatrix4(C, l),
            a.normal.toArray(w, I),
            (w[I + 3] = a.constant);
      }
      (c.value = w), (c.needsUpdate = !0);
    }
    return (e.numPlanes = M), (e.numIntersection = 0), w;
  }
}
function wD(r) {
  let e = new WeakMap();
  function t(a, l) {
    return l === hh ? (a.mapping = io) : l === Sp && (a.mapping = Wl), a;
  }
  function n(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === hh || l === Sp)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return t(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const d = new O3(c.height);
            return (
              d.fromEquirectangularTexture(r, a),
              e.set(a, d),
              a.addEventListener("dispose", i),
              t(d.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function i(a) {
    const l = a.target;
    l.removeEventListener("dispose", i);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: n, dispose: s };
}
const sh = 4,
  sA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  pc = 20,
  Cy = new Wc(),
  aA = new dt();
let Ty = null,
  Ry = 0,
  Iy = 0,
  By = !1;
const fc = (1 + Math.sqrt(5)) / 2,
  Xd = 1 / fc,
  oA = [
    new Y(-fc, Xd, 0),
    new Y(fc, Xd, 0),
    new Y(-Xd, 0, fc),
    new Y(Xd, 0, fc),
    new Y(0, fc, -Xd),
    new Y(0, fc, Xd),
    new Y(-1, 1, -1),
    new Y(1, 1, -1),
    new Y(-1, 1, 1),
    new Y(1, 1, 1),
  ];
class Bv {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (Ty = this._renderer.getRenderTarget()),
      (Ry = this._renderer.getActiveCubeFace()),
      (Iy = this._renderer.getActiveMipmapLevel()),
      (By = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = cA()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = uA()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Ty, Ry, Iy),
      (this._renderer.xr.enabled = By),
      (e.scissorTest = !1),
      i0(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === io || e.mapping === Wl
      ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
      : this._setSize(e.image.width / 4),
      (Ty = this._renderer.getRenderTarget()),
      (Ry = this._renderer.getActiveCubeFace()),
      (Iy = this._renderer.getActiveMipmapLevel()),
      (By = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: Un,
        minFilter: Un,
        generateMipmaps: !1,
        type: Kr,
        format: wr,
        colorSpace: ao,
        depthBuffer: !1,
      },
      i = lA(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = lA(e, t, n));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = MD(s)),
        (this._blurMaterial = SD(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new nr(this._lodPlanes[0], e);
    this._renderer.compile(t, Cy);
  }
  _sceneToCubeUV(e, t, n, i) {
    const s = new Hr(90, 1, t, n),
      a = [1, -1, 1, 1, 1, 1],
      l = [1, 1, 1, -1, -1, -1],
      c = this._renderer,
      d = c.autoClear,
      p = c.toneMapping;
    c.getClearColor(aA), (c.toneMapping = to), (c.autoClear = !1);
    const m = new ds({
        name: "PMREM.Background",
        side: Ji,
        depthWrite: !1,
        depthTest: !1,
      }),
      y = new nr(new Vc(), m);
    let v = !1;
    const A = e.background;
    A
      ? A.isColor && (m.color.copy(A), (e.background = null), (v = !0))
      : (m.color.copy(aA), (v = !0));
    for (let M = 0; M < 6; M++) {
      const w = M % 3;
      w === 0
        ? (s.up.set(0, a[M], 0), s.lookAt(l[M], 0, 0))
        : w === 1
          ? (s.up.set(0, 0, a[M]), s.lookAt(0, l[M], 0))
          : (s.up.set(0, a[M], 0), s.lookAt(0, 0, l[M]));
      const x = this._cubeSize;
      i0(i, w * x, M > 2 ? x : 0, x, x),
        c.setRenderTarget(i),
        v && c.render(y, s),
        c.render(e, s);
    }
    y.geometry.dispose(),
      y.material.dispose(),
      (c.toneMapping = p),
      (c.autoClear = d),
      (e.background = A);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === io || e.mapping === Wl;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = cA()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = uA());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      a = new nr(this._lodPlanes[0], s),
      l = s.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    i0(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(a, Cy);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let s = 1; s < i; s++) {
      const a = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1],
        ),
        l = oA[(i - s - 1) % oA.length];
      this._blur(e, s - 1, s, a, l);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, i, "latitudinal", s),
      this._halfBlur(a, e, n, n, i, "longitudinal", s);
  }
  _halfBlur(e, t, n, i, s, a, l) {
    const c = this._renderer,
      d = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!",
      );
    const p = 3,
      m = new nr(this._lodPlanes[i], d),
      y = d.uniforms,
      v = this._sizeLods[n] - 1,
      A = isFinite(s) ? Math.PI / (2 * v) : (2 * Math.PI) / (2 * pc - 1),
      M = s / A,
      w = isFinite(s) ? 1 + Math.floor(p * M) : pc;
    w > pc &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${pc}`,
      );
    const x = [];
    let C = 0;
    for (let O = 0; O < pc; ++O) {
      const z = O / M,
        L = Math.exp((-z * z) / 2);
      x.push(L), O === 0 ? (C += L) : O < w && (C += 2 * L);
    }
    for (let O = 0; O < x.length; O++) x[O] = x[O] / C;
    (y.envMap.value = e.texture),
      (y.samples.value = w),
      (y.weights.value = x),
      (y.latitudinal.value = a === "latitudinal"),
      l && (y.poleAxis.value = l);
    const { _lodMax: T } = this;
    (y.dTheta.value = A), (y.mipInt.value = T - n);
    const I = this._sizeLods[i],
      U = 3 * I * (i > T - sh ? i - T + sh : 0),
      F = 4 * (this._cubeSize - I);
    i0(t, U, F, 3 * I, 2 * I), c.setRenderTarget(t), c.render(m, Cy);
  }
}
function MD(r) {
  const e = [],
    t = [],
    n = [];
  let i = r;
  const s = r - sh + 1 + sA.length;
  for (let a = 0; a < s; a++) {
    const l = Math.pow(2, i);
    t.push(l);
    let c = 1 / l;
    a > r - sh ? (c = sA[a - r + sh - 1]) : a === 0 && (c = 0), n.push(c);
    const d = 1 / (l - 2),
      p = -d,
      m = 1 + d,
      y = [p, p, m, p, m, m, p, p, m, m, p, m],
      v = 6,
      A = 6,
      M = 3,
      w = 2,
      x = 1,
      C = new Float32Array(M * A * v),
      T = new Float32Array(w * A * v),
      I = new Float32Array(x * A * v);
    for (let F = 0; F < v; F++) {
      const O = ((F % 3) * 2) / 3 - 1,
        z = F > 2 ? 0 : -1,
        L = [
          O,
          z,
          0,
          O + 2 / 3,
          z,
          0,
          O + 2 / 3,
          z + 1,
          0,
          O,
          z,
          0,
          O + 2 / 3,
          z + 1,
          0,
          O,
          z + 1,
          0,
        ];
      C.set(L, M * A * F), T.set(y, w * A * F);
      const N = [F, F, F, F, F, F];
      I.set(N, x * A * F);
    }
    const U = new tn();
    U.setAttribute("position", new Tn(C, M)),
      U.setAttribute("uv", new Tn(T, w)),
      U.setAttribute("faceIndex", new Tn(I, x)),
      e.push(U),
      i > sh && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function lA(r, e, t) {
  const n = new Es(r, e, t);
  return (
    (n.texture.mapping = Sh),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function i0(r, e, t, n, i) {
  r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function SD(r, e, t) {
  const n = new Float32Array(pc),
    i = new Y(0, 1, 0);
  return new fs({
    name: "SphericalGaussianBlur",
    defines: {
      n: pc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: mx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: eo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function uA() {
  return new fs({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: mx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: eo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function cA() {
  return new fs({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: mx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: eo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function mx() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function ED(r) {
  let e = new WeakMap(),
    t = null;
  function n(l) {
    if (l && l.isTexture) {
      const c = l.mapping,
        d = c === hh || c === Sp,
        p = c === io || c === Wl;
      if (d || p) {
        let m = e.get(l);
        const y = m !== void 0 ? m.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== y)
          return (
            t === null && (t = new Bv(r)),
            (m = d ? t.fromEquirectangular(l, m) : t.fromCubemap(l, m)),
            (m.texture.pmremVersion = l.pmremVersion),
            e.set(l, m),
            m.texture
          );
        if (m !== void 0) return m.texture;
        {
          const v = l.image;
          return (d && v && v.height > 0) || (p && v && i(v))
            ? (t === null && (t = new Bv(r)),
              (m = d ? t.fromEquirectangular(l) : t.fromCubemap(l)),
              (m.texture.pmremVersion = l.pmremVersion),
              e.set(l, m),
              l.addEventListener("dispose", s),
              m.texture)
            : null;
        }
      }
    }
    return l;
  }
  function i(l) {
    let c = 0;
    const d = 6;
    for (let p = 0; p < d; p++) l[p] !== void 0 && c++;
    return c === d;
  }
  function s(l) {
    const c = l.target;
    c.removeEventListener("dispose", s);
    const d = e.get(c);
    d !== void 0 && (e.delete(c), d.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: a };
}
function CD(r) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          r.getExtension("WEBGL_depth_texture") ||
          r.getExtension("MOZ_WEBGL_depth_texture") ||
          r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          r.getExtension("EXT_texture_filter_anisotropic") ||
          r.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          r.getExtension("WEBGL_compressed_texture_s3tc") ||
          r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          r.getExtension("WEBGL_compressed_texture_pvrtc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = r.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          Zd("THREE.WebGLRenderer: " + n + " extension not supported."),
        i
      );
    },
  };
}
function TD(r, e, t, n) {
  const i = {},
    s = new WeakMap();
  function a(m) {
    const y = m.target;
    y.index !== null && e.remove(y.index);
    for (const A in y.attributes) e.remove(y.attributes[A]);
    y.removeEventListener("dispose", a), delete i[y.id];
    const v = s.get(y);
    v && (e.remove(v), s.delete(y)),
      n.releaseStatesOfGeometry(y),
      y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount,
      t.memory.geometries--;
  }
  function l(m, y) {
    return (
      i[y.id] === !0 ||
        (y.addEventListener("dispose", a),
        (i[y.id] = !0),
        t.memory.geometries++),
      y
    );
  }
  function c(m) {
    const y = m.attributes;
    for (const v in y) e.update(y[v], r.ARRAY_BUFFER);
  }
  function d(m) {
    const y = [],
      v = m.index,
      A = m.attributes.position;
    let M = 0;
    if (v !== null) {
      const C = v.array;
      M = v.version;
      for (let T = 0, I = C.length; T < I; T += 3) {
        const U = C[T + 0],
          F = C[T + 1],
          O = C[T + 2];
        y.push(U, F, F, O, O, U);
      }
    } else if (A !== void 0) {
      const C = A.array;
      M = A.version;
      for (let T = 0, I = C.length / 3 - 1; T < I; T += 3) {
        const U = T + 0,
          F = T + 1,
          O = T + 2;
        y.push(U, F, F, O, O, U);
      }
    } else return;
    const w = new (O5(y) ? U3 : N3)(y, 1);
    w.version = M;
    const x = s.get(m);
    x && e.remove(x), s.set(m, w);
  }
  function p(m) {
    const y = s.get(m);
    if (y) {
      const v = m.index;
      v !== null && y.version < v.version && d(m);
    } else d(m);
    return s.get(m);
  }
  return { get: l, update: c, getWireframeAttribute: p };
}
function RD(r, e, t) {
  let n;
  function i(y) {
    n = y;
  }
  let s, a;
  function l(y) {
    (s = y.type), (a = y.bytesPerElement);
  }
  function c(y, v) {
    r.drawElements(n, v, s, y * a), t.update(v, n, 1);
  }
  function d(y, v, A) {
    A !== 0 && (r.drawElementsInstanced(n, v, s, y * a, A), t.update(v, n, A));
  }
  function p(y, v, A) {
    if (A === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, v, 0, s, y, 0, A);
    let M = 0;
    for (let w = 0; w < A; w++) M += v[w];
    t.update(M, n, 1);
  }
  function m(y, v, A, M) {
    if (A === 0) return;
    const w = e.get("WEBGL_multi_draw");
    if (w === null) for (let x = 0; x < y.length; x++) d(y[x] / a, v[x], M[x]);
    else {
      w.multiDrawElementsInstancedWEBGL(n, v, 0, s, y, 0, M, 0, A);
      let x = 0;
      for (let C = 0; C < A; C++) x += v[C] * M[C];
      t.update(x, n, 1);
    }
  }
  (this.setMode = i),
    (this.setIndex = l),
    (this.render = c),
    (this.renderInstances = d),
    (this.renderMultiDraw = p),
    (this.renderMultiDrawInstances = m);
}
function ID(r) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, a, l) {
    switch ((t.calls++, a)) {
      case r.TRIANGLES:
        t.triangles += l * (s / 3);
        break;
      case r.LINES:
        t.lines += l * (s / 2);
        break;
      case r.LINE_STRIP:
        t.lines += l * (s - 1);
        break;
      case r.LINE_LOOP:
        t.lines += l * s;
        break;
      case r.POINTS:
        t.points += l * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function BD(r, e, t) {
  const n = new WeakMap(),
    i = new Cn();
  function s(a, l, c) {
    const d = a.morphTargetInfluences,
      p =
        l.morphAttributes.position ||
        l.morphAttributes.normal ||
        l.morphAttributes.color,
      m = p !== void 0 ? p.length : 0;
    let y = n.get(l);
    if (y === void 0 || y.count !== m) {
      let v = function () {
        z.dispose(), n.delete(l), l.removeEventListener("dispose", v);
      };
      y !== void 0 && y.texture.dispose();
      const A = l.morphAttributes.position !== void 0,
        M = l.morphAttributes.normal !== void 0,
        w = l.morphAttributes.color !== void 0,
        x = l.morphAttributes.position || [],
        C = l.morphAttributes.normal || [],
        T = l.morphAttributes.color || [];
      let I = 0;
      A === !0 && (I = 1), M === !0 && (I = 2), w === !0 && (I = 3);
      let U = l.attributes.position.count * I,
        F = 1;
      U > e.maxTextureSize &&
        ((F = Math.ceil(U / e.maxTextureSize)), (U = e.maxTextureSize));
      const O = new Float32Array(U * F * 4 * m),
        z = new Fg(O, U, F, m);
      (z.type = or), (z.needsUpdate = !0);
      const L = I * 4;
      for (let N = 0; N < m; N++) {
        const X = x[N],
          ie = C[N],
          re = T[N],
          me = U * F * 4 * N;
        for (let _e = 0; _e < X.count; _e++) {
          const ge = _e * L;
          A === !0 &&
            (i.fromBufferAttribute(X, _e),
            (O[me + ge + 0] = i.x),
            (O[me + ge + 1] = i.y),
            (O[me + ge + 2] = i.z),
            (O[me + ge + 3] = 0)),
            M === !0 &&
              (i.fromBufferAttribute(ie, _e),
              (O[me + ge + 4] = i.x),
              (O[me + ge + 5] = i.y),
              (O[me + ge + 6] = i.z),
              (O[me + ge + 7] = 0)),
            w === !0 &&
              (i.fromBufferAttribute(re, _e),
              (O[me + ge + 8] = i.x),
              (O[me + ge + 9] = i.y),
              (O[me + ge + 10] = i.z),
              (O[me + ge + 11] = re.itemSize === 4 ? i.w : 1));
        }
      }
      (y = { count: m, texture: z, size: new je(U, F) }),
        n.set(l, y),
        l.addEventListener("dispose", v);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      c.getUniforms().setValue(r, "morphTexture", a.morphTexture, t);
    else {
      let v = 0;
      for (let M = 0; M < d.length; M++) v += d[M];
      const A = l.morphTargetsRelative ? 1 : 1 - v;
      c.getUniforms().setValue(r, "morphTargetBaseInfluence", A),
        c.getUniforms().setValue(r, "morphTargetInfluences", d);
    }
    c.getUniforms().setValue(r, "morphTargetsTexture", y.texture, t),
      c.getUniforms().setValue(r, "morphTargetsTextureSize", y.size);
  }
  return { update: s };
}
function PD(r, e, t, n) {
  let i = new WeakMap();
  function s(c) {
    const d = n.render.frame,
      p = c.geometry,
      m = e.get(c, p);
    if (
      (i.get(m) !== d && (e.update(m), i.set(m, d)),
      c.isInstancedMesh &&
        (c.hasEventListener("dispose", l) === !1 &&
          c.addEventListener("dispose", l),
        i.get(c) !== d &&
          (t.update(c.instanceMatrix, r.ARRAY_BUFFER),
          c.instanceColor !== null && t.update(c.instanceColor, r.ARRAY_BUFFER),
          i.set(c, d))),
      c.isSkinnedMesh)
    ) {
      const y = c.skeleton;
      i.get(y) !== d && (y.update(), i.set(y, d));
    }
    return m;
  }
  function a() {
    i = new WeakMap();
  }
  function l(c) {
    const d = c.target;
    d.removeEventListener("dispose", l),
      t.remove(d.instanceMatrix),
      d.instanceColor !== null && t.remove(d.instanceColor);
  }
  return { update: s, dispose: a };
}
const FS = new Ln(),
  dA = new j3(1, 1),
  NS = new Fg(),
  US = new F3(),
  OS = new em(),
  hA = [],
  fA = [],
  pA = new Float32Array(16),
  mA = new Float32Array(9),
  gA = new Float32Array(4);
function Rh(r, e, t) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const i = e * t;
  let s = hA[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (hA[i] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let a = 1, l = 0; a !== e; ++a) (l += t), r[a].toArray(s, l);
  }
  return s;
}
function Vr(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
  return !0;
}
function Gr(r, e) {
  for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
}
function n2(r, e) {
  let t = fA[e];
  t === void 0 && ((t = new Int32Array(e)), (fA[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
  return t;
}
function LD(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function DD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Vr(t, e)) return;
    r.uniform2fv(this.addr, e), Gr(t, e);
  }
}
function FD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (r.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Vr(t, e)) return;
    r.uniform3fv(this.addr, e), Gr(t, e);
  }
}
function ND(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Vr(t, e)) return;
    r.uniform4fv(this.addr, e), Gr(t, e);
  }
}
function UD(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Vr(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Gr(t, e);
  } else {
    if (Vr(t, n)) return;
    gA.set(n), r.uniformMatrix2fv(this.addr, !1, gA), Gr(t, n);
  }
}
function OD(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Vr(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Gr(t, e);
  } else {
    if (Vr(t, n)) return;
    mA.set(n), r.uniformMatrix3fv(this.addr, !1, mA), Gr(t, n);
  }
}
function kD(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Vr(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Gr(t, e);
  } else {
    if (Vr(t, n)) return;
    pA.set(n), r.uniformMatrix4fv(this.addr, !1, pA), Gr(t, n);
  }
}
function zD(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function HD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Vr(t, e)) return;
    r.uniform2iv(this.addr, e), Gr(t, e);
  }
}
function VD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Vr(t, e)) return;
    r.uniform3iv(this.addr, e), Gr(t, e);
  }
}
function GD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Vr(t, e)) return;
    r.uniform4iv(this.addr, e), Gr(t, e);
  }
}
function jD(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function WD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Vr(t, e)) return;
    r.uniform2uiv(this.addr, e), Gr(t, e);
  }
}
function XD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Vr(t, e)) return;
    r.uniform3uiv(this.addr, e), Gr(t, e);
  }
}
function JD(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Vr(t, e)) return;
    r.uniform4uiv(this.addr, e), Gr(t, e);
  }
}
function YD(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i));
  let s;
  this.type === r.SAMPLER_2D_SHADOW
    ? ((dA.compareFunction = L3), (s = dA))
    : (s = FS),
    t.setTexture2D(e || s, i);
}
function ZD(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || US, i);
}
function qD(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || OS, i);
}
function KD(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || NS, i);
}
function QD(r) {
  switch (r) {
    case 5126:
      return LD;
    case 35664:
      return DD;
    case 35665:
      return FD;
    case 35666:
      return ND;
    case 35674:
      return UD;
    case 35675:
      return OD;
    case 35676:
      return kD;
    case 5124:
    case 35670:
      return zD;
    case 35667:
    case 35671:
      return HD;
    case 35668:
    case 35672:
      return VD;
    case 35669:
    case 35673:
      return GD;
    case 5125:
      return jD;
    case 36294:
      return WD;
    case 36295:
      return XD;
    case 36296:
      return JD;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return YD;
    case 35679:
    case 36299:
    case 36307:
      return ZD;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return qD;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return KD;
  }
}
function $D(r, e) {
  r.uniform1fv(this.addr, e);
}
function eF(r, e) {
  const t = Rh(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function tF(r, e) {
  const t = Rh(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function nF(r, e) {
  const t = Rh(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function rF(r, e) {
  const t = Rh(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function iF(r, e) {
  const t = Rh(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function sF(r, e) {
  const t = Rh(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function aF(r, e) {
  r.uniform1iv(this.addr, e);
}
function oF(r, e) {
  r.uniform2iv(this.addr, e);
}
function lF(r, e) {
  r.uniform3iv(this.addr, e);
}
function uF(r, e) {
  r.uniform4iv(this.addr, e);
}
function cF(r, e) {
  r.uniform1uiv(this.addr, e);
}
function dF(r, e) {
  r.uniform2uiv(this.addr, e);
}
function hF(r, e) {
  r.uniform3uiv(this.addr, e);
}
function fF(r, e) {
  r.uniform4uiv(this.addr, e);
}
function pF(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = n2(t, i);
  Vr(n, s) || (r.uniform1iv(this.addr, s), Gr(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || FS, s[a]);
}
function mF(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = n2(t, i);
  Vr(n, s) || (r.uniform1iv(this.addr, s), Gr(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || US, s[a]);
}
function gF(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = n2(t, i);
  Vr(n, s) || (r.uniform1iv(this.addr, s), Gr(n, s));
  for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || OS, s[a]);
}
function yF(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = n2(t, i);
  Vr(n, s) || (r.uniform1iv(this.addr, s), Gr(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || NS, s[a]);
}
function vF(r) {
  switch (r) {
    case 5126:
      return $D;
    case 35664:
      return eF;
    case 35665:
      return tF;
    case 35666:
      return nF;
    case 35674:
      return rF;
    case 35675:
      return iF;
    case 35676:
      return sF;
    case 5124:
    case 35670:
      return aF;
    case 35667:
    case 35671:
      return oF;
    case 35668:
    case 35672:
      return lF;
    case 35669:
    case 35673:
      return uF;
    case 5125:
      return cF;
    case 36294:
      return dF;
    case 36295:
      return hF;
    case 36296:
      return fF;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return pF;
    case 35679:
    case 36299:
    case 36307:
      return mF;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return gF;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return yF;
  }
}
class xF {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = QD(t.type));
  }
}
class bF {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = vF(t.type));
  }
}
class _F {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let s = 0, a = i.length; s !== a; ++s) {
      const l = i[s];
      l.setValue(e, t[l.id], n);
    }
  }
}
const Py = /(\w+)(\])?(\[|\.)?/g;
function yA(r, e) {
  r.seq.push(e), (r.map[e.id] = e);
}
function AF(r, e, t) {
  const n = r.name,
    i = n.length;
  for (Py.lastIndex = 0; ; ) {
    const s = Py.exec(n),
      a = Py.lastIndex;
    let l = s[1];
    const c = s[2] === "]",
      d = s[3];
    if ((c && (l = l | 0), d === void 0 || (d === "[" && a + 2 === i))) {
      yA(t, d === void 0 ? new xF(l, r, e) : new bF(l, r, e));
      break;
    } else {
      let p = t.map[l];
      p === void 0 && ((p = new _F(l)), yA(t, p)), (t = p);
    }
  }
}
class v0 {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const s = e.getActiveUniform(t, i),
        a = e.getUniformLocation(t, s.name);
      AF(s, a, this);
    }
  }
  setValue(e, t, n, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const l = t[s],
        c = n[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function vA(r, e, t) {
  const n = r.createShader(e);
  return r.shaderSource(n, t), r.compileShader(n), n;
}
const wF = 37297;
let MF = 0;
function SF(r, e) {
  const t = r.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let a = i; a < s; a++) {
    const l = a + 1;
    n.push(`${l === e ? ">" : " "} ${l}: ${t[a]}`);
  }
  return n.join(`
`);
}
const xA = new an();
function EF(r) {
  Sn._getMatrix(xA, Sn.workingColorSpace, r);
  const e = `mat3( ${xA.elements.map((t) => t.toFixed(4))} )`;
  switch (Sn.getTransfer(r)) {
    case Cp:
      return [e, "LinearTransferOETF"];
    case Hn:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", r),
        [e, "LinearTransferOETF"]
      );
  }
}
function bA(r, e, t) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS),
    i = r.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const a = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      SF(r.getShaderSource(e), a)
    );
  } else return i;
}
function CF(r, e) {
  const t = EF(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function TF(r, e) {
  let t;
  switch (e) {
    case y5:
      t = "Linear";
      break;
    case v5:
      t = "Reinhard";
      break;
    case x5:
      t = "Cineon";
      break;
    case Eg:
      t = "ACESFilmic";
      break;
    case _5:
      t = "AgX";
      break;
    case A5:
      t = "Neutral";
      break;
    case b5:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const s0 = new Y();
function RF() {
  Sn.getLuminanceCoefficients(s0);
  const r = s0.x.toFixed(4),
    e = s0.y.toFixed(4),
    t = s0.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function IF(r) {
  return [
    r.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(ep).join(`
`);
}
function BF(r) {
  const e = [];
  for (const t in r) {
    const n = r[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function PF(r, e) {
  const t = {},
    n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i),
      a = s.name;
    let l = 1;
    s.type === r.FLOAT_MAT2 && (l = 2),
      s.type === r.FLOAT_MAT3 && (l = 3),
      s.type === r.FLOAT_MAT4 && (l = 4),
      (t[a] = {
        type: s.type,
        location: r.getAttribLocation(e, a),
        locationSize: l,
      });
  }
  return t;
}
function ep(r) {
  return r !== "";
}
function _A(r, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function AA(r, e) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection,
    );
}
const LF = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Pv(r) {
  return r.replace(LF, FF);
}
const DF = new Map();
function FF(r, e) {
  let t = un[e];
  if (t === void 0) {
    const n = DF.get(e);
    if (n !== void 0)
      (t = un[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n,
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return Pv(t);
}
const NF =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function wA(r) {
  return r.replace(NF, UF);
}
function UF(r, e, t, n) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function MA(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return (
    r.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : r.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : r.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
function OF(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    r.shadowMapType === Sg
      ? (e = "SHADOWMAP_TYPE_PCF")
      : r.shadowMapType === up
        ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
        : r.shadowMapType === _a && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function kF(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case io:
      case Wl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Sh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function zF(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case Wl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function HF(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case Zp:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case m5:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case g5:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function VF(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function GF(r, e, t, n) {
  const i = r.getContext(),
    s = t.defines;
  let a = t.vertexShader,
    l = t.fragmentShader;
  const c = OF(t),
    d = kF(t),
    p = zF(t),
    m = HF(t),
    y = VF(t),
    v = IF(t),
    A = BF(s),
    M = i.createProgram();
  let w,
    x,
    C = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((w = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        A,
      ].filter(ep).join(`
`)),
      w.length > 0 &&
        (w += `
`),
      (x = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        A,
      ].filter(ep).join(`
`)),
      x.length > 0 &&
        (x += `
`))
    : ((w = [
        MA(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        A,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + p : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + c : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(ep).join(`
`)),
      (x = [
        MA(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        A,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + p : "",
        t.envMap ? "#define " + m : "",
        y ? "#define CUBEUV_TEXEL_WIDTH " + y.texelWidth : "",
        y ? "#define CUBEUV_TEXEL_HEIGHT " + y.texelHeight : "",
        y ? "#define CUBEUV_MAX_MIP " + y.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + c : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== to ? "#define TONE_MAPPING" : "",
        t.toneMapping !== to ? un.tonemapping_pars_fragment : "",
        t.toneMapping !== to ? TF("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        un.colorspace_pars_fragment,
        CF("linearToOutputTexel", t.outputColorSpace),
        RF(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(ep).join(`
`))),
    (a = Pv(a)),
    (a = _A(a, t)),
    (a = AA(a, t)),
    (l = Pv(l)),
    (l = _A(l, t)),
    (l = AA(l, t)),
    (a = wA(a)),
    (l = wA(l)),
    t.isRawShaderMaterial !== !0 &&
      ((C = `#version 300 es
`),
      (w =
        [
          v,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        w),
      (x =
        [
          "#define varying in",
          t.glslVersion === Mv
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Mv ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        x));
  const T = C + w + a,
    I = C + x + l,
    U = vA(i, i.VERTEX_SHADER, T),
    F = vA(i, i.FRAGMENT_SHADER, I);
  i.attachShader(M, U),
    i.attachShader(M, F),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(M, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(M, 0, "position"),
    i.linkProgram(M);
  function O(X) {
    if (r.debug.checkShaderErrors) {
      const ie = i.getProgramInfoLog(M).trim(),
        re = i.getShaderInfoLog(U).trim(),
        me = i.getShaderInfoLog(F).trim();
      let _e = !0,
        ge = !0;
      if (i.getProgramParameter(M, i.LINK_STATUS) === !1)
        if (((_e = !1), typeof r.debug.onShaderError == "function"))
          r.debug.onShaderError(i, M, U, F);
        else {
          const Re = bA(i, U, "vertex"),
            J = bA(i, F, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(M, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              X.name +
              `
Material Type: ` +
              X.type +
              `

Program Info Log: ` +
              ie +
              `
` +
              Re +
              `
` +
              J,
          );
        }
      else
        ie !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", ie)
          : (re === "" || me === "") && (ge = !1);
      ge &&
        (X.diagnostics = {
          runnable: _e,
          programLog: ie,
          vertexShader: { log: re, prefix: w },
          fragmentShader: { log: me, prefix: x },
        });
    }
    i.deleteShader(U), i.deleteShader(F), (z = new v0(i, M)), (L = PF(i, M));
  }
  let z;
  this.getUniforms = function () {
    return z === void 0 && O(this), z;
  };
  let L;
  this.getAttributes = function () {
    return L === void 0 && O(this), L;
  };
  let N = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return N === !1 && (N = i.getProgramParameter(M, wF)), N;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(M),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = MF++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = M),
    (this.vertexShader = U),
    (this.fragmentShader = F),
    this
  );
}
let jF = 0;
class WF {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(i) === !1 && (a.add(i), i.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new XF(e)), t.set(e, n)), n;
  }
}
class XF {
  constructor(e) {
    (this.id = jF++), (this.code = e), (this.usedTimes = 0);
  }
}
function JF(r, e, t, n, i, s, a) {
  const l = new Tc(),
    c = new WF(),
    d = new Set(),
    p = [],
    m = i.logarithmicDepthBuffer,
    y = i.vertexTextures;
  let v = i.precision;
  const A = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function M(L) {
    return d.add(L), L === 0 ? "uv" : `uv${L}`;
  }
  function w(L, N, X, ie, re) {
    const me = ie.fog,
      _e = re.geometry,
      ge = L.isMeshStandardMaterial ? ie.environment : null,
      Re = (L.isMeshStandardMaterial ? t : e).get(L.envMap || ge),
      J = Re && Re.mapping === Sh ? Re.image.height : null,
      oe = A[L.type];
    L.precision !== null &&
      ((v = i.getMaxPrecision(L.precision)),
      v !== L.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          L.precision,
          "not supported, using",
          v,
          "instead.",
        ));
    const ae =
        _e.morphAttributes.position ||
        _e.morphAttributes.normal ||
        _e.morphAttributes.color,
      q = ae !== void 0 ? ae.length : 0;
    let ce = 0;
    _e.morphAttributes.position !== void 0 && (ce = 1),
      _e.morphAttributes.normal !== void 0 && (ce = 2),
      _e.morphAttributes.color !== void 0 && (ce = 3);
    let Xe, ye, Pe, Ue;
    if (oe) {
      const ke = Aa[oe];
      (Xe = ke.vertexShader), (ye = ke.fragmentShader);
    } else
      (Xe = L.vertexShader),
        (ye = L.fragmentShader),
        c.update(L),
        (Pe = c.getVertexShaderID(L)),
        (Ue = c.getFragmentShaderID(L));
    const Fe = r.getRenderTarget(),
      Je = r.state.buffers.depth.getReversed(),
      et = re.isInstancedMesh === !0,
      tt = re.isBatchedMesh === !0,
      be = !!L.map,
      Te = !!L.matcap,
      Ne = !!Re,
      K = !!L.aoMap,
      qe = !!L.lightMap,
      ct = !!L.bumpMap,
      Be = !!L.normalMap,
      nt = !!L.displacementMap,
      Dt = !!L.emissiveMap,
      it = !!L.metalnessMap,
      Z = !!L.roughnessMap,
      G = L.anisotropy > 0,
      xe = L.clearcoat > 0,
      ze = L.dispersion > 0,
      We = L.iridescence > 0,
      Oe = L.sheen > 0,
      Mt = L.transmission > 0,
      ot = G && !!L.anisotropyMap,
      ft = xe && !!L.clearcoatMap,
      Ot = xe && !!L.clearcoatNormalMap,
      Ke = xe && !!L.clearcoatRoughnessMap,
      ht = We && !!L.iridescenceMap,
      Tt = We && !!L.iridescenceThicknessMap,
      st = Oe && !!L.sheenColorMap,
      xt = Oe && !!L.sheenRoughnessMap,
      Qt = !!L.specularMap,
      D = !!L.specularColorMap,
      W = !!L.specularIntensityMap,
      k = Mt && !!L.transmissionMap,
      ne = Mt && !!L.thicknessMap,
      Q = !!L.gradientMap,
      te = !!L.alphaMap,
      Ae = L.alphaTest > 0,
      pe = !!L.alphaHash,
      Ve = !!L.extensions;
    let He = to;
    L.toneMapped &&
      (Fe === null || Fe.isXRRenderTarget === !0) &&
      (He = r.toneMapping);
    const Qe = {
      shaderID: oe,
      shaderType: L.type,
      shaderName: L.name,
      vertexShader: Xe,
      fragmentShader: ye,
      defines: L.defines,
      customVertexShaderID: Pe,
      customFragmentShaderID: Ue,
      isRawShaderMaterial: L.isRawShaderMaterial === !0,
      glslVersion: L.glslVersion,
      precision: v,
      batching: tt,
      batchingColor: tt && re._colorsTexture !== null,
      instancing: et,
      instancingColor: et && re.instanceColor !== null,
      instancingMorph: et && re.morphTexture !== null,
      supportsVertexTextures: y,
      outputColorSpace:
        Fe === null
          ? r.outputColorSpace
          : Fe.isXRRenderTarget === !0
            ? Fe.texture.colorSpace
            : ao,
      alphaToCoverage: !!L.alphaToCoverage,
      map: be,
      matcap: Te,
      envMap: Ne,
      envMapMode: Ne && Re.mapping,
      envMapCubeUVHeight: J,
      aoMap: K,
      lightMap: qe,
      bumpMap: ct,
      normalMap: Be,
      displacementMap: y && nt,
      emissiveMap: Dt,
      normalMapObjectSpace: Be && L.normalMapType === I5,
      normalMapTangentSpace: Be && L.normalMapType === Zl,
      metalnessMap: it,
      roughnessMap: Z,
      anisotropy: G,
      anisotropyMap: ot,
      clearcoat: xe,
      clearcoatMap: ft,
      clearcoatNormalMap: Ot,
      clearcoatRoughnessMap: Ke,
      dispersion: ze,
      iridescence: We,
      iridescenceMap: ht,
      iridescenceThicknessMap: Tt,
      sheen: Oe,
      sheenColorMap: st,
      sheenRoughnessMap: xt,
      specularMap: Qt,
      specularColorMap: D,
      specularIntensityMap: W,
      transmission: Mt,
      transmissionMap: k,
      thicknessMap: ne,
      gradientMap: Q,
      opaque:
        L.transparent === !1 && L.blending === Sc && L.alphaToCoverage === !1,
      alphaMap: te,
      alphaTest: Ae,
      alphaHash: pe,
      combine: L.combine,
      mapUv: be && M(L.map.channel),
      aoMapUv: K && M(L.aoMap.channel),
      lightMapUv: qe && M(L.lightMap.channel),
      bumpMapUv: ct && M(L.bumpMap.channel),
      normalMapUv: Be && M(L.normalMap.channel),
      displacementMapUv: nt && M(L.displacementMap.channel),
      emissiveMapUv: Dt && M(L.emissiveMap.channel),
      metalnessMapUv: it && M(L.metalnessMap.channel),
      roughnessMapUv: Z && M(L.roughnessMap.channel),
      anisotropyMapUv: ot && M(L.anisotropyMap.channel),
      clearcoatMapUv: ft && M(L.clearcoatMap.channel),
      clearcoatNormalMapUv: Ot && M(L.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ke && M(L.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ht && M(L.iridescenceMap.channel),
      iridescenceThicknessMapUv: Tt && M(L.iridescenceThicknessMap.channel),
      sheenColorMapUv: st && M(L.sheenColorMap.channel),
      sheenRoughnessMapUv: xt && M(L.sheenRoughnessMap.channel),
      specularMapUv: Qt && M(L.specularMap.channel),
      specularColorMapUv: D && M(L.specularColorMap.channel),
      specularIntensityMapUv: W && M(L.specularIntensityMap.channel),
      transmissionMapUv: k && M(L.transmissionMap.channel),
      thicknessMapUv: ne && M(L.thicknessMap.channel),
      alphaMapUv: te && M(L.alphaMap.channel),
      vertexTangents: !!_e.attributes.tangent && (Be || G),
      vertexColors: L.vertexColors,
      vertexAlphas:
        L.vertexColors === !0 &&
        !!_e.attributes.color &&
        _e.attributes.color.itemSize === 4,
      pointsUvs: re.isPoints === !0 && !!_e.attributes.uv && (be || te),
      fog: !!me,
      useFog: L.fog === !0,
      fogExp2: !!me && me.isFogExp2,
      flatShading: L.flatShading === !0,
      sizeAttenuation: L.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      reverseDepthBuffer: Je,
      skinning: re.isSkinnedMesh === !0,
      morphTargets: _e.morphAttributes.position !== void 0,
      morphNormals: _e.morphAttributes.normal !== void 0,
      morphColors: _e.morphAttributes.color !== void 0,
      morphTargetsCount: q,
      morphTextureStride: ce,
      numDirLights: N.directional.length,
      numPointLights: N.point.length,
      numSpotLights: N.spot.length,
      numSpotLightMaps: N.spotLightMap.length,
      numRectAreaLights: N.rectArea.length,
      numHemiLights: N.hemi.length,
      numDirLightShadows: N.directionalShadowMap.length,
      numPointLightShadows: N.pointShadowMap.length,
      numSpotLightShadows: N.spotShadowMap.length,
      numSpotLightShadowsWithMaps: N.numSpotLightShadowsWithMaps,
      numLightProbes: N.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: L.dithering,
      shadowMapEnabled: r.shadowMap.enabled && X.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: He,
      decodeVideoTexture:
        be &&
        L.map.isVideoTexture === !0 &&
        Sn.getTransfer(L.map.colorSpace) === Hn,
      decodeVideoTextureEmissive:
        Dt &&
        L.emissiveMap.isVideoTexture === !0 &&
        Sn.getTransfer(L.emissiveMap.colorSpace) === Hn,
      premultipliedAlpha: L.premultipliedAlpha,
      doubleSided: L.side === Xs,
      flipSided: L.side === Ji,
      useDepthPacking: L.depthPacking >= 0,
      depthPacking: L.depthPacking || 0,
      index0AttributeName: L.index0AttributeName,
      extensionClipCullDistance:
        Ve &&
        L.extensions.clipCullDistance === !0 &&
        n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((Ve && L.extensions.multiDraw === !0) || tt) &&
        n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has(
        "KHR_parallel_shader_compile",
      ),
      customProgramCacheKey: L.customProgramCacheKey(),
    };
    return (
      (Qe.vertexUv1s = d.has(1)),
      (Qe.vertexUv2s = d.has(2)),
      (Qe.vertexUv3s = d.has(3)),
      d.clear(),
      Qe
    );
  }
  function x(L) {
    const N = [];
    if (
      (L.shaderID
        ? N.push(L.shaderID)
        : (N.push(L.customVertexShaderID), N.push(L.customFragmentShaderID)),
      L.defines !== void 0)
    )
      for (const X in L.defines) N.push(X), N.push(L.defines[X]);
    return (
      L.isRawShaderMaterial === !1 &&
        (C(N, L), T(N, L), N.push(r.outputColorSpace)),
      N.push(L.customProgramCacheKey),
      N.join()
    );
  }
  function C(L, N) {
    L.push(N.precision),
      L.push(N.outputColorSpace),
      L.push(N.envMapMode),
      L.push(N.envMapCubeUVHeight),
      L.push(N.mapUv),
      L.push(N.alphaMapUv),
      L.push(N.lightMapUv),
      L.push(N.aoMapUv),
      L.push(N.bumpMapUv),
      L.push(N.normalMapUv),
      L.push(N.displacementMapUv),
      L.push(N.emissiveMapUv),
      L.push(N.metalnessMapUv),
      L.push(N.roughnessMapUv),
      L.push(N.anisotropyMapUv),
      L.push(N.clearcoatMapUv),
      L.push(N.clearcoatNormalMapUv),
      L.push(N.clearcoatRoughnessMapUv),
      L.push(N.iridescenceMapUv),
      L.push(N.iridescenceThicknessMapUv),
      L.push(N.sheenColorMapUv),
      L.push(N.sheenRoughnessMapUv),
      L.push(N.specularMapUv),
      L.push(N.specularColorMapUv),
      L.push(N.specularIntensityMapUv),
      L.push(N.transmissionMapUv),
      L.push(N.thicknessMapUv),
      L.push(N.combine),
      L.push(N.fogExp2),
      L.push(N.sizeAttenuation),
      L.push(N.morphTargetsCount),
      L.push(N.morphAttributeCount),
      L.push(N.numDirLights),
      L.push(N.numPointLights),
      L.push(N.numSpotLights),
      L.push(N.numSpotLightMaps),
      L.push(N.numHemiLights),
      L.push(N.numRectAreaLights),
      L.push(N.numDirLightShadows),
      L.push(N.numPointLightShadows),
      L.push(N.numSpotLightShadows),
      L.push(N.numSpotLightShadowsWithMaps),
      L.push(N.numLightProbes),
      L.push(N.shadowMapType),
      L.push(N.toneMapping),
      L.push(N.numClippingPlanes),
      L.push(N.numClipIntersection),
      L.push(N.depthPacking);
  }
  function T(L, N) {
    l.disableAll(),
      N.supportsVertexTextures && l.enable(0),
      N.instancing && l.enable(1),
      N.instancingColor && l.enable(2),
      N.instancingMorph && l.enable(3),
      N.matcap && l.enable(4),
      N.envMap && l.enable(5),
      N.normalMapObjectSpace && l.enable(6),
      N.normalMapTangentSpace && l.enable(7),
      N.clearcoat && l.enable(8),
      N.iridescence && l.enable(9),
      N.alphaTest && l.enable(10),
      N.vertexColors && l.enable(11),
      N.vertexAlphas && l.enable(12),
      N.vertexUv1s && l.enable(13),
      N.vertexUv2s && l.enable(14),
      N.vertexUv3s && l.enable(15),
      N.vertexTangents && l.enable(16),
      N.anisotropy && l.enable(17),
      N.alphaHash && l.enable(18),
      N.batching && l.enable(19),
      N.dispersion && l.enable(20),
      N.batchingColor && l.enable(21),
      L.push(l.mask),
      l.disableAll(),
      N.fog && l.enable(0),
      N.useFog && l.enable(1),
      N.flatShading && l.enable(2),
      N.logarithmicDepthBuffer && l.enable(3),
      N.reverseDepthBuffer && l.enable(4),
      N.skinning && l.enable(5),
      N.morphTargets && l.enable(6),
      N.morphNormals && l.enable(7),
      N.morphColors && l.enable(8),
      N.premultipliedAlpha && l.enable(9),
      N.shadowMapEnabled && l.enable(10),
      N.doubleSided && l.enable(11),
      N.flipSided && l.enable(12),
      N.useDepthPacking && l.enable(13),
      N.dithering && l.enable(14),
      N.transmission && l.enable(15),
      N.sheen && l.enable(16),
      N.opaque && l.enable(17),
      N.pointsUvs && l.enable(18),
      N.decodeVideoTexture && l.enable(19),
      N.decodeVideoTextureEmissive && l.enable(20),
      N.alphaToCoverage && l.enable(21),
      L.push(l.mask);
  }
  function I(L) {
    const N = A[L.type];
    let X;
    if (N) {
      const ie = Aa[N];
      X = j5.clone(ie.uniforms);
    } else X = L.uniforms;
    return X;
  }
  function U(L, N) {
    let X;
    for (let ie = 0, re = p.length; ie < re; ie++) {
      const me = p[ie];
      if (me.cacheKey === N) {
        (X = me), ++X.usedTimes;
        break;
      }
    }
    return X === void 0 && ((X = new GF(r, N, L, s)), p.push(X)), X;
  }
  function F(L) {
    if (--L.usedTimes === 0) {
      const N = p.indexOf(L);
      (p[N] = p[p.length - 1]), p.pop(), L.destroy();
    }
  }
  function O(L) {
    c.remove(L);
  }
  function z() {
    c.dispose();
  }
  return {
    getParameters: w,
    getProgramCacheKey: x,
    getUniforms: I,
    acquireProgram: U,
    releaseProgram: F,
    releaseShaderCache: O,
    programs: p,
    dispose: z,
  };
}
function YF() {
  let r = new WeakMap();
  function e(a) {
    return r.has(a);
  }
  function t(a) {
    let l = r.get(a);
    return l === void 0 && ((l = {}), r.set(a, l)), l;
  }
  function n(a) {
    r.delete(a);
  }
  function i(a, l, c) {
    r.get(a)[l] = c;
  }
  function s() {
    r = new WeakMap();
  }
  return { has: e, get: t, remove: n, update: i, dispose: s };
}
function ZF(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
      ? r.renderOrder - e.renderOrder
      : r.material.id !== e.material.id
        ? r.material.id - e.material.id
        : r.z !== e.z
          ? r.z - e.z
          : r.id - e.id;
}
function SA(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
      ? r.renderOrder - e.renderOrder
      : r.z !== e.z
        ? e.z - r.z
        : r.id - e.id;
}
function EA() {
  const r = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function a(m, y, v, A, M, w) {
    let x = r[e];
    return (
      x === void 0
        ? ((x = {
            id: m.id,
            object: m,
            geometry: y,
            material: v,
            groupOrder: A,
            renderOrder: m.renderOrder,
            z: M,
            group: w,
          }),
          (r[e] = x))
        : ((x.id = m.id),
          (x.object = m),
          (x.geometry = y),
          (x.material = v),
          (x.groupOrder = A),
          (x.renderOrder = m.renderOrder),
          (x.z = M),
          (x.group = w)),
      e++,
      x
    );
  }
  function l(m, y, v, A, M, w) {
    const x = a(m, y, v, A, M, w);
    v.transmission > 0
      ? n.push(x)
      : v.transparent === !0
        ? i.push(x)
        : t.push(x);
  }
  function c(m, y, v, A, M, w) {
    const x = a(m, y, v, A, M, w);
    v.transmission > 0
      ? n.unshift(x)
      : v.transparent === !0
        ? i.unshift(x)
        : t.unshift(x);
  }
  function d(m, y) {
    t.length > 1 && t.sort(m || ZF),
      n.length > 1 && n.sort(y || SA),
      i.length > 1 && i.sort(y || SA);
  }
  function p() {
    for (let m = e, y = r.length; m < y; m++) {
      const v = r[m];
      if (v.id === null) break;
      (v.id = null),
        (v.object = null),
        (v.geometry = null),
        (v.material = null),
        (v.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: s,
    push: l,
    unshift: c,
    finish: p,
    sort: d,
  };
}
function qF() {
  let r = new WeakMap();
  function e(n, i) {
    const s = r.get(n);
    let a;
    return (
      s === void 0
        ? ((a = new EA()), r.set(n, [a]))
        : i >= s.length
          ? ((a = new EA()), s.push(a))
          : (a = s[i]),
      a
    );
  }
  function t() {
    r = new WeakMap();
  }
  return { get: e, dispose: t };
}
function KF() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new Y(), color: new dt() };
          break;
        case "SpotLight":
          t = {
            position: new Y(),
            direction: new Y(),
            color: new dt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new Y(), color: new dt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new Y(), skyColor: new dt(), groundColor: new dt() };
          break;
        case "RectAreaLight":
          t = {
            color: new dt(),
            position: new Y(),
            halfWidth: new Y(),
            halfHeight: new Y(),
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
function QF() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new je(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new je(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new je(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
let $F = 0;
function eN(r, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (r.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (r.map ? 1 : 0)
  );
}
function tN(r) {
  const e = new KF(),
    t = QF(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let d = 0; d < 9; d++) n.probe.push(new Y());
  const i = new Y(),
    s = new jt(),
    a = new jt();
  function l(d) {
    let p = 0,
      m = 0,
      y = 0;
    for (let L = 0; L < 9; L++) n.probe[L].set(0, 0, 0);
    let v = 0,
      A = 0,
      M = 0,
      w = 0,
      x = 0,
      C = 0,
      T = 0,
      I = 0,
      U = 0,
      F = 0,
      O = 0;
    d.sort(eN);
    for (let L = 0, N = d.length; L < N; L++) {
      const X = d[L],
        ie = X.color,
        re = X.intensity,
        me = X.distance,
        _e = X.shadow && X.shadow.map ? X.shadow.map.texture : null;
      if (X.isAmbientLight)
        (p += ie.r * re), (m += ie.g * re), (y += ie.b * re);
      else if (X.isLightProbe) {
        for (let ge = 0; ge < 9; ge++)
          n.probe[ge].addScaledVector(X.sh.coefficients[ge], re);
        O++;
      } else if (X.isDirectionalLight) {
        const ge = e.get(X);
        if (
          (ge.color.copy(X.color).multiplyScalar(X.intensity), X.castShadow)
        ) {
          const Re = X.shadow,
            J = t.get(X);
          (J.shadowIntensity = Re.intensity),
            (J.shadowBias = Re.bias),
            (J.shadowNormalBias = Re.normalBias),
            (J.shadowRadius = Re.radius),
            (J.shadowMapSize = Re.mapSize),
            (n.directionalShadow[v] = J),
            (n.directionalShadowMap[v] = _e),
            (n.directionalShadowMatrix[v] = X.shadow.matrix),
            C++;
        }
        (n.directional[v] = ge), v++;
      } else if (X.isSpotLight) {
        const ge = e.get(X);
        ge.position.setFromMatrixPosition(X.matrixWorld),
          ge.color.copy(ie).multiplyScalar(re),
          (ge.distance = me),
          (ge.coneCos = Math.cos(X.angle)),
          (ge.penumbraCos = Math.cos(X.angle * (1 - X.penumbra))),
          (ge.decay = X.decay),
          (n.spot[M] = ge);
        const Re = X.shadow;
        if (
          (X.map &&
            ((n.spotLightMap[U] = X.map),
            U++,
            Re.updateMatrices(X),
            X.castShadow && F++),
          (n.spotLightMatrix[M] = Re.matrix),
          X.castShadow)
        ) {
          const J = t.get(X);
          (J.shadowIntensity = Re.intensity),
            (J.shadowBias = Re.bias),
            (J.shadowNormalBias = Re.normalBias),
            (J.shadowRadius = Re.radius),
            (J.shadowMapSize = Re.mapSize),
            (n.spotShadow[M] = J),
            (n.spotShadowMap[M] = _e),
            I++;
        }
        M++;
      } else if (X.isRectAreaLight) {
        const ge = e.get(X);
        ge.color.copy(ie).multiplyScalar(re),
          ge.halfWidth.set(X.width * 0.5, 0, 0),
          ge.halfHeight.set(0, X.height * 0.5, 0),
          (n.rectArea[w] = ge),
          w++;
      } else if (X.isPointLight) {
        const ge = e.get(X);
        if (
          (ge.color.copy(X.color).multiplyScalar(X.intensity),
          (ge.distance = X.distance),
          (ge.decay = X.decay),
          X.castShadow)
        ) {
          const Re = X.shadow,
            J = t.get(X);
          (J.shadowIntensity = Re.intensity),
            (J.shadowBias = Re.bias),
            (J.shadowNormalBias = Re.normalBias),
            (J.shadowRadius = Re.radius),
            (J.shadowMapSize = Re.mapSize),
            (J.shadowCameraNear = Re.camera.near),
            (J.shadowCameraFar = Re.camera.far),
            (n.pointShadow[A] = J),
            (n.pointShadowMap[A] = _e),
            (n.pointShadowMatrix[A] = X.shadow.matrix),
            T++;
        }
        (n.point[A] = ge), A++;
      } else if (X.isHemisphereLight) {
        const ge = e.get(X);
        ge.skyColor.copy(X.color).multiplyScalar(re),
          ge.groundColor.copy(X.groundColor).multiplyScalar(re),
          (n.hemi[x] = ge),
          x++;
      }
    }
    w > 0 &&
      (r.has("OES_texture_float_linear") === !0
        ? ((n.rectAreaLTC1 = mt.LTC_FLOAT_1), (n.rectAreaLTC2 = mt.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = mt.LTC_HALF_1), (n.rectAreaLTC2 = mt.LTC_HALF_2))),
      (n.ambient[0] = p),
      (n.ambient[1] = m),
      (n.ambient[2] = y);
    const z = n.hash;
    (z.directionalLength !== v ||
      z.pointLength !== A ||
      z.spotLength !== M ||
      z.rectAreaLength !== w ||
      z.hemiLength !== x ||
      z.numDirectionalShadows !== C ||
      z.numPointShadows !== T ||
      z.numSpotShadows !== I ||
      z.numSpotMaps !== U ||
      z.numLightProbes !== O) &&
      ((n.directional.length = v),
      (n.spot.length = M),
      (n.rectArea.length = w),
      (n.point.length = A),
      (n.hemi.length = x),
      (n.directionalShadow.length = C),
      (n.directionalShadowMap.length = C),
      (n.pointShadow.length = T),
      (n.pointShadowMap.length = T),
      (n.spotShadow.length = I),
      (n.spotShadowMap.length = I),
      (n.directionalShadowMatrix.length = C),
      (n.pointShadowMatrix.length = T),
      (n.spotLightMatrix.length = I + U - F),
      (n.spotLightMap.length = U),
      (n.numSpotLightShadowsWithMaps = F),
      (n.numLightProbes = O),
      (z.directionalLength = v),
      (z.pointLength = A),
      (z.spotLength = M),
      (z.rectAreaLength = w),
      (z.hemiLength = x),
      (z.numDirectionalShadows = C),
      (z.numPointShadows = T),
      (z.numSpotShadows = I),
      (z.numSpotMaps = U),
      (z.numLightProbes = O),
      (n.version = $F++));
  }
  function c(d, p) {
    let m = 0,
      y = 0,
      v = 0,
      A = 0,
      M = 0;
    const w = p.matrixWorldInverse;
    for (let x = 0, C = d.length; x < C; x++) {
      const T = d[x];
      if (T.isDirectionalLight) {
        const I = n.directional[m];
        I.direction.setFromMatrixPosition(T.matrixWorld),
          i.setFromMatrixPosition(T.target.matrixWorld),
          I.direction.sub(i),
          I.direction.transformDirection(w),
          m++;
      } else if (T.isSpotLight) {
        const I = n.spot[v];
        I.position.setFromMatrixPosition(T.matrixWorld),
          I.position.applyMatrix4(w),
          I.direction.setFromMatrixPosition(T.matrixWorld),
          i.setFromMatrixPosition(T.target.matrixWorld),
          I.direction.sub(i),
          I.direction.transformDirection(w),
          v++;
      } else if (T.isRectAreaLight) {
        const I = n.rectArea[A];
        I.position.setFromMatrixPosition(T.matrixWorld),
          I.position.applyMatrix4(w),
          a.identity(),
          s.copy(T.matrixWorld),
          s.premultiply(w),
          a.extractRotation(s),
          I.halfWidth.set(T.width * 0.5, 0, 0),
          I.halfHeight.set(0, T.height * 0.5, 0),
          I.halfWidth.applyMatrix4(a),
          I.halfHeight.applyMatrix4(a),
          A++;
      } else if (T.isPointLight) {
        const I = n.point[y];
        I.position.setFromMatrixPosition(T.matrixWorld),
          I.position.applyMatrix4(w),
          y++;
      } else if (T.isHemisphereLight) {
        const I = n.hemi[M];
        I.direction.setFromMatrixPosition(T.matrixWorld),
          I.direction.transformDirection(w),
          M++;
      }
    }
  }
  return { setup: l, setupView: c, state: n };
}
function CA(r) {
  const e = new tN(r),
    t = [],
    n = [];
  function i(p) {
    (d.camera = p), (t.length = 0), (n.length = 0);
  }
  function s(p) {
    t.push(p);
  }
  function a(p) {
    n.push(p);
  }
  function l() {
    e.setup(t);
  }
  function c(p) {
    e.setupView(t, p);
  }
  const d = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: d,
    setupLights: l,
    setupLightsView: c,
    pushLight: s,
    pushShadow: a,
  };
}
function nN(r) {
  let e = new WeakMap();
  function t(i, s = 0) {
    const a = e.get(i);
    let l;
    return (
      a === void 0
        ? ((l = new CA(r)), e.set(i, [l]))
        : s >= a.length
          ? ((l = new CA(r)), a.push(l))
          : (l = a[s]),
      l
    );
  }
  function n() {
    e = new WeakMap();
  }
  return { get: t, dispose: n };
}
const rN = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  iN = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function sN(r, e, t) {
  let n = new rm();
  const i = new je(),
    s = new je(),
    a = new Cn(),
    l = new K3({ depthPacking: R5 }),
    c = new Q3(),
    d = {},
    p = t.maxTextureSize,
    m = { [ro]: Ji, [Ji]: ro, [Xs]: Xs },
    y = new fs({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new je() },
        radius: { value: 4 },
      },
      vertexShader: rN,
      fragmentShader: iN,
    }),
    v = y.clone();
  v.defines.HORIZONTAL_PASS = 1;
  const A = new tn();
  A.setAttribute(
    "position",
    new Tn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  );
  const M = new nr(A, y),
    w = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Sg);
  let x = this.type;
  this.render = function (F, O, z) {
    if (
      w.enabled === !1 ||
      (w.autoUpdate === !1 && w.needsUpdate === !1) ||
      F.length === 0
    )
      return;
    const L = r.getRenderTarget(),
      N = r.getActiveCubeFace(),
      X = r.getActiveMipmapLevel(),
      ie = r.state;
    ie.setBlending(eo),
      ie.buffers.color.setClear(1, 1, 1, 1),
      ie.buffers.depth.setTest(!0),
      ie.setScissorTest(!1);
    const re = x !== _a && this.type === _a,
      me = x === _a && this.type !== _a;
    for (let _e = 0, ge = F.length; _e < ge; _e++) {
      const Re = F[_e],
        J = Re.shadow;
      if (J === void 0) {
        console.warn("THREE.WebGLShadowMap:", Re, "has no shadow.");
        continue;
      }
      if (J.autoUpdate === !1 && J.needsUpdate === !1) continue;
      i.copy(J.mapSize);
      const oe = J.getFrameExtents();
      if (
        (i.multiply(oe),
        s.copy(J.mapSize),
        (i.x > p || i.y > p) &&
          (i.x > p &&
            ((s.x = Math.floor(p / oe.x)),
            (i.x = s.x * oe.x),
            (J.mapSize.x = s.x)),
          i.y > p &&
            ((s.y = Math.floor(p / oe.y)),
            (i.y = s.y * oe.y),
            (J.mapSize.y = s.y))),
        J.map === null || re === !0 || me === !0)
      ) {
        const q = this.type !== _a ? { minFilter: Qr, magFilter: Qr } : {};
        J.map !== null && J.map.dispose(),
          (J.map = new Es(i.x, i.y, q)),
          (J.map.texture.name = Re.name + ".shadowMap"),
          J.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(J.map), r.clear();
      const ae = J.getViewportCount();
      for (let q = 0; q < ae; q++) {
        const ce = J.getViewport(q);
        a.set(s.x * ce.x, s.y * ce.y, s.x * ce.z, s.y * ce.w),
          ie.viewport(a),
          J.updateMatrices(Re, q),
          (n = J.getFrustum()),
          I(O, z, J.camera, Re, this.type);
      }
      J.isPointLightShadow !== !0 && this.type === _a && C(J, z),
        (J.needsUpdate = !1);
    }
    (x = this.type), (w.needsUpdate = !1), r.setRenderTarget(L, N, X);
  };
  function C(F, O) {
    const z = e.update(M);
    y.defines.VSM_SAMPLES !== F.blurSamples &&
      ((y.defines.VSM_SAMPLES = F.blurSamples),
      (v.defines.VSM_SAMPLES = F.blurSamples),
      (y.needsUpdate = !0),
      (v.needsUpdate = !0)),
      F.mapPass === null && (F.mapPass = new Es(i.x, i.y)),
      (y.uniforms.shadow_pass.value = F.map.texture),
      (y.uniforms.resolution.value = F.mapSize),
      (y.uniforms.radius.value = F.radius),
      r.setRenderTarget(F.mapPass),
      r.clear(),
      r.renderBufferDirect(O, null, z, y, M, null),
      (v.uniforms.shadow_pass.value = F.mapPass.texture),
      (v.uniforms.resolution.value = F.mapSize),
      (v.uniforms.radius.value = F.radius),
      r.setRenderTarget(F.map),
      r.clear(),
      r.renderBufferDirect(O, null, z, v, M, null);
  }
  function T(F, O, z, L) {
    let N = null;
    const X =
      z.isPointLight === !0 ? F.customDistanceMaterial : F.customDepthMaterial;
    if (X !== void 0) N = X;
    else if (
      ((N = z.isPointLight === !0 ? c : l),
      (r.localClippingEnabled &&
        O.clipShadows === !0 &&
        Array.isArray(O.clippingPlanes) &&
        O.clippingPlanes.length !== 0) ||
        (O.displacementMap && O.displacementScale !== 0) ||
        (O.alphaMap && O.alphaTest > 0) ||
        (O.map && O.alphaTest > 0))
    ) {
      const ie = N.uuid,
        re = O.uuid;
      let me = d[ie];
      me === void 0 && ((me = {}), (d[ie] = me));
      let _e = me[re];
      _e === void 0 &&
        ((_e = N.clone()), (me[re] = _e), O.addEventListener("dispose", U)),
        (N = _e);
    }
    if (
      ((N.visible = O.visible),
      (N.wireframe = O.wireframe),
      L === _a
        ? (N.side = O.shadowSide !== null ? O.shadowSide : O.side)
        : (N.side = O.shadowSide !== null ? O.shadowSide : m[O.side]),
      (N.alphaMap = O.alphaMap),
      (N.alphaTest = O.alphaTest),
      (N.map = O.map),
      (N.clipShadows = O.clipShadows),
      (N.clippingPlanes = O.clippingPlanes),
      (N.clipIntersection = O.clipIntersection),
      (N.displacementMap = O.displacementMap),
      (N.displacementScale = O.displacementScale),
      (N.displacementBias = O.displacementBias),
      (N.wireframeLinewidth = O.wireframeLinewidth),
      (N.linewidth = O.linewidth),
      z.isPointLight === !0 && N.isMeshDistanceMaterial === !0)
    ) {
      const ie = r.properties.get(N);
      ie.light = z;
    }
    return N;
  }
  function I(F, O, z, L, N) {
    if (F.visible === !1) return;
    if (
      F.layers.test(O.layers) &&
      (F.isMesh || F.isLine || F.isPoints) &&
      (F.castShadow || (F.receiveShadow && N === _a)) &&
      (!F.frustumCulled || n.intersectsObject(F))
    ) {
      F.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, F.matrixWorld);
      const ie = e.update(F),
        re = F.material;
      if (Array.isArray(re)) {
        const me = ie.groups;
        for (let _e = 0, ge = me.length; _e < ge; _e++) {
          const Re = me[_e],
            J = re[Re.materialIndex];
          if (J && J.visible) {
            const oe = T(F, J, L, N);
            F.onBeforeShadow(r, F, O, z, ie, oe, Re),
              r.renderBufferDirect(z, null, ie, oe, F, Re),
              F.onAfterShadow(r, F, O, z, ie, oe, Re);
          }
        }
      } else if (re.visible) {
        const me = T(F, re, L, N);
        F.onBeforeShadow(r, F, O, z, ie, me, null),
          r.renderBufferDirect(z, null, ie, me, F, null),
          F.onAfterShadow(r, F, O, z, ie, me, null);
      }
    }
    const X = F.children;
    for (let ie = 0, re = X.length; ie < re; ie++) I(X[ie], O, z, L, N);
  }
  function U(F) {
    F.target.removeEventListener("dispose", U);
    for (const O in d) {
      const z = d[O],
        L = F.target.uuid;
      L in z && (z[L].dispose(), delete z[L]);
    }
  }
}
const aN = {
  [I0]: B0,
  [P0]: F0,
  [L0]: N0,
  [Pc]: D0,
  [B0]: I0,
  [F0]: P0,
  [N0]: L0,
  [D0]: Pc,
};
function oN(r, e) {
  function t() {
    let k = !1;
    const ne = new Cn();
    let Q = null;
    const te = new Cn(0, 0, 0, 0);
    return {
      setMask: function (Ae) {
        Q !== Ae && !k && (r.colorMask(Ae, Ae, Ae, Ae), (Q = Ae));
      },
      setLocked: function (Ae) {
        k = Ae;
      },
      setClear: function (Ae, pe, Ve, He, Qe) {
        Qe === !0 && ((Ae *= He), (pe *= He), (Ve *= He)),
          ne.set(Ae, pe, Ve, He),
          te.equals(ne) === !1 && (r.clearColor(Ae, pe, Ve, He), te.copy(ne));
      },
      reset: function () {
        (k = !1), (Q = null), te.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let k = !1,
      ne = !1,
      Q = null,
      te = null,
      Ae = null;
    return {
      setReversed: function (pe) {
        if (ne !== pe) {
          const Ve = e.get("EXT_clip_control");
          ne
            ? Ve.clipControlEXT(Ve.LOWER_LEFT_EXT, Ve.ZERO_TO_ONE_EXT)
            : Ve.clipControlEXT(Ve.LOWER_LEFT_EXT, Ve.NEGATIVE_ONE_TO_ONE_EXT);
          const He = Ae;
          (Ae = null), this.setClear(He);
        }
        ne = pe;
      },
      getReversed: function () {
        return ne;
      },
      setTest: function (pe) {
        pe ? Fe(r.DEPTH_TEST) : Je(r.DEPTH_TEST);
      },
      setMask: function (pe) {
        Q !== pe && !k && (r.depthMask(pe), (Q = pe));
      },
      setFunc: function (pe) {
        if ((ne && (pe = aN[pe]), te !== pe)) {
          switch (pe) {
            case I0:
              r.depthFunc(r.NEVER);
              break;
            case B0:
              r.depthFunc(r.ALWAYS);
              break;
            case P0:
              r.depthFunc(r.LESS);
              break;
            case Pc:
              r.depthFunc(r.LEQUAL);
              break;
            case L0:
              r.depthFunc(r.EQUAL);
              break;
            case D0:
              r.depthFunc(r.GEQUAL);
              break;
            case F0:
              r.depthFunc(r.GREATER);
              break;
            case N0:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          te = pe;
        }
      },
      setLocked: function (pe) {
        k = pe;
      },
      setClear: function (pe) {
        Ae !== pe && (ne && (pe = 1 - pe), r.clearDepth(pe), (Ae = pe));
      },
      reset: function () {
        (k = !1), (Q = null), (te = null), (Ae = null), (ne = !1);
      },
    };
  }
  function i() {
    let k = !1,
      ne = null,
      Q = null,
      te = null,
      Ae = null,
      pe = null,
      Ve = null,
      He = null,
      Qe = null;
    return {
      setTest: function (ke) {
        k || (ke ? Fe(r.STENCIL_TEST) : Je(r.STENCIL_TEST));
      },
      setMask: function (ke) {
        ne !== ke && !k && (r.stencilMask(ke), (ne = ke));
      },
      setFunc: function (ke, nn, vt) {
        (Q !== ke || te !== nn || Ae !== vt) &&
          (r.stencilFunc(ke, nn, vt), (Q = ke), (te = nn), (Ae = vt));
      },
      setOp: function (ke, nn, vt) {
        (pe !== ke || Ve !== nn || He !== vt) &&
          (r.stencilOp(ke, nn, vt), (pe = ke), (Ve = nn), (He = vt));
      },
      setLocked: function (ke) {
        k = ke;
      },
      setClear: function (ke) {
        Qe !== ke && (r.clearStencil(ke), (Qe = ke));
      },
      reset: function () {
        (k = !1),
          (ne = null),
          (Q = null),
          (te = null),
          (Ae = null),
          (pe = null),
          (Ve = null),
          (He = null),
          (Qe = null);
      },
    };
  }
  const s = new t(),
    a = new n(),
    l = new i(),
    c = new WeakMap(),
    d = new WeakMap();
  let p = {},
    m = {},
    y = new WeakMap(),
    v = [],
    A = null,
    M = !1,
    w = null,
    x = null,
    C = null,
    T = null,
    I = null,
    U = null,
    F = null,
    O = new dt(0, 0, 0),
    z = 0,
    L = !1,
    N = null,
    X = null,
    ie = null,
    re = null,
    me = null;
  const _e = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let ge = !1,
    Re = 0;
  const J = r.getParameter(r.VERSION);
  J.indexOf("WebGL") !== -1
    ? ((Re = parseFloat(/^WebGL (\d)/.exec(J)[1])), (ge = Re >= 1))
    : J.indexOf("OpenGL ES") !== -1 &&
      ((Re = parseFloat(/^OpenGL ES (\d)/.exec(J)[1])), (ge = Re >= 2));
  let oe = null,
    ae = {};
  const q = r.getParameter(r.SCISSOR_BOX),
    ce = r.getParameter(r.VIEWPORT),
    Xe = new Cn().fromArray(q),
    ye = new Cn().fromArray(ce);
  function Pe(k, ne, Q, te) {
    const Ae = new Uint8Array(4),
      pe = r.createTexture();
    r.bindTexture(k, pe),
      r.texParameteri(k, r.TEXTURE_MIN_FILTER, r.NEAREST),
      r.texParameteri(k, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let Ve = 0; Ve < Q; Ve++)
      k === r.TEXTURE_3D || k === r.TEXTURE_2D_ARRAY
        ? r.texImage3D(ne, 0, r.RGBA, 1, 1, te, 0, r.RGBA, r.UNSIGNED_BYTE, Ae)
        : r.texImage2D(
            ne + Ve,
            0,
            r.RGBA,
            1,
            1,
            0,
            r.RGBA,
            r.UNSIGNED_BYTE,
            Ae,
          );
    return pe;
  }
  const Ue = {};
  (Ue[r.TEXTURE_2D] = Pe(r.TEXTURE_2D, r.TEXTURE_2D, 1)),
    (Ue[r.TEXTURE_CUBE_MAP] = Pe(
      r.TEXTURE_CUBE_MAP,
      r.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    (Ue[r.TEXTURE_2D_ARRAY] = Pe(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1)),
    (Ue[r.TEXTURE_3D] = Pe(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    a.setClear(1),
    l.setClear(0),
    Fe(r.DEPTH_TEST),
    a.setFunc(Pc),
    ct(!1),
    Be(yv),
    Fe(r.CULL_FACE),
    K(eo);
  function Fe(k) {
    p[k] !== !0 && (r.enable(k), (p[k] = !0));
  }
  function Je(k) {
    p[k] !== !1 && (r.disable(k), (p[k] = !1));
  }
  function et(k, ne) {
    return m[k] !== ne
      ? (r.bindFramebuffer(k, ne),
        (m[k] = ne),
        k === r.DRAW_FRAMEBUFFER && (m[r.FRAMEBUFFER] = ne),
        k === r.FRAMEBUFFER && (m[r.DRAW_FRAMEBUFFER] = ne),
        !0)
      : !1;
  }
  function tt(k, ne) {
    let Q = v,
      te = !1;
    if (k) {
      (Q = y.get(ne)), Q === void 0 && ((Q = []), y.set(ne, Q));
      const Ae = k.textures;
      if (Q.length !== Ae.length || Q[0] !== r.COLOR_ATTACHMENT0) {
        for (let pe = 0, Ve = Ae.length; pe < Ve; pe++)
          Q[pe] = r.COLOR_ATTACHMENT0 + pe;
        (Q.length = Ae.length), (te = !0);
      }
    } else Q[0] !== r.BACK && ((Q[0] = r.BACK), (te = !0));
    te && r.drawBuffers(Q);
  }
  function be(k) {
    return A !== k ? (r.useProgram(k), (A = k), !0) : !1;
  }
  const Te = {
    [Hl]: r.FUNC_ADD,
    [QM]: r.FUNC_SUBTRACT,
    [$M]: r.FUNC_REVERSE_SUBTRACT,
  };
  (Te[e5] = r.MIN), (Te[t5] = r.MAX);
  const Ne = {
    [n5]: r.ZERO,
    [r5]: r.ONE,
    [i5]: r.SRC_COLOR,
    [T0]: r.SRC_ALPHA,
    [c5]: r.SRC_ALPHA_SATURATE,
    [l5]: r.DST_COLOR,
    [a5]: r.DST_ALPHA,
    [s5]: r.ONE_MINUS_SRC_COLOR,
    [R0]: r.ONE_MINUS_SRC_ALPHA,
    [u5]: r.ONE_MINUS_DST_COLOR,
    [o5]: r.ONE_MINUS_DST_ALPHA,
    [d5]: r.CONSTANT_COLOR,
    [h5]: r.ONE_MINUS_CONSTANT_COLOR,
    [f5]: r.CONSTANT_ALPHA,
    [p5]: r.ONE_MINUS_CONSTANT_ALPHA,
  };
  function K(k, ne, Q, te, Ae, pe, Ve, He, Qe, ke) {
    if (k === eo) {
      M === !0 && (Je(r.BLEND), (M = !1));
      return;
    }
    if ((M === !1 && (Fe(r.BLEND), (M = !0)), k !== KM)) {
      if (k !== w || ke !== L) {
        if (
          ((x !== Hl || I !== Hl) &&
            (r.blendEquation(r.FUNC_ADD), (x = Hl), (I = Hl)),
          ke)
        )
          switch (k) {
            case Sc:
              r.blendFuncSeparate(
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case vv:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case xv:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case bv:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
        else
          switch (k) {
            case Sc:
              r.blendFuncSeparate(
                r.SRC_ALPHA,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case vv:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case xv:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case bv:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
        (C = null),
          (T = null),
          (U = null),
          (F = null),
          O.set(0, 0, 0),
          (z = 0),
          (w = k),
          (L = ke);
      }
      return;
    }
    (Ae = Ae || ne),
      (pe = pe || Q),
      (Ve = Ve || te),
      (ne !== x || Ae !== I) &&
        (r.blendEquationSeparate(Te[ne], Te[Ae]), (x = ne), (I = Ae)),
      (Q !== C || te !== T || pe !== U || Ve !== F) &&
        (r.blendFuncSeparate(Ne[Q], Ne[te], Ne[pe], Ne[Ve]),
        (C = Q),
        (T = te),
        (U = pe),
        (F = Ve)),
      (He.equals(O) === !1 || Qe !== z) &&
        (r.blendColor(He.r, He.g, He.b, Qe), O.copy(He), (z = Qe)),
      (w = k),
      (L = !1);
  }
  function qe(k, ne) {
    k.side === Xs ? Je(r.CULL_FACE) : Fe(r.CULL_FACE);
    let Q = k.side === Ji;
    ne && (Q = !Q),
      ct(Q),
      k.blending === Sc && k.transparent === !1
        ? K(eo)
        : K(
            k.blending,
            k.blendEquation,
            k.blendSrc,
            k.blendDst,
            k.blendEquationAlpha,
            k.blendSrcAlpha,
            k.blendDstAlpha,
            k.blendColor,
            k.blendAlpha,
            k.premultipliedAlpha,
          ),
      a.setFunc(k.depthFunc),
      a.setTest(k.depthTest),
      a.setMask(k.depthWrite),
      s.setMask(k.colorWrite);
    const te = k.stencilWrite;
    l.setTest(te),
      te &&
        (l.setMask(k.stencilWriteMask),
        l.setFunc(k.stencilFunc, k.stencilRef, k.stencilFuncMask),
        l.setOp(k.stencilFail, k.stencilZFail, k.stencilZPass)),
      Dt(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits),
      k.alphaToCoverage === !0
        ? Fe(r.SAMPLE_ALPHA_TO_COVERAGE)
        : Je(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ct(k) {
    N !== k && (k ? r.frontFace(r.CW) : r.frontFace(r.CCW), (N = k));
  }
  function Be(k) {
    k !== YM
      ? (Fe(r.CULL_FACE),
        k !== X &&
          (k === yv
            ? r.cullFace(r.BACK)
            : k === ZM
              ? r.cullFace(r.FRONT)
              : r.cullFace(r.FRONT_AND_BACK)))
      : Je(r.CULL_FACE),
      (X = k);
  }
  function nt(k) {
    k !== ie && (ge && r.lineWidth(k), (ie = k));
  }
  function Dt(k, ne, Q) {
    k
      ? (Fe(r.POLYGON_OFFSET_FILL),
        (re !== ne || me !== Q) &&
          (r.polygonOffset(ne, Q), (re = ne), (me = Q)))
      : Je(r.POLYGON_OFFSET_FILL);
  }
  function it(k) {
    k ? Fe(r.SCISSOR_TEST) : Je(r.SCISSOR_TEST);
  }
  function Z(k) {
    k === void 0 && (k = r.TEXTURE0 + _e - 1),
      oe !== k && (r.activeTexture(k), (oe = k));
  }
  function G(k, ne, Q) {
    Q === void 0 && (oe === null ? (Q = r.TEXTURE0 + _e - 1) : (Q = oe));
    let te = ae[Q];
    te === void 0 && ((te = { type: void 0, texture: void 0 }), (ae[Q] = te)),
      (te.type !== k || te.texture !== ne) &&
        (oe !== Q && (r.activeTexture(Q), (oe = Q)),
        r.bindTexture(k, ne || Ue[k]),
        (te.type = k),
        (te.texture = ne));
  }
  function xe() {
    const k = ae[oe];
    k !== void 0 &&
      k.type !== void 0 &&
      (r.bindTexture(k.type, null), (k.type = void 0), (k.texture = void 0));
  }
  function ze() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function We() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Oe() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Mt() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function ot() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function ft() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Ot() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Ke() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function ht() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Tt() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function st(k) {
    Xe.equals(k) === !1 && (r.scissor(k.x, k.y, k.z, k.w), Xe.copy(k));
  }
  function xt(k) {
    ye.equals(k) === !1 && (r.viewport(k.x, k.y, k.z, k.w), ye.copy(k));
  }
  function Qt(k, ne) {
    let Q = d.get(ne);
    Q === void 0 && ((Q = new WeakMap()), d.set(ne, Q));
    let te = Q.get(k);
    te === void 0 && ((te = r.getUniformBlockIndex(ne, k.name)), Q.set(k, te));
  }
  function D(k, ne) {
    const Q = d.get(ne).get(k);
    c.get(ne) !== Q &&
      (r.uniformBlockBinding(ne, Q, k.__bindingPointIndex), c.set(ne, Q));
  }
  function W() {
    r.disable(r.BLEND),
      r.disable(r.CULL_FACE),
      r.disable(r.DEPTH_TEST),
      r.disable(r.POLYGON_OFFSET_FILL),
      r.disable(r.SCISSOR_TEST),
      r.disable(r.STENCIL_TEST),
      r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
      r.blendEquation(r.FUNC_ADD),
      r.blendFunc(r.ONE, r.ZERO),
      r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
      r.blendColor(0, 0, 0, 0),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(r.LESS),
      a.setReversed(!1),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(r.ALWAYS, 0, 4294967295),
      r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
      r.clearStencil(0),
      r.cullFace(r.BACK),
      r.frontFace(r.CCW),
      r.polygonOffset(0, 0),
      r.activeTexture(r.TEXTURE0),
      r.bindFramebuffer(r.FRAMEBUFFER, null),
      r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
      r.bindFramebuffer(r.READ_FRAMEBUFFER, null),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (p = {}),
      (oe = null),
      (ae = {}),
      (m = {}),
      (y = new WeakMap()),
      (v = []),
      (A = null),
      (M = !1),
      (w = null),
      (x = null),
      (C = null),
      (T = null),
      (I = null),
      (U = null),
      (F = null),
      (O = new dt(0, 0, 0)),
      (z = 0),
      (L = !1),
      (N = null),
      (X = null),
      (ie = null),
      (re = null),
      (me = null),
      Xe.set(0, 0, r.canvas.width, r.canvas.height),
      ye.set(0, 0, r.canvas.width, r.canvas.height),
      s.reset(),
      a.reset(),
      l.reset();
  }
  return {
    buffers: { color: s, depth: a, stencil: l },
    enable: Fe,
    disable: Je,
    bindFramebuffer: et,
    drawBuffers: tt,
    useProgram: be,
    setBlending: K,
    setMaterial: qe,
    setFlipSided: ct,
    setCullFace: Be,
    setLineWidth: nt,
    setPolygonOffset: Dt,
    setScissorTest: it,
    activeTexture: Z,
    bindTexture: G,
    unbindTexture: xe,
    compressedTexImage2D: ze,
    compressedTexImage3D: We,
    texImage2D: ht,
    texImage3D: Tt,
    updateUBOMapping: Qt,
    uniformBlockBinding: D,
    texStorage2D: Ot,
    texStorage3D: Ke,
    texSubImage2D: Oe,
    texSubImage3D: Mt,
    compressedTexSubImage2D: ot,
    compressedTexSubImage3D: ft,
    scissor: st,
    viewport: xt,
    reset: W,
  };
}
function lN(r, e, t, n, i, s, a) {
  const l = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    c =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    d = new je(),
    p = new WeakMap();
  let m;
  const y = new WeakMap();
  let v = !1;
  try {
    v =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function A(Z, G) {
    return v ? new OffscreenCanvas(Z, G) : Ip("canvas");
  }
  function M(Z, G, xe) {
    let ze = 1;
    const We = it(Z);
    if (
      ((We.width > xe || We.height > xe) &&
        (ze = xe / Math.max(We.width, We.height)),
      ze < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && Z instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && Z instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && Z instanceof VideoFrame)
      ) {
        const Oe = Math.floor(ze * We.width),
          Mt = Math.floor(ze * We.height);
        m === void 0 && (m = A(Oe, Mt));
        const ot = G ? A(Oe, Mt) : m;
        return (
          (ot.width = Oe),
          (ot.height = Mt),
          ot.getContext("2d").drawImage(Z, 0, 0, Oe, Mt),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              We.width +
              "x" +
              We.height +
              ") to (" +
              Oe +
              "x" +
              Mt +
              ").",
          ),
          ot
        );
      } else
        return (
          "data" in Z &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                We.width +
                "x" +
                We.height +
                ").",
            ),
          Z
        );
    return Z;
  }
  function w(Z) {
    return Z.generateMipmaps;
  }
  function x(Z) {
    r.generateMipmap(Z);
  }
  function C(Z) {
    return Z.isWebGLCubeRenderTarget
      ? r.TEXTURE_CUBE_MAP
      : Z.isWebGL3DRenderTarget
        ? r.TEXTURE_3D
        : Z.isWebGLArrayRenderTarget || Z.isCompressedArrayTexture
          ? r.TEXTURE_2D_ARRAY
          : r.TEXTURE_2D;
  }
  function T(Z, G, xe, ze, We = !1) {
    if (Z !== null) {
      if (r[Z] !== void 0) return r[Z];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          Z +
          "'",
      );
    }
    let Oe = G;
    if (
      (G === r.RED &&
        (xe === r.FLOAT && (Oe = r.R32F),
        xe === r.HALF_FLOAT && (Oe = r.R16F),
        xe === r.UNSIGNED_BYTE && (Oe = r.R8)),
      G === r.RED_INTEGER &&
        (xe === r.UNSIGNED_BYTE && (Oe = r.R8UI),
        xe === r.UNSIGNED_SHORT && (Oe = r.R16UI),
        xe === r.UNSIGNED_INT && (Oe = r.R32UI),
        xe === r.BYTE && (Oe = r.R8I),
        xe === r.SHORT && (Oe = r.R16I),
        xe === r.INT && (Oe = r.R32I)),
      G === r.RG &&
        (xe === r.FLOAT && (Oe = r.RG32F),
        xe === r.HALF_FLOAT && (Oe = r.RG16F),
        xe === r.UNSIGNED_BYTE && (Oe = r.RG8)),
      G === r.RG_INTEGER &&
        (xe === r.UNSIGNED_BYTE && (Oe = r.RG8UI),
        xe === r.UNSIGNED_SHORT && (Oe = r.RG16UI),
        xe === r.UNSIGNED_INT && (Oe = r.RG32UI),
        xe === r.BYTE && (Oe = r.RG8I),
        xe === r.SHORT && (Oe = r.RG16I),
        xe === r.INT && (Oe = r.RG32I)),
      G === r.RGB_INTEGER &&
        (xe === r.UNSIGNED_BYTE && (Oe = r.RGB8UI),
        xe === r.UNSIGNED_SHORT && (Oe = r.RGB16UI),
        xe === r.UNSIGNED_INT && (Oe = r.RGB32UI),
        xe === r.BYTE && (Oe = r.RGB8I),
        xe === r.SHORT && (Oe = r.RGB16I),
        xe === r.INT && (Oe = r.RGB32I)),
      G === r.RGBA_INTEGER &&
        (xe === r.UNSIGNED_BYTE && (Oe = r.RGBA8UI),
        xe === r.UNSIGNED_SHORT && (Oe = r.RGBA16UI),
        xe === r.UNSIGNED_INT && (Oe = r.RGBA32UI),
        xe === r.BYTE && (Oe = r.RGBA8I),
        xe === r.SHORT && (Oe = r.RGBA16I),
        xe === r.INT && (Oe = r.RGBA32I)),
      G === r.RGB && xe === r.UNSIGNED_INT_5_9_9_9_REV && (Oe = r.RGB9_E5),
      G === r.RGBA)
    ) {
      const Mt = We ? Cp : Sn.getTransfer(ze);
      xe === r.FLOAT && (Oe = r.RGBA32F),
        xe === r.HALF_FLOAT && (Oe = r.RGBA16F),
        xe === r.UNSIGNED_BYTE && (Oe = Mt === Hn ? r.SRGB8_ALPHA8 : r.RGBA8),
        xe === r.UNSIGNED_SHORT_4_4_4_4 && (Oe = r.RGBA4),
        xe === r.UNSIGNED_SHORT_5_5_5_1 && (Oe = r.RGB5_A1);
    }
    return (
      (Oe === r.R16F ||
        Oe === r.R32F ||
        Oe === r.RG16F ||
        Oe === r.RG32F ||
        Oe === r.RGBA16F ||
        Oe === r.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Oe
    );
  }
  function I(Z, G) {
    let xe;
    return (
      Z
        ? G === null || G === so || G === Lc
          ? (xe = r.DEPTH24_STENCIL8)
          : G === or
            ? (xe = r.DEPTH32F_STENCIL8)
            : G === ph &&
              ((xe = r.DEPTH24_STENCIL8),
              console.warn(
                "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.",
              ))
        : G === null || G === so || G === Lc
          ? (xe = r.DEPTH_COMPONENT24)
          : G === or
            ? (xe = r.DEPTH_COMPONENT32F)
            : G === ph && (xe = r.DEPTH_COMPONENT16),
      xe
    );
  }
  function U(Z, G) {
    return w(Z) === !0 ||
      (Z.isFramebufferTexture && Z.minFilter !== Qr && Z.minFilter !== Un)
      ? Math.log2(Math.max(G.width, G.height)) + 1
      : Z.mipmaps !== void 0 && Z.mipmaps.length > 0
        ? Z.mipmaps.length
        : Z.isCompressedTexture && Array.isArray(Z.image)
          ? G.mipmaps.length
          : 1;
  }
  function F(Z) {
    const G = Z.target;
    G.removeEventListener("dispose", F), z(G), G.isVideoTexture && p.delete(G);
  }
  function O(Z) {
    const G = Z.target;
    G.removeEventListener("dispose", O), N(G);
  }
  function z(Z) {
    const G = n.get(Z);
    if (G.__webglInit === void 0) return;
    const xe = Z.source,
      ze = y.get(xe);
    if (ze) {
      const We = ze[G.__cacheKey];
      We.usedTimes--,
        We.usedTimes === 0 && L(Z),
        Object.keys(ze).length === 0 && y.delete(xe);
    }
    n.remove(Z);
  }
  function L(Z) {
    const G = n.get(Z);
    r.deleteTexture(G.__webglTexture);
    const xe = Z.source,
      ze = y.get(xe);
    delete ze[G.__cacheKey], a.memory.textures--;
  }
  function N(Z) {
    const G = n.get(Z);
    if (
      (Z.depthTexture && (Z.depthTexture.dispose(), n.remove(Z.depthTexture)),
      Z.isWebGLCubeRenderTarget)
    )
      for (let ze = 0; ze < 6; ze++) {
        if (Array.isArray(G.__webglFramebuffer[ze]))
          for (let We = 0; We < G.__webglFramebuffer[ze].length; We++)
            r.deleteFramebuffer(G.__webglFramebuffer[ze][We]);
        else r.deleteFramebuffer(G.__webglFramebuffer[ze]);
        G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer[ze]);
      }
    else {
      if (Array.isArray(G.__webglFramebuffer))
        for (let ze = 0; ze < G.__webglFramebuffer.length; ze++)
          r.deleteFramebuffer(G.__webglFramebuffer[ze]);
      else r.deleteFramebuffer(G.__webglFramebuffer);
      if (
        (G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer),
        G.__webglMultisampledFramebuffer &&
          r.deleteFramebuffer(G.__webglMultisampledFramebuffer),
        G.__webglColorRenderbuffer)
      )
        for (let ze = 0; ze < G.__webglColorRenderbuffer.length; ze++)
          G.__webglColorRenderbuffer[ze] &&
            r.deleteRenderbuffer(G.__webglColorRenderbuffer[ze]);
      G.__webglDepthRenderbuffer &&
        r.deleteRenderbuffer(G.__webglDepthRenderbuffer);
    }
    const xe = Z.textures;
    for (let ze = 0, We = xe.length; ze < We; ze++) {
      const Oe = n.get(xe[ze]);
      Oe.__webglTexture &&
        (r.deleteTexture(Oe.__webglTexture), a.memory.textures--),
        n.remove(xe[ze]);
    }
    n.remove(Z);
  }
  let X = 0;
  function ie() {
    X = 0;
  }
  function re() {
    const Z = X;
    return (
      Z >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            Z +
            " texture units while this GPU supports only " +
            i.maxTextures,
        ),
      (X += 1),
      Z
    );
  }
  function me(Z) {
    const G = [];
    return (
      G.push(Z.wrapS),
      G.push(Z.wrapT),
      G.push(Z.wrapR || 0),
      G.push(Z.magFilter),
      G.push(Z.minFilter),
      G.push(Z.anisotropy),
      G.push(Z.internalFormat),
      G.push(Z.format),
      G.push(Z.type),
      G.push(Z.generateMipmaps),
      G.push(Z.premultiplyAlpha),
      G.push(Z.flipY),
      G.push(Z.unpackAlignment),
      G.push(Z.colorSpace),
      G.join()
    );
  }
  function _e(Z, G) {
    const xe = n.get(Z);
    if (
      (Z.isVideoTexture && nt(Z),
      Z.isRenderTargetTexture === !1 &&
        Z.version > 0 &&
        xe.__version !== Z.version)
    ) {
      const ze = Z.image;
      if (ze === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found.",
        );
      else if (ze.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
        );
      else {
        ye(xe, Z, G);
        return;
      }
    }
    t.bindTexture(r.TEXTURE_2D, xe.__webglTexture, r.TEXTURE0 + G);
  }
  function ge(Z, G) {
    const xe = n.get(Z);
    if (Z.version > 0 && xe.__version !== Z.version) {
      ye(xe, Z, G);
      return;
    }
    t.bindTexture(r.TEXTURE_2D_ARRAY, xe.__webglTexture, r.TEXTURE0 + G);
  }
  function Re(Z, G) {
    const xe = n.get(Z);
    if (Z.version > 0 && xe.__version !== Z.version) {
      ye(xe, Z, G);
      return;
    }
    t.bindTexture(r.TEXTURE_3D, xe.__webglTexture, r.TEXTURE0 + G);
  }
  function J(Z, G) {
    const xe = n.get(Z);
    if (Z.version > 0 && xe.__version !== Z.version) {
      Pe(xe, Z, G);
      return;
    }
    t.bindTexture(r.TEXTURE_CUBE_MAP, xe.__webglTexture, r.TEXTURE0 + G);
  }
  const oe = { [Xl]: r.REPEAT, [Ar]: r.CLAMP_TO_EDGE, [fh]: r.MIRRORED_REPEAT },
    ae = {
      [Qr]: r.NEAREST,
      [Cg]: r.NEAREST_MIPMAP_NEAREST,
      [gc]: r.NEAREST_MIPMAP_LINEAR,
      [Un]: r.LINEAR,
      [ah]: r.LINEAR_MIPMAP_NEAREST,
      [Ys]: r.LINEAR_MIPMAP_LINEAR,
    },
    q = {
      [B5]: r.NEVER,
      [U5]: r.ALWAYS,
      [P5]: r.LESS,
      [L3]: r.LEQUAL,
      [L5]: r.EQUAL,
      [N5]: r.GEQUAL,
      [D5]: r.GREATER,
      [F5]: r.NOTEQUAL,
    };
  function ce(Z, G) {
    if (
      (G.type === or &&
        e.has("OES_texture_float_linear") === !1 &&
        (G.magFilter === Un ||
          G.magFilter === ah ||
          G.magFilter === gc ||
          G.magFilter === Ys ||
          G.minFilter === Un ||
          G.minFilter === ah ||
          G.minFilter === gc ||
          G.minFilter === Ys) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.",
        ),
      r.texParameteri(Z, r.TEXTURE_WRAP_S, oe[G.wrapS]),
      r.texParameteri(Z, r.TEXTURE_WRAP_T, oe[G.wrapT]),
      (Z === r.TEXTURE_3D || Z === r.TEXTURE_2D_ARRAY) &&
        r.texParameteri(Z, r.TEXTURE_WRAP_R, oe[G.wrapR]),
      r.texParameteri(Z, r.TEXTURE_MAG_FILTER, ae[G.magFilter]),
      r.texParameteri(Z, r.TEXTURE_MIN_FILTER, ae[G.minFilter]),
      G.compareFunction &&
        (r.texParameteri(Z, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(Z, r.TEXTURE_COMPARE_FUNC, q[G.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        G.magFilter === Qr ||
        (G.minFilter !== gc && G.minFilter !== Ys) ||
        (G.type === or && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (G.anisotropy > 1 || n.get(G).__currentAnisotropy) {
        const xe = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(
          Z,
          xe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(G.anisotropy, i.getMaxAnisotropy()),
        ),
          (n.get(G).__currentAnisotropy = G.anisotropy);
      }
    }
  }
  function Xe(Z, G) {
    let xe = !1;
    Z.__webglInit === void 0 &&
      ((Z.__webglInit = !0), G.addEventListener("dispose", F));
    const ze = G.source;
    let We = y.get(ze);
    We === void 0 && ((We = {}), y.set(ze, We));
    const Oe = me(G);
    if (Oe !== Z.__cacheKey) {
      We[Oe] === void 0 &&
        ((We[Oe] = { texture: r.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (xe = !0)),
        We[Oe].usedTimes++;
      const Mt = We[Z.__cacheKey];
      Mt !== void 0 &&
        (We[Z.__cacheKey].usedTimes--, Mt.usedTimes === 0 && L(G)),
        (Z.__cacheKey = Oe),
        (Z.__webglTexture = We[Oe].texture);
    }
    return xe;
  }
  function ye(Z, G, xe) {
    let ze = r.TEXTURE_2D;
    (G.isDataArrayTexture || G.isCompressedArrayTexture) &&
      (ze = r.TEXTURE_2D_ARRAY),
      G.isData3DTexture && (ze = r.TEXTURE_3D);
    const We = Xe(Z, G),
      Oe = G.source;
    t.bindTexture(ze, Z.__webglTexture, r.TEXTURE0 + xe);
    const Mt = n.get(Oe);
    if (Oe.version !== Mt.__version || We === !0) {
      t.activeTexture(r.TEXTURE0 + xe);
      const ot = Sn.getPrimaries(Sn.workingColorSpace),
        ft = G.colorSpace === Vo ? null : Sn.getPrimaries(G.colorSpace),
        Ot =
          G.colorSpace === Vo || ot === ft ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, G.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, G.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ot);
      let Ke = M(G.image, !1, i.maxTextureSize);
      Ke = Dt(G, Ke);
      const ht = s.convert(G.format, G.colorSpace),
        Tt = s.convert(G.type);
      let st = T(G.internalFormat, ht, Tt, G.colorSpace, G.isVideoTexture);
      ce(ze, G);
      let xt;
      const Qt = G.mipmaps,
        D = G.isVideoTexture !== !0,
        W = Mt.__version === void 0 || We === !0,
        k = Oe.dataReady,
        ne = U(G, Ke);
      if (G.isDepthTexture)
        (st = I(G.format === Dc, G.type)),
          W &&
            (D
              ? t.texStorage2D(r.TEXTURE_2D, 1, st, Ke.width, Ke.height)
              : t.texImage2D(
                  r.TEXTURE_2D,
                  0,
                  st,
                  Ke.width,
                  Ke.height,
                  0,
                  ht,
                  Tt,
                  null,
                ));
      else if (G.isDataTexture)
        if (Qt.length > 0) {
          D &&
            W &&
            t.texStorage2D(r.TEXTURE_2D, ne, st, Qt[0].width, Qt[0].height);
          for (let Q = 0, te = Qt.length; Q < te; Q++)
            (xt = Qt[Q]),
              D
                ? k &&
                  t.texSubImage2D(
                    r.TEXTURE_2D,
                    Q,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    ht,
                    Tt,
                    xt.data,
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    Q,
                    st,
                    xt.width,
                    xt.height,
                    0,
                    ht,
                    Tt,
                    xt.data,
                  );
          G.generateMipmaps = !1;
        } else
          D
            ? (W && t.texStorage2D(r.TEXTURE_2D, ne, st, Ke.width, Ke.height),
              k &&
                t.texSubImage2D(
                  r.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ke.width,
                  Ke.height,
                  ht,
                  Tt,
                  Ke.data,
                ))
            : t.texImage2D(
                r.TEXTURE_2D,
                0,
                st,
                Ke.width,
                Ke.height,
                0,
                ht,
                Tt,
                Ke.data,
              );
      else if (G.isCompressedTexture)
        if (G.isCompressedArrayTexture) {
          D &&
            W &&
            t.texStorage3D(
              r.TEXTURE_2D_ARRAY,
              ne,
              st,
              Qt[0].width,
              Qt[0].height,
              Ke.depth,
            );
          for (let Q = 0, te = Qt.length; Q < te; Q++)
            if (((xt = Qt[Q]), G.format !== wr))
              if (ht !== null)
                if (D) {
                  if (k)
                    if (G.layerUpdates.size > 0) {
                      const Ae = Iv(xt.width, xt.height, G.format, G.type);
                      for (const pe of G.layerUpdates) {
                        const Ve = xt.data.subarray(
                          (pe * Ae) / xt.data.BYTES_PER_ELEMENT,
                          ((pe + 1) * Ae) / xt.data.BYTES_PER_ELEMENT,
                        );
                        t.compressedTexSubImage3D(
                          r.TEXTURE_2D_ARRAY,
                          Q,
                          0,
                          0,
                          pe,
                          xt.width,
                          xt.height,
                          1,
                          ht,
                          Ve,
                        );
                      }
                      G.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        Q,
                        0,
                        0,
                        0,
                        xt.width,
                        xt.height,
                        Ke.depth,
                        ht,
                        xt.data,
                      );
                } else
                  t.compressedTexImage3D(
                    r.TEXTURE_2D_ARRAY,
                    Q,
                    st,
                    xt.width,
                    xt.height,
                    Ke.depth,
                    0,
                    xt.data,
                    0,
                    0,
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                );
            else
              D
                ? k &&
                  t.texSubImage3D(
                    r.TEXTURE_2D_ARRAY,
                    Q,
                    0,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    Ke.depth,
                    ht,
                    Tt,
                    xt.data,
                  )
                : t.texImage3D(
                    r.TEXTURE_2D_ARRAY,
                    Q,
                    st,
                    xt.width,
                    xt.height,
                    Ke.depth,
                    0,
                    ht,
                    Tt,
                    xt.data,
                  );
        } else {
          D &&
            W &&
            t.texStorage2D(r.TEXTURE_2D, ne, st, Qt[0].width, Qt[0].height);
          for (let Q = 0, te = Qt.length; Q < te; Q++)
            (xt = Qt[Q]),
              G.format !== wr
                ? ht !== null
                  ? D
                    ? k &&
                      t.compressedTexSubImage2D(
                        r.TEXTURE_2D,
                        Q,
                        0,
                        0,
                        xt.width,
                        xt.height,
                        ht,
                        xt.data,
                      )
                    : t.compressedTexImage2D(
                        r.TEXTURE_2D,
                        Q,
                        st,
                        xt.width,
                        xt.height,
                        0,
                        xt.data,
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : D
                  ? k &&
                    t.texSubImage2D(
                      r.TEXTURE_2D,
                      Q,
                      0,
                      0,
                      xt.width,
                      xt.height,
                      ht,
                      Tt,
                      xt.data,
                    )
                  : t.texImage2D(
                      r.TEXTURE_2D,
                      Q,
                      st,
                      xt.width,
                      xt.height,
                      0,
                      ht,
                      Tt,
                      xt.data,
                    );
        }
      else if (G.isDataArrayTexture)
        if (D) {
          if (
            (W &&
              t.texStorage3D(
                r.TEXTURE_2D_ARRAY,
                ne,
                st,
                Ke.width,
                Ke.height,
                Ke.depth,
              ),
            k)
          )
            if (G.layerUpdates.size > 0) {
              const Q = Iv(Ke.width, Ke.height, G.format, G.type);
              for (const te of G.layerUpdates) {
                const Ae = Ke.data.subarray(
                  (te * Q) / Ke.data.BYTES_PER_ELEMENT,
                  ((te + 1) * Q) / Ke.data.BYTES_PER_ELEMENT,
                );
                t.texSubImage3D(
                  r.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  te,
                  Ke.width,
                  Ke.height,
                  1,
                  ht,
                  Tt,
                  Ae,
                );
              }
              G.clearLayerUpdates();
            } else
              t.texSubImage3D(
                r.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ke.width,
                Ke.height,
                Ke.depth,
                ht,
                Tt,
                Ke.data,
              );
        } else
          t.texImage3D(
            r.TEXTURE_2D_ARRAY,
            0,
            st,
            Ke.width,
            Ke.height,
            Ke.depth,
            0,
            ht,
            Tt,
            Ke.data,
          );
      else if (G.isData3DTexture)
        D
          ? (W &&
              t.texStorage3D(
                r.TEXTURE_3D,
                ne,
                st,
                Ke.width,
                Ke.height,
                Ke.depth,
              ),
            k &&
              t.texSubImage3D(
                r.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ke.width,
                Ke.height,
                Ke.depth,
                ht,
                Tt,
                Ke.data,
              ))
          : t.texImage3D(
              r.TEXTURE_3D,
              0,
              st,
              Ke.width,
              Ke.height,
              Ke.depth,
              0,
              ht,
              Tt,
              Ke.data,
            );
      else if (G.isFramebufferTexture) {
        if (W)
          if (D) t.texStorage2D(r.TEXTURE_2D, ne, st, Ke.width, Ke.height);
          else {
            let Q = Ke.width,
              te = Ke.height;
            for (let Ae = 0; Ae < ne; Ae++)
              t.texImage2D(r.TEXTURE_2D, Ae, st, Q, te, 0, ht, Tt, null),
                (Q >>= 1),
                (te >>= 1);
          }
      } else if (Qt.length > 0) {
        if (D && W) {
          const Q = it(Qt[0]);
          t.texStorage2D(r.TEXTURE_2D, ne, st, Q.width, Q.height);
        }
        for (let Q = 0, te = Qt.length; Q < te; Q++)
          (xt = Qt[Q]),
            D
              ? k && t.texSubImage2D(r.TEXTURE_2D, Q, 0, 0, ht, Tt, xt)
              : t.texImage2D(r.TEXTURE_2D, Q, st, ht, Tt, xt);
        G.generateMipmaps = !1;
      } else if (D) {
        if (W) {
          const Q = it(Ke);
          t.texStorage2D(r.TEXTURE_2D, ne, st, Q.width, Q.height);
        }
        k && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, ht, Tt, Ke);
      } else t.texImage2D(r.TEXTURE_2D, 0, st, ht, Tt, Ke);
      w(G) && x(ze), (Mt.__version = Oe.version), G.onUpdate && G.onUpdate(G);
    }
    Z.__version = G.version;
  }
  function Pe(Z, G, xe) {
    if (G.image.length !== 6) return;
    const ze = Xe(Z, G),
      We = G.source;
    t.bindTexture(r.TEXTURE_CUBE_MAP, Z.__webglTexture, r.TEXTURE0 + xe);
    const Oe = n.get(We);
    if (We.version !== Oe.__version || ze === !0) {
      t.activeTexture(r.TEXTURE0 + xe);
      const Mt = Sn.getPrimaries(Sn.workingColorSpace),
        ot = G.colorSpace === Vo ? null : Sn.getPrimaries(G.colorSpace),
        ft =
          G.colorSpace === Vo || Mt === ot ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, G.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, G.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, ft);
      const Ot = G.isCompressedTexture || G.image[0].isCompressedTexture,
        Ke = G.image[0] && G.image[0].isDataTexture,
        ht = [];
      for (let te = 0; te < 6; te++)
        !Ot && !Ke
          ? (ht[te] = M(G.image[te], !0, i.maxCubemapSize))
          : (ht[te] = Ke ? G.image[te].image : G.image[te]),
          (ht[te] = Dt(G, ht[te]));
      const Tt = ht[0],
        st = s.convert(G.format, G.colorSpace),
        xt = s.convert(G.type),
        Qt = T(G.internalFormat, st, xt, G.colorSpace),
        D = G.isVideoTexture !== !0,
        W = Oe.__version === void 0 || ze === !0,
        k = We.dataReady;
      let ne = U(G, Tt);
      ce(r.TEXTURE_CUBE_MAP, G);
      let Q;
      if (Ot) {
        D &&
          W &&
          t.texStorage2D(r.TEXTURE_CUBE_MAP, ne, Qt, Tt.width, Tt.height);
        for (let te = 0; te < 6; te++) {
          Q = ht[te].mipmaps;
          for (let Ae = 0; Ae < Q.length; Ae++) {
            const pe = Q[Ae];
            G.format !== wr
              ? st !== null
                ? D
                  ? k &&
                    t.compressedTexSubImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                      Ae,
                      0,
                      0,
                      pe.width,
                      pe.height,
                      st,
                      pe.data,
                    )
                  : t.compressedTexImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                      Ae,
                      Qt,
                      pe.width,
                      pe.height,
                      0,
                      pe.data,
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                  )
              : D
                ? k &&
                  t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                    Ae,
                    0,
                    0,
                    pe.width,
                    pe.height,
                    st,
                    xt,
                    pe.data,
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                    Ae,
                    Qt,
                    pe.width,
                    pe.height,
                    0,
                    st,
                    xt,
                    pe.data,
                  );
          }
        }
      } else {
        if (((Q = G.mipmaps), D && W)) {
          Q.length > 0 && ne++;
          const te = it(ht[0]);
          t.texStorage2D(r.TEXTURE_CUBE_MAP, ne, Qt, te.width, te.height);
        }
        for (let te = 0; te < 6; te++)
          if (Ke) {
            D
              ? k &&
                t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                  0,
                  0,
                  0,
                  ht[te].width,
                  ht[te].height,
                  st,
                  xt,
                  ht[te].data,
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                  0,
                  Qt,
                  ht[te].width,
                  ht[te].height,
                  0,
                  st,
                  xt,
                  ht[te].data,
                );
            for (let Ae = 0; Ae < Q.length; Ae++) {
              const pe = Q[Ae].image[te].image;
              D
                ? k &&
                  t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                    Ae + 1,
                    0,
                    0,
                    pe.width,
                    pe.height,
                    st,
                    xt,
                    pe.data,
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                    Ae + 1,
                    Qt,
                    pe.width,
                    pe.height,
                    0,
                    st,
                    xt,
                    pe.data,
                  );
            }
          } else {
            D
              ? k &&
                t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                  0,
                  0,
                  0,
                  st,
                  xt,
                  ht[te],
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                  0,
                  Qt,
                  st,
                  xt,
                  ht[te],
                );
            for (let Ae = 0; Ae < Q.length; Ae++) {
              const pe = Q[Ae];
              D
                ? k &&
                  t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                    Ae + 1,
                    0,
                    0,
                    st,
                    xt,
                    pe.image[te],
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                    Ae + 1,
                    Qt,
                    st,
                    xt,
                    pe.image[te],
                  );
            }
          }
      }
      w(G) && x(r.TEXTURE_CUBE_MAP),
        (Oe.__version = We.version),
        G.onUpdate && G.onUpdate(G);
    }
    Z.__version = G.version;
  }
  function Ue(Z, G, xe, ze, We, Oe) {
    const Mt = s.convert(xe.format, xe.colorSpace),
      ot = s.convert(xe.type),
      ft = T(xe.internalFormat, Mt, ot, xe.colorSpace),
      Ot = n.get(G),
      Ke = n.get(xe);
    if (((Ke.__renderTarget = G), !Ot.__hasExternalTextures)) {
      const ht = Math.max(1, G.width >> Oe),
        Tt = Math.max(1, G.height >> Oe);
      We === r.TEXTURE_3D || We === r.TEXTURE_2D_ARRAY
        ? t.texImage3D(We, Oe, ft, ht, Tt, G.depth, 0, Mt, ot, null)
        : t.texImage2D(We, Oe, ft, ht, Tt, 0, Mt, ot, null);
    }
    t.bindFramebuffer(r.FRAMEBUFFER, Z),
      Be(G)
        ? l.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            ze,
            We,
            Ke.__webglTexture,
            0,
            ct(G),
          )
        : (We === r.TEXTURE_2D ||
            (We >= r.TEXTURE_CUBE_MAP_POSITIVE_X &&
              We <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          r.framebufferTexture2D(r.FRAMEBUFFER, ze, We, Ke.__webglTexture, Oe),
      t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Fe(Z, G, xe) {
    if ((r.bindRenderbuffer(r.RENDERBUFFER, Z), G.depthBuffer)) {
      const ze = G.depthTexture,
        We = ze && ze.isDepthTexture ? ze.type : null,
        Oe = I(G.stencilBuffer, We),
        Mt = G.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        ot = ct(G);
      Be(G)
        ? l.renderbufferStorageMultisampleEXT(
            r.RENDERBUFFER,
            ot,
            Oe,
            G.width,
            G.height,
          )
        : xe
          ? r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              ot,
              Oe,
              G.width,
              G.height,
            )
          : r.renderbufferStorage(r.RENDERBUFFER, Oe, G.width, G.height),
        r.framebufferRenderbuffer(r.FRAMEBUFFER, Mt, r.RENDERBUFFER, Z);
    } else {
      const ze = G.textures;
      for (let We = 0; We < ze.length; We++) {
        const Oe = ze[We],
          Mt = s.convert(Oe.format, Oe.colorSpace),
          ot = s.convert(Oe.type),
          ft = T(Oe.internalFormat, Mt, ot, Oe.colorSpace),
          Ot = ct(G);
        xe && Be(G) === !1
          ? r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              Ot,
              ft,
              G.width,
              G.height,
            )
          : Be(G)
            ? l.renderbufferStorageMultisampleEXT(
                r.RENDERBUFFER,
                Ot,
                ft,
                G.width,
                G.height,
              )
            : r.renderbufferStorage(r.RENDERBUFFER, ft, G.width, G.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function Je(Z, G) {
    if (G && G.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported",
      );
    if (
      (t.bindFramebuffer(r.FRAMEBUFFER, Z),
      !(G.depthTexture && G.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    const xe = n.get(G.depthTexture);
    (xe.__renderTarget = G),
      (!xe.__webglTexture ||
        G.depthTexture.image.width !== G.width ||
        G.depthTexture.image.height !== G.height) &&
        ((G.depthTexture.image.width = G.width),
        (G.depthTexture.image.height = G.height),
        (G.depthTexture.needsUpdate = !0)),
      _e(G.depthTexture, 0);
    const ze = xe.__webglTexture,
      We = ct(G);
    if (G.depthTexture.format === Ec)
      Be(G)
        ? l.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ze,
            0,
            We,
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ze,
            0,
          );
    else if (G.depthTexture.format === Dc)
      Be(G)
        ? l.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ze,
            0,
            We,
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ze,
            0,
          );
    else throw new Error("Unknown depthTexture format");
  }
  function et(Z) {
    const G = n.get(Z),
      xe = Z.isWebGLCubeRenderTarget === !0;
    if (G.__boundDepthTexture !== Z.depthTexture) {
      const ze = Z.depthTexture;
      if ((G.__depthDisposeCallback && G.__depthDisposeCallback(), ze)) {
        const We = () => {
          delete G.__boundDepthTexture,
            delete G.__depthDisposeCallback,
            ze.removeEventListener("dispose", We);
        };
        ze.addEventListener("dispose", We), (G.__depthDisposeCallback = We);
      }
      G.__boundDepthTexture = ze;
    }
    if (Z.depthTexture && !G.__autoAllocateDepthBuffer) {
      if (xe)
        throw new Error(
          "target.depthTexture not supported in Cube render targets",
        );
      Je(G.__webglFramebuffer, Z);
    } else if (xe) {
      G.__webglDepthbuffer = [];
      for (let ze = 0; ze < 6; ze++)
        if (
          (t.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer[ze]),
          G.__webglDepthbuffer[ze] === void 0)
        )
          (G.__webglDepthbuffer[ze] = r.createRenderbuffer()),
            Fe(G.__webglDepthbuffer[ze], Z, !1);
        else {
          const We = Z.stencilBuffer
              ? r.DEPTH_STENCIL_ATTACHMENT
              : r.DEPTH_ATTACHMENT,
            Oe = G.__webglDepthbuffer[ze];
          r.bindRenderbuffer(r.RENDERBUFFER, Oe),
            r.framebufferRenderbuffer(r.FRAMEBUFFER, We, r.RENDERBUFFER, Oe);
        }
    } else if (
      (t.bindFramebuffer(r.FRAMEBUFFER, G.__webglFramebuffer),
      G.__webglDepthbuffer === void 0)
    )
      (G.__webglDepthbuffer = r.createRenderbuffer()),
        Fe(G.__webglDepthbuffer, Z, !1);
    else {
      const ze = Z.stencilBuffer
          ? r.DEPTH_STENCIL_ATTACHMENT
          : r.DEPTH_ATTACHMENT,
        We = G.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, We),
        r.framebufferRenderbuffer(r.FRAMEBUFFER, ze, r.RENDERBUFFER, We);
    }
    t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function tt(Z, G, xe) {
    const ze = n.get(Z);
    G !== void 0 &&
      Ue(
        ze.__webglFramebuffer,
        Z,
        Z.texture,
        r.COLOR_ATTACHMENT0,
        r.TEXTURE_2D,
        0,
      ),
      xe !== void 0 && et(Z);
  }
  function be(Z) {
    const G = Z.texture,
      xe = n.get(Z),
      ze = n.get(G);
    Z.addEventListener("dispose", O);
    const We = Z.textures,
      Oe = Z.isWebGLCubeRenderTarget === !0,
      Mt = We.length > 1;
    if (
      (Mt ||
        (ze.__webglTexture === void 0 &&
          (ze.__webglTexture = r.createTexture()),
        (ze.__version = G.version),
        a.memory.textures++),
      Oe)
    ) {
      xe.__webglFramebuffer = [];
      for (let ot = 0; ot < 6; ot++)
        if (G.mipmaps && G.mipmaps.length > 0) {
          xe.__webglFramebuffer[ot] = [];
          for (let ft = 0; ft < G.mipmaps.length; ft++)
            xe.__webglFramebuffer[ot][ft] = r.createFramebuffer();
        } else xe.__webglFramebuffer[ot] = r.createFramebuffer();
    } else {
      if (G.mipmaps && G.mipmaps.length > 0) {
        xe.__webglFramebuffer = [];
        for (let ot = 0; ot < G.mipmaps.length; ot++)
          xe.__webglFramebuffer[ot] = r.createFramebuffer();
      } else xe.__webglFramebuffer = r.createFramebuffer();
      if (Mt)
        for (let ot = 0, ft = We.length; ot < ft; ot++) {
          const Ot = n.get(We[ot]);
          Ot.__webglTexture === void 0 &&
            ((Ot.__webglTexture = r.createTexture()), a.memory.textures++);
        }
      if (Z.samples > 0 && Be(Z) === !1) {
        (xe.__webglMultisampledFramebuffer = r.createFramebuffer()),
          (xe.__webglColorRenderbuffer = []),
          t.bindFramebuffer(r.FRAMEBUFFER, xe.__webglMultisampledFramebuffer);
        for (let ot = 0; ot < We.length; ot++) {
          const ft = We[ot];
          (xe.__webglColorRenderbuffer[ot] = r.createRenderbuffer()),
            r.bindRenderbuffer(r.RENDERBUFFER, xe.__webglColorRenderbuffer[ot]);
          const Ot = s.convert(ft.format, ft.colorSpace),
            Ke = s.convert(ft.type),
            ht = T(
              ft.internalFormat,
              Ot,
              Ke,
              ft.colorSpace,
              Z.isXRRenderTarget === !0,
            ),
            Tt = ct(Z);
          r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            Tt,
            ht,
            Z.width,
            Z.height,
          ),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ot,
              r.RENDERBUFFER,
              xe.__webglColorRenderbuffer[ot],
            );
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null),
          Z.depthBuffer &&
            ((xe.__webglDepthRenderbuffer = r.createRenderbuffer()),
            Fe(xe.__webglDepthRenderbuffer, Z, !0)),
          t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (Oe) {
      t.bindTexture(r.TEXTURE_CUBE_MAP, ze.__webglTexture),
        ce(r.TEXTURE_CUBE_MAP, G);
      for (let ot = 0; ot < 6; ot++)
        if (G.mipmaps && G.mipmaps.length > 0)
          for (let ft = 0; ft < G.mipmaps.length; ft++)
            Ue(
              xe.__webglFramebuffer[ot][ft],
              Z,
              G,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
              ft,
            );
        else
          Ue(
            xe.__webglFramebuffer[ot],
            Z,
            G,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
            0,
          );
      w(G) && x(r.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Mt) {
      for (let ot = 0, ft = We.length; ot < ft; ot++) {
        const Ot = We[ot],
          Ke = n.get(Ot);
        t.bindTexture(r.TEXTURE_2D, Ke.__webglTexture),
          ce(r.TEXTURE_2D, Ot),
          Ue(
            xe.__webglFramebuffer,
            Z,
            Ot,
            r.COLOR_ATTACHMENT0 + ot,
            r.TEXTURE_2D,
            0,
          ),
          w(Ot) && x(r.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let ot = r.TEXTURE_2D;
      if (
        ((Z.isWebGL3DRenderTarget || Z.isWebGLArrayRenderTarget) &&
          (ot = Z.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY),
        t.bindTexture(ot, ze.__webglTexture),
        ce(ot, G),
        G.mipmaps && G.mipmaps.length > 0)
      )
        for (let ft = 0; ft < G.mipmaps.length; ft++)
          Ue(xe.__webglFramebuffer[ft], Z, G, r.COLOR_ATTACHMENT0, ot, ft);
      else Ue(xe.__webglFramebuffer, Z, G, r.COLOR_ATTACHMENT0, ot, 0);
      w(G) && x(ot), t.unbindTexture();
    }
    Z.depthBuffer && et(Z);
  }
  function Te(Z) {
    const G = Z.textures;
    for (let xe = 0, ze = G.length; xe < ze; xe++) {
      const We = G[xe];
      if (w(We)) {
        const Oe = C(Z),
          Mt = n.get(We).__webglTexture;
        t.bindTexture(Oe, Mt), x(Oe), t.unbindTexture();
      }
    }
  }
  const Ne = [],
    K = [];
  function qe(Z) {
    if (Z.samples > 0) {
      if (Be(Z) === !1) {
        const G = Z.textures,
          xe = Z.width,
          ze = Z.height;
        let We = r.COLOR_BUFFER_BIT;
        const Oe = Z.stencilBuffer
            ? r.DEPTH_STENCIL_ATTACHMENT
            : r.DEPTH_ATTACHMENT,
          Mt = n.get(Z),
          ot = G.length > 1;
        if (ot)
          for (let ft = 0; ft < G.length; ft++)
            t.bindFramebuffer(r.FRAMEBUFFER, Mt.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + ft,
                r.RENDERBUFFER,
                null,
              ),
              t.bindFramebuffer(r.FRAMEBUFFER, Mt.__webglFramebuffer),
              r.framebufferTexture2D(
                r.DRAW_FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + ft,
                r.TEXTURE_2D,
                null,
                0,
              );
        t.bindFramebuffer(
          r.READ_FRAMEBUFFER,
          Mt.__webglMultisampledFramebuffer,
        ),
          t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Mt.__webglFramebuffer);
        for (let ft = 0; ft < G.length; ft++) {
          if (
            (Z.resolveDepthBuffer &&
              (Z.depthBuffer && (We |= r.DEPTH_BUFFER_BIT),
              Z.stencilBuffer &&
                Z.resolveStencilBuffer &&
                (We |= r.STENCIL_BUFFER_BIT)),
            ot)
          ) {
            r.framebufferRenderbuffer(
              r.READ_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.RENDERBUFFER,
              Mt.__webglColorRenderbuffer[ft],
            );
            const Ot = n.get(G[ft]).__webglTexture;
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_2D,
              Ot,
              0,
            );
          }
          r.blitFramebuffer(0, 0, xe, ze, 0, 0, xe, ze, We, r.NEAREST),
            c === !0 &&
              ((Ne.length = 0),
              (K.length = 0),
              Ne.push(r.COLOR_ATTACHMENT0 + ft),
              Z.depthBuffer &&
                Z.resolveDepthBuffer === !1 &&
                (Ne.push(Oe),
                K.push(Oe),
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, K)),
              r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Ne));
        }
        if (
          (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
          ot)
        )
          for (let ft = 0; ft < G.length; ft++) {
            t.bindFramebuffer(r.FRAMEBUFFER, Mt.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + ft,
                r.RENDERBUFFER,
                Mt.__webglColorRenderbuffer[ft],
              );
            const Ot = n.get(G[ft]).__webglTexture;
            t.bindFramebuffer(r.FRAMEBUFFER, Mt.__webglFramebuffer),
              r.framebufferTexture2D(
                r.DRAW_FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + ft,
                r.TEXTURE_2D,
                Ot,
                0,
              );
          }
        t.bindFramebuffer(
          r.DRAW_FRAMEBUFFER,
          Mt.__webglMultisampledFramebuffer,
        );
      } else if (Z.depthBuffer && Z.resolveDepthBuffer === !1 && c) {
        const G = Z.stencilBuffer
          ? r.DEPTH_STENCIL_ATTACHMENT
          : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [G]);
      }
    }
  }
  function ct(Z) {
    return Math.min(i.maxSamples, Z.samples);
  }
  function Be(Z) {
    const G = n.get(Z);
    return (
      Z.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      G.__useRenderToTexture !== !1
    );
  }
  function nt(Z) {
    const G = a.render.frame;
    p.get(Z) !== G && (p.set(Z, G), Z.update());
  }
  function Dt(Z, G) {
    const xe = Z.colorSpace,
      ze = Z.format,
      We = Z.type;
    return (
      Z.isCompressedTexture === !0 ||
        Z.isVideoTexture === !0 ||
        (xe !== ao &&
          xe !== Vo &&
          (Sn.getTransfer(xe) === Hn
            ? (ze !== wr || We !== hs) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                xe,
              ))),
      G
    );
  }
  function it(Z) {
    return (
      typeof HTMLImageElement < "u" && Z instanceof HTMLImageElement
        ? ((d.width = Z.naturalWidth || Z.width),
          (d.height = Z.naturalHeight || Z.height))
        : typeof VideoFrame < "u" && Z instanceof VideoFrame
          ? ((d.width = Z.displayWidth), (d.height = Z.displayHeight))
          : ((d.width = Z.width), (d.height = Z.height)),
      d
    );
  }
  (this.allocateTextureUnit = re),
    (this.resetTextureUnits = ie),
    (this.setTexture2D = _e),
    (this.setTexture2DArray = ge),
    (this.setTexture3D = Re),
    (this.setTextureCube = J),
    (this.rebindTextures = tt),
    (this.setupRenderTarget = be),
    (this.updateRenderTargetMipmap = Te),
    (this.updateMultisampleRenderTarget = qe),
    (this.setupDepthRenderbuffer = et),
    (this.setupFrameBufferTexture = Ue),
    (this.useMultisampledRTT = Be);
}
function kS(r, e) {
  function t(n, i = Vo) {
    let s;
    const a = Sn.getTransfer(i);
    if (n === hs) return r.UNSIGNED_BYTE;
    if (n === Ig) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === Bg) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === M3) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === Tg) return r.BYTE;
    if (n === Rg) return r.SHORT;
    if (n === ph) return r.UNSIGNED_SHORT;
    if (n === qp) return r.INT;
    if (n === so) return r.UNSIGNED_INT;
    if (n === or) return r.FLOAT;
    if (n === Kr) return r.HALF_FLOAT;
    if (n === S3) return r.ALPHA;
    if (n === E3) return r.RGB;
    if (n === wr) return r.RGBA;
    if (n === C3) return r.LUMINANCE;
    if (n === T3) return r.LUMINANCE_ALPHA;
    if (n === Ec) return r.DEPTH_COMPONENT;
    if (n === Dc) return r.DEPTH_STENCIL;
    if (n === Kp) return r.RED;
    if (n === Qp) return r.RED_INTEGER;
    if (n === R3) return r.RG;
    if (n === Pg) return r.RG_INTEGER;
    if (n === Lg) return r.RGBA_INTEGER;
    if (n === cp || n === dp || n === hp || n === fp)
      if (a === Hn)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (n === cp) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === dp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === hp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === fp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (n === cp) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === dp) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === hp) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === fp) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === U0 || n === O0 || n === k0 || n === z0)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (n === U0) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === O0) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === k0) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === z0) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (n === H0 || n === V0 || n === G0)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (n === H0 || n === V0)
          return a === Hn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === G0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      n === j0 ||
      n === W0 ||
      n === X0 ||
      n === J0 ||
      n === Y0 ||
      n === Z0 ||
      n === q0 ||
      n === K0 ||
      n === Q0 ||
      n === $0 ||
      n === eg ||
      n === tg ||
      n === ng ||
      n === rg
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (n === j0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === W0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === X0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === J0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Y0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Z0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === q0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === K0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Q0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === $0)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === eg)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === tg)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === ng)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === rg)
          return a === Hn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === pp || n === ig || n === sg)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (n === pp)
          return a === Hn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === ig) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === sg) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === I3 || n === ag || n === og || n === lg)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (n === pp) return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === ag) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === og) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === lg) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === Lc ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: t };
}
const uN = { type: "move" };
class Ly {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new jo()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new jo()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Y()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Y())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new jo()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Y()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Y())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      s = null,
      a = null;
    const l = this._targetRay,
      c = this._grip,
      d = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (d && e.hand) {
        a = !0;
        for (const M of e.hand.values()) {
          const w = t.getJointPose(M, n),
            x = this._getHandJoint(d, M);
          w !== null &&
            (x.matrix.fromArray(w.transform.matrix),
            x.matrix.decompose(x.position, x.rotation, x.scale),
            (x.matrixWorldNeedsUpdate = !0),
            (x.jointRadius = w.radius)),
            (x.visible = w !== null);
        }
        const p = d.joints["index-finger-tip"],
          m = d.joints["thumb-tip"],
          y = p.position.distanceTo(m.position),
          v = 0.02,
          A = 0.005;
        d.inputState.pinching && y > v + A
          ? ((d.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !d.inputState.pinching &&
            y <= v - A &&
            ((d.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        c !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, n)),
          s !== null &&
            (c.matrix.fromArray(s.transform.matrix),
            c.matrix.decompose(c.position, c.rotation, c.scale),
            (c.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((c.hasLinearVelocity = !0),
                c.linearVelocity.copy(s.linearVelocity))
              : (c.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((c.hasAngularVelocity = !0),
                c.angularVelocity.copy(s.angularVelocity))
              : (c.hasAngularVelocity = !1)));
      l !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && s !== null && (i = s),
        i !== null &&
          (l.matrix.fromArray(i.transform.matrix),
          l.matrix.decompose(l.position, l.rotation, l.scale),
          (l.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((l.hasLinearVelocity = !0),
              l.linearVelocity.copy(i.linearVelocity))
            : (l.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((l.hasAngularVelocity = !0),
              l.angularVelocity.copy(i.angularVelocity))
            : (l.hasAngularVelocity = !1),
          this.dispatchEvent(uN)));
    }
    return (
      l !== null && (l.visible = i !== null),
      c !== null && (c.visible = s !== null),
      d !== null && (d.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new jo();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
const cN = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  dN = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class hN {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new Ln(),
        s = e.properties.get(i);
      (s.__webglTexture = t.texture),
        (t.depthNear != n.depthNear || t.depthFar != n.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        n = new fs({
          vertexShader: cN,
          fragmentShader: dN,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new nr(new Kl(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class fN extends oo {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      s = 1,
      a = null,
      l = "local-floor",
      c = 1,
      d = null,
      p = null,
      m = null,
      y = null,
      v = null,
      A = null;
    const M = new hN(),
      w = t.getContextAttributes();
    let x = null,
      C = null;
    const T = [],
      I = [],
      U = new je();
    let F = null;
    const O = new Hr();
    O.viewport = new Cn();
    const z = new Hr();
    z.viewport = new Cn();
    const L = [O, z],
      N = new RS();
    let X = null,
      ie = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ye) {
        let Pe = T[ye];
        return (
          Pe === void 0 && ((Pe = new Ly()), (T[ye] = Pe)),
          Pe.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (ye) {
        let Pe = T[ye];
        return (
          Pe === void 0 && ((Pe = new Ly()), (T[ye] = Pe)), Pe.getGripSpace()
        );
      }),
      (this.getHand = function (ye) {
        let Pe = T[ye];
        return (
          Pe === void 0 && ((Pe = new Ly()), (T[ye] = Pe)), Pe.getHandSpace()
        );
      });
    function re(ye) {
      const Pe = I.indexOf(ye.inputSource);
      if (Pe === -1) return;
      const Ue = T[Pe];
      Ue !== void 0 &&
        (Ue.update(ye.inputSource, ye.frame, d || a),
        Ue.dispatchEvent({ type: ye.type, data: ye.inputSource }));
    }
    function me() {
      i.removeEventListener("select", re),
        i.removeEventListener("selectstart", re),
        i.removeEventListener("selectend", re),
        i.removeEventListener("squeeze", re),
        i.removeEventListener("squeezestart", re),
        i.removeEventListener("squeezeend", re),
        i.removeEventListener("end", me),
        i.removeEventListener("inputsourceschange", _e);
      for (let ye = 0; ye < T.length; ye++) {
        const Pe = I[ye];
        Pe !== null && ((I[ye] = null), T[ye].disconnect(Pe));
      }
      (X = null),
        (ie = null),
        M.reset(),
        e.setRenderTarget(x),
        (v = null),
        (y = null),
        (m = null),
        (i = null),
        (C = null),
        Xe.stop(),
        (n.isPresenting = !1),
        e.setPixelRatio(F),
        e.setSize(U.width, U.height, !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (ye) {
      (s = ye),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
          );
    }),
      (this.setReferenceSpaceType = function (ye) {
        (l = ye),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting.",
            );
      }),
      (this.getReferenceSpace = function () {
        return d || a;
      }),
      (this.setReferenceSpace = function (ye) {
        d = ye;
      }),
      (this.getBaseLayer = function () {
        return y !== null ? y : v;
      }),
      (this.getBinding = function () {
        return m;
      }),
      (this.getFrame = function () {
        return A;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (ye) {
        if (((i = ye), i !== null)) {
          if (
            ((x = e.getRenderTarget()),
            i.addEventListener("select", re),
            i.addEventListener("selectstart", re),
            i.addEventListener("selectend", re),
            i.addEventListener("squeeze", re),
            i.addEventListener("squeezestart", re),
            i.addEventListener("squeezeend", re),
            i.addEventListener("end", me),
            i.addEventListener("inputsourceschange", _e),
            w.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (F = e.getPixelRatio()),
            e.getSize(U),
            i.renderState.layers === void 0)
          ) {
            const Pe = {
              antialias: w.antialias,
              alpha: !0,
              depth: w.depth,
              stencil: w.stencil,
              framebufferScaleFactor: s,
            };
            (v = new XRWebGLLayer(i, t, Pe)),
              i.updateRenderState({ baseLayer: v }),
              e.setPixelRatio(1),
              e.setSize(v.framebufferWidth, v.framebufferHeight, !1),
              (C = new Es(v.framebufferWidth, v.framebufferHeight, {
                format: wr,
                type: hs,
                colorSpace: e.outputColorSpace,
                stencilBuffer: w.stencil,
              }));
          } else {
            let Pe = null,
              Ue = null,
              Fe = null;
            w.depth &&
              ((Fe = w.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (Pe = w.stencil ? Dc : Ec),
              (Ue = w.stencil ? Lc : so));
            const Je = {
              colorFormat: t.RGBA8,
              depthFormat: Fe,
              scaleFactor: s,
            };
            (m = new XRWebGLBinding(i, t)),
              (y = m.createProjectionLayer(Je)),
              i.updateRenderState({ layers: [y] }),
              e.setPixelRatio(1),
              e.setSize(y.textureWidth, y.textureHeight, !1),
              (C = new Es(y.textureWidth, y.textureHeight, {
                format: wr,
                type: hs,
                depthTexture: new j3(
                  y.textureWidth,
                  y.textureHeight,
                  Ue,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Pe,
                ),
                stencilBuffer: w.stencil,
                colorSpace: e.outputColorSpace,
                samples: w.antialias ? 4 : 0,
                resolveDepthBuffer: y.ignoreDepthValues === !1,
              }));
          }
          (C.isXRRenderTarget = !0),
            this.setFoveation(c),
            (d = null),
            (a = await i.requestReferenceSpace(l)),
            Xe.setContext(i),
            Xe.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return M.getDepthTexture();
      });
    function _e(ye) {
      for (let Pe = 0; Pe < ye.removed.length; Pe++) {
        const Ue = ye.removed[Pe],
          Fe = I.indexOf(Ue);
        Fe >= 0 && ((I[Fe] = null), T[Fe].disconnect(Ue));
      }
      for (let Pe = 0; Pe < ye.added.length; Pe++) {
        const Ue = ye.added[Pe];
        let Fe = I.indexOf(Ue);
        if (Fe === -1) {
          for (let et = 0; et < T.length; et++)
            if (et >= I.length) {
              I.push(Ue), (Fe = et);
              break;
            } else if (I[et] === null) {
              (I[et] = Ue), (Fe = et);
              break;
            }
          if (Fe === -1) break;
        }
        const Je = T[Fe];
        Je && Je.connect(Ue);
      }
    }
    const ge = new Y(),
      Re = new Y();
    function J(ye, Pe, Ue) {
      ge.setFromMatrixPosition(Pe.matrixWorld),
        Re.setFromMatrixPosition(Ue.matrixWorld);
      const Fe = ge.distanceTo(Re),
        Je = Pe.projectionMatrix.elements,
        et = Ue.projectionMatrix.elements,
        tt = Je[14] / (Je[10] - 1),
        be = Je[14] / (Je[10] + 1),
        Te = (Je[9] + 1) / Je[5],
        Ne = (Je[9] - 1) / Je[5],
        K = (Je[8] - 1) / Je[0],
        qe = (et[8] + 1) / et[0],
        ct = tt * K,
        Be = tt * qe,
        nt = Fe / (-K + qe),
        Dt = nt * -K;
      if (
        (Pe.matrixWorld.decompose(ye.position, ye.quaternion, ye.scale),
        ye.translateX(Dt),
        ye.translateZ(nt),
        ye.matrixWorld.compose(ye.position, ye.quaternion, ye.scale),
        ye.matrixWorldInverse.copy(ye.matrixWorld).invert(),
        Je[10] === -1)
      )
        ye.projectionMatrix.copy(Pe.projectionMatrix),
          ye.projectionMatrixInverse.copy(Pe.projectionMatrixInverse);
      else {
        const it = tt + nt,
          Z = be + nt,
          G = ct - Dt,
          xe = Be + (Fe - Dt),
          ze = ((Te * be) / Z) * it,
          We = ((Ne * be) / Z) * it;
        ye.projectionMatrix.makePerspective(G, xe, ze, We, it, Z),
          ye.projectionMatrixInverse.copy(ye.projectionMatrix).invert();
      }
    }
    function oe(ye, Pe) {
      Pe === null
        ? ye.matrixWorld.copy(ye.matrix)
        : ye.matrixWorld.multiplyMatrices(Pe.matrixWorld, ye.matrix),
        ye.matrixWorldInverse.copy(ye.matrixWorld).invert();
    }
    this.updateCamera = function (ye) {
      if (i === null) return;
      let Pe = ye.near,
        Ue = ye.far;
      M.texture !== null &&
        (M.depthNear > 0 && (Pe = M.depthNear),
        M.depthFar > 0 && (Ue = M.depthFar)),
        (N.near = z.near = O.near = Pe),
        (N.far = z.far = O.far = Ue),
        (X !== N.near || ie !== N.far) &&
          (i.updateRenderState({ depthNear: N.near, depthFar: N.far }),
          (X = N.near),
          (ie = N.far)),
        (O.layers.mask = ye.layers.mask | 2),
        (z.layers.mask = ye.layers.mask | 4),
        (N.layers.mask = O.layers.mask | z.layers.mask);
      const Fe = ye.parent,
        Je = N.cameras;
      oe(N, Fe);
      for (let et = 0; et < Je.length; et++) oe(Je[et], Fe);
      Je.length === 2
        ? J(N, O, z)
        : N.projectionMatrix.copy(O.projectionMatrix),
        ae(ye, N, Fe);
    };
    function ae(ye, Pe, Ue) {
      Ue === null
        ? ye.matrix.copy(Pe.matrixWorld)
        : (ye.matrix.copy(Ue.matrixWorld),
          ye.matrix.invert(),
          ye.matrix.multiply(Pe.matrixWorld)),
        ye.matrix.decompose(ye.position, ye.quaternion, ye.scale),
        ye.updateMatrixWorld(!0),
        ye.projectionMatrix.copy(Pe.projectionMatrix),
        ye.projectionMatrixInverse.copy(Pe.projectionMatrixInverse),
        ye.isPerspectiveCamera &&
          ((ye.fov = yh * 2 * Math.atan(1 / ye.projectionMatrix.elements[5])),
          (ye.zoom = 1));
    }
    (this.getCamera = function () {
      return N;
    }),
      (this.getFoveation = function () {
        if (!(y === null && v === null)) return c;
      }),
      (this.setFoveation = function (ye) {
        (c = ye),
          y !== null && (y.fixedFoveation = ye),
          v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = ye);
      }),
      (this.hasDepthSensing = function () {
        return M.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return M.getMesh(N);
      });
    let q = null;
    function ce(ye, Pe) {
      if (((p = Pe.getViewerPose(d || a)), (A = Pe), p !== null)) {
        const Ue = p.views;
        v !== null &&
          (e.setRenderTargetFramebuffer(C, v.framebuffer),
          e.setRenderTarget(C));
        let Fe = !1;
        Ue.length !== N.cameras.length && ((N.cameras.length = 0), (Fe = !0));
        for (let et = 0; et < Ue.length; et++) {
          const tt = Ue[et];
          let be = null;
          if (v !== null) be = v.getViewport(tt);
          else {
            const Ne = m.getViewSubImage(y, tt);
            (be = Ne.viewport),
              et === 0 &&
                (e.setRenderTargetTextures(
                  C,
                  Ne.colorTexture,
                  y.ignoreDepthValues ? void 0 : Ne.depthStencilTexture,
                ),
                e.setRenderTarget(C));
          }
          let Te = L[et];
          Te === void 0 &&
            ((Te = new Hr()),
            Te.layers.enable(et),
            (Te.viewport = new Cn()),
            (L[et] = Te)),
            Te.matrix.fromArray(tt.transform.matrix),
            Te.matrix.decompose(Te.position, Te.quaternion, Te.scale),
            Te.projectionMatrix.fromArray(tt.projectionMatrix),
            Te.projectionMatrixInverse.copy(Te.projectionMatrix).invert(),
            Te.viewport.set(be.x, be.y, be.width, be.height),
            et === 0 &&
              (N.matrix.copy(Te.matrix),
              N.matrix.decompose(N.position, N.quaternion, N.scale)),
            Fe === !0 && N.cameras.push(Te);
        }
        const Je = i.enabledFeatures;
        if (Je && Je.includes("depth-sensing")) {
          const et = m.getDepthInformation(Ue[0]);
          et && et.isValid && et.texture && M.init(e, et, i.renderState);
        }
      }
      for (let Ue = 0; Ue < T.length; Ue++) {
        const Fe = I[Ue],
          Je = T[Ue];
        Fe !== null && Je !== void 0 && Je.update(Fe, Pe, d || a);
      }
      q && q(ye, Pe),
        Pe.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: Pe }),
        (A = null);
    }
    const Xe = new DS();
    Xe.setAnimationLoop(ce),
      (this.setAnimationLoop = function (ye) {
        q = ye;
      }),
      (this.dispose = function () {});
  }
}
const oc = new Cs(),
  pN = new jt();
function mN(r, e) {
  function t(w, x) {
    w.matrixAutoUpdate === !0 && w.updateMatrix(), x.value.copy(w.matrix);
  }
  function n(w, x) {
    x.color.getRGB(w.fogColor.value, G5(r)),
      x.isFog
        ? ((w.fogNear.value = x.near), (w.fogFar.value = x.far))
        : x.isFogExp2 && (w.fogDensity.value = x.density);
  }
  function i(w, x, C, T, I) {
    x.isMeshBasicMaterial || x.isMeshLambertMaterial
      ? s(w, x)
      : x.isMeshToonMaterial
        ? (s(w, x), m(w, x))
        : x.isMeshPhongMaterial
          ? (s(w, x), p(w, x))
          : x.isMeshStandardMaterial
            ? (s(w, x), y(w, x), x.isMeshPhysicalMaterial && v(w, x, I))
            : x.isMeshMatcapMaterial
              ? (s(w, x), A(w, x))
              : x.isMeshDepthMaterial
                ? s(w, x)
                : x.isMeshDistanceMaterial
                  ? (s(w, x), M(w, x))
                  : x.isMeshNormalMaterial
                    ? s(w, x)
                    : x.isLineBasicMaterial
                      ? (a(w, x), x.isLineDashedMaterial && l(w, x))
                      : x.isPointsMaterial
                        ? c(w, x, C, T)
                        : x.isSpriteMaterial
                          ? d(w, x)
                          : x.isShadowMaterial
                            ? (w.color.value.copy(x.color),
                              (w.opacity.value = x.opacity))
                            : x.isShaderMaterial && (x.uniformsNeedUpdate = !1);
  }
  function s(w, x) {
    (w.opacity.value = x.opacity),
      x.color && w.diffuse.value.copy(x.color),
      x.emissive &&
        w.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),
      x.map && ((w.map.value = x.map), t(x.map, w.mapTransform)),
      x.alphaMap &&
        ((w.alphaMap.value = x.alphaMap), t(x.alphaMap, w.alphaMapTransform)),
      x.bumpMap &&
        ((w.bumpMap.value = x.bumpMap),
        t(x.bumpMap, w.bumpMapTransform),
        (w.bumpScale.value = x.bumpScale),
        x.side === Ji && (w.bumpScale.value *= -1)),
      x.normalMap &&
        ((w.normalMap.value = x.normalMap),
        t(x.normalMap, w.normalMapTransform),
        w.normalScale.value.copy(x.normalScale),
        x.side === Ji && w.normalScale.value.negate()),
      x.displacementMap &&
        ((w.displacementMap.value = x.displacementMap),
        t(x.displacementMap, w.displacementMapTransform),
        (w.displacementScale.value = x.displacementScale),
        (w.displacementBias.value = x.displacementBias)),
      x.emissiveMap &&
        ((w.emissiveMap.value = x.emissiveMap),
        t(x.emissiveMap, w.emissiveMapTransform)),
      x.specularMap &&
        ((w.specularMap.value = x.specularMap),
        t(x.specularMap, w.specularMapTransform)),
      x.alphaTest > 0 && (w.alphaTest.value = x.alphaTest);
    const C = e.get(x),
      T = C.envMap,
      I = C.envMapRotation;
    T &&
      ((w.envMap.value = T),
      oc.copy(I),
      (oc.x *= -1),
      (oc.y *= -1),
      (oc.z *= -1),
      T.isCubeTexture &&
        T.isRenderTargetTexture === !1 &&
        ((oc.y *= -1), (oc.z *= -1)),
      w.envMapRotation.value.setFromMatrix4(pN.makeRotationFromEuler(oc)),
      (w.flipEnvMap.value =
        T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1),
      (w.reflectivity.value = x.reflectivity),
      (w.ior.value = x.ior),
      (w.refractionRatio.value = x.refractionRatio)),
      x.lightMap &&
        ((w.lightMap.value = x.lightMap),
        (w.lightMapIntensity.value = x.lightMapIntensity),
        t(x.lightMap, w.lightMapTransform)),
      x.aoMap &&
        ((w.aoMap.value = x.aoMap),
        (w.aoMapIntensity.value = x.aoMapIntensity),
        t(x.aoMap, w.aoMapTransform));
  }
  function a(w, x) {
    w.diffuse.value.copy(x.color),
      (w.opacity.value = x.opacity),
      x.map && ((w.map.value = x.map), t(x.map, w.mapTransform));
  }
  function l(w, x) {
    (w.dashSize.value = x.dashSize),
      (w.totalSize.value = x.dashSize + x.gapSize),
      (w.scale.value = x.scale);
  }
  function c(w, x, C, T) {
    w.diffuse.value.copy(x.color),
      (w.opacity.value = x.opacity),
      (w.size.value = x.size * C),
      (w.scale.value = T * 0.5),
      x.map && ((w.map.value = x.map), t(x.map, w.uvTransform)),
      x.alphaMap &&
        ((w.alphaMap.value = x.alphaMap), t(x.alphaMap, w.alphaMapTransform)),
      x.alphaTest > 0 && (w.alphaTest.value = x.alphaTest);
  }
  function d(w, x) {
    w.diffuse.value.copy(x.color),
      (w.opacity.value = x.opacity),
      (w.rotation.value = x.rotation),
      x.map && ((w.map.value = x.map), t(x.map, w.mapTransform)),
      x.alphaMap &&
        ((w.alphaMap.value = x.alphaMap), t(x.alphaMap, w.alphaMapTransform)),
      x.alphaTest > 0 && (w.alphaTest.value = x.alphaTest);
  }
  function p(w, x) {
    w.specular.value.copy(x.specular),
      (w.shininess.value = Math.max(x.shininess, 1e-4));
  }
  function m(w, x) {
    x.gradientMap && (w.gradientMap.value = x.gradientMap);
  }
  function y(w, x) {
    (w.metalness.value = x.metalness),
      x.metalnessMap &&
        ((w.metalnessMap.value = x.metalnessMap),
        t(x.metalnessMap, w.metalnessMapTransform)),
      (w.roughness.value = x.roughness),
      x.roughnessMap &&
        ((w.roughnessMap.value = x.roughnessMap),
        t(x.roughnessMap, w.roughnessMapTransform)),
      x.envMap && (w.envMapIntensity.value = x.envMapIntensity);
  }
  function v(w, x, C) {
    (w.ior.value = x.ior),
      x.sheen > 0 &&
        (w.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen),
        (w.sheenRoughness.value = x.sheenRoughness),
        x.sheenColorMap &&
          ((w.sheenColorMap.value = x.sheenColorMap),
          t(x.sheenColorMap, w.sheenColorMapTransform)),
        x.sheenRoughnessMap &&
          ((w.sheenRoughnessMap.value = x.sheenRoughnessMap),
          t(x.sheenRoughnessMap, w.sheenRoughnessMapTransform))),
      x.clearcoat > 0 &&
        ((w.clearcoat.value = x.clearcoat),
        (w.clearcoatRoughness.value = x.clearcoatRoughness),
        x.clearcoatMap &&
          ((w.clearcoatMap.value = x.clearcoatMap),
          t(x.clearcoatMap, w.clearcoatMapTransform)),
        x.clearcoatRoughnessMap &&
          ((w.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap),
          t(x.clearcoatRoughnessMap, w.clearcoatRoughnessMapTransform)),
        x.clearcoatNormalMap &&
          ((w.clearcoatNormalMap.value = x.clearcoatNormalMap),
          t(x.clearcoatNormalMap, w.clearcoatNormalMapTransform),
          w.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),
          x.side === Ji && w.clearcoatNormalScale.value.negate())),
      x.dispersion > 0 && (w.dispersion.value = x.dispersion),
      x.iridescence > 0 &&
        ((w.iridescence.value = x.iridescence),
        (w.iridescenceIOR.value = x.iridescenceIOR),
        (w.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0]),
        (w.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1]),
        x.iridescenceMap &&
          ((w.iridescenceMap.value = x.iridescenceMap),
          t(x.iridescenceMap, w.iridescenceMapTransform)),
        x.iridescenceThicknessMap &&
          ((w.iridescenceThicknessMap.value = x.iridescenceThicknessMap),
          t(x.iridescenceThicknessMap, w.iridescenceThicknessMapTransform))),
      x.transmission > 0 &&
        ((w.transmission.value = x.transmission),
        (w.transmissionSamplerMap.value = C.texture),
        w.transmissionSamplerSize.value.set(C.width, C.height),
        x.transmissionMap &&
          ((w.transmissionMap.value = x.transmissionMap),
          t(x.transmissionMap, w.transmissionMapTransform)),
        (w.thickness.value = x.thickness),
        x.thicknessMap &&
          ((w.thicknessMap.value = x.thicknessMap),
          t(x.thicknessMap, w.thicknessMapTransform)),
        (w.attenuationDistance.value = x.attenuationDistance),
        w.attenuationColor.value.copy(x.attenuationColor)),
      x.anisotropy > 0 &&
        (w.anisotropyVector.value.set(
          x.anisotropy * Math.cos(x.anisotropyRotation),
          x.anisotropy * Math.sin(x.anisotropyRotation),
        ),
        x.anisotropyMap &&
          ((w.anisotropyMap.value = x.anisotropyMap),
          t(x.anisotropyMap, w.anisotropyMapTransform))),
      (w.specularIntensity.value = x.specularIntensity),
      w.specularColor.value.copy(x.specularColor),
      x.specularColorMap &&
        ((w.specularColorMap.value = x.specularColorMap),
        t(x.specularColorMap, w.specularColorMapTransform)),
      x.specularIntensityMap &&
        ((w.specularIntensityMap.value = x.specularIntensityMap),
        t(x.specularIntensityMap, w.specularIntensityMapTransform));
  }
  function A(w, x) {
    x.matcap && (w.matcap.value = x.matcap);
  }
  function M(w, x) {
    const C = e.get(x).light;
    w.referencePosition.value.setFromMatrixPosition(C.matrixWorld),
      (w.nearDistance.value = C.shadow.camera.near),
      (w.farDistance.value = C.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function gN(r, e, t, n) {
  let i = {},
    s = {},
    a = [];
  const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(C, T) {
    const I = T.program;
    n.uniformBlockBinding(C, I);
  }
  function d(C, T) {
    let I = i[C.id];
    I === void 0 &&
      (A(C), (I = p(C)), (i[C.id] = I), C.addEventListener("dispose", w));
    const U = T.program;
    n.updateUBOMapping(C, U);
    const F = e.render.frame;
    s[C.id] !== F && (y(C), (s[C.id] = F));
  }
  function p(C) {
    const T = m();
    C.__bindingPointIndex = T;
    const I = r.createBuffer(),
      U = C.__size,
      F = C.usage;
    return (
      r.bindBuffer(r.UNIFORM_BUFFER, I),
      r.bufferData(r.UNIFORM_BUFFER, U, F),
      r.bindBuffer(r.UNIFORM_BUFFER, null),
      r.bindBufferBase(r.UNIFORM_BUFFER, T, I),
      I
    );
  }
  function m() {
    for (let C = 0; C < l; C++) if (a.indexOf(C) === -1) return a.push(C), C;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
      ),
      0
    );
  }
  function y(C) {
    const T = i[C.id],
      I = C.uniforms,
      U = C.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, T);
    for (let F = 0, O = I.length; F < O; F++) {
      const z = Array.isArray(I[F]) ? I[F] : [I[F]];
      for (let L = 0, N = z.length; L < N; L++) {
        const X = z[L];
        if (v(X, F, L, U) === !0) {
          const ie = X.__offset,
            re = Array.isArray(X.value) ? X.value : [X.value];
          let me = 0;
          for (let _e = 0; _e < re.length; _e++) {
            const ge = re[_e],
              Re = M(ge);
            typeof ge == "number" || typeof ge == "boolean"
              ? ((X.__data[0] = ge),
                r.bufferSubData(r.UNIFORM_BUFFER, ie + me, X.__data))
              : ge.isMatrix3
                ? ((X.__data[0] = ge.elements[0]),
                  (X.__data[1] = ge.elements[1]),
                  (X.__data[2] = ge.elements[2]),
                  (X.__data[3] = 0),
                  (X.__data[4] = ge.elements[3]),
                  (X.__data[5] = ge.elements[4]),
                  (X.__data[6] = ge.elements[5]),
                  (X.__data[7] = 0),
                  (X.__data[8] = ge.elements[6]),
                  (X.__data[9] = ge.elements[7]),
                  (X.__data[10] = ge.elements[8]),
                  (X.__data[11] = 0))
                : (ge.toArray(X.__data, me),
                  (me += Re.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          r.bufferSubData(r.UNIFORM_BUFFER, ie, X.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function v(C, T, I, U) {
    const F = C.value,
      O = T + "_" + I;
    if (U[O] === void 0)
      return (
        typeof F == "number" || typeof F == "boolean"
          ? (U[O] = F)
          : (U[O] = F.clone()),
        !0
      );
    {
      const z = U[O];
      if (typeof F == "number" || typeof F == "boolean") {
        if (z !== F) return (U[O] = F), !0;
      } else if (z.equals(F) === !1) return z.copy(F), !0;
    }
    return !1;
  }
  function A(C) {
    const T = C.uniforms;
    let I = 0;
    const U = 16;
    for (let O = 0, z = T.length; O < z; O++) {
      const L = Array.isArray(T[O]) ? T[O] : [T[O]];
      for (let N = 0, X = L.length; N < X; N++) {
        const ie = L[N],
          re = Array.isArray(ie.value) ? ie.value : [ie.value];
        for (let me = 0, _e = re.length; me < _e; me++) {
          const ge = re[me],
            Re = M(ge),
            J = I % U,
            oe = J % Re.boundary,
            ae = J + oe;
          (I += oe),
            ae !== 0 && U - ae < Re.storage && (I += U - ae),
            (ie.__data = new Float32Array(
              Re.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            (ie.__offset = I),
            (I += Re.storage);
        }
      }
    }
    const F = I % U;
    return F > 0 && (I += U - F), (C.__size = I), (C.__cache = {}), this;
  }
  function M(C) {
    const T = { boundary: 0, storage: 0 };
    return (
      typeof C == "number" || typeof C == "boolean"
        ? ((T.boundary = 4), (T.storage = 4))
        : C.isVector2
          ? ((T.boundary = 8), (T.storage = 8))
          : C.isVector3 || C.isColor
            ? ((T.boundary = 16), (T.storage = 12))
            : C.isVector4
              ? ((T.boundary = 16), (T.storage = 16))
              : C.isMatrix3
                ? ((T.boundary = 48), (T.storage = 48))
                : C.isMatrix4
                  ? ((T.boundary = 64), (T.storage = 64))
                  : C.isTexture
                    ? console.warn(
                        "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Unsupported uniform value type.",
                        C,
                      ),
      T
    );
  }
  function w(C) {
    const T = C.target;
    T.removeEventListener("dispose", w);
    const I = a.indexOf(T.__bindingPointIndex);
    a.splice(I, 1), r.deleteBuffer(i[T.id]), delete i[T.id], delete s[T.id];
  }
  function x() {
    for (const C in i) r.deleteBuffer(i[C]);
    (a = []), (i = {}), (s = {});
  }
  return { bind: c, update: d, dispose: x };
}
class gx {
  constructor(e = {}) {
    const {
      canvas: t = k5(),
      context: n = null,
      depth: i = !0,
      stencil: s = !1,
      alpha: a = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: d = !1,
      powerPreference: p = "default",
      failIfMajorPerformanceCaveat: m = !1,
      reverseDepthBuffer: y = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let v;
    if (n !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163.",
        );
      v = n.getContextAttributes().alpha;
    } else v = a;
    const A = new Uint32Array(4),
      M = new Int32Array(4);
    let w = null,
      x = null;
    const C = [],
      T = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Ei),
      (this.toneMapping = to),
      (this.toneMappingExposure = 1);
    const I = this;
    let U = !1,
      F = 0,
      O = 0,
      z = null,
      L = -1,
      N = null;
    const X = new Cn(),
      ie = new Cn();
    let re = null;
    const me = new dt(0);
    let _e = 0,
      ge = t.width,
      Re = t.height,
      J = 1,
      oe = null,
      ae = null;
    const q = new Cn(0, 0, ge, Re),
      ce = new Cn(0, 0, ge, Re);
    let Xe = !1;
    const ye = new rm();
    let Pe = !1,
      Ue = !1;
    const Fe = new jt(),
      Je = new jt(),
      et = new Y(),
      tt = new Cn(),
      be = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let Te = !1;
    function Ne() {
      return z === null ? J : 1;
    }
    let K = n;
    function qe(j, le) {
      return t.getContext(j, le);
    }
    try {
      const j = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: d,
        powerPreference: p,
        failIfMajorPerformanceCaveat: m,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Mh}`),
        t.addEventListener("webglcontextlost", te, !1),
        t.addEventListener("webglcontextrestored", Ae, !1),
        t.addEventListener("webglcontextcreationerror", pe, !1),
        K === null)
      ) {
        const le = "webgl2";
        if (((K = qe(le, j)), K === null))
          throw qe(le)
            ? new Error(
                "Error creating WebGL context with your selected attributes.",
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (j) {
      throw (console.error("THREE.WebGLRenderer: " + j.message), j);
    }
    let ct,
      Be,
      nt,
      Dt,
      it,
      Z,
      G,
      xe,
      ze,
      We,
      Oe,
      Mt,
      ot,
      ft,
      Ot,
      Ke,
      ht,
      Tt,
      st,
      xt,
      Qt,
      D,
      W,
      k;
    function ne() {
      (ct = new CD(K)),
        ct.init(),
        (D = new kS(K, ct)),
        (Be = new _D(K, ct, e, D)),
        (nt = new oN(K, ct)),
        Be.reverseDepthBuffer && y && nt.buffers.depth.setReversed(!0),
        (Dt = new ID(K)),
        (it = new YF()),
        (Z = new lN(K, ct, nt, it, Be, D, Dt)),
        (G = new wD(I)),
        (xe = new ED(I)),
        (ze = new UB(K)),
        (W = new xD(K, ze)),
        (We = new TD(K, ze, Dt, W)),
        (Oe = new PD(K, We, ze, Dt)),
        (st = new BD(K, Be, Z)),
        (Ke = new AD(it)),
        (Mt = new JF(I, G, xe, ct, Be, W, Ke)),
        (ot = new mN(I, it)),
        (ft = new qF()),
        (Ot = new nN(ct)),
        (Tt = new vD(I, G, xe, nt, Oe, v, c)),
        (ht = new sN(I, Oe, Be)),
        (k = new gN(K, Dt, Be, nt)),
        (xt = new bD(K, ct, Dt)),
        (Qt = new RD(K, ct, Dt)),
        (Dt.programs = Mt.programs),
        (I.capabilities = Be),
        (I.extensions = ct),
        (I.properties = it),
        (I.renderLists = ft),
        (I.shadowMap = ht),
        (I.state = nt),
        (I.info = Dt);
    }
    ne();
    const Q = new fN(I, K);
    (this.xr = Q),
      (this.getContext = function () {
        return K;
      }),
      (this.getContextAttributes = function () {
        return K.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const j = ct.get("WEBGL_lose_context");
        j && j.loseContext();
      }),
      (this.forceContextRestore = function () {
        const j = ct.get("WEBGL_lose_context");
        j && j.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return J;
      }),
      (this.setPixelRatio = function (j) {
        j !== void 0 && ((J = j), this.setSize(ge, Re, !1));
      }),
      (this.getSize = function (j) {
        return j.set(ge, Re);
      }),
      (this.setSize = function (j, le, Me = !0) {
        if (Q.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
          );
          return;
        }
        (ge = j),
          (Re = le),
          (t.width = Math.floor(j * J)),
          (t.height = Math.floor(le * J)),
          Me === !0 &&
            ((t.style.width = j + "px"), (t.style.height = le + "px")),
          this.setViewport(0, 0, j, le);
      }),
      (this.getDrawingBufferSize = function (j) {
        return j.set(ge * J, Re * J).floor();
      }),
      (this.setDrawingBufferSize = function (j, le, Me) {
        (ge = j),
          (Re = le),
          (J = Me),
          (t.width = Math.floor(j * Me)),
          (t.height = Math.floor(le * Me)),
          this.setViewport(0, 0, j, le);
      }),
      (this.getCurrentViewport = function (j) {
        return j.copy(X);
      }),
      (this.getViewport = function (j) {
        return j.copy(q);
      }),
      (this.setViewport = function (j, le, Me, Ee) {
        j.isVector4 ? q.set(j.x, j.y, j.z, j.w) : q.set(j, le, Me, Ee),
          nt.viewport(X.copy(q).multiplyScalar(J).round());
      }),
      (this.getScissor = function (j) {
        return j.copy(ce);
      }),
      (this.setScissor = function (j, le, Me, Ee) {
        j.isVector4 ? ce.set(j.x, j.y, j.z, j.w) : ce.set(j, le, Me, Ee),
          nt.scissor(ie.copy(ce).multiplyScalar(J).round());
      }),
      (this.getScissorTest = function () {
        return Xe;
      }),
      (this.setScissorTest = function (j) {
        nt.setScissorTest((Xe = j));
      }),
      (this.setOpaqueSort = function (j) {
        oe = j;
      }),
      (this.setTransparentSort = function (j) {
        ae = j;
      }),
      (this.getClearColor = function (j) {
        return j.copy(Tt.getClearColor());
      }),
      (this.setClearColor = function () {
        Tt.setClearColor.apply(Tt, arguments);
      }),
      (this.getClearAlpha = function () {
        return Tt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Tt.setClearAlpha.apply(Tt, arguments);
      }),
      (this.clear = function (j = !0, le = !0, Me = !0) {
        let Ee = 0;
        if (j) {
          let se = !1;
          if (z !== null) {
            const Ge = z.texture.format;
            se = Ge === Lg || Ge === Pg || Ge === Qp;
          }
          if (se) {
            const Ge = z.texture.type,
              pt =
                Ge === hs ||
                Ge === so ||
                Ge === ph ||
                Ge === Lc ||
                Ge === Ig ||
                Ge === Bg,
              _t = Tt.getClearColor(),
              St = Tt.getClearAlpha(),
              zt = _t.r,
              Ut = _t.g,
              gt = _t.b;
            pt
              ? ((A[0] = zt),
                (A[1] = Ut),
                (A[2] = gt),
                (A[3] = St),
                K.clearBufferuiv(K.COLOR, 0, A))
              : ((M[0] = zt),
                (M[1] = Ut),
                (M[2] = gt),
                (M[3] = St),
                K.clearBufferiv(K.COLOR, 0, M));
          } else Ee |= K.COLOR_BUFFER_BIT;
        }
        le && (Ee |= K.DEPTH_BUFFER_BIT),
          Me &&
            ((Ee |= K.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          K.clear(Ee);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", te, !1),
          t.removeEventListener("webglcontextrestored", Ae, !1),
          t.removeEventListener("webglcontextcreationerror", pe, !1),
          Tt.dispose(),
          ft.dispose(),
          Ot.dispose(),
          it.dispose(),
          G.dispose(),
          xe.dispose(),
          Oe.dispose(),
          W.dispose(),
          k.dispose(),
          Mt.dispose(),
          Q.dispose(),
          Q.removeEventListener("sessionstart", It),
          Q.removeEventListener("sessionend", Ht),
          Wt.stop();
      });
    function te(j) {
      j.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (U = !0);
    }
    function Ae() {
      console.log("THREE.WebGLRenderer: Context Restored."), (U = !1);
      const j = Dt.autoReset,
        le = ht.enabled,
        Me = ht.autoUpdate,
        Ee = ht.needsUpdate,
        se = ht.type;
      ne(),
        (Dt.autoReset = j),
        (ht.enabled = le),
        (ht.autoUpdate = Me),
        (ht.needsUpdate = Ee),
        (ht.type = se);
    }
    function pe(j) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        j.statusMessage,
      );
    }
    function Ve(j) {
      const le = j.target;
      le.removeEventListener("dispose", Ve), He(le);
    }
    function He(j) {
      Qe(j), it.remove(j);
    }
    function Qe(j) {
      const le = it.get(j).programs;
      le !== void 0 &&
        (le.forEach(function (Me) {
          Mt.releaseProgram(Me);
        }),
        j.isShaderMaterial && Mt.releaseShaderCache(j));
    }
    this.renderBufferDirect = function (j, le, Me, Ee, se, Ge) {
      le === null && (le = be);
      const pt = se.isMesh && se.matrixWorld.determinant() < 0,
        _t = hi(j, le, Me, Ee, se);
      nt.setMaterial(Ee, pt);
      let St = Me.index,
        zt = 1;
      if (Ee.wireframe === !0) {
        if (((St = We.getWireframeAttribute(Me)), St === void 0)) return;
        zt = 2;
      }
      const Ut = Me.drawRange,
        gt = Me.attributes.position;
      let At = Ut.start * zt,
        hn = (Ut.start + Ut.count) * zt;
      Ge !== null &&
        ((At = Math.max(At, Ge.start * zt)),
        (hn = Math.min(hn, (Ge.start + Ge.count) * zt))),
        St !== null
          ? ((At = Math.max(At, 0)), (hn = Math.min(hn, St.count)))
          : gt != null &&
            ((At = Math.max(At, 0)), (hn = Math.min(hn, gt.count)));
      const Jt = hn - At;
      if (Jt < 0 || Jt === 1 / 0) return;
      W.setup(se, Ee, _t, Me, St);
      let $t,
        gn = xt;
      if (
        (St !== null && (($t = ze.get(St)), (gn = Qt), gn.setIndex($t)),
        se.isMesh)
      )
        Ee.wireframe === !0
          ? (nt.setLineWidth(Ee.wireframeLinewidth * Ne()), gn.setMode(K.LINES))
          : gn.setMode(K.TRIANGLES);
      else if (se.isLine) {
        let Ft = Ee.linewidth;
        Ft === void 0 && (Ft = 1),
          nt.setLineWidth(Ft * Ne()),
          se.isLineSegments
            ? gn.setMode(K.LINES)
            : se.isLineLoop
              ? gn.setMode(K.LINE_LOOP)
              : gn.setMode(K.LINE_STRIP);
      } else
        se.isPoints
          ? gn.setMode(K.POINTS)
          : se.isSprite && gn.setMode(K.TRIANGLES);
      if (se.isBatchedMesh)
        if (se._multiDrawInstances !== null)
          gn.renderMultiDrawInstances(
            se._multiDrawStarts,
            se._multiDrawCounts,
            se._multiDrawCount,
            se._multiDrawInstances,
          );
        else if (ct.get("WEBGL_multi_draw"))
          gn.renderMultiDraw(
            se._multiDrawStarts,
            se._multiDrawCounts,
            se._multiDrawCount,
          );
        else {
          const Ft = se._multiDrawStarts,
            vn = se._multiDrawCounts,
            $r = se._multiDrawCount,
            Mr = St ? ze.get(St).bytesPerElement : 1,
            Yi = it.get(Ee).currentProgram.getUniforms();
          for (let Sr = 0; Sr < $r; Sr++)
            Yi.setValue(K, "_gl_DrawID", Sr), gn.render(Ft[Sr] / Mr, vn[Sr]);
        }
      else if (se.isInstancedMesh) gn.renderInstances(At, Jt, se.count);
      else if (Me.isInstancedBufferGeometry) {
        const Ft =
            Me._maxInstanceCount !== void 0 ? Me._maxInstanceCount : 1 / 0,
          vn = Math.min(Me.instanceCount, Ft);
        gn.renderInstances(At, Jt, vn);
      } else gn.render(At, Jt);
    };
    function ke(j, le, Me) {
      j.transparent === !0 && j.side === Xs && j.forceSinglePass === !1
        ? ((j.side = Ji),
          (j.needsUpdate = !0),
          Fr(j, le, Me),
          (j.side = ro),
          (j.needsUpdate = !0),
          Fr(j, le, Me),
          (j.side = Xs))
        : Fr(j, le, Me);
    }
    (this.compile = function (j, le, Me = null) {
      Me === null && (Me = j),
        (x = Ot.get(Me)),
        x.init(le),
        T.push(x),
        Me.traverseVisible(function (se) {
          se.isLight &&
            se.layers.test(le.layers) &&
            (x.pushLight(se), se.castShadow && x.pushShadow(se));
        }),
        j !== Me &&
          j.traverseVisible(function (se) {
            se.isLight &&
              se.layers.test(le.layers) &&
              (x.pushLight(se), se.castShadow && x.pushShadow(se));
          }),
        x.setupLights();
      const Ee = new Set();
      return (
        j.traverse(function (se) {
          if (!(se.isMesh || se.isPoints || se.isLine || se.isSprite)) return;
          const Ge = se.material;
          if (Ge)
            if (Array.isArray(Ge))
              for (let pt = 0; pt < Ge.length; pt++) {
                const _t = Ge[pt];
                ke(_t, Me, se), Ee.add(_t);
              }
            else ke(Ge, Me, se), Ee.add(Ge);
        }),
        T.pop(),
        (x = null),
        Ee
      );
    }),
      (this.compileAsync = function (j, le, Me = null) {
        const Ee = this.compile(j, le, Me);
        return new Promise((se) => {
          function Ge() {
            if (
              (Ee.forEach(function (pt) {
                it.get(pt).currentProgram.isReady() && Ee.delete(pt);
              }),
              Ee.size === 0)
            ) {
              se(j);
              return;
            }
            setTimeout(Ge, 10);
          }
          ct.get("KHR_parallel_shader_compile") !== null
            ? Ge()
            : setTimeout(Ge, 10);
        });
      });
    let nn = null;
    function vt(j) {
      nn && nn(j);
    }
    function It() {
      Wt.stop();
    }
    function Ht() {
      Wt.start();
    }
    const Wt = new DS();
    Wt.setAnimationLoop(vt),
      typeof self < "u" && Wt.setContext(self),
      (this.setAnimationLoop = function (j) {
        (nn = j), Q.setAnimationLoop(j), j === null ? Wt.stop() : Wt.start();
      }),
      Q.addEventListener("sessionstart", It),
      Q.addEventListener("sessionend", Ht),
      (this.render = function (j, le) {
        if (le !== void 0 && le.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
          );
          return;
        }
        if (U === !0) return;
        if (
          (j.matrixWorldAutoUpdate === !0 && j.updateMatrixWorld(),
          le.parent === null &&
            le.matrixWorldAutoUpdate === !0 &&
            le.updateMatrixWorld(),
          Q.enabled === !0 &&
            Q.isPresenting === !0 &&
            (Q.cameraAutoUpdate === !0 && Q.updateCamera(le),
            (le = Q.getCamera())),
          j.isScene === !0 && j.onBeforeRender(I, j, le, z),
          (x = Ot.get(j, T.length)),
          x.init(le),
          T.push(x),
          Je.multiplyMatrices(le.projectionMatrix, le.matrixWorldInverse),
          ye.setFromProjectionMatrix(Je),
          (Ue = this.localClippingEnabled),
          (Pe = Ke.init(this.clippingPlanes, Ue)),
          (w = ft.get(j, C.length)),
          w.init(),
          C.push(w),
          Q.enabled === !0 && Q.isPresenting === !0)
        ) {
          const Ge = I.xr.getDepthSensingMesh();
          Ge !== null && dn(Ge, le, -1 / 0, I.sortObjects);
        }
        dn(j, le, 0, I.sortObjects),
          w.finish(),
          I.sortObjects === !0 && w.sort(oe, ae),
          (Te =
            Q.enabled === !1 ||
            Q.isPresenting === !1 ||
            Q.hasDepthSensing() === !1),
          Te && Tt.addToRenderList(w, j),
          this.info.render.frame++,
          Pe === !0 && Ke.beginShadows();
        const Me = x.state.shadowsArray;
        ht.render(Me, j, le),
          Pe === !0 && Ke.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Ee = w.opaque,
          se = w.transmissive;
        if ((x.setupLights(), le.isArrayCamera)) {
          const Ge = le.cameras;
          if (se.length > 0)
            for (let pt = 0, _t = Ge.length; pt < _t; pt++) {
              const St = Ge[pt];
              mn(Ee, se, j, St);
            }
          Te && Tt.render(j);
          for (let pt = 0, _t = Ge.length; pt < _t; pt++) {
            const St = Ge[pt];
            An(w, j, St, St.viewport);
          }
        } else
          se.length > 0 && mn(Ee, se, j, le), Te && Tt.render(j), An(w, j, le);
        z !== null &&
          (Z.updateMultisampleRenderTarget(z), Z.updateRenderTargetMipmap(z)),
          j.isScene === !0 && j.onAfterRender(I, j, le),
          W.resetDefaultState(),
          (L = -1),
          (N = null),
          T.pop(),
          T.length > 0
            ? ((x = T[T.length - 1]),
              Pe === !0 && Ke.setGlobalState(I.clippingPlanes, x.state.camera))
            : (x = null),
          C.pop(),
          C.length > 0 ? (w = C[C.length - 1]) : (w = null);
      });
    function dn(j, le, Me, Ee) {
      if (j.visible === !1) return;
      if (j.layers.test(le.layers)) {
        if (j.isGroup) Me = j.renderOrder;
        else if (j.isLOD) j.autoUpdate === !0 && j.update(le);
        else if (j.isLight) x.pushLight(j), j.castShadow && x.pushShadow(j);
        else if (j.isSprite) {
          if (!j.frustumCulled || ye.intersectsSprite(j)) {
            Ee && tt.setFromMatrixPosition(j.matrixWorld).applyMatrix4(Je);
            const Ge = Oe.update(j),
              pt = j.material;
            pt.visible && w.push(j, Ge, pt, Me, tt.z, null);
          }
        } else if (
          (j.isMesh || j.isLine || j.isPoints) &&
          (!j.frustumCulled || ye.intersectsObject(j))
        ) {
          const Ge = Oe.update(j),
            pt = j.material;
          if (
            (Ee &&
              (j.boundingSphere !== void 0
                ? (j.boundingSphere === null && j.computeBoundingSphere(),
                  tt.copy(j.boundingSphere.center))
                : (Ge.boundingSphere === null && Ge.computeBoundingSphere(),
                  tt.copy(Ge.boundingSphere.center)),
              tt.applyMatrix4(j.matrixWorld).applyMatrix4(Je)),
            Array.isArray(pt))
          ) {
            const _t = Ge.groups;
            for (let St = 0, zt = _t.length; St < zt; St++) {
              const Ut = _t[St],
                gt = pt[Ut.materialIndex];
              gt && gt.visible && w.push(j, Ge, gt, Me, tt.z, Ut);
            }
          } else pt.visible && w.push(j, Ge, pt, Me, tt.z, null);
        }
      }
      const se = j.children;
      for (let Ge = 0, pt = se.length; Ge < pt; Ge++) dn(se[Ge], le, Me, Ee);
    }
    function An(j, le, Me, Ee) {
      const se = j.opaque,
        Ge = j.transmissive,
        pt = j.transparent;
      x.setupLightsView(Me),
        Pe === !0 && Ke.setGlobalState(I.clippingPlanes, Me),
        Ee && nt.viewport(X.copy(Ee)),
        se.length > 0 && Wn(se, le, Me),
        Ge.length > 0 && Wn(Ge, le, Me),
        pt.length > 0 && Wn(pt, le, Me),
        nt.buffers.depth.setTest(!0),
        nt.buffers.depth.setMask(!0),
        nt.buffers.color.setMask(!0),
        nt.setPolygonOffset(!1);
    }
    function mn(j, le, Me, Ee) {
      if ((Me.isScene === !0 ? Me.overrideMaterial : null) !== null) return;
      x.state.transmissionRenderTarget[Ee.id] === void 0 &&
        (x.state.transmissionRenderTarget[Ee.id] = new Es(1, 1, {
          generateMipmaps: !0,
          type:
            ct.has("EXT_color_buffer_half_float") ||
            ct.has("EXT_color_buffer_float")
              ? Kr
              : hs,
          minFilter: Ys,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Sn.workingColorSpace,
        }));
      const se = x.state.transmissionRenderTarget[Ee.id],
        Ge = Ee.viewport || X;
      se.setSize(Ge.z, Ge.w);
      const pt = I.getRenderTarget();
      I.setRenderTarget(se),
        I.getClearColor(me),
        (_e = I.getClearAlpha()),
        _e < 1 && I.setClearColor(16777215, 0.5),
        I.clear(),
        Te && Tt.render(Me);
      const _t = I.toneMapping;
      I.toneMapping = to;
      const St = Ee.viewport;
      if (
        (Ee.viewport !== void 0 && (Ee.viewport = void 0),
        x.setupLightsView(Ee),
        Pe === !0 && Ke.setGlobalState(I.clippingPlanes, Ee),
        Wn(j, Me, Ee),
        Z.updateMultisampleRenderTarget(se),
        Z.updateRenderTargetMipmap(se),
        ct.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let zt = !1;
        for (let Ut = 0, gt = le.length; Ut < gt; Ut++) {
          const At = le[Ut],
            hn = At.object,
            Jt = At.geometry,
            $t = At.material,
            gn = At.group;
          if ($t.side === Xs && hn.layers.test(Ee.layers)) {
            const Ft = $t.side;
            ($t.side = Ji),
              ($t.needsUpdate = !0),
              wn(hn, Me, Ee, Jt, $t, gn),
              ($t.side = Ft),
              ($t.needsUpdate = !0),
              (zt = !0);
          }
        }
        zt === !0 &&
          (Z.updateMultisampleRenderTarget(se), Z.updateRenderTargetMipmap(se));
      }
      I.setRenderTarget(pt),
        I.setClearColor(me, _e),
        St !== void 0 && (Ee.viewport = St),
        (I.toneMapping = _t);
    }
    function Wn(j, le, Me) {
      const Ee = le.isScene === !0 ? le.overrideMaterial : null;
      for (let se = 0, Ge = j.length; se < Ge; se++) {
        const pt = j[se],
          _t = pt.object,
          St = pt.geometry,
          zt = Ee === null ? pt.material : Ee,
          Ut = pt.group;
        _t.layers.test(Me.layers) && wn(_t, le, Me, St, zt, Ut);
      }
    }
    function wn(j, le, Me, Ee, se, Ge) {
      j.onBeforeRender(I, le, Me, Ee, se, Ge),
        j.modelViewMatrix.multiplyMatrices(
          Me.matrixWorldInverse,
          j.matrixWorld,
        ),
        j.normalMatrix.getNormalMatrix(j.modelViewMatrix),
        se.onBeforeRender(I, le, Me, Ee, j, Ge),
        se.transparent === !0 && se.side === Xs && se.forceSinglePass === !1
          ? ((se.side = Ji),
            (se.needsUpdate = !0),
            I.renderBufferDirect(Me, le, Ee, se, j, Ge),
            (se.side = ro),
            (se.needsUpdate = !0),
            I.renderBufferDirect(Me, le, Ee, se, j, Ge),
            (se.side = Xs))
          : I.renderBufferDirect(Me, le, Ee, se, j, Ge),
        j.onAfterRender(I, le, Me, Ee, se, Ge);
    }
    function Fr(j, le, Me) {
      le.isScene !== !0 && (le = be);
      const Ee = it.get(j),
        se = x.state.lights,
        Ge = x.state.shadowsArray,
        pt = se.state.version,
        _t = Mt.getParameters(j, se.state, Ge, le, Me),
        St = Mt.getProgramCacheKey(_t);
      let zt = Ee.programs;
      (Ee.environment = j.isMeshStandardMaterial ? le.environment : null),
        (Ee.fog = le.fog),
        (Ee.envMap = (j.isMeshStandardMaterial ? xe : G).get(
          j.envMap || Ee.environment,
        )),
        (Ee.envMapRotation =
          Ee.environment !== null && j.envMap === null
            ? le.environmentRotation
            : j.envMapRotation),
        zt === void 0 &&
          (j.addEventListener("dispose", Ve),
          (zt = new Map()),
          (Ee.programs = zt));
      let Ut = zt.get(St);
      if (Ut !== void 0) {
        if (Ee.currentProgram === Ut && Ee.lightsStateVersion === pt)
          return Dn(j, _t), Ut;
      } else
        (_t.uniforms = Mt.getUniforms(j)),
          j.onBeforeCompile(_t, I),
          (Ut = Mt.acquireProgram(_t, St)),
          zt.set(St, Ut),
          (Ee.uniforms = _t.uniforms);
      const gt = Ee.uniforms;
      return (
        ((!j.isShaderMaterial && !j.isRawShaderMaterial) ||
          j.clipping === !0) &&
          (gt.clippingPlanes = Ke.uniform),
        Dn(j, _t),
        (Ee.needsLights = jr(j)),
        (Ee.lightsStateVersion = pt),
        Ee.needsLights &&
          ((gt.ambientLightColor.value = se.state.ambient),
          (gt.lightProbe.value = se.state.probe),
          (gt.directionalLights.value = se.state.directional),
          (gt.directionalLightShadows.value = se.state.directionalShadow),
          (gt.spotLights.value = se.state.spot),
          (gt.spotLightShadows.value = se.state.spotShadow),
          (gt.rectAreaLights.value = se.state.rectArea),
          (gt.ltc_1.value = se.state.rectAreaLTC1),
          (gt.ltc_2.value = se.state.rectAreaLTC2),
          (gt.pointLights.value = se.state.point),
          (gt.pointLightShadows.value = se.state.pointShadow),
          (gt.hemisphereLights.value = se.state.hemi),
          (gt.directionalShadowMap.value = se.state.directionalShadowMap),
          (gt.directionalShadowMatrix.value = se.state.directionalShadowMatrix),
          (gt.spotShadowMap.value = se.state.spotShadowMap),
          (gt.spotLightMatrix.value = se.state.spotLightMatrix),
          (gt.spotLightMap.value = se.state.spotLightMap),
          (gt.pointShadowMap.value = se.state.pointShadowMap),
          (gt.pointShadowMatrix.value = se.state.pointShadowMatrix)),
        (Ee.currentProgram = Ut),
        (Ee.uniformsList = null),
        Ut
      );
    }
    function lr(j) {
      if (j.uniformsList === null) {
        const le = j.currentProgram.getUniforms();
        j.uniformsList = v0.seqWithValue(le.seq, j.uniforms);
      }
      return j.uniformsList;
    }
    function Dn(j, le) {
      const Me = it.get(j);
      (Me.outputColorSpace = le.outputColorSpace),
        (Me.batching = le.batching),
        (Me.batchingColor = le.batchingColor),
        (Me.instancing = le.instancing),
        (Me.instancingColor = le.instancingColor),
        (Me.instancingMorph = le.instancingMorph),
        (Me.skinning = le.skinning),
        (Me.morphTargets = le.morphTargets),
        (Me.morphNormals = le.morphNormals),
        (Me.morphColors = le.morphColors),
        (Me.morphTargetsCount = le.morphTargetsCount),
        (Me.numClippingPlanes = le.numClippingPlanes),
        (Me.numIntersection = le.numClipIntersection),
        (Me.vertexAlphas = le.vertexAlphas),
        (Me.vertexTangents = le.vertexTangents),
        (Me.toneMapping = le.toneMapping);
    }
    function hi(j, le, Me, Ee, se) {
      le.isScene !== !0 && (le = be), Z.resetTextureUnits();
      const Ge = le.fog,
        pt = Ee.isMeshStandardMaterial ? le.environment : null,
        _t =
          z === null
            ? I.outputColorSpace
            : z.isXRRenderTarget === !0
              ? z.texture.colorSpace
              : ao,
        St = (Ee.isMeshStandardMaterial ? xe : G).get(Ee.envMap || pt),
        zt =
          Ee.vertexColors === !0 &&
          !!Me.attributes.color &&
          Me.attributes.color.itemSize === 4,
        Ut = !!Me.attributes.tangent && (!!Ee.normalMap || Ee.anisotropy > 0),
        gt = !!Me.morphAttributes.position,
        At = !!Me.morphAttributes.normal,
        hn = !!Me.morphAttributes.color;
      let Jt = to;
      Ee.toneMapped &&
        (z === null || z.isXRRenderTarget === !0) &&
        (Jt = I.toneMapping);
      const $t =
          Me.morphAttributes.position ||
          Me.morphAttributes.normal ||
          Me.morphAttributes.color,
        gn = $t !== void 0 ? $t.length : 0,
        Ft = it.get(Ee),
        vn = x.state.lights;
      if (Pe === !0 && (Ue === !0 || j !== N)) {
        const Kn = j === N && Ee.id === L;
        Ke.setState(Ee, j, Kn);
      }
      let $r = !1;
      Ee.version === Ft.__version
        ? ((Ft.needsLights && Ft.lightsStateVersion !== vn.state.version) ||
            Ft.outputColorSpace !== _t ||
            (se.isBatchedMesh && Ft.batching === !1) ||
            (!se.isBatchedMesh && Ft.batching === !0) ||
            (se.isBatchedMesh &&
              Ft.batchingColor === !0 &&
              se.colorTexture === null) ||
            (se.isBatchedMesh &&
              Ft.batchingColor === !1 &&
              se.colorTexture !== null) ||
            (se.isInstancedMesh && Ft.instancing === !1) ||
            (!se.isInstancedMesh && Ft.instancing === !0) ||
            (se.isSkinnedMesh && Ft.skinning === !1) ||
            (!se.isSkinnedMesh && Ft.skinning === !0) ||
            (se.isInstancedMesh &&
              Ft.instancingColor === !0 &&
              se.instanceColor === null) ||
            (se.isInstancedMesh &&
              Ft.instancingColor === !1 &&
              se.instanceColor !== null) ||
            (se.isInstancedMesh &&
              Ft.instancingMorph === !0 &&
              se.morphTexture === null) ||
            (se.isInstancedMesh &&
              Ft.instancingMorph === !1 &&
              se.morphTexture !== null) ||
            Ft.envMap !== St ||
            (Ee.fog === !0 && Ft.fog !== Ge) ||
            (Ft.numClippingPlanes !== void 0 &&
              (Ft.numClippingPlanes !== Ke.numPlanes ||
                Ft.numIntersection !== Ke.numIntersection)) ||
            Ft.vertexAlphas !== zt ||
            Ft.vertexTangents !== Ut ||
            Ft.morphTargets !== gt ||
            Ft.morphNormals !== At ||
            Ft.morphColors !== hn ||
            Ft.toneMapping !== Jt ||
            Ft.morphTargetsCount !== gn) &&
          ($r = !0)
        : (($r = !0), (Ft.__version = Ee.version));
      let Mr = Ft.currentProgram;
      $r === !0 && (Mr = Fr(Ee, le, se));
      let Yi = !1,
        Sr = !1,
        Ra = !1;
      const cn = Mr.getUniforms(),
        ei = Ft.uniforms;
      if (
        (nt.useProgram(Mr.program) && ((Yi = !0), (Sr = !0), (Ra = !0)),
        Ee.id !== L && ((L = Ee.id), (Sr = !0)),
        Yi || N !== j)
      ) {
        nt.buffers.depth.getReversed()
          ? (Fe.copy(j.projectionMatrix),
            fR(Fe),
            pR(Fe),
            cn.setValue(K, "projectionMatrix", Fe))
          : cn.setValue(K, "projectionMatrix", j.projectionMatrix),
          cn.setValue(K, "viewMatrix", j.matrixWorldInverse);
        const Kn = cn.map.cameraPosition;
        Kn !== void 0 &&
          Kn.setValue(K, et.setFromMatrixPosition(j.matrixWorld)),
          Be.logarithmicDepthBuffer &&
            cn.setValue(
              K,
              "logDepthBufFC",
              2 / (Math.log(j.far + 1) / Math.LN2),
            ),
          (Ee.isMeshPhongMaterial ||
            Ee.isMeshToonMaterial ||
            Ee.isMeshLambertMaterial ||
            Ee.isMeshBasicMaterial ||
            Ee.isMeshStandardMaterial ||
            Ee.isShaderMaterial) &&
            cn.setValue(K, "isOrthographic", j.isOrthographicCamera === !0),
          N !== j && ((N = j), (Sr = !0), (Ra = !0));
      }
      if (se.isSkinnedMesh) {
        cn.setOptional(K, se, "bindMatrix"),
          cn.setOptional(K, se, "bindMatrixInverse");
        const Kn = se.skeleton;
        Kn &&
          (Kn.boneTexture === null && Kn.computeBoneTexture(),
          cn.setValue(K, "boneTexture", Kn.boneTexture, Z));
      }
      se.isBatchedMesh &&
        (cn.setOptional(K, se, "batchingTexture"),
        cn.setValue(K, "batchingTexture", se._matricesTexture, Z),
        cn.setOptional(K, se, "batchingIdTexture"),
        cn.setValue(K, "batchingIdTexture", se._indirectTexture, Z),
        cn.setOptional(K, se, "batchingColorTexture"),
        se._colorsTexture !== null &&
          cn.setValue(K, "batchingColorTexture", se._colorsTexture, Z));
      const Wr = Me.morphAttributes;
      if (
        ((Wr.position !== void 0 ||
          Wr.normal !== void 0 ||
          Wr.color !== void 0) &&
          st.update(se, Me, Mr),
        (Sr || Ft.receiveShadow !== se.receiveShadow) &&
          ((Ft.receiveShadow = se.receiveShadow),
          cn.setValue(K, "receiveShadow", se.receiveShadow)),
        Ee.isMeshGouraudMaterial &&
          Ee.envMap !== null &&
          ((ei.envMap.value = St),
          (ei.flipEnvMap.value =
            St.isCubeTexture && St.isRenderTargetTexture === !1 ? -1 : 1)),
        Ee.isMeshStandardMaterial &&
          Ee.envMap === null &&
          le.environment !== null &&
          (ei.envMapIntensity.value = le.environmentIntensity),
        Sr &&
          (cn.setValue(K, "toneMappingExposure", I.toneMappingExposure),
          Ft.needsLights && ps(ei, Ra),
          Ge && Ee.fog === !0 && ot.refreshFogUniforms(ei, Ge),
          ot.refreshMaterialUniforms(
            ei,
            Ee,
            J,
            Re,
            x.state.transmissionRenderTarget[j.id],
          ),
          v0.upload(K, lr(Ft), ei, Z)),
        Ee.isShaderMaterial &&
          Ee.uniformsNeedUpdate === !0 &&
          (v0.upload(K, lr(Ft), ei, Z), (Ee.uniformsNeedUpdate = !1)),
        Ee.isSpriteMaterial && cn.setValue(K, "center", se.center),
        cn.setValue(K, "modelViewMatrix", se.modelViewMatrix),
        cn.setValue(K, "normalMatrix", se.normalMatrix),
        cn.setValue(K, "modelMatrix", se.matrixWorld),
        Ee.isShaderMaterial || Ee.isRawShaderMaterial)
      ) {
        const Kn = Ee.uniformsGroups;
        for (let Xr = 0, Ts = Kn.length; Xr < Ts; Xr++) {
          const rn = Kn[Xr];
          k.update(rn, Mr), k.bind(rn, Mr);
        }
      }
      return Mr;
    }
    function ps(j, le) {
      (j.ambientLightColor.needsUpdate = le),
        (j.lightProbe.needsUpdate = le),
        (j.directionalLights.needsUpdate = le),
        (j.directionalLightShadows.needsUpdate = le),
        (j.pointLights.needsUpdate = le),
        (j.pointLightShadows.needsUpdate = le),
        (j.spotLights.needsUpdate = le),
        (j.spotLightShadows.needsUpdate = le),
        (j.rectAreaLights.needsUpdate = le),
        (j.hemisphereLights.needsUpdate = le);
    }
    function jr(j) {
      return (
        j.isMeshLambertMaterial ||
        j.isMeshToonMaterial ||
        j.isMeshPhongMaterial ||
        j.isMeshStandardMaterial ||
        j.isShadowMaterial ||
        (j.isShaderMaterial && j.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return F;
    }),
      (this.getActiveMipmapLevel = function () {
        return O;
      }),
      (this.getRenderTarget = function () {
        return z;
      }),
      (this.setRenderTargetTextures = function (j, le, Me) {
        (it.get(j.texture).__webglTexture = le),
          (it.get(j.depthTexture).__webglTexture = Me);
        const Ee = it.get(j);
        (Ee.__hasExternalTextures = !0),
          (Ee.__autoAllocateDepthBuffer = Me === void 0),
          Ee.__autoAllocateDepthBuffer ||
            (ct.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
              ),
              (Ee.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (j, le) {
        const Me = it.get(j);
        (Me.__webglFramebuffer = le),
          (Me.__useDefaultFramebuffer = le === void 0);
      }),
      (this.setRenderTarget = function (j, le = 0, Me = 0) {
        (z = j), (F = le), (O = Me);
        let Ee = !0,
          se = null,
          Ge = !1,
          pt = !1;
        if (j) {
          const _t = it.get(j);
          if (_t.__useDefaultFramebuffer !== void 0)
            nt.bindFramebuffer(K.FRAMEBUFFER, null), (Ee = !1);
          else if (_t.__webglFramebuffer === void 0) Z.setupRenderTarget(j);
          else if (_t.__hasExternalTextures)
            Z.rebindTextures(
              j,
              it.get(j.texture).__webglTexture,
              it.get(j.depthTexture).__webglTexture,
            );
          else if (j.depthBuffer) {
            const Ut = j.depthTexture;
            if (_t.__boundDepthTexture !== Ut) {
              if (
                Ut !== null &&
                it.has(Ut) &&
                (j.width !== Ut.image.width || j.height !== Ut.image.height)
              )
                throw new Error(
                  "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.",
                );
              Z.setupDepthRenderbuffer(j);
            }
          }
          const St = j.texture;
          (St.isData3DTexture ||
            St.isDataArrayTexture ||
            St.isCompressedArrayTexture) &&
            (pt = !0);
          const zt = it.get(j).__webglFramebuffer;
          j.isWebGLCubeRenderTarget
            ? (Array.isArray(zt[le]) ? (se = zt[le][Me]) : (se = zt[le]),
              (Ge = !0))
            : j.samples > 0 && Z.useMultisampledRTT(j) === !1
              ? (se = it.get(j).__webglMultisampledFramebuffer)
              : Array.isArray(zt)
                ? (se = zt[Me])
                : (se = zt),
            X.copy(j.viewport),
            ie.copy(j.scissor),
            (re = j.scissorTest);
        } else
          X.copy(q).multiplyScalar(J).floor(),
            ie.copy(ce).multiplyScalar(J).floor(),
            (re = Xe);
        if (
          (nt.bindFramebuffer(K.FRAMEBUFFER, se) && Ee && nt.drawBuffers(j, se),
          nt.viewport(X),
          nt.scissor(ie),
          nt.setScissorTest(re),
          Ge)
        ) {
          const _t = it.get(j.texture);
          K.framebufferTexture2D(
            K.FRAMEBUFFER,
            K.COLOR_ATTACHMENT0,
            K.TEXTURE_CUBE_MAP_POSITIVE_X + le,
            _t.__webglTexture,
            Me,
          );
        } else if (pt) {
          const _t = it.get(j.texture),
            St = le || 0;
          K.framebufferTextureLayer(
            K.FRAMEBUFFER,
            K.COLOR_ATTACHMENT0,
            _t.__webglTexture,
            Me || 0,
            St,
          );
        }
        L = -1;
      }),
      (this.readRenderTargetPixels = function (j, le, Me, Ee, se, Ge, pt) {
        if (!(j && j.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
          return;
        }
        let _t = it.get(j).__webglFramebuffer;
        if ((j.isWebGLCubeRenderTarget && pt !== void 0 && (_t = _t[pt]), _t)) {
          nt.bindFramebuffer(K.FRAMEBUFFER, _t);
          try {
            const St = j.texture,
              zt = St.format,
              Ut = St.type;
            if (!Be.textureFormatReadable(zt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
              );
              return;
            }
            if (!Be.textureTypeReadable(Ut)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
              return;
            }
            le >= 0 &&
              le <= j.width - Ee &&
              Me >= 0 &&
              Me <= j.height - se &&
              K.readPixels(le, Me, Ee, se, D.convert(zt), D.convert(Ut), Ge);
          } finally {
            const St = z !== null ? it.get(z).__webglFramebuffer : null;
            nt.bindFramebuffer(K.FRAMEBUFFER, St);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        j,
        le,
        Me,
        Ee,
        se,
        Ge,
        pt,
      ) {
        if (!(j && j.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
        let _t = it.get(j).__webglFramebuffer;
        if ((j.isWebGLCubeRenderTarget && pt !== void 0 && (_t = _t[pt]), _t)) {
          const St = j.texture,
            zt = St.format,
            Ut = St.type;
          if (!Be.textureFormatReadable(zt))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.",
            );
          if (!Be.textureTypeReadable(Ut))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.",
            );
          if (le >= 0 && le <= j.width - Ee && Me >= 0 && Me <= j.height - se) {
            nt.bindFramebuffer(K.FRAMEBUFFER, _t);
            const gt = K.createBuffer();
            K.bindBuffer(K.PIXEL_PACK_BUFFER, gt),
              K.bufferData(K.PIXEL_PACK_BUFFER, Ge.byteLength, K.STREAM_READ),
              K.readPixels(le, Me, Ee, se, D.convert(zt), D.convert(Ut), 0);
            const At = z !== null ? it.get(z).__webglFramebuffer : null;
            nt.bindFramebuffer(K.FRAMEBUFFER, At);
            const hn = K.fenceSync(K.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              K.flush(),
              await hR(K, hn, 4),
              K.bindBuffer(K.PIXEL_PACK_BUFFER, gt),
              K.getBufferSubData(K.PIXEL_PACK_BUFFER, 0, Ge),
              K.deleteBuffer(gt),
              K.deleteSync(hn),
              Ge
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.",
            );
        }
      }),
      (this.copyFramebufferToTexture = function (j, le = null, Me = 0) {
        j.isTexture !== !0 &&
          (Zd(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed.",
          ),
          (le = arguments[0] || null),
          (j = arguments[1]));
        const Ee = Math.pow(2, -Me),
          se = Math.floor(j.image.width * Ee),
          Ge = Math.floor(j.image.height * Ee),
          pt = le !== null ? le.x : 0,
          _t = le !== null ? le.y : 0;
        Z.setTexture2D(j, 0),
          K.copyTexSubImage2D(K.TEXTURE_2D, Me, 0, 0, pt, _t, se, Ge),
          nt.unbindTexture();
      });
    const Fn = K.createFramebuffer(),
      Zn = K.createFramebuffer();
    (this.copyTextureToTexture = function (
      j,
      le,
      Me = null,
      Ee = null,
      se = 0,
      Ge = null,
    ) {
      j.isTexture !== !0 &&
        (Zd(
          "WebGLRenderer: copyTextureToTexture function signature has changed.",
        ),
        (Ee = arguments[0] || null),
        (j = arguments[1]),
        (le = arguments[2]),
        (Ge = arguments[3] || 0),
        (Me = null)),
        Ge === null &&
          (se !== 0
            ? (Zd(
                "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.",
              ),
              (Ge = se),
              (se = 0))
            : (Ge = 0));
      let pt, _t, St, zt, Ut, gt, At, hn, Jt;
      const $t = j.isCompressedTexture ? j.mipmaps[Ge] : j.image;
      if (Me !== null)
        (pt = Me.max.x - Me.min.x),
          (_t = Me.max.y - Me.min.y),
          (St = Me.isBox3 ? Me.max.z - Me.min.z : 1),
          (zt = Me.min.x),
          (Ut = Me.min.y),
          (gt = Me.isBox3 ? Me.min.z : 0);
      else {
        const Wr = Math.pow(2, -se);
        (pt = Math.floor($t.width * Wr)),
          (_t = Math.floor($t.height * Wr)),
          j.isDataArrayTexture
            ? (St = $t.depth)
            : j.isData3DTexture
              ? (St = Math.floor($t.depth * Wr))
              : (St = 1),
          (zt = 0),
          (Ut = 0),
          (gt = 0);
      }
      Ee !== null
        ? ((At = Ee.x), (hn = Ee.y), (Jt = Ee.z))
        : ((At = 0), (hn = 0), (Jt = 0));
      const gn = D.convert(le.format),
        Ft = D.convert(le.type);
      let vn;
      le.isData3DTexture
        ? (Z.setTexture3D(le, 0), (vn = K.TEXTURE_3D))
        : le.isDataArrayTexture || le.isCompressedArrayTexture
          ? (Z.setTexture2DArray(le, 0), (vn = K.TEXTURE_2D_ARRAY))
          : (Z.setTexture2D(le, 0), (vn = K.TEXTURE_2D)),
        K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, le.flipY),
        K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, le.premultiplyAlpha),
        K.pixelStorei(K.UNPACK_ALIGNMENT, le.unpackAlignment);
      const $r = K.getParameter(K.UNPACK_ROW_LENGTH),
        Mr = K.getParameter(K.UNPACK_IMAGE_HEIGHT),
        Yi = K.getParameter(K.UNPACK_SKIP_PIXELS),
        Sr = K.getParameter(K.UNPACK_SKIP_ROWS),
        Ra = K.getParameter(K.UNPACK_SKIP_IMAGES);
      K.pixelStorei(K.UNPACK_ROW_LENGTH, $t.width),
        K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, $t.height),
        K.pixelStorei(K.UNPACK_SKIP_PIXELS, zt),
        K.pixelStorei(K.UNPACK_SKIP_ROWS, Ut),
        K.pixelStorei(K.UNPACK_SKIP_IMAGES, gt);
      const cn = j.isDataArrayTexture || j.isData3DTexture,
        ei = le.isDataArrayTexture || le.isData3DTexture;
      if (j.isDepthTexture) {
        const Wr = it.get(j),
          Kn = it.get(le),
          Xr = it.get(Wr.__renderTarget),
          Ts = it.get(Kn.__renderTarget);
        nt.bindFramebuffer(K.READ_FRAMEBUFFER, Xr.__webglFramebuffer),
          nt.bindFramebuffer(K.DRAW_FRAMEBUFFER, Ts.__webglFramebuffer);
        for (let rn = 0; rn < St; rn++)
          cn &&
            (K.framebufferTextureLayer(
              K.READ_FRAMEBUFFER,
              K.COLOR_ATTACHMENT0,
              it.get(j).__webglTexture,
              se,
              gt + rn,
            ),
            K.framebufferTextureLayer(
              K.DRAW_FRAMEBUFFER,
              K.COLOR_ATTACHMENT0,
              it.get(le).__webglTexture,
              Ge,
              Jt + rn,
            )),
            K.blitFramebuffer(
              zt,
              Ut,
              pt,
              _t,
              At,
              hn,
              pt,
              _t,
              K.DEPTH_BUFFER_BIT,
              K.NEAREST,
            );
        nt.bindFramebuffer(K.READ_FRAMEBUFFER, null),
          nt.bindFramebuffer(K.DRAW_FRAMEBUFFER, null);
      } else if (se !== 0 || j.isRenderTargetTexture || it.has(j)) {
        const Wr = it.get(j),
          Kn = it.get(le);
        nt.bindFramebuffer(K.READ_FRAMEBUFFER, Fn),
          nt.bindFramebuffer(K.DRAW_FRAMEBUFFER, Zn);
        for (let Xr = 0; Xr < St; Xr++)
          cn
            ? K.framebufferTextureLayer(
                K.READ_FRAMEBUFFER,
                K.COLOR_ATTACHMENT0,
                Wr.__webglTexture,
                se,
                gt + Xr,
              )
            : K.framebufferTexture2D(
                K.READ_FRAMEBUFFER,
                K.COLOR_ATTACHMENT0,
                K.TEXTURE_2D,
                Wr.__webglTexture,
                se,
              ),
            ei
              ? K.framebufferTextureLayer(
                  K.DRAW_FRAMEBUFFER,
                  K.COLOR_ATTACHMENT0,
                  Kn.__webglTexture,
                  Ge,
                  Jt + Xr,
                )
              : K.framebufferTexture2D(
                  K.DRAW_FRAMEBUFFER,
                  K.COLOR_ATTACHMENT0,
                  K.TEXTURE_2D,
                  Kn.__webglTexture,
                  Ge,
                ),
            se !== 0
              ? K.blitFramebuffer(
                  zt,
                  Ut,
                  pt,
                  _t,
                  At,
                  hn,
                  pt,
                  _t,
                  K.COLOR_BUFFER_BIT,
                  K.NEAREST,
                )
              : ei
                ? K.copyTexSubImage3D(vn, Ge, At, hn, Jt + Xr, zt, Ut, pt, _t)
                : K.copyTexSubImage2D(vn, Ge, At, hn, zt, Ut, pt, _t);
        nt.bindFramebuffer(K.READ_FRAMEBUFFER, null),
          nt.bindFramebuffer(K.DRAW_FRAMEBUFFER, null);
      } else
        ei
          ? j.isDataTexture || j.isData3DTexture
            ? K.texSubImage3D(vn, Ge, At, hn, Jt, pt, _t, St, gn, Ft, $t.data)
            : le.isCompressedArrayTexture
              ? K.compressedTexSubImage3D(
                  vn,
                  Ge,
                  At,
                  hn,
                  Jt,
                  pt,
                  _t,
                  St,
                  gn,
                  $t.data,
                )
              : K.texSubImage3D(vn, Ge, At, hn, Jt, pt, _t, St, gn, Ft, $t)
          : j.isDataTexture
            ? K.texSubImage2D(K.TEXTURE_2D, Ge, At, hn, pt, _t, gn, Ft, $t.data)
            : j.isCompressedTexture
              ? K.compressedTexSubImage2D(
                  K.TEXTURE_2D,
                  Ge,
                  At,
                  hn,
                  $t.width,
                  $t.height,
                  gn,
                  $t.data,
                )
              : K.texSubImage2D(K.TEXTURE_2D, Ge, At, hn, pt, _t, gn, Ft, $t);
      K.pixelStorei(K.UNPACK_ROW_LENGTH, $r),
        K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, Mr),
        K.pixelStorei(K.UNPACK_SKIP_PIXELS, Yi),
        K.pixelStorei(K.UNPACK_SKIP_ROWS, Sr),
        K.pixelStorei(K.UNPACK_SKIP_IMAGES, Ra),
        Ge === 0 && le.generateMipmaps && K.generateMipmap(vn),
        nt.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        j,
        le,
        Me = null,
        Ee = null,
        se = 0,
      ) {
        return (
          j.isTexture !== !0 &&
            (Zd(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed.",
            ),
            (Me = arguments[0] || null),
            (Ee = arguments[1] || null),
            (j = arguments[2]),
            (le = arguments[3]),
            (se = arguments[4] || 0)),
          Zd(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.',
          ),
          this.copyTextureToTexture(j, le, Me, Ee, se)
        );
      }),
      (this.initRenderTarget = function (j) {
        it.get(j).__webglFramebuffer === void 0 && Z.setupRenderTarget(j);
      }),
      (this.initTexture = function (j) {
        j.isCubeTexture
          ? Z.setTextureCube(j, 0)
          : j.isData3DTexture
            ? Z.setTexture3D(j, 0)
            : j.isDataArrayTexture || j.isCompressedArrayTexture
              ? Z.setTexture2DArray(j, 0)
              : Z.setTexture2D(j, 0),
          nt.unbindTexture();
      }),
      (this.resetState = function () {
        (F = 0), (O = 0), (z = null), nt.reset(), W.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
  }
  get coordinateSystem() {
    return Ka;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorspace = Sn._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = Sn._getUnpackColorSpace());
  }
}
const yN = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: Eg,
      AddEquation: Hl,
      AddOperation: g5,
      AdditiveAnimationBlendMode: B3,
      AdditiveBlending: vv,
      AgXToneMapping: _5,
      AlphaFormat: S3,
      AlwaysCompare: U5,
      AlwaysDepth: B0,
      AlwaysStencilFunc: wv,
      AmbientLight: AS,
      AnimationAction: PS,
      AnimationClip: bh,
      AnimationLoader: FI,
      AnimationMixer: aB,
      AnimationObjectGroup: iB,
      AnimationUtils: BI,
      ArcCurve: q5,
      ArrayCamera: RS,
      ArrowHelper: CB,
      AttachedBindMode: _v,
      Audio: IS,
      AudioAnalyser: YI,
      AudioContext: lx,
      AudioListener: WI,
      AudioLoader: VI,
      AxesHelper: TB,
      BackSide: Ji,
      BasicDepthPacking: T5,
      BasicShadowMap: qM,
      BatchedMesh: Z5,
      Bone: Og,
      BooleanKeyframeTrack: Gc,
      Box2: fB,
      Box3: Ti,
      Box3Helper: SB,
      BoxGeometry: Vc,
      BoxHelper: MB,
      BufferAttribute: Tn,
      BufferGeometry: tn,
      BufferGeometryLoader: CS,
      ByteType: Tg,
      Cache: Wo,
      Camera: $p,
      CameraHelper: wB,
      CanvasTexture: tI,
      CapsuleGeometry: Vg,
      CatmullRomCurve3: K5,
      CineonToneMapping: x5,
      CircleGeometry: Gg,
      ClampToEdgeWrapping: Ar,
      Clock: ux,
      Color: dt,
      ColorKeyframeTrack: tx,
      ColorManagement: Sn,
      CompressedArrayTexture: $R,
      CompressedCubeTexture: eI,
      CompressedTexture: zg,
      CompressedTextureLoader: NI,
      ConeGeometry: jg,
      ConstantAlphaFactor: f5,
      ConstantColorFactor: d5,
      Controls: IB,
      CubeCamera: W5,
      CubeReflectionMapping: io,
      CubeRefractionMapping: Wl,
      CubeTexture: em,
      CubeTextureLoader: bS,
      CubeUVReflectionMapping: Sh,
      CubicBezierCurve: X3,
      CubicBezierCurve3: Q5,
      CubicInterpolant: gS,
      CullFaceBack: yv,
      CullFaceFront: ZM,
      CullFaceFrontBack: x9,
      CullFaceNone: YM,
      Curve: Ca,
      CurvePath: eS,
      CustomBlending: KM,
      CustomToneMapping: b5,
      CylinderGeometry: Ch,
      Cylindrical: hB,
      Data3DTexture: F3,
      DataArrayTexture: Fg,
      DataTexture: wa,
      DataTextureLoader: nx,
      DataUtils: bc,
      DecrementStencilOp: R9,
      DecrementWrapStencilOp: B9,
      DefaultLoadingManager: xS,
      DepthFormat: Ec,
      DepthStencilFormat: Dc,
      DepthTexture: j3,
      DetachedBindMode: w5,
      DirectionalLight: ox,
      DirectionalLightHelper: AB,
      DiscreteInterpolant: yS,
      DodecahedronGeometry: Wg,
      DoubleSide: Xs,
      DstAlphaFactor: a5,
      DstColorFactor: l5,
      DynamicCopyUsage: X9,
      DynamicDrawUsage: z9,
      DynamicReadUsage: G9,
      EdgesGeometry: tS,
      EllipseCurve: Hg,
      EqualCompare: L5,
      EqualDepth: L0,
      EqualStencilFunc: F9,
      EquirectangularReflectionMapping: hh,
      EquirectangularRefractionMapping: Sp,
      Euler: Cs,
      EventDispatcher: oo,
      ExtrudeGeometry: Jg,
      FileLoader: ci,
      Float16BufferAttribute: DR,
      Float32BufferAttribute: Lt,
      FloatType: or,
      Fog: Ug,
      FogExp2: Ng,
      FramebufferTexture: QR,
      FrontSide: ro,
      Frustum: rm,
      GLBufferAttribute: cB,
      GLSL1: Y9,
      GLSL3: Mv,
      GreaterCompare: D5,
      GreaterDepth: F0,
      GreaterEqualCompare: N5,
      GreaterEqualDepth: D0,
      GreaterEqualStencilFunc: k9,
      GreaterStencilFunc: U9,
      GridHelper: bB,
      Group: jo,
      HalfFloatType: Kr,
      HemisphereLight: _S,
      HemisphereLightHelper: xB,
      IcosahedronGeometry: sm,
      ImageBitmapLoader: TS,
      ImageLoader: Fp,
      ImageUtils: z5,
      IncrementStencilOp: T9,
      IncrementWrapStencilOp: I9,
      InstancedBufferAttribute: Fc,
      InstancedBufferGeometry: ES,
      InstancedInterleavedBuffer: uB,
      InstancedMesh: H3,
      Int16BufferAttribute: PR,
      Int32BufferAttribute: LR,
      Int8BufferAttribute: RR,
      IntType: qp,
      InterleavedBuffer: tm,
      InterleavedBufferAttribute: Jl,
      Interpolant: Th,
      InterpolateDiscrete: mh,
      InterpolateLinear: gh,
      InterpolateSmooth: y0,
      InvertStencilOp: P9,
      KeepStencilOp: hc,
      KeyframeTrack: Ta,
      LOD: Y5,
      LatheGeometry: im,
      Layers: Tc,
      LessCompare: P5,
      LessDepth: P0,
      LessEqualCompare: L3,
      LessEqualDepth: Pc,
      LessEqualStencilFunc: N9,
      LessStencilFunc: D9,
      Light: Ql,
      LightProbe: SS,
      Line: Ko,
      Line3: pB,
      LineBasicMaterial: Ii,
      LineCurve: J3,
      LineCurve3: $5,
      LineDashedMaterial: fS,
      LineLoop: V3,
      LineSegments: Ea,
      LinearFilter: Un,
      LinearInterpolant: ex,
      LinearMipMapLinearFilter: Av,
      LinearMipMapNearestFilter: A9,
      LinearMipmapLinearFilter: Ys,
      LinearMipmapNearestFilter: ah,
      LinearSRGBColorSpace: ao,
      LinearToneMapping: y5,
      LinearTransfer: Cp,
      Loader: di,
      LoaderUtils: Vl,
      LoadingManager: e2,
      LoopOnce: M5,
      LoopPingPong: E5,
      LoopRepeat: S5,
      LuminanceAlphaFormat: T3,
      LuminanceFormat: C3,
      MOUSE: y9,
      Material: Dr,
      MaterialLoader: t2,
      MathUtils: gp,
      Matrix2: px,
      Matrix3: an,
      Matrix4: jt,
      MaxEquation: t5,
      Mesh: nr,
      MeshBasicMaterial: ds,
      MeshDepthMaterial: K3,
      MeshDistanceMaterial: Q3,
      MeshLambertMaterial: dS,
      MeshMatcapMaterial: hS,
      MeshNormalMaterial: cS,
      MeshPhongMaterial: lS,
      MeshPhysicalMaterial: Ri,
      MeshStandardMaterial: lm,
      MeshToonMaterial: uS,
      MinEquation: e5,
      MirroredRepeatWrapping: fh,
      MixOperation: m5,
      MultiplyBlending: bv,
      MultiplyOperation: Zp,
      NearestFilter: Qr,
      NearestMipMapLinearFilter: _9,
      NearestMipMapNearestFilter: b9,
      NearestMipmapLinearFilter: gc,
      NearestMipmapNearestFilter: Cg,
      NeutralToneMapping: A5,
      NeverCompare: B5,
      NeverDepth: I0,
      NeverStencilFunc: L9,
      NoBlending: eo,
      NoColorSpace: Vo,
      NoToneMapping: to,
      NormalAnimationBlendMode: Dg,
      NormalBlending: Sc,
      NotEqualCompare: F5,
      NotEqualDepth: N0,
      NotEqualStencilFunc: O9,
      NumberKeyframeTrack: Uc,
      Object3D: _n,
      ObjectLoader: zI,
      ObjectSpaceNormalMap: I5,
      OctahedronGeometry: am,
      OneFactor: r5,
      OneMinusConstantAlphaFactor: p5,
      OneMinusConstantColorFactor: h5,
      OneMinusDstAlphaFactor: o5,
      OneMinusDstColorFactor: u5,
      OneMinusSrcAlphaFactor: R0,
      OneMinusSrcColorFactor: s5,
      OrthographicCamera: Wc,
      PCFShadowMap: Sg,
      PCFSoftShadowMap: up,
      PMREMGenerator: Bv,
      Path: Bp,
      PerspectiveCamera: Hr,
      Plane: kl,
      PlaneGeometry: Kl,
      PlaneHelper: EB,
      PointLight: ax,
      PointLightHelper: yB,
      Points: G3,
      PointsMaterial: kg,
      PolarGridHelper: _B,
      PolyhedronGeometry: ql,
      PositionalAudio: JI,
      PropertyBinding: Mn,
      PropertyMixer: BS,
      QuadraticBezierCurve: Y3,
      QuadraticBezierCurve3: Z3,
      Quaternion: Ci,
      QuaternionKeyframeTrack: Oc,
      QuaternionLinearInterpolant: vS,
      RED_GREEN_RGTC2_Format: og,
      RED_RGTC1_Format: I3,
      REVISION: Mh,
      RGBADepthPacking: R5,
      RGBAFormat: wr,
      RGBAIntegerFormat: Lg,
      RGBA_ASTC_10x10_Format: tg,
      RGBA_ASTC_10x5_Format: Q0,
      RGBA_ASTC_10x6_Format: $0,
      RGBA_ASTC_10x8_Format: eg,
      RGBA_ASTC_12x10_Format: ng,
      RGBA_ASTC_12x12_Format: rg,
      RGBA_ASTC_4x4_Format: j0,
      RGBA_ASTC_5x4_Format: W0,
      RGBA_ASTC_5x5_Format: X0,
      RGBA_ASTC_6x5_Format: J0,
      RGBA_ASTC_6x6_Format: Y0,
      RGBA_ASTC_8x5_Format: Z0,
      RGBA_ASTC_8x6_Format: q0,
      RGBA_ASTC_8x8_Format: K0,
      RGBA_BPTC_Format: pp,
      RGBA_ETC2_EAC_Format: G0,
      RGBA_PVRTC_2BPPV1_Format: z0,
      RGBA_PVRTC_4BPPV1_Format: k0,
      RGBA_S3TC_DXT1_Format: dp,
      RGBA_S3TC_DXT3_Format: hp,
      RGBA_S3TC_DXT5_Format: fp,
      RGBDepthPacking: M9,
      RGBFormat: E3,
      RGBIntegerFormat: w9,
      RGB_BPTC_SIGNED_Format: ig,
      RGB_BPTC_UNSIGNED_Format: sg,
      RGB_ETC1_Format: H0,
      RGB_ETC2_Format: V0,
      RGB_PVRTC_2BPPV1_Format: O0,
      RGB_PVRTC_4BPPV1_Format: U0,
      RGB_S3TC_DXT1_Format: cp,
      RGDepthPacking: S9,
      RGFormat: R3,
      RGIntegerFormat: Pg,
      RawShaderMaterial: oS,
      Ray: Eh,
      Raycaster: fx,
      RectAreaLight: wS,
      RedFormat: Kp,
      RedIntegerFormat: Qp,
      ReinhardToneMapping: v5,
      RenderTarget: H5,
      RepeatWrapping: Xl,
      ReplaceStencilOp: C9,
      ReverseSubtractEquation: $M,
      RingGeometry: Yg,
      SIGNED_RED_GREEN_RGTC2_Format: lg,
      SIGNED_RED_RGTC1_Format: ag,
      SRGBColorSpace: Ei,
      SRGBTransfer: Hn,
      Scene: xh,
      ShaderChunk: un,
      ShaderLib: Aa,
      ShaderMaterial: fs,
      ShadowMaterial: aS,
      Shape: Rc,
      ShapeGeometry: Zg,
      ShapePath: RB,
      ShapeUtils: no,
      ShortType: Rg,
      Skeleton: nm,
      SkeletonHelper: gB,
      SkinnedMesh: z3,
      Source: xc,
      Sphere: ui,
      SphereGeometry: om,
      Spherical: dB,
      SphericalHarmonics3: MS,
      SplineCurve: q3,
      SpotLight: sx,
      SpotLightHelper: mB,
      Sprite: J5,
      SpriteMaterial: k3,
      SrcAlphaFactor: T0,
      SrcAlphaSaturateFactor: c5,
      SrcColorFactor: i5,
      StaticCopyUsage: W9,
      StaticDrawUsage: Tp,
      StaticReadUsage: V9,
      StereoCamera: GI,
      StreamCopyUsage: J9,
      StreamDrawUsage: H9,
      StreamReadUsage: j9,
      StringKeyframeTrack: jc,
      SubtractEquation: QM,
      SubtractiveBlending: xv,
      TOUCH: v9,
      TangentSpaceNormalMap: Zl,
      TetrahedronGeometry: qg,
      Texture: Ln,
      TextureLoader: rx,
      TextureUtils: FB,
      TorusGeometry: Kg,
      TorusKnotGeometry: Qg,
      Triangle: cs,
      TriangleFanDrawMode: ug,
      TriangleStripDrawMode: P3,
      TrianglesDrawMode: C5,
      TubeGeometry: $g,
      UVMapping: jl,
      Uint16BufferAttribute: N3,
      Uint32BufferAttribute: U3,
      Uint8BufferAttribute: IR,
      Uint8ClampedBufferAttribute: BR,
      Uniform: hx,
      UniformsGroup: lB,
      UniformsLib: mt,
      UniformsUtils: j5,
      UnsignedByteType: hs,
      UnsignedInt248Type: Lc,
      UnsignedInt5999Type: M3,
      UnsignedIntType: so,
      UnsignedShort4444Type: Ig,
      UnsignedShort5551Type: Bg,
      UnsignedShortType: ph,
      VSMShadowMap: _a,
      Vector2: je,
      Vector3: Y,
      Vector4: Cn,
      VectorKeyframeTrack: kc,
      VideoTexture: KR,
      WebGL3DRenderTarget: xR,
      WebGLArrayRenderTarget: vR,
      WebGLCoordinateSystem: Ka,
      WebGLCubeRenderTarget: O3,
      WebGLMultipleRenderTargets: NB,
      WebGLRenderTarget: Es,
      WebGLRenderer: gx,
      WebGLUtils: kS,
      WebGPUCoordinateSystem: Rp,
      WireframeGeometry: sS,
      WrapAroundEnding: Ep,
      ZeroCurvatureEnding: yc,
      ZeroFactor: n5,
      ZeroSlopeEnding: vc,
      ZeroStencilOp: E9,
      createCanvasElement: k5,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
var TA = { exports: {} },
  lc = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var RA;
function vN() {
  return (
    RA ||
      ((RA = 1),
      (lc.ConcurrentRoot = 1),
      (lc.ContinuousEventPriority = 4),
      (lc.DefaultEventPriority = 16),
      (lc.DiscreteEventPriority = 1),
      (lc.IdleEventPriority = 536870912),
      (lc.LegacyRoot = 0)),
    lc
  );
}
var IA;
function xN() {
  return IA || ((IA = 1), (TA.exports = vN())), TA.exports;
}
var tp = xN();
function bN(r) {
  let e;
  const t = new Set(),
    n = (l, c) => {
      const d = typeof l == "function" ? l(e) : l;
      if (d !== e) {
        const p = e;
        (e = c ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, p));
      }
    },
    i = () => e,
    s = (l, c = i, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware",
      );
      let p = c(e);
      function m() {
        const y = c(e);
        if (!d(p, y)) {
          const v = p;
          l((p = y), v);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    a = {
      setState: n,
      getState: i,
      subscribe: (l, c, d) =>
        c || d ? s(l, c, d) : (t.add(l), () => t.delete(l)),
      destroy: () => t.clear(),
    };
  return (e = r(n, i, a)), a;
}
const _N =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  BA = _N ? he.useEffect : he.useLayoutEffect;
function zS(r) {
  const e = typeof r == "function" ? bN(r) : r,
    t = (n = e.getState, i = Object.is) => {
      const [, s] = he.useReducer((w) => w + 1, 0),
        a = e.getState(),
        l = he.useRef(a),
        c = he.useRef(n),
        d = he.useRef(i),
        p = he.useRef(!1),
        m = he.useRef();
      m.current === void 0 && (m.current = n(a));
      let y,
        v = !1;
      (l.current !== a || c.current !== n || d.current !== i || p.current) &&
        ((y = n(a)), (v = !i(m.current, y))),
        BA(() => {
          v && (m.current = y),
            (l.current = a),
            (c.current = n),
            (d.current = i),
            (p.current = !1);
        });
      const A = he.useRef(a);
      BA(() => {
        const w = () => {
            try {
              const C = e.getState(),
                T = c.current(C);
              d.current(m.current, T) ||
                ((l.current = C), (m.current = T), s());
            } catch {
              (p.current = !0), s();
            }
          },
          x = e.subscribe(w);
        return e.getState() !== A.current && w(), x;
      }, []);
      const M = v ? y : m.current;
      return he.useDebugValue(M), M;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4",
      );
      const n = [t, e];
      return {
        next() {
          const i = n.length <= 0;
          return { value: n.shift(), done: i };
        },
      };
    }),
    t
  );
}
const AN = (r) => typeof r == "object" && typeof r.then == "function",
  Ac = [];
function HS(r, e, t = (n, i) => n === i) {
  if (r === e) return !0;
  if (!r || !e) return !1;
  const n = r.length;
  if (e.length !== n) return !1;
  for (let i = 0; i < n; i++) if (!t(r[i], e[i])) return !1;
  return !0;
}
function VS(r, e = null, t = !1, n = {}) {
  e === null && (e = [r]);
  for (const s of Ac)
    if (HS(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          n.lifespan &&
            n.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, n.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const i = {
    keys: e,
    equal: n.equal,
    remove: () => {
      const s = Ac.indexOf(i);
      s !== -1 && Ac.splice(s, 1);
    },
    promise: (AN(r) ? r : r(...e))
      .then((s) => {
        (i.response = s),
          n.lifespan &&
            n.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, n.lifespan));
      })
      .catch((s) => (i.error = s)),
  };
  if ((Ac.push(i), !t)) throw i.promise;
}
const wN = (r, e, t) => VS(r, e, !1, t),
  MN = (r, e, t) => void VS(r, e, !0, t),
  SN = (r) => {
    if (r === void 0 || r.length === 0) Ac.splice(0, Ac.length);
    else {
      const e = Ac.find((t) => HS(r, t.keys, t.equal));
      e && e.remove();
    }
  };
var PA = { exports: {} },
  LA = { exports: {} },
  DA = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var FA;
function EN() {
  return (
    FA ||
      ((FA = 1),
      (function (r) {
        function e(J, oe) {
          var ae = J.length;
          J.push(oe);
          e: for (; 0 < ae; ) {
            var q = (ae - 1) >>> 1,
              ce = J[q];
            if (0 < i(ce, oe)) (J[q] = oe), (J[ae] = ce), (ae = q);
            else break e;
          }
        }
        function t(J) {
          return J.length === 0 ? null : J[0];
        }
        function n(J) {
          if (J.length === 0) return null;
          var oe = J[0],
            ae = J.pop();
          if (ae !== oe) {
            J[0] = ae;
            e: for (var q = 0, ce = J.length, Xe = ce >>> 1; q < Xe; ) {
              var ye = 2 * (q + 1) - 1,
                Pe = J[ye],
                Ue = ye + 1,
                Fe = J[Ue];
              if (0 > i(Pe, ae))
                Ue < ce && 0 > i(Fe, Pe)
                  ? ((J[q] = Fe), (J[Ue] = ae), (q = Ue))
                  : ((J[q] = Pe), (J[ye] = ae), (q = ye));
              else if (Ue < ce && 0 > i(Fe, ae))
                (J[q] = Fe), (J[Ue] = ae), (q = Ue);
              else break e;
            }
          }
          return oe;
        }
        function i(J, oe) {
          var ae = J.sortIndex - oe.sortIndex;
          return ae !== 0 ? ae : J.id - oe.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          r.unstable_now = function () {
            return s.now();
          };
        } else {
          var a = Date,
            l = a.now();
          r.unstable_now = function () {
            return a.now() - l;
          };
        }
        var c = [],
          d = [],
          p = 1,
          m = null,
          y = 3,
          v = !1,
          A = !1,
          M = !1,
          w = typeof setTimeout == "function" ? setTimeout : null,
          x = typeof clearTimeout == "function" ? clearTimeout : null,
          C = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function T(J) {
          for (var oe = t(d); oe !== null; ) {
            if (oe.callback === null) n(d);
            else if (oe.startTime <= J)
              n(d), (oe.sortIndex = oe.expirationTime), e(c, oe);
            else break;
            oe = t(d);
          }
        }
        function I(J) {
          if (((M = !1), T(J), !A))
            if (t(c) !== null) (A = !0), ge(U);
            else {
              var oe = t(d);
              oe !== null && Re(I, oe.startTime - J);
            }
        }
        function U(J, oe) {
          (A = !1), M && ((M = !1), x(z), (z = -1)), (v = !0);
          var ae = y;
          try {
            for (
              T(oe), m = t(c);
              m !== null && (!(m.expirationTime > oe) || (J && !X()));

            ) {
              var q = m.callback;
              if (typeof q == "function") {
                (m.callback = null), (y = m.priorityLevel);
                var ce = q(m.expirationTime <= oe);
                (oe = r.unstable_now()),
                  typeof ce == "function"
                    ? (m.callback = ce)
                    : m === t(c) && n(c),
                  T(oe);
              } else n(c);
              m = t(c);
            }
            if (m !== null) var Xe = !0;
            else {
              var ye = t(d);
              ye !== null && Re(I, ye.startTime - oe), (Xe = !1);
            }
            return Xe;
          } finally {
            (m = null), (y = ae), (v = !1);
          }
        }
        var F = !1,
          O = null,
          z = -1,
          L = 5,
          N = -1;
        function X() {
          return !(r.unstable_now() - N < L);
        }
        function ie() {
          if (O !== null) {
            var J = r.unstable_now();
            N = J;
            var oe = !0;
            try {
              oe = O(!0, J);
            } finally {
              oe ? re() : ((F = !1), (O = null));
            }
          } else F = !1;
        }
        var re;
        if (typeof C == "function")
          re = function () {
            C(ie);
          };
        else if (typeof MessageChannel < "u") {
          var me = new MessageChannel(),
            _e = me.port2;
          (me.port1.onmessage = ie),
            (re = function () {
              _e.postMessage(null);
            });
        } else
          re = function () {
            w(ie, 0);
          };
        function ge(J) {
          (O = J), F || ((F = !0), re());
        }
        function Re(J, oe) {
          z = w(function () {
            J(r.unstable_now());
          }, oe);
        }
        (r.unstable_IdlePriority = 5),
          (r.unstable_ImmediatePriority = 1),
          (r.unstable_LowPriority = 4),
          (r.unstable_NormalPriority = 3),
          (r.unstable_Profiling = null),
          (r.unstable_UserBlockingPriority = 2),
          (r.unstable_cancelCallback = function (J) {
            J.callback = null;
          }),
          (r.unstable_continueExecution = function () {
            A || v || ((A = !0), ge(U));
          }),
          (r.unstable_forceFrameRate = function (J) {
            0 > J || 125 < J
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
                )
              : (L = 0 < J ? Math.floor(1e3 / J) : 5);
          }),
          (r.unstable_getCurrentPriorityLevel = function () {
            return y;
          }),
          (r.unstable_getFirstCallbackNode = function () {
            return t(c);
          }),
          (r.unstable_next = function (J) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var oe = 3;
                break;
              default:
                oe = y;
            }
            var ae = y;
            y = oe;
            try {
              return J();
            } finally {
              y = ae;
            }
          }),
          (r.unstable_pauseExecution = function () {}),
          (r.unstable_requestPaint = function () {}),
          (r.unstable_runWithPriority = function (J, oe) {
            switch (J) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                J = 3;
            }
            var ae = y;
            y = J;
            try {
              return oe();
            } finally {
              y = ae;
            }
          }),
          (r.unstable_scheduleCallback = function (J, oe, ae) {
            var q = r.unstable_now();
            switch (
              (typeof ae == "object" && ae !== null
                ? ((ae = ae.delay),
                  (ae = typeof ae == "number" && 0 < ae ? q + ae : q))
                : (ae = q),
              J)
            ) {
              case 1:
                var ce = -1;
                break;
              case 2:
                ce = 250;
                break;
              case 5:
                ce = 1073741823;
                break;
              case 4:
                ce = 1e4;
                break;
              default:
                ce = 5e3;
            }
            return (
              (ce = ae + ce),
              (J = {
                id: p++,
                callback: oe,
                priorityLevel: J,
                startTime: ae,
                expirationTime: ce,
                sortIndex: -1,
              }),
              ae > q
                ? ((J.sortIndex = ae),
                  e(d, J),
                  t(c) === null &&
                    J === t(d) &&
                    (M ? (x(z), (z = -1)) : (M = !0), Re(I, ae - q)))
                : ((J.sortIndex = ce), e(c, J), A || v || ((A = !0), ge(U))),
              J
            );
          }),
          (r.unstable_shouldYield = X),
          (r.unstable_wrapCallback = function (J) {
            var oe = y;
            return function () {
              var ae = y;
              y = oe;
              try {
                return J.apply(this, arguments);
              } finally {
                y = ae;
              }
            };
          });
      })(DA)),
    DA
  );
}
var NA;
function GS() {
  return NA || ((NA = 1), (LA.exports = EN())), LA.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var UA, OA;
function CN() {
  return (
    OA ||
      ((OA = 1),
      (UA = function (r) {
        var e = {},
          t = yg(),
          n = GS(),
          i = Object.assign;
        function s(h) {
          for (
            var f =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + h,
              b = 1;
            b < arguments.length;
            b++
          )
            f += "&args[]=" + encodeURIComponent(arguments[b]);
          return (
            "Minified React error #" +
            h +
            "; visit " +
            f +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var a = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          l = Symbol.for("react.element"),
          c = Symbol.for("react.portal"),
          d = Symbol.for("react.fragment"),
          p = Symbol.for("react.strict_mode"),
          m = Symbol.for("react.profiler"),
          y = Symbol.for("react.provider"),
          v = Symbol.for("react.context"),
          A = Symbol.for("react.forward_ref"),
          M = Symbol.for("react.suspense"),
          w = Symbol.for("react.suspense_list"),
          x = Symbol.for("react.memo"),
          C = Symbol.for("react.lazy"),
          T = Symbol.for("react.offscreen"),
          I = Symbol.iterator;
        function U(h) {
          return h === null || typeof h != "object"
            ? null
            : ((h = (I && h[I]) || h["@@iterator"]),
              typeof h == "function" ? h : null);
        }
        function F(h) {
          if (h == null) return null;
          if (typeof h == "function") return h.displayName || h.name || null;
          if (typeof h == "string") return h;
          switch (h) {
            case d:
              return "Fragment";
            case c:
              return "Portal";
            case m:
              return "Profiler";
            case p:
              return "StrictMode";
            case M:
              return "Suspense";
            case w:
              return "SuspenseList";
          }
          if (typeof h == "object")
            switch (h.$$typeof) {
              case v:
                return (h.displayName || "Context") + ".Consumer";
              case y:
                return (h._context.displayName || "Context") + ".Provider";
              case A:
                var f = h.render;
                return (
                  (h = h.displayName),
                  h ||
                    ((h = f.displayName || f.name || ""),
                    (h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef")),
                  h
                );
              case x:
                return (
                  (f = h.displayName || null),
                  f !== null ? f : F(h.type) || "Memo"
                );
              case C:
                (f = h._payload), (h = h._init);
                try {
                  return F(h(f));
                } catch {}
            }
          return null;
        }
        function O(h) {
          var f = h.type;
          switch (h.tag) {
            case 24:
              return "Cache";
            case 9:
              return (f.displayName || "Context") + ".Consumer";
            case 10:
              return (f._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (h = f.render),
                (h = h.displayName || h.name || ""),
                f.displayName ||
                  (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return f;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return F(f);
            case 8:
              return f === p ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof f == "function")
                return f.displayName || f.name || null;
              if (typeof f == "string") return f;
          }
          return null;
        }
        function z(h) {
          var f = h,
            b = h;
          if (h.alternate) for (; f.return; ) f = f.return;
          else {
            h = f;
            do (f = h), f.flags & 4098 && (b = f.return), (h = f.return);
            while (h);
          }
          return f.tag === 3 ? b : null;
        }
        function L(h) {
          if (z(h) !== h) throw Error(s(188));
        }
        function N(h) {
          var f = h.alternate;
          if (!f) {
            if (((f = z(h)), f === null)) throw Error(s(188));
            return f !== h ? null : h;
          }
          for (var b = h, S = f; ; ) {
            var R = b.return;
            if (R === null) break;
            var P = R.alternate;
            if (P === null) {
              if (((S = R.return), S !== null)) {
                b = S;
                continue;
              }
              break;
            }
            if (R.child === P.child) {
              for (P = R.child; P; ) {
                if (P === b) return L(R), h;
                if (P === S) return L(R), f;
                P = P.sibling;
              }
              throw Error(s(188));
            }
            if (b.return !== S.return) (b = R), (S = P);
            else {
              for (var $ = !1, fe = R.child; fe; ) {
                if (fe === b) {
                  ($ = !0), (b = R), (S = P);
                  break;
                }
                if (fe === S) {
                  ($ = !0), (S = R), (b = P);
                  break;
                }
                fe = fe.sibling;
              }
              if (!$) {
                for (fe = P.child; fe; ) {
                  if (fe === b) {
                    ($ = !0), (b = P), (S = R);
                    break;
                  }
                  if (fe === S) {
                    ($ = !0), (S = P), (b = R);
                    break;
                  }
                  fe = fe.sibling;
                }
                if (!$) throw Error(s(189));
              }
            }
            if (b.alternate !== S) throw Error(s(190));
          }
          if (b.tag !== 3) throw Error(s(188));
          return b.stateNode.current === b ? h : f;
        }
        function X(h) {
          return (h = N(h)), h !== null ? ie(h) : null;
        }
        function ie(h) {
          if (h.tag === 5 || h.tag === 6) return h;
          for (h = h.child; h !== null; ) {
            var f = ie(h);
            if (f !== null) return f;
            h = h.sibling;
          }
          return null;
        }
        function re(h) {
          if (h.tag === 5 || h.tag === 6) return h;
          for (h = h.child; h !== null; ) {
            if (h.tag !== 4) {
              var f = re(h);
              if (f !== null) return f;
            }
            h = h.sibling;
          }
          return null;
        }
        var me = Array.isArray,
          _e = r.getPublicInstance,
          ge = r.getRootHostContext,
          Re = r.getChildHostContext,
          J = r.prepareForCommit,
          oe = r.resetAfterCommit,
          ae = r.createInstance,
          q = r.appendInitialChild,
          ce = r.finalizeInitialChildren,
          Xe = r.prepareUpdate,
          ye = r.shouldSetTextContent,
          Pe = r.createTextInstance,
          Ue = r.scheduleTimeout,
          Fe = r.cancelTimeout,
          Je = r.noTimeout,
          et = r.isPrimaryRenderer,
          tt = r.supportsMutation,
          be = r.supportsPersistence,
          Te = r.supportsHydration,
          Ne = r.getInstanceFromNode,
          K = r.preparePortalMount,
          qe = r.getCurrentEventPriority,
          ct = r.detachDeletedInstance,
          Be = r.supportsMicrotasks,
          nt = r.scheduleMicrotask,
          Dt = r.supportsTestSelectors,
          it = r.findFiberRoot,
          Z = r.getBoundingRect,
          G = r.getTextContent,
          xe = r.isHiddenSubtree,
          ze = r.matchAccessibilityRole,
          We = r.setFocusIfFocusable,
          Oe = r.setupIntersectionObserver,
          Mt = r.appendChild,
          ot = r.appendChildToContainer,
          ft = r.commitTextUpdate,
          Ot = r.commitMount,
          Ke = r.commitUpdate,
          ht = r.insertBefore,
          Tt = r.insertInContainerBefore,
          st = r.removeChild,
          xt = r.removeChildFromContainer,
          Qt = r.resetTextContent,
          D = r.hideInstance,
          W = r.hideTextInstance,
          k = r.unhideInstance,
          ne = r.unhideTextInstance,
          Q = r.clearContainer,
          te = r.cloneInstance,
          Ae = r.createContainerChildSet,
          pe = r.appendChildToContainerChildSet,
          Ve = r.finalizeContainerChildren,
          He = r.replaceContainerChildren,
          Qe = r.cloneHiddenInstance,
          ke = r.cloneHiddenTextInstance,
          nn = r.canHydrateInstance,
          vt = r.canHydrateTextInstance,
          It = r.canHydrateSuspenseInstance,
          Ht = r.isSuspenseInstancePending,
          Wt = r.isSuspenseInstanceFallback,
          dn = r.registerSuspenseInstanceRetry,
          An = r.getNextHydratableSibling,
          mn = r.getFirstHydratableChild,
          Wn = r.getFirstHydratableChildWithinContainer,
          wn = r.getFirstHydratableChildWithinSuspenseInstance,
          Fr = r.hydrateInstance,
          lr = r.hydrateTextInstance,
          Dn = r.hydrateSuspenseInstance,
          hi = r.getNextHydratableInstanceAfterSuspenseInstance,
          ps = r.commitHydratedContainer,
          jr = r.commitHydratedSuspenseInstance,
          Fn = r.clearSuspenseBoundary,
          Zn = r.clearSuspenseBoundaryFromContainer,
          j = r.shouldDeleteUnhydratedTailInstances,
          le = r.didNotMatchHydratedContainerTextInstance,
          Me = r.didNotMatchHydratedTextInstance,
          Ee;
        function se(h) {
          if (Ee === void 0)
            try {
              throw Error();
            } catch (b) {
              var f = b.stack.trim().match(/\n( *(at )?)/);
              Ee = (f && f[1]) || "";
            }
          return (
            `
` +
            Ee +
            h
          );
        }
        var Ge = !1;
        function pt(h, f) {
          if (!h || Ge) return "";
          Ge = !0;
          var b = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (f)
              if (
                ((f = function () {
                  throw Error();
                }),
                Object.defineProperty(f.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(f, []);
                } catch (rt) {
                  var S = rt;
                }
                Reflect.construct(h, [], f);
              } else {
                try {
                  f.call();
                } catch (rt) {
                  S = rt;
                }
                h.call(f.prototype);
              }
            else {
              try {
                throw Error();
              } catch (rt) {
                S = rt;
              }
              h();
            }
          } catch (rt) {
            if (rt && S && typeof rt.stack == "string") {
              for (
                var R = rt.stack.split(`
`),
                  P = S.stack.split(`
`),
                  $ = R.length - 1,
                  fe = P.length - 1;
                1 <= $ && 0 <= fe && R[$] !== P[fe];

              )
                fe--;
              for (; 1 <= $ && 0 <= fe; $--, fe--)
                if (R[$] !== P[fe]) {
                  if ($ !== 1 || fe !== 1)
                    do
                      if (($--, fe--, 0 > fe || R[$] !== P[fe])) {
                        var De =
                          `
` + R[$].replace(" at new ", " at ");
                        return (
                          h.displayName &&
                            De.includes("<anonymous>") &&
                            (De = De.replace("<anonymous>", h.displayName)),
                          De
                        );
                      }
                    while (1 <= $ && 0 <= fe);
                  break;
                }
            }
          } finally {
            (Ge = !1), (Error.prepareStackTrace = b);
          }
          return (h = h ? h.displayName || h.name : "") ? se(h) : "";
        }
        var _t = Object.prototype.hasOwnProperty,
          St = [],
          zt = -1;
        function Ut(h) {
          return { current: h };
        }
        function gt(h) {
          0 > zt || ((h.current = St[zt]), (St[zt] = null), zt--);
        }
        function At(h, f) {
          zt++, (St[zt] = h.current), (h.current = f);
        }
        var hn = {},
          Jt = Ut(hn),
          $t = Ut(!1),
          gn = hn;
        function Ft(h, f) {
          var b = h.type.contextTypes;
          if (!b) return hn;
          var S = h.stateNode;
          if (S && S.__reactInternalMemoizedUnmaskedChildContext === f)
            return S.__reactInternalMemoizedMaskedChildContext;
          var R = {},
            P;
          for (P in b) R[P] = f[P];
          return (
            S &&
              ((h = h.stateNode),
              (h.__reactInternalMemoizedUnmaskedChildContext = f),
              (h.__reactInternalMemoizedMaskedChildContext = R)),
            R
          );
        }
        function vn(h) {
          return (h = h.childContextTypes), h != null;
        }
        function $r() {
          gt($t), gt(Jt);
        }
        function Mr(h, f, b) {
          if (Jt.current !== hn) throw Error(s(168));
          At(Jt, f), At($t, b);
        }
        function Yi(h, f, b) {
          var S = h.stateNode;
          if (
            ((f = f.childContextTypes), typeof S.getChildContext != "function")
          )
            return b;
          S = S.getChildContext();
          for (var R in S)
            if (!(R in f)) throw Error(s(108, O(h) || "Unknown", R));
          return i({}, b, S);
        }
        function Sr(h) {
          return (
            (h =
              ((h = h.stateNode) &&
                h.__reactInternalMemoizedMergedChildContext) ||
              hn),
            (gn = Jt.current),
            At(Jt, h),
            At($t, $t.current),
            !0
          );
        }
        function Ra(h, f, b) {
          var S = h.stateNode;
          if (!S) throw Error(s(169));
          b
            ? ((h = Yi(h, f, gn)),
              (S.__reactInternalMemoizedMergedChildContext = h),
              gt($t),
              gt(Jt),
              At(Jt, h))
            : gt($t),
            At($t, b);
        }
        var cn = Math.clz32 ? Math.clz32 : Kn,
          ei = Math.log,
          Wr = Math.LN2;
        function Kn(h) {
          return (h >>>= 0), h === 0 ? 32 : (31 - ((ei(h) / Wr) | 0)) | 0;
        }
        var Xr = 64,
          Ts = 4194304;
        function rn(h) {
          switch (h & -h) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return h & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return h & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return h;
          }
        }
        function $l(h, f) {
          var b = h.pendingLanes;
          if (b === 0) return 0;
          var S = 0,
            R = h.suspendedLanes,
            P = h.pingedLanes,
            $ = b & 268435455;
          if ($ !== 0) {
            var fe = $ & ~R;
            fe !== 0 ? (S = rn(fe)) : ((P &= $), P !== 0 && (S = rn(P)));
          } else ($ = b & ~R), $ !== 0 ? (S = rn($)) : P !== 0 && (S = rn(P));
          if (S === 0) return 0;
          if (
            f !== 0 &&
            f !== S &&
            !(f & R) &&
            ((R = S & -S),
            (P = f & -f),
            R >= P || (R === 16 && (P & 4194240) !== 0))
          )
            return f;
          if ((S & 4 && (S |= b & 16), (f = h.entangledLanes), f !== 0))
            for (h = h.entanglements, f &= S; 0 < f; )
              (b = 31 - cn(f)), (R = 1 << b), (S |= h[b]), (f &= ~R);
          return S;
        }
        function fm(h, f) {
          switch (h) {
            case 1:
            case 2:
            case 4:
              return f + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return f + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function Ih(h, f) {
          for (
            var b = h.suspendedLanes,
              S = h.pingedLanes,
              R = h.expirationTimes,
              P = h.pendingLanes;
            0 < P;

          ) {
            var $ = 31 - cn(P),
              fe = 1 << $,
              De = R[$];
            De === -1
              ? (!(fe & b) || fe & S) && (R[$] = fm(fe, f))
              : De <= f && (h.expiredLanes |= fe),
              (P &= ~fe);
          }
        }
        function Xc(h) {
          return (
            (h = h.pendingLanes & -1073741825),
            h !== 0 ? h : h & 1073741824 ? 1073741824 : 0
          );
        }
        function Jc(h) {
          for (var f = [], b = 0; 31 > b; b++) f.push(h);
          return f;
        }
        function $o(h, f, b) {
          (h.pendingLanes |= f),
            f !== 536870912 && ((h.suspendedLanes = 0), (h.pingedLanes = 0)),
            (h = h.eventTimes),
            (f = 31 - cn(f)),
            (h[f] = b);
        }
        function Bh(h, f) {
          var b = h.pendingLanes & ~f;
          (h.pendingLanes = f),
            (h.suspendedLanes = 0),
            (h.pingedLanes = 0),
            (h.expiredLanes &= f),
            (h.mutableReadLanes &= f),
            (h.entangledLanes &= f),
            (f = h.entanglements);
          var S = h.eventTimes;
          for (h = h.expirationTimes; 0 < b; ) {
            var R = 31 - cn(b),
              P = 1 << R;
            (f[R] = 0), (S[R] = -1), (h[R] = -1), (b &= ~P);
          }
        }
        function el(h, f) {
          var b = (h.entangledLanes |= f);
          for (h = h.entanglements; b; ) {
            var S = 31 - cn(b),
              R = 1 << S;
            (R & f) | (h[S] & f) && (h[S] |= f), (b &= ~R);
          }
        }
        var ln = 0;
        function Zs(h) {
          return (
            (h &= -h),
            1 < h ? (4 < h ? (h & 268435455 ? 16 : 536870912) : 4) : 1
          );
        }
        var Rs = n.unstable_scheduleCallback,
          tl = n.unstable_cancelCallback,
          eu = n.unstable_shouldYield,
          Ia = n.unstable_requestPaint,
          Er = n.unstable_now,
          Yc = n.unstable_ImmediatePriority,
          tu = n.unstable_UserBlockingPriority,
          Ph = n.unstable_NormalPriority,
          pm = n.unstable_IdlePriority,
          lo = null,
          ms = null;
        function a2(h) {
          if (ms && typeof ms.onCommitFiberRoot == "function")
            try {
              ms.onCommitFiberRoot(
                lo,
                h,
                void 0,
                (h.current.flags & 128) === 128,
              );
            } catch {}
        }
        function nu(h, f) {
          return (
            (h === f && (h !== 0 || 1 / h === 1 / f)) || (h !== h && f !== f)
          );
        }
        var fi = typeof Object.is == "function" ? Object.is : nu,
          pi = null,
          uo = !1,
          Lh = !1;
        function mm(h) {
          pi === null ? (pi = [h]) : pi.push(h);
        }
        function Dh(h) {
          (uo = !0), mm(h);
        }
        function Bi() {
          if (!Lh && pi !== null) {
            Lh = !0;
            var h = 0,
              f = ln;
            try {
              var b = pi;
              for (ln = 1; h < b.length; h++) {
                var S = b[h];
                do S = S(!0);
                while (S !== null);
              }
              (pi = null), (uo = !1);
            } catch (R) {
              throw (pi !== null && (pi = pi.slice(h + 1)), Rs(Yc, Bi), R);
            } finally {
              (ln = f), (Lh = !1);
            }
          }
          return null;
        }
        var Fh = a.ReactCurrentBatchConfig;
        function ru(h, f) {
          if (fi(h, f)) return !0;
          if (
            typeof h != "object" ||
            h === null ||
            typeof f != "object" ||
            f === null
          )
            return !1;
          var b = Object.keys(h),
            S = Object.keys(f);
          if (b.length !== S.length) return !1;
          for (S = 0; S < b.length; S++) {
            var R = b[S];
            if (!_t.call(f, R) || !fi(h[R], f[R])) return !1;
          }
          return !0;
        }
        function Ba(h) {
          switch (h.tag) {
            case 5:
              return se(h.type);
            case 16:
              return se("Lazy");
            case 13:
              return se("Suspense");
            case 19:
              return se("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (h = pt(h.type, !1)), h;
            case 11:
              return (h = pt(h.type.render, !1)), h;
            case 1:
              return (h = pt(h.type, !0)), h;
            default:
              return "";
          }
        }
        function Pi(h, f) {
          if (h && h.defaultProps) {
            (f = i({}, f)), (h = h.defaultProps);
            for (var b in h) f[b] === void 0 && (f[b] = h[b]);
            return f;
          }
          return f;
        }
        var co = Ut(null),
          iu = null,
          qs = null,
          nl = null;
        function Zc() {
          nl = qs = iu = null;
        }
        function mi(h, f, b) {
          et
            ? (At(co, f._currentValue), (f._currentValue = b))
            : (At(co, f._currentValue2), (f._currentValue2 = b));
        }
        function Pa(h) {
          var f = co.current;
          gt(co), et ? (h._currentValue = f) : (h._currentValue2 = f);
        }
        function su(h, f, b) {
          for (; h !== null; ) {
            var S = h.alternate;
            if (
              ((h.childLanes & f) !== f
                ? ((h.childLanes |= f), S !== null && (S.childLanes |= f))
                : S !== null && (S.childLanes & f) !== f && (S.childLanes |= f),
              h === b)
            )
              break;
            h = h.return;
          }
        }
        function Is(h, f) {
          (iu = h),
            (nl = qs = null),
            (h = h.dependencies),
            h !== null &&
              h.firstContext !== null &&
              (h.lanes & f && (ri = !0), (h.firstContext = null));
        }
        function Zi(h) {
          var f = et ? h._currentValue : h._currentValue2;
          if (nl !== h)
            if (
              ((h = { context: h, memoizedValue: f, next: null }), qs === null)
            ) {
              if (iu === null) throw Error(s(308));
              (qs = h), (iu.dependencies = { lanes: 0, firstContext: h });
            } else qs = qs.next = h;
          return f;
        }
        var qi = null,
          Bs = !1;
        function ho(h) {
          h.updateQueue = {
            baseState: h.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function au(h, f) {
          (h = h.updateQueue),
            f.updateQueue === h &&
              (f.updateQueue = {
                baseState: h.baseState,
                firstBaseUpdate: h.firstBaseUpdate,
                lastBaseUpdate: h.lastBaseUpdate,
                shared: h.shared,
                effects: h.effects,
              });
        }
        function Ps(h, f) {
          return {
            eventTime: h,
            lane: f,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function La(h, f) {
          var b = h.updateQueue;
          b !== null &&
            ((b = b.shared),
            tr !== null && h.mode & 1 && !(Yt & 2)
              ? ((h = b.interleaved),
                h === null
                  ? ((f.next = f), qi === null ? (qi = [b]) : qi.push(b))
                  : ((f.next = h.next), (h.next = f)),
                (b.interleaved = f))
              : ((h = b.pending),
                h === null ? (f.next = f) : ((f.next = h.next), (h.next = f)),
                (b.pending = f)));
        }
        function qc(h, f, b) {
          if (
            ((f = f.updateQueue),
            f !== null && ((f = f.shared), (b & 4194240) !== 0))
          ) {
            var S = f.lanes;
            (S &= h.pendingLanes), (b |= S), (f.lanes = b), el(h, b);
          }
        }
        function gm(h, f) {
          var b = h.updateQueue,
            S = h.alternate;
          if (S !== null && ((S = S.updateQueue), b === S)) {
            var R = null,
              P = null;
            if (((b = b.firstBaseUpdate), b !== null)) {
              do {
                var $ = {
                  eventTime: b.eventTime,
                  lane: b.lane,
                  tag: b.tag,
                  payload: b.payload,
                  callback: b.callback,
                  next: null,
                };
                P === null ? (R = P = $) : (P = P.next = $), (b = b.next);
              } while (b !== null);
              P === null ? (R = P = f) : (P = P.next = f);
            } else R = P = f;
            (b = {
              baseState: S.baseState,
              firstBaseUpdate: R,
              lastBaseUpdate: P,
              shared: S.shared,
              effects: S.effects,
            }),
              (h.updateQueue = b);
            return;
          }
          (h = b.lastBaseUpdate),
            h === null ? (b.firstBaseUpdate = f) : (h.next = f),
            (b.lastBaseUpdate = f);
        }
        function rl(h, f, b, S) {
          var R = h.updateQueue;
          Bs = !1;
          var P = R.firstBaseUpdate,
            $ = R.lastBaseUpdate,
            fe = R.shared.pending;
          if (fe !== null) {
            R.shared.pending = null;
            var De = fe,
              rt = De.next;
            (De.next = null), $ === null ? (P = rt) : ($.next = rt), ($ = De);
            var Et = h.alternate;
            Et !== null &&
              ((Et = Et.updateQueue),
              (fe = Et.lastBaseUpdate),
              fe !== $ &&
                (fe === null ? (Et.firstBaseUpdate = rt) : (fe.next = rt),
                (Et.lastBaseUpdate = De)));
          }
          if (P !== null) {
            var Kt = R.baseState;
            ($ = 0), (Et = rt = De = null), (fe = P);
            do {
              var kt = fe.lane,
                zn = fe.eventTime;
              if ((S & kt) === kt) {
                Et !== null &&
                  (Et = Et.next =
                    {
                      eventTime: zn,
                      lane: 0,
                      tag: fe.tag,
                      payload: fe.payload,
                      callback: fe.callback,
                      next: null,
                    });
                e: {
                  var bt = h,
                    In = fe;
                  switch (((kt = f), (zn = b), In.tag)) {
                    case 1:
                      if (((bt = In.payload), typeof bt == "function")) {
                        Kt = bt.call(zn, Kt, kt);
                        break e;
                      }
                      Kt = bt;
                      break e;
                    case 3:
                      bt.flags = (bt.flags & -65537) | 128;
                    case 0:
                      if (
                        ((bt = In.payload),
                        (kt =
                          typeof bt == "function" ? bt.call(zn, Kt, kt) : bt),
                        kt == null)
                      )
                        break e;
                      Kt = i({}, Kt, kt);
                      break e;
                    case 2:
                      Bs = !0;
                  }
                }
                fe.callback !== null &&
                  fe.lane !== 0 &&
                  ((h.flags |= 64),
                  (kt = R.effects),
                  kt === null ? (R.effects = [fe]) : kt.push(fe));
              } else
                (zn = {
                  eventTime: zn,
                  lane: kt,
                  tag: fe.tag,
                  payload: fe.payload,
                  callback: fe.callback,
                  next: null,
                }),
                  Et === null
                    ? ((rt = Et = zn), (De = Kt))
                    : (Et = Et.next = zn),
                  ($ |= kt);
              if (((fe = fe.next), fe === null)) {
                if (((fe = R.shared.pending), fe === null)) break;
                (kt = fe),
                  (fe = kt.next),
                  (kt.next = null),
                  (R.lastBaseUpdate = kt),
                  (R.shared.pending = null);
              }
            } while (!0);
            if (
              (Et === null && (De = Kt),
              (R.baseState = De),
              (R.firstBaseUpdate = rt),
              (R.lastBaseUpdate = Et),
              (f = R.shared.interleaved),
              f !== null)
            ) {
              R = f;
              do ($ |= R.lane), (R = R.next);
              while (R !== f);
            } else P === null && (R.shared.lanes = 0);
            (Ro |= $), (h.lanes = $), (h.memoizedState = Kt);
          }
        }
        function ym(h, f, b) {
          if (((h = f.effects), (f.effects = null), h !== null))
            for (f = 0; f < h.length; f++) {
              var S = h[f],
                R = S.callback;
              if (R !== null) {
                if (((S.callback = null), (S = b), typeof R != "function"))
                  throw Error(s(191, R));
                R.call(S);
              }
            }
        }
        var vm = new t.Component().refs;
        function Nh(h, f, b, S) {
          (f = h.memoizedState),
            (b = b(S, f)),
            (b = b == null ? f : i({}, f, b)),
            (h.memoizedState = b),
            h.lanes === 0 && (h.updateQueue.baseState = b);
        }
        var Kc = {
          isMounted: function (h) {
            return (h = h._reactInternals) ? z(h) === h : !1;
          },
          enqueueSetState: function (h, f, b) {
            h = h._reactInternals;
            var S = xn(),
              R = Yn(h),
              P = Ps(S, R);
            (P.payload = f),
              b != null && (P.callback = b),
              La(h, P),
              (f = ai(h, R, S)),
              f !== null && qc(f, h, R);
          },
          enqueueReplaceState: function (h, f, b) {
            h = h._reactInternals;
            var S = xn(),
              R = Yn(h),
              P = Ps(S, R);
            (P.tag = 1),
              (P.payload = f),
              b != null && (P.callback = b),
              La(h, P),
              (f = ai(h, R, S)),
              f !== null && qc(f, h, R);
          },
          enqueueForceUpdate: function (h, f) {
            h = h._reactInternals;
            var b = xn(),
              S = Yn(h),
              R = Ps(b, S);
            (R.tag = 2),
              f != null && (R.callback = f),
              La(h, R),
              (f = ai(h, S, b)),
              f !== null && qc(f, h, S);
          },
        };
        function xm(h, f, b, S, R, P, $) {
          return (
            (h = h.stateNode),
            typeof h.shouldComponentUpdate == "function"
              ? h.shouldComponentUpdate(S, P, $)
              : f.prototype && f.prototype.isPureReactComponent
                ? !ru(b, S) || !ru(R, P)
                : !0
          );
        }
        function Uh(h, f, b) {
          var S = !1,
            R = hn,
            P = f.contextType;
          return (
            typeof P == "object" && P !== null
              ? (P = Zi(P))
              : ((R = vn(f) ? gn : Jt.current),
                (S = f.contextTypes),
                (P = (S = S != null) ? Ft(h, R) : hn)),
            (f = new f(b, P)),
            (h.memoizedState =
              f.state !== null && f.state !== void 0 ? f.state : null),
            (f.updater = Kc),
            (h.stateNode = f),
            (f._reactInternals = h),
            S &&
              ((h = h.stateNode),
              (h.__reactInternalMemoizedUnmaskedChildContext = R),
              (h.__reactInternalMemoizedMaskedChildContext = P)),
            f
          );
        }
        function bm(h, f, b, S) {
          (h = f.state),
            typeof f.componentWillReceiveProps == "function" &&
              f.componentWillReceiveProps(b, S),
            typeof f.UNSAFE_componentWillReceiveProps == "function" &&
              f.UNSAFE_componentWillReceiveProps(b, S),
            f.state !== h && Kc.enqueueReplaceState(f, f.state, null);
        }
        function Oh(h, f, b, S) {
          var R = h.stateNode;
          (R.props = b), (R.state = h.memoizedState), (R.refs = vm), ho(h);
          var P = f.contextType;
          typeof P == "object" && P !== null
            ? (R.context = Zi(P))
            : ((P = vn(f) ? gn : Jt.current), (R.context = Ft(h, P))),
            (R.state = h.memoizedState),
            (P = f.getDerivedStateFromProps),
            typeof P == "function" &&
              (Nh(h, f, P, b), (R.state = h.memoizedState)),
            typeof f.getDerivedStateFromProps == "function" ||
              typeof R.getSnapshotBeforeUpdate == "function" ||
              (typeof R.UNSAFE_componentWillMount != "function" &&
                typeof R.componentWillMount != "function") ||
              ((f = R.state),
              typeof R.componentWillMount == "function" &&
                R.componentWillMount(),
              typeof R.UNSAFE_componentWillMount == "function" &&
                R.UNSAFE_componentWillMount(),
              f !== R.state && Kc.enqueueReplaceState(R, R.state, null),
              rl(h, b, R, S),
              (R.state = h.memoizedState)),
            typeof R.componentDidMount == "function" && (h.flags |= 4194308);
        }
        var il = [],
          sl = 0,
          al = null,
          Qc = 0,
          Ki = [],
          Qi = 0,
          Da = null,
          Ks = 1,
          Qs = "";
        function fo(h, f) {
          (il[sl++] = Qc), (il[sl++] = al), (al = h), (Qc = f);
        }
        function _m(h, f, b) {
          (Ki[Qi++] = Ks), (Ki[Qi++] = Qs), (Ki[Qi++] = Da), (Da = h);
          var S = Ks;
          h = Qs;
          var R = 32 - cn(S) - 1;
          (S &= ~(1 << R)), (b += 1);
          var P = 32 - cn(f) + R;
          if (30 < P) {
            var $ = R - (R % 5);
            (P = (S & ((1 << $) - 1)).toString(32)),
              (S >>= $),
              (R -= $),
              (Ks = (1 << (32 - cn(f) + R)) | (b << R) | S),
              (Qs = P + h);
          } else (Ks = (1 << P) | (b << R) | S), (Qs = h);
        }
        function kh(h) {
          h.return !== null && (fo(h, 1), _m(h, 1, 0));
        }
        function zh(h) {
          for (; h === al; )
            (al = il[--sl]), (il[sl] = null), (Qc = il[--sl]), (il[sl] = null);
          for (; h === Da; )
            (Da = Ki[--Qi]),
              (Ki[Qi] = null),
              (Qs = Ki[--Qi]),
              (Ki[Qi] = null),
              (Ks = Ki[--Qi]),
              (Ki[Qi] = null);
        }
        var Li = null,
          ti = null,
          On = !1,
          ou = !1,
          $i = null;
        function Hh(h, f) {
          var b = ki(5, null, null, 0);
          (b.elementType = "DELETED"),
            (b.stateNode = f),
            (b.return = h),
            (f = h.deletions),
            f === null ? ((h.deletions = [b]), (h.flags |= 16)) : f.push(b);
        }
        function Vh(h, f) {
          switch (h.tag) {
            case 5:
              return (
                (f = nn(f, h.type, h.pendingProps)),
                f !== null
                  ? ((h.stateNode = f), (Li = h), (ti = mn(f)), !0)
                  : !1
              );
            case 6:
              return (
                (f = vt(f, h.pendingProps)),
                f !== null ? ((h.stateNode = f), (Li = h), (ti = null), !0) : !1
              );
            case 13:
              if (((f = It(f)), f !== null)) {
                var b = Da !== null ? { id: Ks, overflow: Qs } : null;
                return (
                  (h.memoizedState = {
                    dehydrated: f,
                    treeContext: b,
                    retryLane: 1073741824,
                  }),
                  (b = ki(18, null, null, 0)),
                  (b.stateNode = f),
                  (b.return = h),
                  (h.child = b),
                  (Li = h),
                  (ti = null),
                  !0
                );
              }
              return !1;
            default:
              return !1;
          }
        }
        function $c(h) {
          return (h.mode & 1) !== 0 && (h.flags & 128) === 0;
        }
        function ed(h) {
          if (On) {
            var f = ti;
            if (f) {
              var b = f;
              if (!Vh(h, f)) {
                if ($c(h)) throw Error(s(418));
                f = An(b);
                var S = Li;
                f && Vh(h, f)
                  ? Hh(S, b)
                  : ((h.flags = (h.flags & -4097) | 2), (On = !1), (Li = h));
              }
            } else {
              if ($c(h)) throw Error(s(418));
              (h.flags = (h.flags & -4097) | 2), (On = !1), (Li = h);
            }
          }
        }
        function po(h) {
          for (
            h = h.return;
            h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13;

          )
            h = h.return;
          Li = h;
        }
        function lu(h) {
          if (!Te || h !== Li) return !1;
          if (!On) return po(h), (On = !0), !1;
          if (
            h.tag !== 3 &&
            (h.tag !== 5 || (j(h.type) && !ye(h.type, h.memoizedProps)))
          ) {
            var f = ti;
            if (f) {
              if ($c(h)) {
                for (h = ti; h; ) h = An(h);
                throw Error(s(418));
              }
              for (; f; ) Hh(h, f), (f = An(f));
            }
          }
          if ((po(h), h.tag === 13)) {
            if (!Te) throw Error(s(316));
            if (
              ((h = h.memoizedState),
              (h = h !== null ? h.dehydrated : null),
              !h)
            )
              throw Error(s(317));
            ti = hi(h);
          } else ti = Li ? An(h.stateNode) : null;
          return !0;
        }
        function ol() {
          Te && ((ti = Li = null), (ou = On = !1));
        }
        function Gh(h) {
          $i === null ? ($i = [h]) : $i.push(h);
        }
        function ll(h, f, b) {
          if (
            ((h = b.ref),
            h !== null && typeof h != "function" && typeof h != "object")
          ) {
            if (b._owner) {
              if (((b = b._owner), b)) {
                if (b.tag !== 1) throw Error(s(309));
                var S = b.stateNode;
              }
              if (!S) throw Error(s(147, h));
              var R = S,
                P = "" + h;
              return f !== null &&
                f.ref !== null &&
                typeof f.ref == "function" &&
                f.ref._stringRef === P
                ? f.ref
                : ((f = function ($) {
                    var fe = R.refs;
                    fe === vm && (fe = R.refs = {}),
                      $ === null ? delete fe[P] : (fe[P] = $);
                  }),
                  (f._stringRef = P),
                  f);
            }
            if (typeof h != "string") throw Error(s(284));
            if (!b._owner) throw Error(s(290, h));
          }
          return h;
        }
        function uu(h, f) {
          throw (
            ((h = Object.prototype.toString.call(f)),
            Error(
              s(
                31,
                h === "[object Object]"
                  ? "object with keys {" + Object.keys(f).join(", ") + "}"
                  : h,
              ),
            ))
          );
        }
        function ul(h) {
          var f = h._init;
          return f(h._payload);
        }
        function cl(h) {
          function f(Ce, ve) {
            if (h) {
              var Le = Ce.deletions;
              Le === null
                ? ((Ce.deletions = [ve]), (Ce.flags |= 16))
                : Le.push(ve);
            }
          }
          function b(Ce, ve) {
            if (!h) return null;
            for (; ve !== null; ) f(Ce, ve), (ve = ve.sibling);
            return null;
          }
          function S(Ce, ve) {
            for (Ce = new Map(); ve !== null; )
              ve.key !== null ? Ce.set(ve.key, ve) : Ce.set(ve.index, ve),
                (ve = ve.sibling);
            return Ce;
          }
          function R(Ce, ve) {
            return (Ce = Ya(Ce, ve)), (Ce.index = 0), (Ce.sibling = null), Ce;
          }
          function P(Ce, ve, Le) {
            return (
              (Ce.index = Le),
              h
                ? ((Le = Ce.alternate),
                  Le !== null
                    ? ((Le = Le.index), Le < ve ? ((Ce.flags |= 2), ve) : Le)
                    : ((Ce.flags |= 2), ve))
                : ((Ce.flags |= 1048576), ve)
            );
          }
          function $(Ce) {
            return h && Ce.alternate === null && (Ce.flags |= 2), Ce;
          }
          function fe(Ce, ve, Le, yt) {
            return ve === null || ve.tag !== 6
              ? ((ve = Ad(Le, Ce.mode, yt)), (ve.return = Ce), ve)
              : ((ve = R(ve, Le)), (ve.return = Ce), ve);
          }
          function De(Ce, ve, Le, yt) {
            var Pt = Le.type;
            return Pt === d
              ? Et(Ce, ve, Le.props.children, yt, Le.key)
              : ve !== null &&
                  (ve.elementType === Pt ||
                    (typeof Pt == "object" &&
                      Pt !== null &&
                      Pt.$$typeof === C &&
                      ul(Pt) === ve.type))
                ? ((yt = R(ve, Le.props)),
                  (yt.ref = ll(Ce, ve, Le)),
                  (yt.return = Ce),
                  yt)
                : ((yt = Hu(Le.type, Le.key, Le.props, null, Ce.mode, yt)),
                  (yt.ref = ll(Ce, ve, Le)),
                  (yt.return = Ce),
                  yt);
          }
          function rt(Ce, ve, Le, yt) {
            return ve === null ||
              ve.tag !== 4 ||
              ve.stateNode.containerInfo !== Le.containerInfo ||
              ve.stateNode.implementation !== Le.implementation
              ? ((ve = wd(Le, Ce.mode, yt)), (ve.return = Ce), ve)
              : ((ve = R(ve, Le.children || [])), (ve.return = Ce), ve);
          }
          function Et(Ce, ve, Le, yt, Pt) {
            return ve === null || ve.tag !== 7
              ? ((ve = Po(Le, Ce.mode, yt, Pt)), (ve.return = Ce), ve)
              : ((ve = R(ve, Le)), (ve.return = Ce), ve);
          }
          function Kt(Ce, ve, Le) {
            if ((typeof ve == "string" && ve !== "") || typeof ve == "number")
              return (ve = Ad("" + ve, Ce.mode, Le)), (ve.return = Ce), ve;
            if (typeof ve == "object" && ve !== null) {
              switch (ve.$$typeof) {
                case l:
                  return (
                    (Le = Hu(ve.type, ve.key, ve.props, null, Ce.mode, Le)),
                    (Le.ref = ll(Ce, null, ve)),
                    (Le.return = Ce),
                    Le
                  );
                case c:
                  return (ve = wd(ve, Ce.mode, Le)), (ve.return = Ce), ve;
                case C:
                  var yt = ve._init;
                  return Kt(Ce, yt(ve._payload), Le);
              }
              if (me(ve) || U(ve))
                return (ve = Po(ve, Ce.mode, Le, null)), (ve.return = Ce), ve;
              uu(Ce, ve);
            }
            return null;
          }
          function kt(Ce, ve, Le, yt) {
            var Pt = ve !== null ? ve.key : null;
            if ((typeof Le == "string" && Le !== "") || typeof Le == "number")
              return Pt !== null ? null : fe(Ce, ve, "" + Le, yt);
            if (typeof Le == "object" && Le !== null) {
              switch (Le.$$typeof) {
                case l:
                  return Le.key === Pt ? De(Ce, ve, Le, yt) : null;
                case c:
                  return Le.key === Pt ? rt(Ce, ve, Le, yt) : null;
                case C:
                  return (Pt = Le._init), kt(Ce, ve, Pt(Le._payload), yt);
              }
              if (me(Le) || U(Le))
                return Pt !== null ? null : Et(Ce, ve, Le, yt, null);
              uu(Ce, Le);
            }
            return null;
          }
          function zn(Ce, ve, Le, yt, Pt) {
            if ((typeof yt == "string" && yt !== "") || typeof yt == "number")
              return (Ce = Ce.get(Le) || null), fe(ve, Ce, "" + yt, Pt);
            if (typeof yt == "object" && yt !== null) {
              switch (yt.$$typeof) {
                case l:
                  return (
                    (Ce = Ce.get(yt.key === null ? Le : yt.key) || null),
                    De(ve, Ce, yt, Pt)
                  );
                case c:
                  return (
                    (Ce = Ce.get(yt.key === null ? Le : yt.key) || null),
                    rt(ve, Ce, yt, Pt)
                  );
                case C:
                  var sn = yt._init;
                  return zn(Ce, ve, Le, sn(yt._payload), Pt);
              }
              if (me(yt) || U(yt))
                return (Ce = Ce.get(Le) || null), Et(ve, Ce, yt, Pt, null);
              uu(ve, yt);
            }
            return null;
          }
          function bt(Ce, ve, Le, yt) {
            for (
              var Pt = null, sn = null, Zt = ve, bn = (ve = 0), vr = null;
              Zt !== null && bn < Le.length;
              bn++
            ) {
              Zt.index > bn ? ((vr = Zt), (Zt = null)) : (vr = Zt.sibling);
              var yn = kt(Ce, Zt, Le[bn], yt);
              if (yn === null) {
                Zt === null && (Zt = vr);
                break;
              }
              h && Zt && yn.alternate === null && f(Ce, Zt),
                (ve = P(yn, ve, bn)),
                sn === null ? (Pt = yn) : (sn.sibling = yn),
                (sn = yn),
                (Zt = vr);
            }
            if (bn === Le.length) return b(Ce, Zt), On && fo(Ce, bn), Pt;
            if (Zt === null) {
              for (; bn < Le.length; bn++)
                (Zt = Kt(Ce, Le[bn], yt)),
                  Zt !== null &&
                    ((ve = P(Zt, ve, bn)),
                    sn === null ? (Pt = Zt) : (sn.sibling = Zt),
                    (sn = Zt));
              return On && fo(Ce, bn), Pt;
            }
            for (Zt = S(Ce, Zt); bn < Le.length; bn++)
              (vr = zn(Zt, Ce, bn, Le[bn], yt)),
                vr !== null &&
                  (h &&
                    vr.alternate !== null &&
                    Zt.delete(vr.key === null ? bn : vr.key),
                  (ve = P(vr, ve, bn)),
                  sn === null ? (Pt = vr) : (sn.sibling = vr),
                  (sn = vr));
            return (
              h &&
                Zt.forEach(function (ks) {
                  return f(Ce, ks);
                }),
              On && fo(Ce, bn),
              Pt
            );
          }
          function In(Ce, ve, Le, yt) {
            var Pt = U(Le);
            if (typeof Pt != "function") throw Error(s(150));
            if (((Le = Pt.call(Le)), Le == null)) throw Error(s(151));
            for (
              var sn = (Pt = null),
                Zt = ve,
                bn = (ve = 0),
                vr = null,
                yn = Le.next();
              Zt !== null && !yn.done;
              bn++, yn = Le.next()
            ) {
              Zt.index > bn ? ((vr = Zt), (Zt = null)) : (vr = Zt.sibling);
              var ks = kt(Ce, Zt, yn.value, yt);
              if (ks === null) {
                Zt === null && (Zt = vr);
                break;
              }
              h && Zt && ks.alternate === null && f(Ce, Zt),
                (ve = P(ks, ve, bn)),
                sn === null ? (Pt = ks) : (sn.sibling = ks),
                (sn = ks),
                (Zt = vr);
            }
            if (yn.done) return b(Ce, Zt), On && fo(Ce, bn), Pt;
            if (Zt === null) {
              for (; !yn.done; bn++, yn = Le.next())
                (yn = Kt(Ce, yn.value, yt)),
                  yn !== null &&
                    ((ve = P(yn, ve, bn)),
                    sn === null ? (Pt = yn) : (sn.sibling = yn),
                    (sn = yn));
              return On && fo(Ce, bn), Pt;
            }
            for (Zt = S(Ce, Zt); !yn.done; bn++, yn = Le.next())
              (yn = zn(Zt, Ce, bn, yn.value, yt)),
                yn !== null &&
                  (h &&
                    yn.alternate !== null &&
                    Zt.delete(yn.key === null ? bn : yn.key),
                  (ve = P(yn, ve, bn)),
                  sn === null ? (Pt = yn) : (sn.sibling = yn),
                  (sn = yn));
            return (
              h &&
                Zt.forEach(function (Gm) {
                  return f(Ce, Gm);
                }),
              On && fo(Ce, bn),
              Pt
            );
          }
          function Hi(Ce, ve, Le, yt) {
            if (
              (typeof Le == "object" &&
                Le !== null &&
                Le.type === d &&
                Le.key === null &&
                (Le = Le.props.children),
              typeof Le == "object" && Le !== null)
            ) {
              switch (Le.$$typeof) {
                case l:
                  e: {
                    for (var Pt = Le.key, sn = ve; sn !== null; ) {
                      if (sn.key === Pt) {
                        if (((Pt = Le.type), Pt === d)) {
                          if (sn.tag === 7) {
                            b(Ce, sn.sibling),
                              (ve = R(sn, Le.props.children)),
                              (ve.return = Ce),
                              (Ce = ve);
                            break e;
                          }
                        } else if (
                          sn.elementType === Pt ||
                          (typeof Pt == "object" &&
                            Pt !== null &&
                            Pt.$$typeof === C &&
                            ul(Pt) === sn.type)
                        ) {
                          b(Ce, sn.sibling),
                            (ve = R(sn, Le.props)),
                            (ve.ref = ll(Ce, sn, Le)),
                            (ve.return = Ce),
                            (Ce = ve);
                          break e;
                        }
                        b(Ce, sn);
                        break;
                      } else f(Ce, sn);
                      sn = sn.sibling;
                    }
                    Le.type === d
                      ? ((ve = Po(Le.props.children, Ce.mode, yt, Le.key)),
                        (ve.return = Ce),
                        (Ce = ve))
                      : ((yt = Hu(
                          Le.type,
                          Le.key,
                          Le.props,
                          null,
                          Ce.mode,
                          yt,
                        )),
                        (yt.ref = ll(Ce, ve, Le)),
                        (yt.return = Ce),
                        (Ce = yt));
                  }
                  return $(Ce);
                case c:
                  e: {
                    for (sn = Le.key; ve !== null; ) {
                      if (ve.key === sn)
                        if (
                          ve.tag === 4 &&
                          ve.stateNode.containerInfo === Le.containerInfo &&
                          ve.stateNode.implementation === Le.implementation
                        ) {
                          b(Ce, ve.sibling),
                            (ve = R(ve, Le.children || [])),
                            (ve.return = Ce),
                            (Ce = ve);
                          break e;
                        } else {
                          b(Ce, ve);
                          break;
                        }
                      else f(Ce, ve);
                      ve = ve.sibling;
                    }
                    (ve = wd(Le, Ce.mode, yt)), (ve.return = Ce), (Ce = ve);
                  }
                  return $(Ce);
                case C:
                  return (sn = Le._init), Hi(Ce, ve, sn(Le._payload), yt);
              }
              if (me(Le)) return bt(Ce, ve, Le, yt);
              if (U(Le)) return In(Ce, ve, Le, yt);
              uu(Ce, Le);
            }
            return (typeof Le == "string" && Le !== "") || typeof Le == "number"
              ? ((Le = "" + Le),
                ve !== null && ve.tag === 6
                  ? (b(Ce, ve.sibling),
                    (ve = R(ve, Le)),
                    (ve.return = Ce),
                    (Ce = ve))
                  : (b(Ce, ve),
                    (ve = Ad(Le, Ce.mode, yt)),
                    (ve.return = Ce),
                    (Ce = ve)),
                $(Ce))
              : b(Ce, ve);
          }
          return Hi;
        }
        var dl = cl(!0),
          cu = cl(!1),
          du = {},
          Di = Ut(du),
          mo = Ut(du),
          Fa = Ut(du);
        function gs(h) {
          if (h === du) throw Error(s(174));
          return h;
        }
        function td(h, f) {
          At(Fa, f), At(mo, h), At(Di, du), (h = ge(f)), gt(Di), At(Di, h);
        }
        function go() {
          gt(Di), gt(mo), gt(Fa);
        }
        function Am(h) {
          var f = gs(Fa.current),
            b = gs(Di.current);
          (f = Re(b, h.type, f)), b !== f && (At(mo, h), At(Di, f));
        }
        function jh(h) {
          mo.current === h && (gt(Di), gt(mo));
        }
        var Qn = Ut(0);
        function nd(h) {
          for (var f = h; f !== null; ) {
            if (f.tag === 13) {
              var b = f.memoizedState;
              if (
                b !== null &&
                ((b = b.dehydrated), b === null || Ht(b) || Wt(b))
              )
                return f;
            } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
              if (f.flags & 128) return f;
            } else if (f.child !== null) {
              (f.child.return = f), (f = f.child);
              continue;
            }
            if (f === h) break;
            for (; f.sibling === null; ) {
              if (f.return === null || f.return === h) return null;
              f = f.return;
            }
            (f.sibling.return = f.return), (f = f.sibling);
          }
          return null;
        }
        var Wh = [];
        function Fi() {
          for (var h = 0; h < Wh.length; h++) {
            var f = Wh[h];
            et
              ? (f._workInProgressVersionPrimary = null)
              : (f._workInProgressVersionSecondary = null);
          }
          Wh.length = 0;
        }
        var Na = a.ReactCurrentDispatcher,
          Ni = a.ReactCurrentBatchConfig,
          yo = 0,
          $n = null,
          Nr = null,
          ur = null,
          rd = !1,
          hu = !1,
          Ls = 0,
          Xh = 0;
        function cr() {
          throw Error(s(321));
        }
        function fu(h, f) {
          if (f === null) return !1;
          for (var b = 0; b < f.length && b < h.length; b++)
            if (!fi(h[b], f[b])) return !1;
          return !0;
        }
        function id(h, f, b, S, R, P) {
          if (
            ((yo = P),
            ($n = f),
            (f.memoizedState = null),
            (f.updateQueue = null),
            (f.lanes = 0),
            (Na.current = h === null || h.memoizedState === null ? nf : rf),
            (h = b(S, R)),
            hu)
          ) {
            P = 0;
            do {
              if (((hu = !1), (Ls = 0), 25 <= P)) throw Error(s(301));
              (P += 1),
                (ur = Nr = null),
                (f.updateQueue = null),
                (Na.current = sf),
                (h = b(S, R));
            } while (hu);
          }
          if (
            ((Na.current = _o),
            (f = Nr !== null && Nr.next !== null),
            (yo = 0),
            (ur = Nr = $n = null),
            (rd = !1),
            f)
          )
            throw Error(s(300));
          return h;
        }
        function hl() {
          var h = Ls !== 0;
          return (Ls = 0), h;
        }
        function gi() {
          var h = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            ur === null ? ($n.memoizedState = ur = h) : (ur = ur.next = h), ur
          );
        }
        function es() {
          if (Nr === null) {
            var h = $n.alternate;
            h = h !== null ? h.memoizedState : null;
          } else h = Nr.next;
          var f = ur === null ? $n.memoizedState : ur.next;
          if (f !== null) (ur = f), (Nr = h);
          else {
            if (h === null) throw Error(s(310));
            (Nr = h),
              (h = {
                memoizedState: Nr.memoizedState,
                baseState: Nr.baseState,
                baseQueue: Nr.baseQueue,
                queue: Nr.queue,
                next: null,
              }),
              ur === null ? ($n.memoizedState = ur = h) : (ur = ur.next = h);
          }
          return ur;
        }
        function Ua(h, f) {
          return typeof f == "function" ? f(h) : f;
        }
        function vo(h) {
          var f = es(),
            b = f.queue;
          if (b === null) throw Error(s(311));
          b.lastRenderedReducer = h;
          var S = Nr,
            R = S.baseQueue,
            P = b.pending;
          if (P !== null) {
            if (R !== null) {
              var $ = R.next;
              (R.next = P.next), (P.next = $);
            }
            (S.baseQueue = R = P), (b.pending = null);
          }
          if (R !== null) {
            (P = R.next), (S = S.baseState);
            var fe = ($ = null),
              De = null,
              rt = P;
            do {
              var Et = rt.lane;
              if ((yo & Et) === Et)
                De !== null &&
                  (De = De.next =
                    {
                      lane: 0,
                      action: rt.action,
                      hasEagerState: rt.hasEagerState,
                      eagerState: rt.eagerState,
                      next: null,
                    }),
                  (S = rt.hasEagerState ? rt.eagerState : h(S, rt.action));
              else {
                var Kt = {
                  lane: Et,
                  action: rt.action,
                  hasEagerState: rt.hasEagerState,
                  eagerState: rt.eagerState,
                  next: null,
                };
                De === null ? ((fe = De = Kt), ($ = S)) : (De = De.next = Kt),
                  ($n.lanes |= Et),
                  (Ro |= Et);
              }
              rt = rt.next;
            } while (rt !== null && rt !== P);
            De === null ? ($ = S) : (De.next = fe),
              fi(S, f.memoizedState) || (ri = !0),
              (f.memoizedState = S),
              (f.baseState = $),
              (f.baseQueue = De),
              (b.lastRenderedState = S);
          }
          if (((h = b.interleaved), h !== null)) {
            R = h;
            do (P = R.lane), ($n.lanes |= P), (Ro |= P), (R = R.next);
            while (R !== h);
          } else R === null && (b.lanes = 0);
          return [f.memoizedState, b.dispatch];
        }
        function pu(h) {
          var f = es(),
            b = f.queue;
          if (b === null) throw Error(s(311));
          b.lastRenderedReducer = h;
          var S = b.dispatch,
            R = b.pending,
            P = f.memoizedState;
          if (R !== null) {
            b.pending = null;
            var $ = (R = R.next);
            do (P = h(P, $.action)), ($ = $.next);
            while ($ !== R);
            fi(P, f.memoizedState) || (ri = !0),
              (f.memoizedState = P),
              f.baseQueue === null && (f.baseState = P),
              (b.lastRenderedState = P);
          }
          return [P, S];
        }
        function Jh() {}
        function Yh(h, f) {
          var b = $n,
            S = es(),
            R = f(),
            P = !fi(S.memoizedState, R);
          if (
            (P && ((S.memoizedState = R), (ri = !0)),
            (S = S.queue),
            fl(Kh.bind(null, b, S, h), [h]),
            S.getSnapshot !== f ||
              P ||
              (ur !== null && ur.memoizedState.tag & 1))
          ) {
            if (
              ((b.flags |= 2048),
              xo(9, qh.bind(null, b, S, R, f), void 0, null),
              tr === null)
            )
              throw Error(s(349));
            yo & 30 || Zh(b, f, R);
          }
          return R;
        }
        function Zh(h, f, b) {
          (h.flags |= 16384),
            (h = { getSnapshot: f, value: b }),
            (f = $n.updateQueue),
            f === null
              ? ((f = { lastEffect: null, stores: null }),
                ($n.updateQueue = f),
                (f.stores = [h]))
              : ((b = f.stores), b === null ? (f.stores = [h]) : b.push(h));
        }
        function qh(h, f, b, S) {
          (f.value = b), (f.getSnapshot = S), $s(f) && ai(h, 1, -1);
        }
        function Kh(h, f, b) {
          return b(function () {
            $s(f) && ai(h, 1, -1);
          });
        }
        function $s(h) {
          var f = h.getSnapshot;
          h = h.value;
          try {
            var b = f();
            return !fi(h, b);
          } catch {
            return !0;
          }
        }
        function mu(h) {
          var f = gi();
          return (
            typeof h == "function" && (h = h()),
            (f.memoizedState = f.baseState = h),
            (h = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: Ua,
              lastRenderedState: h,
            }),
            (f.queue = h),
            (h = h.dispatch = Mm.bind(null, $n, h)),
            [f.memoizedState, h]
          );
        }
        function xo(h, f, b, S) {
          return (
            (h = { tag: h, create: f, destroy: b, deps: S, next: null }),
            (f = $n.updateQueue),
            f === null
              ? ((f = { lastEffect: null, stores: null }),
                ($n.updateQueue = f),
                (f.lastEffect = h.next = h))
              : ((b = f.lastEffect),
                b === null
                  ? (f.lastEffect = h.next = h)
                  : ((S = b.next),
                    (b.next = h),
                    (h.next = S),
                    (f.lastEffect = h))),
            h
          );
        }
        function wm() {
          return es().memoizedState;
        }
        function sd(h, f, b, S) {
          var R = gi();
          ($n.flags |= h),
            (R.memoizedState = xo(1 | f, b, void 0, S === void 0 ? null : S));
        }
        function Oa(h, f, b, S) {
          var R = es();
          S = S === void 0 ? null : S;
          var P = void 0;
          if (Nr !== null) {
            var $ = Nr.memoizedState;
            if (((P = $.destroy), S !== null && fu(S, $.deps))) {
              R.memoizedState = xo(f, b, P, S);
              return;
            }
          }
          ($n.flags |= h), (R.memoizedState = xo(1 | f, b, P, S));
        }
        function Qh(h, f) {
          return sd(8390656, 8, h, f);
        }
        function fl(h, f) {
          return Oa(2048, 8, h, f);
        }
        function $h(h, f) {
          return Oa(4, 2, h, f);
        }
        function Vn(h, f) {
          return Oa(4, 4, h, f);
        }
        function ad(h, f) {
          if (typeof f == "function")
            return (
              (h = h()),
              f(h),
              function () {
                f(null);
              }
            );
          if (f != null)
            return (
              (h = h()),
              (f.current = h),
              function () {
                f.current = null;
              }
            );
        }
        function gu(h, f, b) {
          return (
            (b = b != null ? b.concat([h]) : null),
            Oa(4, 4, ad.bind(null, f, h), b)
          );
        }
        function bo() {}
        function ef(h, f) {
          var b = es();
          f = f === void 0 ? null : f;
          var S = b.memoizedState;
          return S !== null && f !== null && fu(f, S[1])
            ? S[0]
            : ((b.memoizedState = [h, f]), h);
        }
        function od(h, f) {
          var b = es();
          f = f === void 0 ? null : f;
          var S = b.memoizedState;
          return S !== null && f !== null && fu(f, S[1])
            ? S[0]
            : ((h = h()), (b.memoizedState = [h, f]), h);
        }
        function yu(h, f) {
          var b = ln;
          (ln = b !== 0 && 4 > b ? b : 4), h(!0);
          var S = Ni.transition;
          Ni.transition = {};
          try {
            h(!1), f();
          } finally {
            (ln = b), (Ni.transition = S);
          }
        }
        function vu() {
          return es().memoizedState;
        }
        function pl(h, f, b) {
          var S = Yn(h);
          (b = {
            lane: S,
            action: b,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          }),
            Sm(h)
              ? Em(f, b)
              : (tf(h, f, b),
                (b = xn()),
                (h = ai(h, S, b)),
                h !== null && xu(h, f, S));
        }
        function Mm(h, f, b) {
          var S = Yn(h),
            R = {
              lane: S,
              action: b,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (Sm(h)) Em(f, R);
          else {
            tf(h, f, R);
            var P = h.alternate;
            if (
              h.lanes === 0 &&
              (P === null || P.lanes === 0) &&
              ((P = f.lastRenderedReducer), P !== null)
            )
              try {
                var $ = f.lastRenderedState,
                  fe = P($, b);
                if (((R.hasEagerState = !0), (R.eagerState = fe), fi(fe, $)))
                  return;
              } catch {
              } finally {
              }
            (b = xn()), (h = ai(h, S, b)), h !== null && xu(h, f, S);
          }
        }
        function Sm(h) {
          var f = h.alternate;
          return h === $n || (f !== null && f === $n);
        }
        function Em(h, f) {
          hu = rd = !0;
          var b = h.pending;
          b === null ? (f.next = f) : ((f.next = b.next), (b.next = f)),
            (h.pending = f);
        }
        function tf(h, f, b) {
          tr !== null && h.mode & 1 && !(Yt & 2)
            ? ((h = f.interleaved),
              h === null
                ? ((b.next = b), qi === null ? (qi = [f]) : qi.push(f))
                : ((b.next = h.next), (h.next = b)),
              (f.interleaved = b))
            : ((h = f.pending),
              h === null ? (b.next = b) : ((b.next = h.next), (h.next = b)),
              (f.pending = b));
        }
        function xu(h, f, b) {
          if (b & 4194240) {
            var S = f.lanes;
            (S &= h.pendingLanes), (b |= S), (f.lanes = b), el(h, b);
          }
        }
        var _o = {
            readContext: Zi,
            useCallback: cr,
            useContext: cr,
            useEffect: cr,
            useImperativeHandle: cr,
            useInsertionEffect: cr,
            useLayoutEffect: cr,
            useMemo: cr,
            useReducer: cr,
            useRef: cr,
            useState: cr,
            useDebugValue: cr,
            useDeferredValue: cr,
            useTransition: cr,
            useMutableSource: cr,
            useSyncExternalStore: cr,
            useId: cr,
            unstable_isNewReconciler: !1,
          },
          nf = {
            readContext: Zi,
            useCallback: function (h, f) {
              return (gi().memoizedState = [h, f === void 0 ? null : f]), h;
            },
            useContext: Zi,
            useEffect: Qh,
            useImperativeHandle: function (h, f, b) {
              return (
                (b = b != null ? b.concat([h]) : null),
                sd(4194308, 4, ad.bind(null, f, h), b)
              );
            },
            useLayoutEffect: function (h, f) {
              return sd(4194308, 4, h, f);
            },
            useInsertionEffect: function (h, f) {
              return sd(4, 2, h, f);
            },
            useMemo: function (h, f) {
              var b = gi();
              return (
                (f = f === void 0 ? null : f),
                (h = h()),
                (b.memoizedState = [h, f]),
                h
              );
            },
            useReducer: function (h, f, b) {
              var S = gi();
              return (
                (f = b !== void 0 ? b(f) : f),
                (S.memoizedState = S.baseState = f),
                (h = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: h,
                  lastRenderedState: f,
                }),
                (S.queue = h),
                (h = h.dispatch = pl.bind(null, $n, h)),
                [S.memoizedState, h]
              );
            },
            useRef: function (h) {
              var f = gi();
              return (h = { current: h }), (f.memoizedState = h);
            },
            useState: mu,
            useDebugValue: bo,
            useDeferredValue: function (h) {
              var f = mu(h),
                b = f[0],
                S = f[1];
              return (
                Qh(
                  function () {
                    var R = Ni.transition;
                    Ni.transition = {};
                    try {
                      S(h);
                    } finally {
                      Ni.transition = R;
                    }
                  },
                  [h],
                ),
                b
              );
            },
            useTransition: function () {
              var h = mu(!1),
                f = h[0];
              return (
                (h = yu.bind(null, h[1])), (gi().memoizedState = h), [f, h]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (h, f, b) {
              var S = $n,
                R = gi();
              if (On) {
                if (b === void 0) throw Error(s(407));
                b = b();
              } else {
                if (((b = f()), tr === null)) throw Error(s(349));
                yo & 30 || Zh(S, f, b);
              }
              R.memoizedState = b;
              var P = { value: b, getSnapshot: f };
              return (
                (R.queue = P),
                Qh(Kh.bind(null, S, P, h), [h]),
                (S.flags |= 2048),
                xo(9, qh.bind(null, S, P, b, f), void 0, null),
                b
              );
            },
            useId: function () {
              var h = gi(),
                f = tr.identifierPrefix;
              if (On) {
                var b = Qs,
                  S = Ks;
                (b = (S & ~(1 << (32 - cn(S) - 1))).toString(32) + b),
                  (f = ":" + f + "R" + b),
                  (b = Ls++),
                  0 < b && (f += "H" + b.toString(32)),
                  (f += ":");
              } else (b = Xh++), (f = ":" + f + "r" + b.toString(32) + ":");
              return (h.memoizedState = f);
            },
            unstable_isNewReconciler: !1,
          },
          rf = {
            readContext: Zi,
            useCallback: ef,
            useContext: Zi,
            useEffect: fl,
            useImperativeHandle: gu,
            useInsertionEffect: $h,
            useLayoutEffect: Vn,
            useMemo: od,
            useReducer: vo,
            useRef: wm,
            useState: function () {
              return vo(Ua);
            },
            useDebugValue: bo,
            useDeferredValue: function (h) {
              var f = vo(Ua),
                b = f[0],
                S = f[1];
              return (
                fl(
                  function () {
                    var R = Ni.transition;
                    Ni.transition = {};
                    try {
                      S(h);
                    } finally {
                      Ni.transition = R;
                    }
                  },
                  [h],
                ),
                b
              );
            },
            useTransition: function () {
              var h = vo(Ua)[0],
                f = es().memoizedState;
              return [h, f];
            },
            useMutableSource: Jh,
            useSyncExternalStore: Yh,
            useId: vu,
            unstable_isNewReconciler: !1,
          },
          sf = {
            readContext: Zi,
            useCallback: ef,
            useContext: Zi,
            useEffect: fl,
            useImperativeHandle: gu,
            useInsertionEffect: $h,
            useLayoutEffect: Vn,
            useMemo: od,
            useReducer: pu,
            useRef: wm,
            useState: function () {
              return pu(Ua);
            },
            useDebugValue: bo,
            useDeferredValue: function (h) {
              var f = pu(Ua),
                b = f[0],
                S = f[1];
              return (
                fl(
                  function () {
                    var R = Ni.transition;
                    Ni.transition = {};
                    try {
                      S(h);
                    } finally {
                      Ni.transition = R;
                    }
                  },
                  [h],
                ),
                b
              );
            },
            useTransition: function () {
              var h = pu(Ua)[0],
                f = es().memoizedState;
              return [h, f];
            },
            useMutableSource: Jh,
            useSyncExternalStore: Yh,
            useId: vu,
            unstable_isNewReconciler: !1,
          };
        function bu(h, f) {
          try {
            var b = "",
              S = f;
            do (b += Ba(S)), (S = S.return);
            while (S);
            var R = b;
          } catch (P) {
            R =
              `
Error generating stack: ` +
              P.message +
              `
` +
              P.stack;
          }
          return { value: h, source: f, stack: R };
        }
        function af(h, f) {
          try {
            console.error(f.value);
          } catch (b) {
            setTimeout(function () {
              throw b;
            });
          }
        }
        var Cm = typeof WeakMap == "function" ? WeakMap : Map;
        function Tm(h, f, b) {
          (b = Ps(-1, b)), (b.tag = 3), (b.payload = { element: null });
          var S = f.value;
          return (
            (b.callback = function () {
              Du || ((Du = !0), (Fu = S)), af(h, f);
            }),
            b
          );
        }
        function Rm(h, f, b) {
          (b = Ps(-1, b)), (b.tag = 3);
          var S = h.type.getDerivedStateFromError;
          if (typeof S == "function") {
            var R = f.value;
            (b.payload = function () {
              return S(R);
            }),
              (b.callback = function () {
                af(h, f);
              });
          }
          var P = h.stateNode;
          return (
            P !== null &&
              typeof P.componentDidCatch == "function" &&
              (b.callback = function () {
                af(h, f),
                  typeof S != "function" &&
                    (Rn === null ? (Rn = new Set([this])) : Rn.add(this));
                var $ = f.stack;
                this.componentDidCatch(f.value, {
                  componentStack: $ !== null ? $ : "",
                });
              }),
            b
          );
        }
        function ld(h, f, b) {
          var S = h.pingCache;
          if (S === null) {
            S = h.pingCache = new Cm();
            var R = new Set();
            S.set(f, R);
          } else (R = S.get(f)), R === void 0 && ((R = new Set()), S.set(f, R));
          R.has(b) || (R.add(b), (h = Fm.bind(null, h, f, b)), f.then(h, h));
        }
        function ea(h) {
          do {
            var f;
            if (
              ((f = h.tag === 13) &&
                ((f = h.memoizedState),
                (f = f !== null ? f.dehydrated !== null : !0)),
              f)
            )
              return h;
            h = h.return;
          } while (h !== null);
          return null;
        }
        function of(h, f, b, S, R) {
          return h.mode & 1
            ? ((h.flags |= 65536), (h.lanes = R), h)
            : (h === f
                ? (h.flags |= 65536)
                : ((h.flags |= 128),
                  (b.flags |= 131072),
                  (b.flags &= -52805),
                  b.tag === 1 &&
                    (b.alternate === null
                      ? (b.tag = 17)
                      : ((f = Ps(-1, 1)), (f.tag = 2), La(b, f))),
                  (b.lanes |= 1)),
              h);
        }
        function ni(h) {
          h.flags |= 4;
        }
        function ys(h, f) {
          if (h !== null && h.child === f.child) return !0;
          if (f.flags & 16) return !1;
          for (h = f.child; h !== null; ) {
            if (h.flags & 12854 || h.subtreeFlags & 12854) return !1;
            h = h.sibling;
          }
          return !0;
        }
        var ta, Ui, ml, ud;
        if (tt)
          (ta = function (h, f) {
            for (var b = f.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6) q(h, b.stateNode);
              else if (b.tag !== 4 && b.child !== null) {
                (b.child.return = b), (b = b.child);
                continue;
              }
              if (b === f) break;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === f) return;
                b = b.return;
              }
              (b.sibling.return = b.return), (b = b.sibling);
            }
          }),
            (Ui = function () {}),
            (ml = function (h, f, b, S, R) {
              if (((h = h.memoizedProps), h !== S)) {
                var P = f.stateNode,
                  $ = gs(Di.current);
                (b = Xe(P, b, h, S, R, $)), (f.updateQueue = b) && ni(f);
              }
            }),
            (ud = function (h, f, b, S) {
              b !== S && ni(f);
            });
        else if (be) {
          ta = function (h, f, b, S) {
            for (var R = f.child; R !== null; ) {
              if (R.tag === 5) {
                var P = R.stateNode;
                b && S && (P = Qe(P, R.type, R.memoizedProps, R)), q(h, P);
              } else if (R.tag === 6)
                (P = R.stateNode),
                  b && S && (P = ke(P, R.memoizedProps, R)),
                  q(h, P);
              else if (R.tag !== 4) {
                if (R.tag === 22 && R.memoizedState !== null)
                  (P = R.child), P !== null && (P.return = R), ta(h, R, !0, !0);
                else if (R.child !== null) {
                  (R.child.return = R), (R = R.child);
                  continue;
                }
              }
              if (R === f) break;
              for (; R.sibling === null; ) {
                if (R.return === null || R.return === f) return;
                R = R.return;
              }
              (R.sibling.return = R.return), (R = R.sibling);
            }
          };
          var Im = function (h, f, b, S) {
            for (var R = f.child; R !== null; ) {
              if (R.tag === 5) {
                var P = R.stateNode;
                b && S && (P = Qe(P, R.type, R.memoizedProps, R)), pe(h, P);
              } else if (R.tag === 6)
                (P = R.stateNode),
                  b && S && (P = ke(P, R.memoizedProps, R)),
                  pe(h, P);
              else if (R.tag !== 4) {
                if (R.tag === 22 && R.memoizedState !== null)
                  (P = R.child), P !== null && (P.return = R), Im(h, R, !0, !0);
                else if (R.child !== null) {
                  (R.child.return = R), (R = R.child);
                  continue;
                }
              }
              if (R === f) break;
              for (; R.sibling === null; ) {
                if (R.return === null || R.return === f) return;
                R = R.return;
              }
              (R.sibling.return = R.return), (R = R.sibling);
            }
          };
          (Ui = function (h, f) {
            var b = f.stateNode;
            if (!ys(h, f)) {
              h = b.containerInfo;
              var S = Ae(h);
              Im(S, f, !1, !1), (b.pendingChildren = S), ni(f), Ve(h, S);
            }
          }),
            (ml = function (h, f, b, S, R) {
              var P = h.stateNode,
                $ = h.memoizedProps;
              if ((h = ys(h, f)) && $ === S) f.stateNode = P;
              else {
                var fe = f.stateNode,
                  De = gs(Di.current),
                  rt = null;
                $ !== S && (rt = Xe(fe, b, $, S, R, De)),
                  h && rt === null
                    ? (f.stateNode = P)
                    : ((P = te(P, rt, b, $, S, f, h, fe)),
                      ce(P, b, S, R, De) && ni(f),
                      (f.stateNode = P),
                      h ? ni(f) : ta(P, f, !1, !1));
              }
            }),
            (ud = function (h, f, b, S) {
              b !== S
                ? ((h = gs(Fa.current)),
                  (b = gs(Di.current)),
                  (f.stateNode = Pe(S, h, b, f)),
                  ni(f))
                : (f.stateNode = h.stateNode);
            });
        } else
          (Ui = function () {}), (ml = function () {}), (ud = function () {});
        function vs(h, f) {
          if (!On)
            switch (h.tailMode) {
              case "hidden":
                f = h.tail;
                for (var b = null; f !== null; )
                  f.alternate !== null && (b = f), (f = f.sibling);
                b === null ? (h.tail = null) : (b.sibling = null);
                break;
              case "collapsed":
                b = h.tail;
                for (var S = null; b !== null; )
                  b.alternate !== null && (S = b), (b = b.sibling);
                S === null
                  ? f || h.tail === null
                    ? (h.tail = null)
                    : (h.tail.sibling = null)
                  : (S.sibling = null);
            }
        }
        function dr(h) {
          var f = h.alternate !== null && h.alternate.child === h.child,
            b = 0,
            S = 0;
          if (f)
            for (var R = h.child; R !== null; )
              (b |= R.lanes | R.childLanes),
                (S |= R.subtreeFlags & 14680064),
                (S |= R.flags & 14680064),
                (R.return = h),
                (R = R.sibling);
          else
            for (R = h.child; R !== null; )
              (b |= R.lanes | R.childLanes),
                (S |= R.subtreeFlags),
                (S |= R.flags),
                (R.return = h),
                (R = R.sibling);
          return (h.subtreeFlags |= S), (h.childLanes = b), f;
        }
        function gl(h, f, b) {
          var S = f.pendingProps;
          switch ((zh(f), f.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return dr(f), null;
            case 1:
              return vn(f.type) && $r(), dr(f), null;
            case 3:
              return (
                (S = f.stateNode),
                go(),
                gt($t),
                gt(Jt),
                Fi(),
                S.pendingContext &&
                  ((S.context = S.pendingContext), (S.pendingContext = null)),
                (h === null || h.child === null) &&
                  (lu(f)
                    ? ni(f)
                    : h === null ||
                      (h.memoizedState.isDehydrated && !(f.flags & 256)) ||
                      ((f.flags |= 1024),
                      $i !== null && (Uu($i), ($i = null)))),
                Ui(h, f),
                dr(f),
                null
              );
            case 5:
              jh(f), (b = gs(Fa.current));
              var R = f.type;
              if (h !== null && f.stateNode != null)
                ml(h, f, R, S, b),
                  h.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152));
              else {
                if (!S) {
                  if (f.stateNode === null) throw Error(s(166));
                  return dr(f), null;
                }
                if (((h = gs(Di.current)), lu(f))) {
                  if (!Te) throw Error(s(175));
                  (h = Fr(f.stateNode, f.type, f.memoizedProps, b, h, f, !ou)),
                    (f.updateQueue = h),
                    h !== null && ni(f);
                } else {
                  var P = ae(R, S, b, h, f);
                  ta(P, f, !1, !1),
                    (f.stateNode = P),
                    ce(P, R, S, b, h) && ni(f);
                }
                f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
              }
              return dr(f), null;
            case 6:
              if (h && f.stateNode != null) ud(h, f, h.memoizedProps, S);
              else {
                if (typeof S != "string" && f.stateNode === null)
                  throw Error(s(166));
                if (((h = gs(Fa.current)), (b = gs(Di.current)), lu(f))) {
                  if (!Te) throw Error(s(176));
                  if (
                    ((h = f.stateNode),
                    (S = f.memoizedProps),
                    (b = lr(h, S, f, !ou)) && ((R = Li), R !== null))
                  )
                    switch (((P = (R.mode & 1) !== 0), R.tag)) {
                      case 3:
                        le(R.stateNode.containerInfo, h, S, P);
                        break;
                      case 5:
                        Me(R.type, R.memoizedProps, R.stateNode, h, S, P);
                    }
                  b && ni(f);
                } else f.stateNode = Pe(S, h, b, f);
              }
              return dr(f), null;
            case 13:
              if (
                (gt(Qn),
                (S = f.memoizedState),
                On && ti !== null && f.mode & 1 && !(f.flags & 128))
              ) {
                for (h = ti; h; ) h = An(h);
                return ol(), (f.flags |= 98560), f;
              }
              if (S !== null && S.dehydrated !== null) {
                if (((S = lu(f)), h === null)) {
                  if (!S) throw Error(s(318));
                  if (!Te) throw Error(s(344));
                  if (
                    ((h = f.memoizedState),
                    (h = h !== null ? h.dehydrated : null),
                    !h)
                  )
                    throw Error(s(317));
                  Dn(h, f);
                } else
                  ol(),
                    !(f.flags & 128) && (f.memoizedState = null),
                    (f.flags |= 4);
                return dr(f), null;
              }
              return (
                $i !== null && (Uu($i), ($i = null)),
                f.flags & 128
                  ? ((f.lanes = b), f)
                  : ((S = S !== null),
                    (b = !1),
                    h === null ? lu(f) : (b = h.memoizedState !== null),
                    S &&
                      !b &&
                      ((f.child.flags |= 8192),
                      f.mode & 1 &&
                        (h === null || Qn.current & 1
                          ? pr === 0 && (pr = 3)
                          : vd())),
                    f.updateQueue !== null && (f.flags |= 4),
                    dr(f),
                    null)
              );
            case 4:
              return (
                go(),
                Ui(h, f),
                h === null && K(f.stateNode.containerInfo),
                dr(f),
                null
              );
            case 10:
              return Pa(f.type._context), dr(f), null;
            case 17:
              return vn(f.type) && $r(), dr(f), null;
            case 19:
              if ((gt(Qn), (R = f.memoizedState), R === null))
                return dr(f), null;
              if (((S = (f.flags & 128) !== 0), (P = R.rendering), P === null))
                if (S) vs(R, !1);
                else {
                  if (pr !== 0 || (h !== null && h.flags & 128))
                    for (h = f.child; h !== null; ) {
                      if (((P = nd(h)), P !== null)) {
                        for (
                          f.flags |= 128,
                            vs(R, !1),
                            h = P.updateQueue,
                            h !== null && ((f.updateQueue = h), (f.flags |= 4)),
                            f.subtreeFlags = 0,
                            h = b,
                            S = f.child;
                          S !== null;

                        )
                          (b = S),
                            (R = h),
                            (b.flags &= 14680066),
                            (P = b.alternate),
                            P === null
                              ? ((b.childLanes = 0),
                                (b.lanes = R),
                                (b.child = null),
                                (b.subtreeFlags = 0),
                                (b.memoizedProps = null),
                                (b.memoizedState = null),
                                (b.updateQueue = null),
                                (b.dependencies = null),
                                (b.stateNode = null))
                              : ((b.childLanes = P.childLanes),
                                (b.lanes = P.lanes),
                                (b.child = P.child),
                                (b.subtreeFlags = 0),
                                (b.deletions = null),
                                (b.memoizedProps = P.memoizedProps),
                                (b.memoizedState = P.memoizedState),
                                (b.updateQueue = P.updateQueue),
                                (b.type = P.type),
                                (R = P.dependencies),
                                (b.dependencies =
                                  R === null
                                    ? null
                                    : {
                                        lanes: R.lanes,
                                        firstContext: R.firstContext,
                                      })),
                            (S = S.sibling);
                        return At(Qn, (Qn.current & 1) | 2), f.child;
                      }
                      h = h.sibling;
                    }
                  R.tail !== null &&
                    Er() > Lu &&
                    ((f.flags |= 128),
                    (S = !0),
                    vs(R, !1),
                    (f.lanes = 4194304));
                }
              else {
                if (!S)
                  if (((h = nd(P)), h !== null)) {
                    if (
                      ((f.flags |= 128),
                      (S = !0),
                      (h = h.updateQueue),
                      h !== null && ((f.updateQueue = h), (f.flags |= 4)),
                      vs(R, !0),
                      R.tail === null &&
                        R.tailMode === "hidden" &&
                        !P.alternate &&
                        !On)
                    )
                      return dr(f), null;
                  } else
                    2 * Er() - R.renderingStartTime > Lu &&
                      b !== 1073741824 &&
                      ((f.flags |= 128),
                      (S = !0),
                      vs(R, !1),
                      (f.lanes = 4194304));
                R.isBackwards
                  ? ((P.sibling = f.child), (f.child = P))
                  : ((h = R.last),
                    h !== null ? (h.sibling = P) : (f.child = P),
                    (R.last = P));
              }
              return R.tail !== null
                ? ((f = R.tail),
                  (R.rendering = f),
                  (R.tail = f.sibling),
                  (R.renderingStartTime = Er()),
                  (f.sibling = null),
                  (h = Qn.current),
                  At(Qn, S ? (h & 1) | 2 : h & 1),
                  f)
                : (dr(f), null);
            case 22:
            case 23:
              return (
                Bo(),
                (S = f.memoizedState !== null),
                h !== null &&
                  (h.memoizedState !== null) !== S &&
                  (f.flags |= 8192),
                S && f.mode & 1
                  ? fr & 1073741824 &&
                    (dr(f), tt && f.subtreeFlags & 6 && (f.flags |= 8192))
                  : dr(f),
                null
              );
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(s(156, f.tag));
        }
        var cd = a.ReactCurrentOwner,
          ri = !1;
        function hr(h, f, b, S) {
          f.child = h === null ? cu(f, null, b, S) : dl(f, h.child, b, S);
        }
        function na(h, f, b, S, R) {
          b = b.render;
          var P = f.ref;
          return (
            Is(f, R),
            (S = id(h, f, b, S, P, R)),
            (b = hl()),
            h !== null && !ri
              ? ((f.updateQueue = h.updateQueue),
                (f.flags &= -2053),
                (h.lanes &= ~R),
                yi(h, f, R))
              : (On && b && kh(f), (f.flags |= 1), hr(h, f, S, R), f.child)
          );
        }
        function Gn(h, f, b, S, R) {
          if (h === null) {
            var P = b.type;
            return typeof P == "function" &&
              !bd(P) &&
              P.defaultProps === void 0 &&
              b.compare === null &&
              b.defaultProps === void 0
              ? ((f.tag = 15), (f.type = P), kn(h, f, P, S, R))
              : ((h = Hu(b.type, null, S, f, f.mode, R)),
                (h.ref = f.ref),
                (h.return = f),
                (f.child = h));
          }
          if (((P = h.child), !(h.lanes & R))) {
            var $ = P.memoizedProps;
            if (
              ((b = b.compare),
              (b = b !== null ? b : ru),
              b($, S) && h.ref === f.ref)
            )
              return yi(h, f, R);
          }
          return (
            (f.flags |= 1),
            (h = Ya(P, S)),
            (h.ref = f.ref),
            (h.return = f),
            (f.child = h)
          );
        }
        function kn(h, f, b, S, R) {
          if (h !== null && ru(h.memoizedProps, S) && h.ref === f.ref)
            if (((ri = !1), (h.lanes & R) !== 0)) h.flags & 131072 && (ri = !0);
            else return (f.lanes = h.lanes), yi(h, f, R);
          return Jr(h, f, b, S, R);
        }
        function ra(h, f, b) {
          var S = f.pendingProps,
            R = S.children,
            P = h !== null ? h.memoizedState : null;
          if (S.mode === "hidden")
            if (!(f.mode & 1))
              (f.memoizedState = { baseLanes: 0, cachePool: null }),
                At(ua, fr),
                (fr |= b);
            else if (b & 1073741824)
              (f.memoizedState = { baseLanes: 0, cachePool: null }),
                (S = P !== null ? P.baseLanes : b),
                At(ua, fr),
                (fr |= S);
            else
              return (
                (h = P !== null ? P.baseLanes | b : b),
                (f.lanes = f.childLanes = 1073741824),
                (f.memoizedState = { baseLanes: h, cachePool: null }),
                (f.updateQueue = null),
                At(ua, fr),
                (fr |= h),
                null
              );
          else
            P !== null
              ? ((S = P.baseLanes | b), (f.memoizedState = null))
              : (S = b),
              At(ua, fr),
              (fr |= S);
          return hr(h, f, R, b), f.child;
        }
        function Ur(h, f) {
          var b = f.ref;
          ((h === null && b !== null) || (h !== null && h.ref !== b)) &&
            ((f.flags |= 512), (f.flags |= 2097152));
        }
        function Jr(h, f, b, S, R) {
          var P = vn(b) ? gn : Jt.current;
          return (
            (P = Ft(f, P)),
            Is(f, R),
            (b = id(h, f, b, S, P, R)),
            (S = hl()),
            h !== null && !ri
              ? ((f.updateQueue = h.updateQueue),
                (f.flags &= -2053),
                (h.lanes &= ~R),
                yi(h, f, R))
              : (On && S && kh(f), (f.flags |= 1), hr(h, f, b, R), f.child)
          );
        }
        function ka(h, f, b, S, R) {
          if (vn(b)) {
            var P = !0;
            Sr(f);
          } else P = !1;
          if ((Is(f, R), f.stateNode === null))
            h !== null &&
              ((h.alternate = null), (f.alternate = null), (f.flags |= 2)),
              Uh(f, b, S),
              Oh(f, b, S, R),
              (S = !0);
          else if (h === null) {
            var $ = f.stateNode,
              fe = f.memoizedProps;
            $.props = fe;
            var De = $.context,
              rt = b.contextType;
            typeof rt == "object" && rt !== null
              ? (rt = Zi(rt))
              : ((rt = vn(b) ? gn : Jt.current), (rt = Ft(f, rt)));
            var Et = b.getDerivedStateFromProps,
              Kt =
                typeof Et == "function" ||
                typeof $.getSnapshotBeforeUpdate == "function";
            Kt ||
              (typeof $.UNSAFE_componentWillReceiveProps != "function" &&
                typeof $.componentWillReceiveProps != "function") ||
              ((fe !== S || De !== rt) && bm(f, $, S, rt)),
              (Bs = !1);
            var kt = f.memoizedState;
            ($.state = kt),
              rl(f, S, $, R),
              (De = f.memoizedState),
              fe !== S || kt !== De || $t.current || Bs
                ? (typeof Et == "function" &&
                    (Nh(f, b, Et, S), (De = f.memoizedState)),
                  (fe = Bs || xm(f, b, fe, S, kt, De, rt))
                    ? (Kt ||
                        (typeof $.UNSAFE_componentWillMount != "function" &&
                          typeof $.componentWillMount != "function") ||
                        (typeof $.componentWillMount == "function" &&
                          $.componentWillMount(),
                        typeof $.UNSAFE_componentWillMount == "function" &&
                          $.UNSAFE_componentWillMount()),
                      typeof $.componentDidMount == "function" &&
                        (f.flags |= 4194308))
                    : (typeof $.componentDidMount == "function" &&
                        (f.flags |= 4194308),
                      (f.memoizedProps = S),
                      (f.memoizedState = De)),
                  ($.props = S),
                  ($.state = De),
                  ($.context = rt),
                  (S = fe))
                : (typeof $.componentDidMount == "function" &&
                    (f.flags |= 4194308),
                  (S = !1));
          } else {
            ($ = f.stateNode),
              au(h, f),
              (fe = f.memoizedProps),
              (rt = f.type === f.elementType ? fe : Pi(f.type, fe)),
              ($.props = rt),
              (Kt = f.pendingProps),
              (kt = $.context),
              (De = b.contextType),
              typeof De == "object" && De !== null
                ? (De = Zi(De))
                : ((De = vn(b) ? gn : Jt.current), (De = Ft(f, De)));
            var zn = b.getDerivedStateFromProps;
            (Et =
              typeof zn == "function" ||
              typeof $.getSnapshotBeforeUpdate == "function") ||
              (typeof $.UNSAFE_componentWillReceiveProps != "function" &&
                typeof $.componentWillReceiveProps != "function") ||
              ((fe !== Kt || kt !== De) && bm(f, $, S, De)),
              (Bs = !1),
              (kt = f.memoizedState),
              ($.state = kt),
              rl(f, S, $, R);
            var bt = f.memoizedState;
            fe !== Kt || kt !== bt || $t.current || Bs
              ? (typeof zn == "function" &&
                  (Nh(f, b, zn, S), (bt = f.memoizedState)),
                (rt = Bs || xm(f, b, rt, S, kt, bt, De) || !1)
                  ? (Et ||
                      (typeof $.UNSAFE_componentWillUpdate != "function" &&
                        typeof $.componentWillUpdate != "function") ||
                      (typeof $.componentWillUpdate == "function" &&
                        $.componentWillUpdate(S, bt, De),
                      typeof $.UNSAFE_componentWillUpdate == "function" &&
                        $.UNSAFE_componentWillUpdate(S, bt, De)),
                    typeof $.componentDidUpdate == "function" && (f.flags |= 4),
                    typeof $.getSnapshotBeforeUpdate == "function" &&
                      (f.flags |= 1024))
                  : (typeof $.componentDidUpdate != "function" ||
                      (fe === h.memoizedProps && kt === h.memoizedState) ||
                      (f.flags |= 4),
                    typeof $.getSnapshotBeforeUpdate != "function" ||
                      (fe === h.memoizedProps && kt === h.memoizedState) ||
                      (f.flags |= 1024),
                    (f.memoizedProps = S),
                    (f.memoizedState = bt)),
                ($.props = S),
                ($.state = bt),
                ($.context = De),
                (S = rt))
              : (typeof $.componentDidUpdate != "function" ||
                  (fe === h.memoizedProps && kt === h.memoizedState) ||
                  (f.flags |= 4),
                typeof $.getSnapshotBeforeUpdate != "function" ||
                  (fe === h.memoizedProps && kt === h.memoizedState) ||
                  (f.flags |= 1024),
                (S = !1));
          }
          return za(h, f, b, S, P, R);
        }
        function za(h, f, b, S, R, P) {
          Ur(h, f);
          var $ = (f.flags & 128) !== 0;
          if (!S && !$) return R && Ra(f, b, !1), yi(h, f, P);
          (S = f.stateNode), (cd.current = f);
          var fe =
            $ && typeof b.getDerivedStateFromError != "function"
              ? null
              : S.render();
          return (
            (f.flags |= 1),
            h !== null && $
              ? ((f.child = dl(f, h.child, null, P)),
                (f.child = dl(f, null, fe, P)))
              : hr(h, f, fe, P),
            (f.memoizedState = S.state),
            R && Ra(f, b, !0),
            f.child
          );
        }
        function ii(h) {
          var f = h.stateNode;
          f.pendingContext
            ? Mr(h, f.pendingContext, f.pendingContext !== f.context)
            : f.context && Mr(h, f.context, !1),
            td(h, f.containerInfo);
        }
        function _u(h, f, b, S, R) {
          return ol(), Gh(R), (f.flags |= 256), hr(h, f, b, S), f.child;
        }
        var Au = { dehydrated: null, treeContext: null, retryLane: 0 };
        function wu(h) {
          return { baseLanes: h, cachePool: null };
        }
        function Mu(h, f, b) {
          var S = f.pendingProps,
            R = Qn.current,
            P = !1,
            $ = (f.flags & 128) !== 0,
            fe;
          if (
            ((fe = $) ||
              (fe =
                h !== null && h.memoizedState === null ? !1 : (R & 2) !== 0),
            fe
              ? ((P = !0), (f.flags &= -129))
              : (h === null || h.memoizedState !== null) && (R |= 1),
            At(Qn, R & 1),
            h === null)
          )
            return (
              ed(f),
              (h = f.memoizedState),
              h !== null && ((h = h.dehydrated), h !== null)
                ? (f.mode & 1
                    ? Wt(h)
                      ? (f.lanes = 8)
                      : (f.lanes = 1073741824)
                    : (f.lanes = 1),
                  null)
                : ((R = S.children),
                  (h = S.fallback),
                  P
                    ? ((S = f.mode),
                      (P = f.child),
                      (R = { mode: "hidden", children: R }),
                      !(S & 1) && P !== null
                        ? ((P.childLanes = 0), (P.pendingProps = R))
                        : (P = _d(R, S, 0, null)),
                      (h = Po(h, S, b, null)),
                      (P.return = f),
                      (h.return = f),
                      (P.sibling = h),
                      (f.child = P),
                      (f.child.memoizedState = wu(b)),
                      (f.memoizedState = Au),
                      h)
                    : dd(f, R))
            );
          if (((R = h.memoizedState), R !== null)) {
            if (((fe = R.dehydrated), fe !== null)) {
              if ($)
                return f.flags & 256
                  ? ((f.flags &= -257), yl(h, f, b, Error(s(422))))
                  : f.memoizedState !== null
                    ? ((f.child = h.child), (f.flags |= 128), null)
                    : ((P = S.fallback),
                      (R = f.mode),
                      (S = _d(
                        { mode: "visible", children: S.children },
                        R,
                        0,
                        null,
                      )),
                      (P = Po(P, R, b, null)),
                      (P.flags |= 2),
                      (S.return = f),
                      (P.return = f),
                      (S.sibling = P),
                      (f.child = S),
                      f.mode & 1 && dl(f, h.child, null, b),
                      (f.child.memoizedState = wu(b)),
                      (f.memoizedState = Au),
                      P);
              if (!(f.mode & 1)) f = yl(h, f, b, null);
              else if (Wt(fe)) f = yl(h, f, b, Error(s(419)));
              else if (((S = (b & h.childLanes) !== 0), ri || S)) {
                if (((S = tr), S !== null)) {
                  switch (b & -b) {
                    case 4:
                      P = 2;
                      break;
                    case 16:
                      P = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      P = 32;
                      break;
                    case 536870912:
                      P = 268435456;
                      break;
                    default:
                      P = 0;
                  }
                  (S = P & (S.suspendedLanes | b) ? 0 : P),
                    S !== 0 &&
                      S !== R.retryLane &&
                      ((R.retryLane = S), ai(h, S, -1));
                }
                vd(), (f = yl(h, f, b, Error(s(421))));
              } else
                Ht(fe)
                  ? ((f.flags |= 128),
                    (f.child = h.child),
                    (f = Nm.bind(null, h)),
                    dn(fe, f),
                    (f = null))
                  : ((b = R.treeContext),
                    Te &&
                      ((ti = wn(fe)),
                      (Li = f),
                      (On = !0),
                      ($i = null),
                      (ou = !1),
                      b !== null &&
                        ((Ki[Qi++] = Ks),
                        (Ki[Qi++] = Qs),
                        (Ki[Qi++] = Da),
                        (Ks = b.id),
                        (Qs = b.overflow),
                        (Da = f))),
                    (f = dd(f, f.pendingProps.children)),
                    (f.flags |= 4096));
              return f;
            }
            return P
              ? ((S = Su(h, f, S.children, S.fallback, b)),
                (P = f.child),
                (R = h.child.memoizedState),
                (P.memoizedState =
                  R === null
                    ? wu(b)
                    : { baseLanes: R.baseLanes | b, cachePool: null }),
                (P.childLanes = h.childLanes & ~b),
                (f.memoizedState = Au),
                S)
              : ((b = Ds(h, f, S.children, b)), (f.memoizedState = null), b);
          }
          return P
            ? ((S = Su(h, f, S.children, S.fallback, b)),
              (P = f.child),
              (R = h.child.memoizedState),
              (P.memoizedState =
                R === null
                  ? wu(b)
                  : { baseLanes: R.baseLanes | b, cachePool: null }),
              (P.childLanes = h.childLanes & ~b),
              (f.memoizedState = Au),
              S)
            : ((b = Ds(h, f, S.children, b)), (f.memoizedState = null), b);
        }
        function dd(h, f) {
          return (
            (f = _d({ mode: "visible", children: f }, h.mode, 0, null)),
            (f.return = h),
            (h.child = f)
          );
        }
        function Ds(h, f, b, S) {
          var R = h.child;
          return (
            (h = R.sibling),
            (b = Ya(R, { mode: "visible", children: b })),
            !(f.mode & 1) && (b.lanes = S),
            (b.return = f),
            (b.sibling = null),
            h !== null &&
              ((S = f.deletions),
              S === null ? ((f.deletions = [h]), (f.flags |= 16)) : S.push(h)),
            (f.child = b)
          );
        }
        function Su(h, f, b, S, R) {
          var P = f.mode;
          h = h.child;
          var $ = h.sibling,
            fe = { mode: "hidden", children: b };
          return (
            !(P & 1) && f.child !== h
              ? ((b = f.child),
                (b.childLanes = 0),
                (b.pendingProps = fe),
                (f.deletions = null))
              : ((b = Ya(h, fe)), (b.subtreeFlags = h.subtreeFlags & 14680064)),
            $ !== null
              ? (S = Ya($, S))
              : ((S = Po(S, P, R, null)), (S.flags |= 2)),
            (S.return = f),
            (b.return = f),
            (b.sibling = S),
            (f.child = b),
            S
          );
        }
        function yl(h, f, b, S) {
          return (
            S !== null && Gh(S),
            dl(f, h.child, null, b),
            (h = dd(f, f.pendingProps.children)),
            (h.flags |= 2),
            (f.memoizedState = null),
            h
          );
        }
        function lf(h, f, b) {
          h.lanes |= f;
          var S = h.alternate;
          S !== null && (S.lanes |= f), su(h.return, f, b);
        }
        function uf(h, f, b, S, R) {
          var P = h.memoizedState;
          P === null
            ? (h.memoizedState = {
                isBackwards: f,
                rendering: null,
                renderingStartTime: 0,
                last: S,
                tail: b,
                tailMode: R,
              })
            : ((P.isBackwards = f),
              (P.rendering = null),
              (P.renderingStartTime = 0),
              (P.last = S),
              (P.tail = b),
              (P.tailMode = R));
        }
        function ia(h, f, b) {
          var S = f.pendingProps,
            R = S.revealOrder,
            P = S.tail;
          if ((hr(h, f, S.children, b), (S = Qn.current), S & 2))
            (S = (S & 1) | 2), (f.flags |= 128);
          else {
            if (h !== null && h.flags & 128)
              e: for (h = f.child; h !== null; ) {
                if (h.tag === 13) h.memoizedState !== null && lf(h, b, f);
                else if (h.tag === 19) lf(h, b, f);
                else if (h.child !== null) {
                  (h.child.return = h), (h = h.child);
                  continue;
                }
                if (h === f) break e;
                for (; h.sibling === null; ) {
                  if (h.return === null || h.return === f) break e;
                  h = h.return;
                }
                (h.sibling.return = h.return), (h = h.sibling);
              }
            S &= 1;
          }
          if ((At(Qn, S), !(f.mode & 1))) f.memoizedState = null;
          else
            switch (R) {
              case "forwards":
                for (b = f.child, R = null; b !== null; )
                  (h = b.alternate),
                    h !== null && nd(h) === null && (R = b),
                    (b = b.sibling);
                (b = R),
                  b === null
                    ? ((R = f.child), (f.child = null))
                    : ((R = b.sibling), (b.sibling = null)),
                  uf(f, !1, R, b, P);
                break;
              case "backwards":
                for (b = null, R = f.child, f.child = null; R !== null; ) {
                  if (((h = R.alternate), h !== null && nd(h) === null)) {
                    f.child = R;
                    break;
                  }
                  (h = R.sibling), (R.sibling = b), (b = R), (R = h);
                }
                uf(f, !0, b, null, P);
                break;
              case "together":
                uf(f, !1, null, null, void 0);
                break;
              default:
                f.memoizedState = null;
            }
          return f.child;
        }
        function yi(h, f, b) {
          if (
            (h !== null && (f.dependencies = h.dependencies),
            (Ro |= f.lanes),
            !(b & f.childLanes))
          )
            return null;
          if (h !== null && f.child !== h.child) throw Error(s(153));
          if (f.child !== null) {
            for (
              h = f.child, b = Ya(h, h.pendingProps), f.child = b, b.return = f;
              h.sibling !== null;

            )
              (h = h.sibling),
                (b = b.sibling = Ya(h, h.pendingProps)),
                (b.return = f);
            b.sibling = null;
          }
          return f.child;
        }
        function vl(h, f, b) {
          switch (f.tag) {
            case 3:
              ii(f), ol();
              break;
            case 5:
              Am(f);
              break;
            case 1:
              vn(f.type) && Sr(f);
              break;
            case 4:
              td(f, f.stateNode.containerInfo);
              break;
            case 10:
              mi(f, f.type._context, f.memoizedProps.value);
              break;
            case 13:
              var S = f.memoizedState;
              if (S !== null)
                return S.dehydrated !== null
                  ? (At(Qn, Qn.current & 1), (f.flags |= 128), null)
                  : b & f.child.childLanes
                    ? Mu(h, f, b)
                    : (At(Qn, Qn.current & 1),
                      (h = yi(h, f, b)),
                      h !== null ? h.sibling : null);
              At(Qn, Qn.current & 1);
              break;
            case 19:
              if (((S = (b & f.childLanes) !== 0), h.flags & 128)) {
                if (S) return ia(h, f, b);
                f.flags |= 128;
              }
              var R = f.memoizedState;
              if (
                (R !== null &&
                  ((R.rendering = null),
                  (R.tail = null),
                  (R.lastEffect = null)),
                At(Qn, Qn.current),
                S)
              )
                break;
              return null;
            case 22:
            case 23:
              return (f.lanes = 0), ra(h, f, b);
          }
          return yi(h, f, b);
        }
        function hd(h, f) {
          switch ((zh(f), f.tag)) {
            case 1:
              return (
                vn(f.type) && $r(),
                (h = f.flags),
                h & 65536 ? ((f.flags = (h & -65537) | 128), f) : null
              );
            case 3:
              return (
                go(),
                gt($t),
                gt(Jt),
                Fi(),
                (h = f.flags),
                h & 65536 && !(h & 128)
                  ? ((f.flags = (h & -65537) | 128), f)
                  : null
              );
            case 5:
              return jh(f), null;
            case 13:
              if (
                (gt(Qn),
                (h = f.memoizedState),
                h !== null && h.dehydrated !== null)
              ) {
                if (f.alternate === null) throw Error(s(340));
                ol();
              }
              return (
                (h = f.flags),
                h & 65536 ? ((f.flags = (h & -65537) | 128), f) : null
              );
            case 19:
              return gt(Qn), null;
            case 4:
              return go(), null;
            case 10:
              return Pa(f.type._context), null;
            case 22:
            case 23:
              return Bo(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Ao = !1,
          Cr = !1,
          ts = typeof WeakSet == "function" ? WeakSet : Set,
          ut = null;
        function ns(h, f) {
          var b = h.ref;
          if (b !== null)
            if (typeof b == "function")
              try {
                b(null);
              } catch (S) {
                Or(h, f, S);
              }
            else b.current = null;
        }
        function Fs(h, f, b) {
          try {
            b();
          } catch (S) {
            Or(h, f, S);
          }
        }
        var Ha = !1;
        function Bm(h, f) {
          for (J(h.containerInfo), ut = f; ut !== null; )
            if (
              ((h = ut),
              (f = h.child),
              (h.subtreeFlags & 1028) !== 0 && f !== null)
            )
              (f.return = h), (ut = f);
            else
              for (; ut !== null; ) {
                h = ut;
                try {
                  var b = h.alternate;
                  if (h.flags & 1024)
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (b !== null) {
                          var S = b.memoizedProps,
                            R = b.memoizedState,
                            P = h.stateNode,
                            $ = P.getSnapshotBeforeUpdate(
                              h.elementType === h.type ? S : Pi(h.type, S),
                              R,
                            );
                          P.__reactInternalSnapshotBeforeUpdate = $;
                        }
                        break;
                      case 3:
                        tt && Q(h.stateNode.containerInfo);
                        break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        throw Error(s(163));
                    }
                } catch (fe) {
                  Or(h, h.return, fe);
                }
                if (((f = h.sibling), f !== null)) {
                  (f.return = h.return), (ut = f);
                  break;
                }
                ut = h.return;
              }
          return (b = Ha), (Ha = !1), b;
        }
        function sa(h, f, b) {
          var S = f.updateQueue;
          if (((S = S !== null ? S.lastEffect : null), S !== null)) {
            var R = (S = S.next);
            do {
              if ((R.tag & h) === h) {
                var P = R.destroy;
                (R.destroy = void 0), P !== void 0 && Fs(f, b, P);
              }
              R = R.next;
            } while (R !== S);
          }
        }
        function wo(h, f) {
          if (
            ((f = f.updateQueue),
            (f = f !== null ? f.lastEffect : null),
            f !== null)
          ) {
            var b = (f = f.next);
            do {
              if ((b.tag & h) === h) {
                var S = b.create;
                b.destroy = S();
              }
              b = b.next;
            } while (b !== f);
          }
        }
        function si(h) {
          var f = h.ref;
          if (f !== null) {
            var b = h.stateNode;
            switch (h.tag) {
              case 5:
                h = _e(b);
                break;
              default:
                h = b;
            }
            typeof f == "function" ? f(h) : (f.current = h);
          }
        }
        function vi(h, f, b) {
          if (ms && typeof ms.onCommitFiberUnmount == "function")
            try {
              ms.onCommitFiberUnmount(lo, f);
            } catch {}
          switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                ((h = f.updateQueue),
                h !== null && ((h = h.lastEffect), h !== null))
              ) {
                var S = (h = h.next);
                do {
                  var R = S,
                    P = R.destroy;
                  (R = R.tag),
                    P !== void 0 && (R & 2 || R & 4) && Fs(f, b, P),
                    (S = S.next);
                } while (S !== h);
              }
              break;
            case 1:
              if (
                (ns(f, b),
                (h = f.stateNode),
                typeof h.componentWillUnmount == "function")
              )
                try {
                  (h.props = f.memoizedProps),
                    (h.state = f.memoizedState),
                    h.componentWillUnmount();
                } catch ($) {
                  Or(f, b, $);
                }
              break;
            case 5:
              ns(f, b);
              break;
            case 4:
              tt
                ? Cu(h, f, b)
                : be &&
                  be &&
                  ((f = f.stateNode.containerInfo), (b = Ae(f)), He(f, b));
          }
        }
        function Xn(h, f, b) {
          for (var S = f; ; )
            if ((vi(h, S, b), S.child === null || (tt && S.tag === 4))) {
              if (S === f) break;
              for (; S.sibling === null; ) {
                if (S.return === null || S.return === f) return;
                S = S.return;
              }
              (S.sibling.return = S.return), (S = S.sibling);
            } else (S.child.return = S), (S = S.child);
        }
        function rs(h) {
          var f = h.alternate;
          f !== null && ((h.alternate = null), rs(f)),
            (h.child = null),
            (h.deletions = null),
            (h.sibling = null),
            h.tag === 5 && ((f = h.stateNode), f !== null && ct(f)),
            (h.stateNode = null),
            (h.return = null),
            (h.dependencies = null),
            (h.memoizedProps = null),
            (h.memoizedState = null),
            (h.pendingProps = null),
            (h.stateNode = null),
            (h.updateQueue = null);
        }
        function cf(h) {
          return h.tag === 5 || h.tag === 3 || h.tag === 4;
        }
        function df(h) {
          e: for (;;) {
            for (; h.sibling === null; ) {
              if (h.return === null || cf(h.return)) return null;
              h = h.return;
            }
            for (
              h.sibling.return = h.return, h = h.sibling;
              h.tag !== 5 && h.tag !== 6 && h.tag !== 18;

            ) {
              if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
              (h.child.return = h), (h = h.child);
            }
            if (!(h.flags & 2)) return h.stateNode;
          }
        }
        function fd(h) {
          if (tt) {
            e: {
              for (var f = h.return; f !== null; ) {
                if (cf(f)) break e;
                f = f.return;
              }
              throw Error(s(160));
            }
            var b = f;
            switch (b.tag) {
              case 5:
                (f = b.stateNode),
                  b.flags & 32 && (Qt(f), (b.flags &= -33)),
                  (b = df(h)),
                  pd(h, b, f);
                break;
              case 3:
              case 4:
                (f = b.stateNode.containerInfo), (b = df(h)), Eu(h, b, f);
                break;
              default:
                throw Error(s(161));
            }
          }
        }
        function Eu(h, f, b) {
          var S = h.tag;
          if (S === 5 || S === 6) (h = h.stateNode), f ? Tt(b, h, f) : ot(b, h);
          else if (S !== 4 && ((h = h.child), h !== null))
            for (Eu(h, f, b), h = h.sibling; h !== null; )
              Eu(h, f, b), (h = h.sibling);
        }
        function pd(h, f, b) {
          var S = h.tag;
          if (S === 5 || S === 6) (h = h.stateNode), f ? ht(b, h, f) : Mt(b, h);
          else if (S !== 4 && ((h = h.child), h !== null))
            for (pd(h, f, b), h = h.sibling; h !== null; )
              pd(h, f, b), (h = h.sibling);
        }
        function Cu(h, f, b) {
          for (var S = f, R = !1, P, $; ; ) {
            if (!R) {
              R = S.return;
              e: for (;;) {
                if (R === null) throw Error(s(160));
                switch (((P = R.stateNode), R.tag)) {
                  case 5:
                    $ = !1;
                    break e;
                  case 3:
                    (P = P.containerInfo), ($ = !0);
                    break e;
                  case 4:
                    (P = P.containerInfo), ($ = !0);
                    break e;
                }
                R = R.return;
              }
              R = !0;
            }
            if (S.tag === 5 || S.tag === 6)
              Xn(h, S, b), $ ? xt(P, S.stateNode) : st(P, S.stateNode);
            else if (S.tag === 18) $ ? Zn(P, S.stateNode) : Fn(P, S.stateNode);
            else if (S.tag === 4) {
              if (S.child !== null) {
                (P = S.stateNode.containerInfo),
                  ($ = !0),
                  (S.child.return = S),
                  (S = S.child);
                continue;
              }
            } else if ((vi(h, S, b), S.child !== null)) {
              (S.child.return = S), (S = S.child);
              continue;
            }
            if (S === f) break;
            for (; S.sibling === null; ) {
              if (S.return === null || S.return === f) return;
              (S = S.return), S.tag === 4 && (R = !1);
            }
            (S.sibling.return = S.return), (S = S.sibling);
          }
        }
        function md(h, f) {
          if (tt) {
            switch (f.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                sa(3, f, f.return), wo(3, f), sa(5, f, f.return);
                return;
              case 1:
                return;
              case 5:
                var b = f.stateNode;
                if (b != null) {
                  var S = f.memoizedProps;
                  h = h !== null ? h.memoizedProps : S;
                  var R = f.type,
                    P = f.updateQueue;
                  (f.updateQueue = null), P !== null && Ke(b, P, R, h, S, f);
                }
                return;
              case 6:
                if (f.stateNode === null) throw Error(s(162));
                (b = f.memoizedProps),
                  ft(f.stateNode, h !== null ? h.memoizedProps : b, b);
                return;
              case 3:
                Te &&
                  h !== null &&
                  h.memoizedState.isDehydrated &&
                  ps(f.stateNode.containerInfo);
                return;
              case 12:
                return;
              case 13:
                aa(f);
                return;
              case 19:
                aa(f);
                return;
              case 17:
                return;
            }
            throw Error(s(163));
          }
          switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              sa(3, f, f.return), wo(3, f), sa(5, f, f.return);
              return;
            case 12:
              return;
            case 13:
              aa(f);
              return;
            case 19:
              aa(f);
              return;
            case 3:
              Te &&
                h !== null &&
                h.memoizedState.isDehydrated &&
                ps(f.stateNode.containerInfo);
              break;
            case 22:
            case 23:
              return;
          }
          e: if (be) {
            switch (f.tag) {
              case 1:
              case 5:
              case 6:
                break e;
              case 3:
              case 4:
                (f = f.stateNode), He(f.containerInfo, f.pendingChildren);
                break e;
            }
            throw Error(s(163));
          }
        }
        function aa(h) {
          var f = h.updateQueue;
          if (f !== null) {
            h.updateQueue = null;
            var b = h.stateNode;
            b === null && (b = h.stateNode = new ts()),
              f.forEach(function (S) {
                var R = Um.bind(null, h, S);
                b.has(S) || (b.add(S), S.then(R, R));
              });
          }
        }
        function hf(h, f) {
          for (ut = f; ut !== null; ) {
            f = ut;
            var b = f.deletions;
            if (b !== null)
              for (var S = 0; S < b.length; S++) {
                var R = b[S];
                try {
                  var P = h;
                  tt ? Cu(P, R, f) : Xn(P, R, f);
                  var $ = R.alternate;
                  $ !== null && ($.return = null), (R.return = null);
                } catch (Pt) {
                  Or(R, f, Pt);
                }
              }
            if (((b = f.child), f.subtreeFlags & 12854 && b !== null))
              (b.return = f), (ut = b);
            else
              for (; ut !== null; ) {
                f = ut;
                try {
                  var fe = f.flags;
                  if ((fe & 32 && tt && Qt(f.stateNode), fe & 512)) {
                    var De = f.alternate;
                    if (De !== null) {
                      var rt = De.ref;
                      rt !== null &&
                        (typeof rt == "function"
                          ? rt(null)
                          : (rt.current = null));
                    }
                  }
                  if (fe & 8192)
                    switch (f.tag) {
                      case 13:
                        if (f.memoizedState !== null) {
                          var Et = f.alternate;
                          (Et === null || Et.memoizedState === null) &&
                            (da = Er());
                        }
                        break;
                      case 22:
                        var Kt = f.memoizedState !== null,
                          kt = f.alternate,
                          zn = kt !== null && kt.memoizedState !== null;
                        if (((b = f), tt)) {
                          e: if (((S = b), (R = Kt), (P = null), tt))
                            for (var bt = S; ; ) {
                              if (bt.tag === 5) {
                                if (P === null) {
                                  P = bt;
                                  var In = bt.stateNode;
                                  R ? D(In) : k(bt.stateNode, bt.memoizedProps);
                                }
                              } else if (bt.tag === 6) {
                                if (P === null) {
                                  var Hi = bt.stateNode;
                                  R ? W(Hi) : ne(Hi, bt.memoizedProps);
                                }
                              } else if (
                                ((bt.tag !== 22 && bt.tag !== 23) ||
                                  bt.memoizedState === null ||
                                  bt === S) &&
                                bt.child !== null
                              ) {
                                (bt.child.return = bt), (bt = bt.child);
                                continue;
                              }
                              if (bt === S) break;
                              for (; bt.sibling === null; ) {
                                if (bt.return === null || bt.return === S)
                                  break e;
                                P === bt && (P = null), (bt = bt.return);
                              }
                              P === bt && (P = null),
                                (bt.sibling.return = bt.return),
                                (bt = bt.sibling);
                            }
                        }
                        if (Kt && !zn && b.mode & 1) {
                          ut = b;
                          for (var Ce = b.child; Ce !== null; ) {
                            for (b = ut = Ce; ut !== null; ) {
                              S = ut;
                              var ve = S.child;
                              switch (S.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  sa(4, S, S.return);
                                  break;
                                case 1:
                                  ns(S, S.return);
                                  var Le = S.stateNode;
                                  if (
                                    typeof Le.componentWillUnmount == "function"
                                  ) {
                                    var yt = S.return;
                                    try {
                                      (Le.props = S.memoizedProps),
                                        (Le.state = S.memoizedState),
                                        Le.componentWillUnmount();
                                    } catch (Pt) {
                                      Or(S, yt, Pt);
                                    }
                                  }
                                  break;
                                case 5:
                                  ns(S, S.return);
                                  break;
                                case 22:
                                  if (S.memoizedState !== null) {
                                    ff(b);
                                    continue;
                                  }
                              }
                              ve !== null
                                ? ((ve.return = S), (ut = ve))
                                : ff(b);
                            }
                            Ce = Ce.sibling;
                          }
                        }
                    }
                  switch (fe & 4102) {
                    case 2:
                      fd(f), (f.flags &= -3);
                      break;
                    case 6:
                      fd(f), (f.flags &= -3), md(f.alternate, f);
                      break;
                    case 4096:
                      f.flags &= -4097;
                      break;
                    case 4100:
                      (f.flags &= -4097), md(f.alternate, f);
                      break;
                    case 4:
                      md(f.alternate, f);
                  }
                } catch (Pt) {
                  Or(f, f.return, Pt);
                }
                if (((b = f.sibling), b !== null)) {
                  (b.return = f.return), (ut = b);
                  break;
                }
                ut = f.return;
              }
          }
        }
        function o2(h, f, b) {
          (ut = h), xl(h);
        }
        function xl(h, f, b) {
          for (var S = (h.mode & 1) !== 0; ut !== null; ) {
            var R = ut,
              P = R.child;
            if (R.tag === 22 && S) {
              var $ = R.memoizedState !== null || Ao;
              if (!$) {
                var fe = R.alternate,
                  De = (fe !== null && fe.memoizedState !== null) || Cr;
                fe = Ao;
                var rt = Cr;
                if (((Ao = $), (Cr = De) && !rt))
                  for (ut = R; ut !== null; )
                    ($ = ut),
                      (De = $.child),
                      $.tag === 22 && $.memoizedState !== null
                        ? pf(R)
                        : De !== null
                          ? ((De.return = $), (ut = De))
                          : pf(R);
                for (; P !== null; ) (ut = P), xl(P), (P = P.sibling);
                (ut = R), (Ao = fe), (Cr = rt);
              }
              Tu(h);
            } else
              R.subtreeFlags & 8772 && P !== null
                ? ((P.return = R), (ut = P))
                : Tu(h);
          }
        }
        function Tu(h) {
          for (; ut !== null; ) {
            var f = ut;
            if (f.flags & 8772) {
              var b = f.alternate;
              try {
                if (f.flags & 8772)
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Cr || wo(5, f);
                      break;
                    case 1:
                      var S = f.stateNode;
                      if (f.flags & 4 && !Cr)
                        if (b === null) S.componentDidMount();
                        else {
                          var R =
                            f.elementType === f.type
                              ? b.memoizedProps
                              : Pi(f.type, b.memoizedProps);
                          S.componentDidUpdate(
                            R,
                            b.memoizedState,
                            S.__reactInternalSnapshotBeforeUpdate,
                          );
                        }
                      var P = f.updateQueue;
                      P !== null && ym(f, P, S);
                      break;
                    case 3:
                      var $ = f.updateQueue;
                      if ($ !== null) {
                        if (((b = null), f.child !== null))
                          switch (f.child.tag) {
                            case 5:
                              b = _e(f.child.stateNode);
                              break;
                            case 1:
                              b = f.child.stateNode;
                          }
                        ym(f, $, b);
                      }
                      break;
                    case 5:
                      var fe = f.stateNode;
                      b === null &&
                        f.flags & 4 &&
                        Ot(fe, f.type, f.memoizedProps, f);
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (Te && f.memoizedState === null) {
                        var De = f.alternate;
                        if (De !== null) {
                          var rt = De.memoizedState;
                          if (rt !== null) {
                            var Et = rt.dehydrated;
                            Et !== null && jr(Et);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break;
                    default:
                      throw Error(s(163));
                  }
                Cr || (f.flags & 512 && si(f));
              } catch (Kt) {
                Or(f, f.return, Kt);
              }
            }
            if (f === h) {
              ut = null;
              break;
            }
            if (((b = f.sibling), b !== null)) {
              (b.return = f.return), (ut = b);
              break;
            }
            ut = f.return;
          }
        }
        function ff(h) {
          for (; ut !== null; ) {
            var f = ut;
            if (f === h) {
              ut = null;
              break;
            }
            var b = f.sibling;
            if (b !== null) {
              (b.return = f.return), (ut = b);
              break;
            }
            ut = f.return;
          }
        }
        function pf(h) {
          for (; ut !== null; ) {
            var f = ut;
            try {
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  var b = f.return;
                  try {
                    wo(4, f);
                  } catch (De) {
                    Or(f, b, De);
                  }
                  break;
                case 1:
                  var S = f.stateNode;
                  if (typeof S.componentDidMount == "function") {
                    var R = f.return;
                    try {
                      S.componentDidMount();
                    } catch (De) {
                      Or(f, R, De);
                    }
                  }
                  var P = f.return;
                  try {
                    si(f);
                  } catch (De) {
                    Or(f, P, De);
                  }
                  break;
                case 5:
                  var $ = f.return;
                  try {
                    si(f);
                  } catch (De) {
                    Or(f, $, De);
                  }
              }
            } catch (De) {
              Or(f, f.return, De);
            }
            if (f === h) {
              ut = null;
              break;
            }
            var fe = f.sibling;
            if (fe !== null) {
              (fe.return = f.return), (ut = fe);
              break;
            }
            ut = f.return;
          }
        }
        var oa = 0,
          Ru = 1,
          Mo = 2,
          So = 3,
          la = 4;
        if (typeof Symbol == "function" && Symbol.for) {
          var Eo = Symbol.for;
          (oa = Eo("selector.component")),
            (Ru = Eo("selector.has_pseudo_class")),
            (Mo = Eo("selector.role")),
            (So = Eo("selector.test_id")),
            (la = Eo("selector.text"));
        }
        function Iu(h) {
          var f = Ne(h);
          if (f != null) {
            if (typeof f.memoizedProps["data-testname"] != "string")
              throw Error(s(364));
            return f;
          }
          if (((h = it(h)), h === null)) throw Error(s(362));
          return h.stateNode.current;
        }
        function Bu(h, f) {
          switch (f.$$typeof) {
            case oa:
              if (h.type === f.value) return !0;
              break;
            case Ru:
              e: {
                (f = f.value), (h = [h, 0]);
                for (var b = 0; b < h.length; ) {
                  var S = h[b++],
                    R = h[b++],
                    P = f[R];
                  if (S.tag !== 5 || !xe(S)) {
                    for (; P != null && Bu(S, P); ) R++, (P = f[R]);
                    if (R === f.length) {
                      f = !0;
                      break e;
                    } else
                      for (S = S.child; S !== null; )
                        h.push(S, R), (S = S.sibling);
                  }
                }
                f = !1;
              }
              return f;
            case Mo:
              if (h.tag === 5 && ze(h.stateNode, f.value)) return !0;
              break;
            case la:
              if (
                (h.tag === 5 || h.tag === 6) &&
                ((h = G(h)), h !== null && 0 <= h.indexOf(f.value))
              )
                return !0;
              break;
            case So:
              if (
                h.tag === 5 &&
                ((h = h.memoizedProps["data-testname"]),
                typeof h == "string" &&
                  h.toLowerCase() === f.value.toLowerCase())
              )
                return !0;
              break;
            default:
              throw Error(s(365));
          }
          return !1;
        }
        function Pu(h) {
          switch (h.$$typeof) {
            case oa:
              return "<" + (F(h.value) || "Unknown") + ">";
            case Ru:
              return ":has(" + (Pu(h) || "") + ")";
            case Mo:
              return '[role="' + h.value + '"]';
            case la:
              return '"' + h.value + '"';
            case So:
              return '[data-testname="' + h.value + '"]';
            default:
              throw Error(s(365));
          }
        }
        function Co(h, f) {
          var b = [];
          h = [h, 0];
          for (var S = 0; S < h.length; ) {
            var R = h[S++],
              P = h[S++],
              $ = f[P];
            if (R.tag !== 5 || !xe(R)) {
              for (; $ != null && Bu(R, $); ) P++, ($ = f[P]);
              if (P === f.length) b.push(R);
              else
                for (R = R.child; R !== null; ) h.push(R, P), (R = R.sibling);
            }
          }
          return b;
        }
        function xi(h, f) {
          if (!Dt) throw Error(s(363));
          (h = Iu(h)), (h = Co(h, f)), (f = []), (h = Array.from(h));
          for (var b = 0; b < h.length; ) {
            var S = h[b++];
            if (S.tag === 5) xe(S) || f.push(S.stateNode);
            else for (S = S.child; S !== null; ) h.push(S), (S = S.sibling);
          }
          return f;
        }
        var To = Math.ceil,
          bl = a.ReactCurrentDispatcher,
          gd = a.ReactCurrentOwner,
          Nn = a.ReactCurrentBatchConfig,
          Yt = 0,
          tr = null,
          rr = null,
          Jn = 0,
          fr = 0,
          ua = Ut(0),
          pr = 0,
          Va = null,
          Ro = 0,
          Ga = 0,
          is = 0,
          ca = null,
          Tr = null,
          da = 0,
          Lu = 1 / 0;
        function xs() {
          Lu = Er() + 500;
        }
        var Du = !1,
          Fu = null,
          Rn = null,
          Io = !1,
          Ns = null,
          _l = 0,
          ja = 0,
          Nu = null,
          Us = -1,
          jn = 0;
        function xn() {
          return Yt & 6 ? Er() : Us !== -1 ? Us : (Us = Er());
        }
        function Yn(h) {
          return h.mode & 1
            ? Yt & 2 && Jn !== 0
              ? Jn & -Jn
              : Fh.transition !== null
                ? (jn === 0 &&
                    ((h = Xr),
                    (Xr <<= 1),
                    !(Xr & 4194240) && (Xr = 64),
                    (jn = h)),
                  jn)
                : ((h = ln), h !== 0 ? h : qe())
            : 1;
        }
        function ai(h, f, b) {
          if (50 < ja) throw ((ja = 0), (Nu = null), Error(s(185)));
          var S = Wa(h, f);
          return S === null
            ? null
            : ($o(S, f, b),
              (!(Yt & 2) || S !== tr) &&
                (S === tr && (!(Yt & 2) && (Ga |= f), pr === 4 && Os(S, Jn)),
                Rr(S, b),
                f === 1 && Yt === 0 && !(h.mode & 1) && (xs(), uo && Bi())),
              S);
        }
        function Wa(h, f) {
          h.lanes |= f;
          var b = h.alternate;
          for (b !== null && (b.lanes |= f), b = h, h = h.return; h !== null; )
            (h.childLanes |= f),
              (b = h.alternate),
              b !== null && (b.childLanes |= f),
              (b = h),
              (h = h.return);
          return b.tag === 3 ? b.stateNode : null;
        }
        function Rr(h, f) {
          var b = h.callbackNode;
          Ih(h, f);
          var S = $l(h, h === tr ? Jn : 0);
          if (S === 0)
            b !== null && tl(b),
              (h.callbackNode = null),
              (h.callbackPriority = 0);
          else if (((f = S & -S), h.callbackPriority !== f)) {
            if ((b != null && tl(b), f === 1))
              h.tag === 0 ? Dh(bs.bind(null, h)) : mm(bs.bind(null, h)),
                Be
                  ? nt(function () {
                      Yt === 0 && Bi();
                    })
                  : Rs(Yc, Bi),
                (b = null);
            else {
              switch (Zs(S)) {
                case 1:
                  b = Yc;
                  break;
                case 4:
                  b = tu;
                  break;
                case 16:
                  b = Ph;
                  break;
                case 536870912:
                  b = pm;
                  break;
                default:
                  b = Ph;
              }
              b = bf(b, Pm.bind(null, h));
            }
            (h.callbackPriority = f), (h.callbackNode = b);
          }
        }
        function Pm(h, f) {
          if (((Us = -1), (jn = 0), Yt & 6)) throw Error(s(327));
          var b = h.callbackNode;
          if (Ja() && h.callbackNode !== b) return null;
          var S = $l(h, h === tr ? Jn : 0);
          if (S === 0) return null;
          if (S & 30 || S & h.expiredLanes || f) f = Ou(h, S);
          else {
            f = S;
            var R = Yt;
            Yt |= 2;
            var P = gf();
            (tr !== h || Jn !== f) && (xs(), ha(h, f));
            do
              try {
                Dm();
                break;
              } catch (fe) {
                yd(h, fe);
              }
            while (!0);
            Zc(),
              (bl.current = P),
              (Yt = R),
              rr !== null ? (f = 0) : ((tr = null), (Jn = 0), (f = pr));
          }
          if (f !== 0) {
            if (
              (f === 2 && ((R = Xc(h)), R !== 0 && ((S = R), (f = Ir(h, R)))),
              f === 1)
            )
              throw ((b = Va), ha(h, 0), Os(h, S), Rr(h, Er()), b);
            if (f === 6) Os(h, S);
            else {
              if (
                ((R = h.current.alternate),
                !(S & 30) &&
                  !mf(R) &&
                  ((f = Ou(h, S)),
                  f === 2 &&
                    ((P = Xc(h)), P !== 0 && ((S = P), (f = Ir(h, P)))),
                  f === 1))
              )
                throw ((b = Va), ha(h, 0), Os(h, S), Rr(h, Er()), b);
              switch (((h.finishedWork = R), (h.finishedLanes = S), f)) {
                case 0:
                case 1:
                  throw Error(s(345));
                case 2:
                  Xa(h, Tr);
                  break;
                case 3:
                  if (
                    (Os(h, S),
                    (S & 130023424) === S && ((f = da + 500 - Er()), 10 < f))
                  ) {
                    if ($l(h, 0) !== 0) break;
                    if (((R = h.suspendedLanes), (R & S) !== S)) {
                      xn(), (h.pingedLanes |= h.suspendedLanes & R);
                      break;
                    }
                    h.timeoutHandle = Ue(Xa.bind(null, h, Tr), f);
                    break;
                  }
                  Xa(h, Tr);
                  break;
                case 4:
                  if ((Os(h, S), (S & 4194240) === S)) break;
                  for (f = h.eventTimes, R = -1; 0 < S; ) {
                    var $ = 31 - cn(S);
                    (P = 1 << $), ($ = f[$]), $ > R && (R = $), (S &= ~P);
                  }
                  if (
                    ((S = R),
                    (S = Er() - S),
                    (S =
                      (120 > S
                        ? 120
                        : 480 > S
                          ? 480
                          : 1080 > S
                            ? 1080
                            : 1920 > S
                              ? 1920
                              : 3e3 > S
                                ? 3e3
                                : 4320 > S
                                  ? 4320
                                  : 1960 * To(S / 1960)) - S),
                    10 < S)
                  ) {
                    h.timeoutHandle = Ue(Xa.bind(null, h, Tr), S);
                    break;
                  }
                  Xa(h, Tr);
                  break;
                case 5:
                  Xa(h, Tr);
                  break;
                default:
                  throw Error(s(329));
              }
            }
          }
          return Rr(h, Er()), h.callbackNode === b ? Pm.bind(null, h) : null;
        }
        function Ir(h, f) {
          var b = ca;
          return (
            h.current.memoizedState.isDehydrated && (ha(h, f).flags |= 256),
            (h = Ou(h, f)),
            h !== 2 && ((f = Tr), (Tr = b), f !== null && Uu(f)),
            h
          );
        }
        function Uu(h) {
          Tr === null ? (Tr = h) : Tr.push.apply(Tr, h);
        }
        function mf(h) {
          for (var f = h; ; ) {
            if (f.flags & 16384) {
              var b = f.updateQueue;
              if (b !== null && ((b = b.stores), b !== null))
                for (var S = 0; S < b.length; S++) {
                  var R = b[S],
                    P = R.getSnapshot;
                  R = R.value;
                  try {
                    if (!fi(P(), R)) return !1;
                  } catch {
                    return !1;
                  }
                }
            }
            if (((b = f.child), f.subtreeFlags & 16384 && b !== null))
              (b.return = f), (f = b);
            else {
              if (f === h) break;
              for (; f.sibling === null; ) {
                if (f.return === null || f.return === h) return !0;
                f = f.return;
              }
              (f.sibling.return = f.return), (f = f.sibling);
            }
          }
          return !0;
        }
        function Os(h, f) {
          for (
            f &= ~is,
              f &= ~Ga,
              h.suspendedLanes |= f,
              h.pingedLanes &= ~f,
              h = h.expirationTimes;
            0 < f;

          ) {
            var b = 31 - cn(f),
              S = 1 << b;
            (h[b] = -1), (f &= ~S);
          }
        }
        function bs(h) {
          if (Yt & 6) throw Error(s(327));
          Ja();
          var f = $l(h, 0);
          if (!(f & 1)) return Rr(h, Er()), null;
          var b = Ou(h, f);
          if (h.tag !== 0 && b === 2) {
            var S = Xc(h);
            S !== 0 && ((f = S), (b = Ir(h, S)));
          }
          if (b === 1) throw ((b = Va), ha(h, 0), Os(h, f), Rr(h, Er()), b);
          if (b === 6) throw Error(s(345));
          return (
            (h.finishedWork = h.current.alternate),
            (h.finishedLanes = f),
            Xa(h, Tr),
            Rr(h, Er()),
            null
          );
        }
        function Oi(h) {
          Ns !== null && Ns.tag === 0 && !(Yt & 6) && Ja();
          var f = Yt;
          Yt |= 1;
          var b = Nn.transition,
            S = ln;
          try {
            if (((Nn.transition = null), (ln = 1), h)) return h();
          } finally {
            (ln = S), (Nn.transition = b), (Yt = f), !(Yt & 6) && Bi();
          }
        }
        function Bo() {
          (fr = ua.current), gt(ua);
        }
        function ha(h, f) {
          (h.finishedWork = null), (h.finishedLanes = 0);
          var b = h.timeoutHandle;
          if ((b !== Je && ((h.timeoutHandle = Je), Fe(b)), rr !== null))
            for (b = rr.return; b !== null; ) {
              var S = b;
              switch ((zh(S), S.tag)) {
                case 1:
                  (S = S.type.childContextTypes), S != null && $r();
                  break;
                case 3:
                  go(), gt($t), gt(Jt), Fi();
                  break;
                case 5:
                  jh(S);
                  break;
                case 4:
                  go();
                  break;
                case 13:
                  gt(Qn);
                  break;
                case 19:
                  gt(Qn);
                  break;
                case 10:
                  Pa(S.type._context);
                  break;
                case 22:
                case 23:
                  Bo();
              }
              b = b.return;
            }
          if (
            ((tr = h),
            (rr = h = Ya(h.current, null)),
            (Jn = fr = f),
            (pr = 0),
            (Va = null),
            (is = Ga = Ro = 0),
            (Tr = ca = null),
            qi !== null)
          ) {
            for (f = 0; f < qi.length; f++)
              if (((b = qi[f]), (S = b.interleaved), S !== null)) {
                b.interleaved = null;
                var R = S.next,
                  P = b.pending;
                if (P !== null) {
                  var $ = P.next;
                  (P.next = R), (S.next = $);
                }
                b.pending = S;
              }
            qi = null;
          }
          return h;
        }
        function yd(h, f) {
          do {
            var b = rr;
            try {
              if ((Zc(), (Na.current = _o), rd)) {
                for (var S = $n.memoizedState; S !== null; ) {
                  var R = S.queue;
                  R !== null && (R.pending = null), (S = S.next);
                }
                rd = !1;
              }
              if (
                ((yo = 0),
                (ur = Nr = $n = null),
                (hu = !1),
                (Ls = 0),
                (gd.current = null),
                b === null || b.return === null)
              ) {
                (pr = 1), (Va = f), (rr = null);
                break;
              }
              e: {
                var P = h,
                  $ = b.return,
                  fe = b,
                  De = f;
                if (
                  ((f = Jn),
                  (fe.flags |= 32768),
                  De !== null &&
                    typeof De == "object" &&
                    typeof De.then == "function")
                ) {
                  var rt = De,
                    Et = fe,
                    Kt = Et.tag;
                  if (!(Et.mode & 1) && (Kt === 0 || Kt === 11 || Kt === 15)) {
                    var kt = Et.alternate;
                    kt
                      ? ((Et.updateQueue = kt.updateQueue),
                        (Et.memoizedState = kt.memoizedState),
                        (Et.lanes = kt.lanes))
                      : ((Et.updateQueue = null), (Et.memoizedState = null));
                  }
                  var zn = ea($);
                  if (zn !== null) {
                    (zn.flags &= -257),
                      of(zn, $, fe, P, f),
                      zn.mode & 1 && ld(P, rt, f),
                      (f = zn),
                      (De = rt);
                    var bt = f.updateQueue;
                    if (bt === null) {
                      var In = new Set();
                      In.add(De), (f.updateQueue = In);
                    } else bt.add(De);
                    break e;
                  } else {
                    if (!(f & 1)) {
                      ld(P, rt, f), vd();
                      break e;
                    }
                    De = Error(s(426));
                  }
                } else if (On && fe.mode & 1) {
                  var Hi = ea($);
                  if (Hi !== null) {
                    !(Hi.flags & 65536) && (Hi.flags |= 256),
                      of(Hi, $, fe, P, f),
                      Gh(De);
                    break e;
                  }
                }
                (P = De),
                  pr !== 4 && (pr = 2),
                  ca === null ? (ca = [P]) : ca.push(P),
                  (De = bu(De, fe)),
                  (fe = $);
                do {
                  switch (fe.tag) {
                    case 3:
                      (fe.flags |= 65536), (f &= -f), (fe.lanes |= f);
                      var Ce = Tm(fe, De, f);
                      gm(fe, Ce);
                      break e;
                    case 1:
                      P = De;
                      var ve = fe.type,
                        Le = fe.stateNode;
                      if (
                        !(fe.flags & 128) &&
                        (typeof ve.getDerivedStateFromError == "function" ||
                          (Le !== null &&
                            typeof Le.componentDidCatch == "function" &&
                            (Rn === null || !Rn.has(Le))))
                      ) {
                        (fe.flags |= 65536), (f &= -f), (fe.lanes |= f);
                        var yt = Rm(fe, P, f);
                        gm(fe, yt);
                        break e;
                      }
                  }
                  fe = fe.return;
                } while (fe !== null);
              }
              vf(b);
            } catch (Pt) {
              (f = Pt), rr === b && b !== null && (rr = b = b.return);
              continue;
            }
            break;
          } while (!0);
        }
        function gf() {
          var h = bl.current;
          return (bl.current = _o), h === null ? _o : h;
        }
        function vd() {
          (pr === 0 || pr === 3 || pr === 2) && (pr = 4),
            tr === null ||
              (!(Ro & 268435455) && !(Ga & 268435455)) ||
              Os(tr, Jn);
        }
        function Ou(h, f) {
          var b = Yt;
          Yt |= 2;
          var S = gf();
          (tr === h && Jn === f) || ha(h, f);
          do
            try {
              Lm();
              break;
            } catch (R) {
              yd(h, R);
            }
          while (!0);
          if ((Zc(), (Yt = b), (bl.current = S), rr !== null))
            throw Error(s(261));
          return (tr = null), (Jn = 0), pr;
        }
        function Lm() {
          for (; rr !== null; ) yf(rr);
        }
        function Dm() {
          for (; rr !== null && !eu(); ) yf(rr);
        }
        function yf(h) {
          var f = xf(h.alternate, h, fr);
          (h.memoizedProps = h.pendingProps),
            f === null ? vf(h) : (rr = f),
            (gd.current = null);
        }
        function vf(h) {
          var f = h;
          do {
            var b = f.alternate;
            if (((h = f.return), f.flags & 32768)) {
              if (((b = hd(b, f)), b !== null)) {
                (b.flags &= 32767), (rr = b);
                return;
              }
              if (h !== null)
                (h.flags |= 32768), (h.subtreeFlags = 0), (h.deletions = null);
              else {
                (pr = 6), (rr = null);
                return;
              }
            } else if (((b = gl(b, f, fr)), b !== null)) {
              rr = b;
              return;
            }
            if (((f = f.sibling), f !== null)) {
              rr = f;
              return;
            }
            rr = f = h;
          } while (f !== null);
          pr === 0 && (pr = 5);
        }
        function Xa(h, f) {
          var b = ln,
            S = Nn.transition;
          try {
            (Nn.transition = null), (ln = 1), ku(h, f, b);
          } finally {
            (Nn.transition = S), (ln = b);
          }
          return null;
        }
        function ku(h, f, b) {
          do Ja();
          while (Ns !== null);
          if (Yt & 6) throw Error(s(327));
          var S = h.finishedWork,
            R = h.finishedLanes;
          if (S === null) return null;
          if (((h.finishedWork = null), (h.finishedLanes = 0), S === h.current))
            throw Error(s(177));
          (h.callbackNode = null), (h.callbackPriority = 0);
          var P = S.lanes | S.childLanes;
          if (
            (Bh(h, P),
            h === tr && ((rr = tr = null), (Jn = 0)),
            (!(S.subtreeFlags & 2064) && !(S.flags & 2064)) ||
              Io ||
              ((Io = !0),
              bf(Ph, function () {
                return Ja(), null;
              })),
            (P = (S.flags & 15990) !== 0),
            S.subtreeFlags & 15990 || P)
          ) {
            (P = Nn.transition), (Nn.transition = null);
            var $ = ln;
            ln = 1;
            var fe = Yt;
            (Yt |= 4),
              (gd.current = null),
              Bm(h, S),
              hf(h, S),
              oe(h.containerInfo),
              (h.current = S),
              o2(S),
              Ia(),
              (Yt = fe),
              (ln = $),
              (Nn.transition = P);
          } else h.current = S;
          if (
            (Io && ((Io = !1), (Ns = h), (_l = R)),
            (P = h.pendingLanes),
            P === 0 && (Rn = null),
            a2(S.stateNode),
            Rr(h, Er()),
            f !== null)
          )
            for (b = h.onRecoverableError, S = 0; S < f.length; S++) b(f[S]);
          if (Du) throw ((Du = !1), (h = Fu), (Fu = null), h);
          return (
            _l & 1 && h.tag !== 0 && Ja(),
            (P = h.pendingLanes),
            P & 1 ? (h === Nu ? ja++ : ((ja = 0), (Nu = h))) : (ja = 0),
            Bi(),
            null
          );
        }
        function Ja() {
          if (Ns !== null) {
            var h = Zs(_l),
              f = Nn.transition,
              b = ln;
            try {
              if (((Nn.transition = null), (ln = 16 > h ? 16 : h), Ns === null))
                var S = !1;
              else {
                if (((h = Ns), (Ns = null), (_l = 0), Yt & 6))
                  throw Error(s(331));
                var R = Yt;
                for (Yt |= 4, ut = h.current; ut !== null; ) {
                  var P = ut,
                    $ = P.child;
                  if (ut.flags & 16) {
                    var fe = P.deletions;
                    if (fe !== null) {
                      for (var De = 0; De < fe.length; De++) {
                        var rt = fe[De];
                        for (ut = rt; ut !== null; ) {
                          var Et = ut;
                          switch (Et.tag) {
                            case 0:
                            case 11:
                            case 15:
                              sa(8, Et, P);
                          }
                          var Kt = Et.child;
                          if (Kt !== null) (Kt.return = Et), (ut = Kt);
                          else
                            for (; ut !== null; ) {
                              Et = ut;
                              var kt = Et.sibling,
                                zn = Et.return;
                              if ((rs(Et), Et === rt)) {
                                ut = null;
                                break;
                              }
                              if (kt !== null) {
                                (kt.return = zn), (ut = kt);
                                break;
                              }
                              ut = zn;
                            }
                        }
                      }
                      var bt = P.alternate;
                      if (bt !== null) {
                        var In = bt.child;
                        if (In !== null) {
                          bt.child = null;
                          do {
                            var Hi = In.sibling;
                            (In.sibling = null), (In = Hi);
                          } while (In !== null);
                        }
                      }
                      ut = P;
                    }
                  }
                  if (P.subtreeFlags & 2064 && $ !== null)
                    ($.return = P), (ut = $);
                  else
                    e: for (; ut !== null; ) {
                      if (((P = ut), P.flags & 2048))
                        switch (P.tag) {
                          case 0:
                          case 11:
                          case 15:
                            sa(9, P, P.return);
                        }
                      var Ce = P.sibling;
                      if (Ce !== null) {
                        (Ce.return = P.return), (ut = Ce);
                        break e;
                      }
                      ut = P.return;
                    }
                }
                var ve = h.current;
                for (ut = ve; ut !== null; ) {
                  $ = ut;
                  var Le = $.child;
                  if ($.subtreeFlags & 2064 && Le !== null)
                    (Le.return = $), (ut = Le);
                  else
                    e: for ($ = ve; ut !== null; ) {
                      if (((fe = ut), fe.flags & 2048))
                        try {
                          switch (fe.tag) {
                            case 0:
                            case 11:
                            case 15:
                              wo(9, fe);
                          }
                        } catch (Pt) {
                          Or(fe, fe.return, Pt);
                        }
                      if (fe === $) {
                        ut = null;
                        break e;
                      }
                      var yt = fe.sibling;
                      if (yt !== null) {
                        (yt.return = fe.return), (ut = yt);
                        break e;
                      }
                      ut = fe.return;
                    }
                }
                if (
                  ((Yt = R),
                  Bi(),
                  ms && typeof ms.onPostCommitFiberRoot == "function")
                )
                  try {
                    ms.onPostCommitFiberRoot(lo, h);
                  } catch {}
                S = !0;
              }
              return S;
            } finally {
              (ln = b), (Nn.transition = f);
            }
          }
          return !1;
        }
        function zu(h, f, b) {
          (f = bu(b, f)),
            (f = Tm(h, f, 1)),
            La(h, f),
            (f = xn()),
            (h = Wa(h, 1)),
            h !== null && ($o(h, 1, f), Rr(h, f));
        }
        function Or(h, f, b) {
          if (h.tag === 3) zu(h, h, b);
          else
            for (; f !== null; ) {
              if (f.tag === 3) {
                zu(f, h, b);
                break;
              } else if (f.tag === 1) {
                var S = f.stateNode;
                if (
                  typeof f.type.getDerivedStateFromError == "function" ||
                  (typeof S.componentDidCatch == "function" &&
                    (Rn === null || !Rn.has(S)))
                ) {
                  (h = bu(b, h)),
                    (h = Rm(f, h, 1)),
                    La(f, h),
                    (h = xn()),
                    (f = Wa(f, 1)),
                    f !== null && ($o(f, 1, h), Rr(f, h));
                  break;
                }
              }
              f = f.return;
            }
        }
        function Fm(h, f, b) {
          var S = h.pingCache;
          S !== null && S.delete(f),
            (f = xn()),
            (h.pingedLanes |= h.suspendedLanes & b),
            tr === h &&
              (Jn & b) === b &&
              (pr === 4 ||
              (pr === 3 && (Jn & 130023424) === Jn && 500 > Er() - da)
                ? ha(h, 0)
                : (is |= b)),
            Rr(h, f);
        }
        function xd(h, f) {
          f === 0 &&
            (h.mode & 1
              ? ((f = Ts), (Ts <<= 1), !(Ts & 130023424) && (Ts = 4194304))
              : (f = 1));
          var b = xn();
          (h = Wa(h, f)), h !== null && ($o(h, f, b), Rr(h, b));
        }
        function Nm(h) {
          var f = h.memoizedState,
            b = 0;
          f !== null && (b = f.retryLane), xd(h, b);
        }
        function Um(h, f) {
          var b = 0;
          switch (h.tag) {
            case 13:
              var S = h.stateNode,
                R = h.memoizedState;
              R !== null && (b = R.retryLane);
              break;
            case 19:
              S = h.stateNode;
              break;
            default:
              throw Error(s(314));
          }
          S !== null && S.delete(f), xd(h, b);
        }
        var xf;
        xf = function (h, f, b) {
          if (h !== null)
            if (h.memoizedProps !== f.pendingProps || $t.current) ri = !0;
            else {
              if (!(h.lanes & b) && !(f.flags & 128))
                return (ri = !1), vl(h, f, b);
              ri = !!(h.flags & 131072);
            }
          else (ri = !1), On && f.flags & 1048576 && _m(f, Qc, f.index);
          switch (((f.lanes = 0), f.tag)) {
            case 2:
              var S = f.type;
              h !== null &&
                ((h.alternate = null), (f.alternate = null), (f.flags |= 2)),
                (h = f.pendingProps);
              var R = Ft(f, Jt.current);
              Is(f, b), (R = id(null, f, S, h, R, b));
              var P = hl();
              return (
                (f.flags |= 1),
                typeof R == "object" &&
                R !== null &&
                typeof R.render == "function" &&
                R.$$typeof === void 0
                  ? ((f.tag = 1),
                    (f.memoizedState = null),
                    (f.updateQueue = null),
                    vn(S) ? ((P = !0), Sr(f)) : (P = !1),
                    (f.memoizedState =
                      R.state !== null && R.state !== void 0 ? R.state : null),
                    ho(f),
                    (R.updater = Kc),
                    (f.stateNode = R),
                    (R._reactInternals = f),
                    Oh(f, S, h, b),
                    (f = za(null, f, S, !0, P, b)))
                  : ((f.tag = 0),
                    On && P && kh(f),
                    hr(null, f, R, b),
                    (f = f.child)),
                f
              );
            case 16:
              S = f.elementType;
              e: {
                switch (
                  (h !== null &&
                    ((h.alternate = null),
                    (f.alternate = null),
                    (f.flags |= 2)),
                  (h = f.pendingProps),
                  (R = S._init),
                  (S = R(S._payload)),
                  (f.type = S),
                  (R = f.tag = Om(S)),
                  (h = Pi(S, h)),
                  R)
                ) {
                  case 0:
                    f = Jr(null, f, S, h, b);
                    break e;
                  case 1:
                    f = ka(null, f, S, h, b);
                    break e;
                  case 11:
                    f = na(null, f, S, h, b);
                    break e;
                  case 14:
                    f = Gn(null, f, S, Pi(S.type, h), b);
                    break e;
                }
                throw Error(s(306, S, ""));
              }
              return f;
            case 0:
              return (
                (S = f.type),
                (R = f.pendingProps),
                (R = f.elementType === S ? R : Pi(S, R)),
                Jr(h, f, S, R, b)
              );
            case 1:
              return (
                (S = f.type),
                (R = f.pendingProps),
                (R = f.elementType === S ? R : Pi(S, R)),
                ka(h, f, S, R, b)
              );
            case 3:
              e: {
                if ((ii(f), h === null)) throw Error(s(387));
                (S = f.pendingProps),
                  (P = f.memoizedState),
                  (R = P.element),
                  au(h, f),
                  rl(f, S, null, b);
                var $ = f.memoizedState;
                if (((S = $.element), Te && P.isDehydrated))
                  if (
                    ((P = {
                      element: S,
                      isDehydrated: !1,
                      cache: $.cache,
                      transitions: $.transitions,
                    }),
                    (f.updateQueue.baseState = P),
                    (f.memoizedState = P),
                    f.flags & 256)
                  ) {
                    (R = Error(s(423))), (f = _u(h, f, S, b, R));
                    break e;
                  } else if (S !== R) {
                    (R = Error(s(424))), (f = _u(h, f, S, b, R));
                    break e;
                  } else
                    for (
                      Te &&
                        ((ti = Wn(f.stateNode.containerInfo)),
                        (Li = f),
                        (On = !0),
                        ($i = null),
                        (ou = !1)),
                        b = cu(f, null, S, b),
                        f.child = b;
                      b;

                    )
                      (b.flags = (b.flags & -3) | 4096), (b = b.sibling);
                else {
                  if ((ol(), S === R)) {
                    f = yi(h, f, b);
                    break e;
                  }
                  hr(h, f, S, b);
                }
                f = f.child;
              }
              return f;
            case 5:
              return (
                Am(f),
                h === null && ed(f),
                (S = f.type),
                (R = f.pendingProps),
                (P = h !== null ? h.memoizedProps : null),
                ($ = R.children),
                ye(S, R)
                  ? ($ = null)
                  : P !== null && ye(S, P) && (f.flags |= 32),
                Ur(h, f),
                hr(h, f, $, b),
                f.child
              );
            case 6:
              return h === null && ed(f), null;
            case 13:
              return Mu(h, f, b);
            case 4:
              return (
                td(f, f.stateNode.containerInfo),
                (S = f.pendingProps),
                h === null ? (f.child = dl(f, null, S, b)) : hr(h, f, S, b),
                f.child
              );
            case 11:
              return (
                (S = f.type),
                (R = f.pendingProps),
                (R = f.elementType === S ? R : Pi(S, R)),
                na(h, f, S, R, b)
              );
            case 7:
              return hr(h, f, f.pendingProps, b), f.child;
            case 8:
              return hr(h, f, f.pendingProps.children, b), f.child;
            case 12:
              return hr(h, f, f.pendingProps.children, b), f.child;
            case 10:
              e: {
                if (
                  ((S = f.type._context),
                  (R = f.pendingProps),
                  (P = f.memoizedProps),
                  ($ = R.value),
                  mi(f, S, $),
                  P !== null)
                )
                  if (fi(P.value, $)) {
                    if (P.children === R.children && !$t.current) {
                      f = yi(h, f, b);
                      break e;
                    }
                  } else
                    for (
                      P = f.child, P !== null && (P.return = f);
                      P !== null;

                    ) {
                      var fe = P.dependencies;
                      if (fe !== null) {
                        $ = P.child;
                        for (var De = fe.firstContext; De !== null; ) {
                          if (De.context === S) {
                            if (P.tag === 1) {
                              (De = Ps(-1, b & -b)), (De.tag = 2);
                              var rt = P.updateQueue;
                              if (rt !== null) {
                                rt = rt.shared;
                                var Et = rt.pending;
                                Et === null
                                  ? (De.next = De)
                                  : ((De.next = Et.next), (Et.next = De)),
                                  (rt.pending = De);
                              }
                            }
                            (P.lanes |= b),
                              (De = P.alternate),
                              De !== null && (De.lanes |= b),
                              su(P.return, b, f),
                              (fe.lanes |= b);
                            break;
                          }
                          De = De.next;
                        }
                      } else if (P.tag === 10)
                        $ = P.type === f.type ? null : P.child;
                      else if (P.tag === 18) {
                        if ((($ = P.return), $ === null)) throw Error(s(341));
                        ($.lanes |= b),
                          (fe = $.alternate),
                          fe !== null && (fe.lanes |= b),
                          su($, b, f),
                          ($ = P.sibling);
                      } else $ = P.child;
                      if ($ !== null) $.return = P;
                      else
                        for ($ = P; $ !== null; ) {
                          if ($ === f) {
                            $ = null;
                            break;
                          }
                          if (((P = $.sibling), P !== null)) {
                            (P.return = $.return), ($ = P);
                            break;
                          }
                          $ = $.return;
                        }
                      P = $;
                    }
                hr(h, f, R.children, b), (f = f.child);
              }
              return f;
            case 9:
              return (
                (R = f.type),
                (S = f.pendingProps.children),
                Is(f, b),
                (R = Zi(R)),
                (S = S(R)),
                (f.flags |= 1),
                hr(h, f, S, b),
                f.child
              );
            case 14:
              return (
                (S = f.type),
                (R = Pi(S, f.pendingProps)),
                (R = Pi(S.type, R)),
                Gn(h, f, S, R, b)
              );
            case 15:
              return kn(h, f, f.type, f.pendingProps, b);
            case 17:
              return (
                (S = f.type),
                (R = f.pendingProps),
                (R = f.elementType === S ? R : Pi(S, R)),
                h !== null &&
                  ((h.alternate = null), (f.alternate = null), (f.flags |= 2)),
                (f.tag = 1),
                vn(S) ? ((h = !0), Sr(f)) : (h = !1),
                Is(f, b),
                Uh(f, S, R),
                Oh(f, S, R, b),
                za(null, f, S, !0, h, b)
              );
            case 19:
              return ia(h, f, b);
            case 22:
              return ra(h, f, b);
          }
          throw Error(s(156, f.tag));
        };
        function bf(h, f) {
          return Rs(h, f);
        }
        function _f(h, f, b, S) {
          (this.tag = h),
            (this.key = b),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = f),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = S),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function ki(h, f, b, S) {
          return new _f(h, f, b, S);
        }
        function bd(h) {
          return (h = h.prototype), !(!h || !h.isReactComponent);
        }
        function Om(h) {
          if (typeof h == "function") return bd(h) ? 1 : 0;
          if (h != null) {
            if (((h = h.$$typeof), h === A)) return 11;
            if (h === x) return 14;
          }
          return 2;
        }
        function Ya(h, f) {
          var b = h.alternate;
          return (
            b === null
              ? ((b = ki(h.tag, f, h.key, h.mode)),
                (b.elementType = h.elementType),
                (b.type = h.type),
                (b.stateNode = h.stateNode),
                (b.alternate = h),
                (h.alternate = b))
              : ((b.pendingProps = f),
                (b.type = h.type),
                (b.flags = 0),
                (b.subtreeFlags = 0),
                (b.deletions = null)),
            (b.flags = h.flags & 14680064),
            (b.childLanes = h.childLanes),
            (b.lanes = h.lanes),
            (b.child = h.child),
            (b.memoizedProps = h.memoizedProps),
            (b.memoizedState = h.memoizedState),
            (b.updateQueue = h.updateQueue),
            (f = h.dependencies),
            (b.dependencies =
              f === null
                ? null
                : { lanes: f.lanes, firstContext: f.firstContext }),
            (b.sibling = h.sibling),
            (b.index = h.index),
            (b.ref = h.ref),
            b
          );
        }
        function Hu(h, f, b, S, R, P) {
          var $ = 2;
          if (((S = h), typeof h == "function")) bd(h) && ($ = 1);
          else if (typeof h == "string") $ = 5;
          else
            e: switch (h) {
              case d:
                return Po(b.children, R, P, f);
              case p:
                ($ = 8), (R |= 8);
                break;
              case m:
                return (
                  (h = ki(12, b, f, R | 2)),
                  (h.elementType = m),
                  (h.lanes = P),
                  h
                );
              case M:
                return (
                  (h = ki(13, b, f, R)), (h.elementType = M), (h.lanes = P), h
                );
              case w:
                return (
                  (h = ki(19, b, f, R)), (h.elementType = w), (h.lanes = P), h
                );
              case T:
                return _d(b, R, P, f);
              default:
                if (typeof h == "object" && h !== null)
                  switch (h.$$typeof) {
                    case y:
                      $ = 10;
                      break e;
                    case v:
                      $ = 9;
                      break e;
                    case A:
                      $ = 11;
                      break e;
                    case x:
                      $ = 14;
                      break e;
                    case C:
                      ($ = 16), (S = null);
                      break e;
                  }
                throw Error(s(130, h == null ? h : typeof h, ""));
            }
          return (
            (f = ki($, b, f, R)),
            (f.elementType = h),
            (f.type = S),
            (f.lanes = P),
            f
          );
        }
        function Po(h, f, b, S) {
          return (h = ki(7, h, S, f)), (h.lanes = b), h;
        }
        function _d(h, f, b, S) {
          return (
            (h = ki(22, h, S, f)),
            (h.elementType = T),
            (h.lanes = b),
            (h.stateNode = {}),
            h
          );
        }
        function Ad(h, f, b) {
          return (h = ki(6, h, null, f)), (h.lanes = b), h;
        }
        function wd(h, f, b) {
          return (
            (f = ki(4, h.children !== null ? h.children : [], h.key, f)),
            (f.lanes = b),
            (f.stateNode = {
              containerInfo: h.containerInfo,
              pendingChildren: null,
              implementation: h.implementation,
            }),
            f
          );
        }
        function km(h, f, b, S, R) {
          (this.tag = f),
            (this.containerInfo = h),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = Je),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = Jc(0)),
            (this.expirationTimes = Jc(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = Jc(0)),
            (this.identifierPrefix = S),
            (this.onRecoverableError = R),
            Te && (this.mutableSourceEagerHydrationData = null);
        }
        function Vu(h, f, b, S, R, P, $, fe, De) {
          return (
            (h = new km(h, f, b, fe, De)),
            f === 1 ? ((f = 1), P === !0 && (f |= 8)) : (f = 0),
            (P = ki(3, null, null, f)),
            (h.current = P),
            (P.stateNode = h),
            (P.memoizedState = {
              element: S,
              isDehydrated: b,
              cache: null,
              transitions: null,
            }),
            ho(P),
            h
          );
        }
        function zm(h) {
          if (!h) return hn;
          h = h._reactInternals;
          e: {
            if (z(h) !== h || h.tag !== 1) throw Error(s(170));
            var f = h;
            do {
              switch (f.tag) {
                case 3:
                  f = f.stateNode.context;
                  break e;
                case 1:
                  if (vn(f.type)) {
                    f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              f = f.return;
            } while (f !== null);
            throw Error(s(171));
          }
          if (h.tag === 1) {
            var b = h.type;
            if (vn(b)) return Yi(h, b, f);
          }
          return f;
        }
        function Hm(h) {
          var f = h._reactInternals;
          if (f === void 0)
            throw typeof h.render == "function"
              ? Error(s(188))
              : ((h = Object.keys(h).join(",")), Error(s(268, h)));
          return (h = X(f)), h === null ? null : h.stateNode;
        }
        function Vm(h, f) {
          if (((h = h.memoizedState), h !== null && h.dehydrated !== null)) {
            var b = h.retryLane;
            h.retryLane = b !== 0 && b < f ? b : f;
          }
        }
        function zi(h, f) {
          Vm(h, f), (h = h.alternate) && Vm(h, f);
        }
        function Af(h) {
          return (h = X(h)), h === null ? null : h.stateNode;
        }
        function Md() {
          return null;
        }
        return (
          (e.attemptContinuousHydration = function (h) {
            if (h.tag === 13) {
              var f = xn();
              ai(h, 134217728, f), zi(h, 134217728);
            }
          }),
          (e.attemptHydrationAtCurrentPriority = function (h) {
            if (h.tag === 13) {
              var f = xn(),
                b = Yn(h);
              ai(h, b, f), zi(h, b);
            }
          }),
          (e.attemptSynchronousHydration = function (h) {
            switch (h.tag) {
              case 3:
                var f = h.stateNode;
                if (f.current.memoizedState.isDehydrated) {
                  var b = rn(f.pendingLanes);
                  b !== 0 &&
                    (el(f, b | 1), Rr(f, Er()), !(Yt & 6) && (xs(), Bi()));
                }
                break;
              case 13:
                var S = xn();
                Oi(function () {
                  return ai(h, 1, S);
                }),
                  zi(h, 1);
            }
          }),
          (e.batchedUpdates = function (h, f) {
            var b = Yt;
            Yt |= 1;
            try {
              return h(f);
            } finally {
              (Yt = b), Yt === 0 && (xs(), uo && Bi());
            }
          }),
          (e.createComponentSelector = function (h) {
            return { $$typeof: oa, value: h };
          }),
          (e.createContainer = function (h, f, b, S, R, P, $) {
            return Vu(h, f, !1, null, b, S, R, P, $);
          }),
          (e.createHasPseudoClassSelector = function (h) {
            return { $$typeof: Ru, value: h };
          }),
          (e.createHydrationContainer = function (h, f, b, S, R, P, $, fe, De) {
            return (
              (h = Vu(b, S, !0, h, R, P, $, fe, De)),
              (h.context = zm(null)),
              (b = h.current),
              (S = xn()),
              (R = Yn(b)),
              (P = Ps(S, R)),
              (P.callback = f ?? null),
              La(b, P),
              (h.current.lanes = R),
              $o(h, R, S),
              Rr(h, S),
              h
            );
          }),
          (e.createPortal = function (h, f, b) {
            var S =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null;
            return {
              $$typeof: c,
              key: S == null ? null : "" + S,
              children: h,
              containerInfo: f,
              implementation: b,
            };
          }),
          (e.createRoleSelector = function (h) {
            return { $$typeof: Mo, value: h };
          }),
          (e.createTestNameSelector = function (h) {
            return { $$typeof: So, value: h };
          }),
          (e.createTextSelector = function (h) {
            return { $$typeof: la, value: h };
          }),
          (e.deferredUpdates = function (h) {
            var f = ln,
              b = Nn.transition;
            try {
              return (Nn.transition = null), (ln = 16), h();
            } finally {
              (ln = f), (Nn.transition = b);
            }
          }),
          (e.discreteUpdates = function (h, f, b, S, R) {
            var P = ln,
              $ = Nn.transition;
            try {
              return (Nn.transition = null), (ln = 1), h(f, b, S, R);
            } finally {
              (ln = P), (Nn.transition = $), Yt === 0 && xs();
            }
          }),
          (e.findAllNodes = xi),
          (e.findBoundingRects = function (h, f) {
            if (!Dt) throw Error(s(363));
            (f = xi(h, f)), (h = []);
            for (var b = 0; b < f.length; b++) h.push(Z(f[b]));
            for (f = h.length - 1; 0 < f; f--) {
              b = h[f];
              for (
                var S = b.x,
                  R = S + b.width,
                  P = b.y,
                  $ = P + b.height,
                  fe = f - 1;
                0 <= fe;
                fe--
              )
                if (f !== fe) {
                  var De = h[fe],
                    rt = De.x,
                    Et = rt + De.width,
                    Kt = De.y,
                    kt = Kt + De.height;
                  if (S >= rt && P >= Kt && R <= Et && $ <= kt) {
                    h.splice(f, 1);
                    break;
                  } else if (
                    S !== rt ||
                    b.width !== De.width ||
                    kt < P ||
                    Kt > $
                  ) {
                    if (
                      !(P !== Kt || b.height !== De.height || Et < S || rt > R)
                    ) {
                      rt > S && ((De.width += rt - S), (De.x = S)),
                        Et < R && (De.width = R - rt),
                        h.splice(f, 1);
                      break;
                    }
                  } else {
                    Kt > P && ((De.height += Kt - P), (De.y = P)),
                      kt < $ && (De.height = $ - Kt),
                      h.splice(f, 1);
                    break;
                  }
                }
            }
            return h;
          }),
          (e.findHostInstance = Hm),
          (e.findHostInstanceWithNoPortals = function (h) {
            return (
              (h = N(h)),
              (h = h !== null ? re(h) : null),
              h === null ? null : h.stateNode
            );
          }),
          (e.findHostInstanceWithWarning = function (h) {
            return Hm(h);
          }),
          (e.flushControlled = function (h) {
            var f = Yt;
            Yt |= 1;
            var b = Nn.transition,
              S = ln;
            try {
              (Nn.transition = null), (ln = 1), h();
            } finally {
              (ln = S), (Nn.transition = b), (Yt = f), Yt === 0 && (xs(), Bi());
            }
          }),
          (e.flushPassiveEffects = Ja),
          (e.flushSync = Oi),
          (e.focusWithin = function (h, f) {
            if (!Dt) throw Error(s(363));
            for (
              h = Iu(h), f = Co(h, f), f = Array.from(f), h = 0;
              h < f.length;

            ) {
              var b = f[h++];
              if (!xe(b)) {
                if (b.tag === 5 && We(b.stateNode)) return !0;
                for (b = b.child; b !== null; ) f.push(b), (b = b.sibling);
              }
            }
            return !1;
          }),
          (e.getCurrentUpdatePriority = function () {
            return ln;
          }),
          (e.getFindAllNodesFailureDescription = function (h, f) {
            if (!Dt) throw Error(s(363));
            var b = 0,
              S = [];
            h = [Iu(h), 0];
            for (var R = 0; R < h.length; ) {
              var P = h[R++],
                $ = h[R++],
                fe = f[$];
              if (
                (P.tag !== 5 || !xe(P)) &&
                (Bu(P, fe) && (S.push(Pu(fe)), $++, $ > b && (b = $)),
                $ < f.length)
              )
                for (P = P.child; P !== null; ) h.push(P, $), (P = P.sibling);
            }
            if (b < f.length) {
              for (h = []; b < f.length; b++) h.push(Pu(f[b]));
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (S.join(" > ") +
                  `

No matching component was found for:
  `) +
                h.join(" > ")
              );
            }
            return null;
          }),
          (e.getPublicRootInstance = function (h) {
            if (((h = h.current), !h.child)) return null;
            switch (h.child.tag) {
              case 5:
                return _e(h.child.stateNode);
              default:
                return h.child.stateNode;
            }
          }),
          (e.injectIntoDevTools = function (h) {
            if (
              ((h = {
                bundleType: h.bundleType,
                version: h.version,
                rendererPackageName: h.rendererPackageName,
                rendererConfig: h.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: a.ReactCurrentDispatcher,
                findHostInstanceByFiber: Af,
                findFiberByHostInstance: h.findFiberByHostInstance || Md,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329",
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            )
              h = !1;
            else {
              var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (f.isDisabled || !f.supportsFiber) h = !0;
              else {
                try {
                  (lo = f.inject(h)), (ms = f);
                } catch {}
                h = !!f.checkDCE;
              }
            }
            return h;
          }),
          (e.isAlreadyRendering = function () {
            return !1;
          }),
          (e.observeVisibleRects = function (h, f, b, S) {
            if (!Dt) throw Error(s(363));
            h = xi(h, f);
            var R = Oe(h, b, S).disconnect;
            return {
              disconnect: function () {
                R();
              },
            };
          }),
          (e.registerMutableSourceForHydration = function (h, f) {
            var b = f._getVersion;
            (b = b(f._source)),
              h.mutableSourceEagerHydrationData == null
                ? (h.mutableSourceEagerHydrationData = [f, b])
                : h.mutableSourceEagerHydrationData.push(f, b);
          }),
          (e.runWithPriority = function (h, f) {
            var b = ln;
            try {
              return (ln = h), f();
            } finally {
              ln = b;
            }
          }),
          (e.shouldError = function () {
            return null;
          }),
          (e.shouldSuspend = function () {
            return !1;
          }),
          (e.updateContainer = function (h, f, b, S) {
            var R = f.current,
              P = xn(),
              $ = Yn(R);
            return (
              (b = zm(b)),
              f.context === null ? (f.context = b) : (f.pendingContext = b),
              (f = Ps(P, $)),
              (f.payload = { element: h }),
              (S = S === void 0 ? null : S),
              S !== null && (f.callback = S),
              La(R, f),
              (h = ai(R, $, P)),
              h !== null && qc(h, R, $),
              $
            );
          }),
          e
        );
      })),
    UA
  );
}
var kA;
function TN() {
  return kA || ((kA = 1), (PA.exports = CN())), PA.exports;
}
var RN = TN();
const IN = Vv(RN);
var zA = GS();
const yx = {},
  jS = (r) => void Object.assign(yx, r);
function BN(r, e) {
  function t(d, { args: p = [], attach: m, ...y }, v) {
    let A = `${d[0].toUpperCase()}${d.slice(1)}`,
      M;
    if (d === "primitive") {
      if (y.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const w = y.object;
      M = qd(w, { type: d, root: v, attach: m, primitive: !0 });
    } else {
      const w = yx[A];
      if (!w)
        throw new Error(
          `R3F: ${A} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`,
        );
      if (!Array.isArray(p))
        throw new Error("R3F: The args prop must be an array!");
      M = qd(new w(...p), {
        type: d,
        root: v,
        attach: m,
        memoizedProps: { args: p },
      });
    }
    return (
      M.__r3f.attach === void 0 &&
        (M instanceof tn
          ? (M.__r3f.attach = "geometry")
          : M instanceof Dr && (M.__r3f.attach = "material")),
      A !== "inject" && Ny(M, y),
      M
    );
  }
  function n(d, p) {
    let m = !1;
    if (p) {
      var y, v;
      (y = p.__r3f) != null && y.attach
        ? Fy(d, p, p.__r3f.attach)
        : p.isObject3D && d.isObject3D && (d.add(p), (m = !0)),
        m || (v = d.__r3f) == null || v.objects.push(p),
        p.__r3f || qd(p, {}),
        (p.__r3f.parent = d),
        Dv(p),
        Kd(p);
    }
  }
  function i(d, p, m) {
    let y = !1;
    if (p) {
      var v, A;
      if ((v = p.__r3f) != null && v.attach) Fy(d, p, p.__r3f.attach);
      else if (p.isObject3D && d.isObject3D) {
        (p.parent = d),
          p.dispatchEvent({ type: "added" }),
          d.dispatchEvent({ type: "childadded", child: p });
        const M = d.children.filter((x) => x !== p),
          w = M.indexOf(m);
        (d.children = [...M.slice(0, w), p, ...M.slice(w)]), (y = !0);
      }
      y || (A = d.__r3f) == null || A.objects.push(p),
        p.__r3f || qd(p, {}),
        (p.__r3f.parent = d),
        Dv(p),
        Kd(p);
    }
  }
  function s(d, p, m = !1) {
    d && [...d].forEach((y) => a(p, y, m));
  }
  function a(d, p, m) {
    if (p) {
      var y, v, A;
      if (
        (p.__r3f && (p.__r3f.parent = null),
        (y = d.__r3f) != null &&
          y.objects &&
          (d.__r3f.objects = d.__r3f.objects.filter((T) => T !== p)),
        (v = p.__r3f) != null && v.attach)
      )
        WA(d, p, p.__r3f.attach);
      else if (p.isObject3D && d.isObject3D) {
        var M;
        d.remove(p), (M = p.__r3f) != null && M.root && ON(x0(p), p);
      }
      const x = (A = p.__r3f) == null ? void 0 : A.primitive,
        C = !x && (m === void 0 ? p.dispose !== null : m);
      if (!x) {
        var w;
        s((w = p.__r3f) == null ? void 0 : w.objects, p, C),
          s(p.children, p, C);
      }
      if ((delete p.__r3f, C && p.dispose && p.type !== "Scene")) {
        const T = () => {
          try {
            p.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? zA.unstable_scheduleCallback(zA.unstable_IdlePriority, T)
          : T();
      }
      Kd(d);
    }
  }
  function l(d, p, m, y) {
    var v;
    const A = (v = d.__r3f) == null ? void 0 : v.parent;
    if (!A) return;
    const M = t(p, m, d.__r3f.root);
    if (d.children) {
      for (const w of d.children) w.__r3f && n(M, w);
      d.children = d.children.filter((w) => !w.__r3f);
    }
    d.__r3f.objects.forEach((w) => n(M, w)),
      (d.__r3f.objects = []),
      d.__r3f.autoRemovedBeforeAppend || a(A, d),
      M.parent && (M.__r3f.autoRemovedBeforeAppend = !0),
      n(A, M),
      M.raycast &&
        M.__r3f.eventCount &&
        x0(M).getState().internal.interaction.push(M),
      [y, y.alternate].forEach((w) => {
        w !== null &&
          ((w.stateNode = M),
          w.ref &&
            (typeof w.ref == "function" ? w.ref(M) : (w.ref.current = M)));
      });
  }
  const c = () => {};
  return {
    reconciler: IN({
      createInstance: t,
      removeChild: a,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (d, p) => {
        if (!p) return;
        const m = d.getState().scene;
        m.__r3f && ((m.__r3f.root = d), n(m, p));
      },
      removeChildFromContainer: (d, p) => {
        p && a(d.getState().scene, p);
      },
      insertInContainerBefore: (d, p, m) => {
        if (!p || !m) return;
        const y = d.getState().scene;
        y.__r3f && i(y, p, m);
      },
      getRootHostContext: () => null,
      getChildHostContext: (d) => d,
      finalizeInitialChildren(d) {
        var p;
        return !!((p = d == null ? void 0 : d.__r3f) != null ? p : {}).handlers;
      },
      prepareUpdate(d, p, m, y) {
        var v;
        if (
          ((v = d == null ? void 0 : d.__r3f) != null ? v : {}).primitive &&
          y.object &&
          y.object !== d
        )
          return [!0];
        {
          const { args: A = [], children: M, ...w } = y,
            { args: x = [], children: C, ...T } = m;
          if (!Array.isArray(A))
            throw new Error("R3F: the args prop must be an array!");
          if (A.some((U, F) => U !== x[F])) return [!0];
          const I = KS(d, w, T, !0);
          return I.changes.length ? [!1, I] : null;
        }
      },
      commitUpdate(d, [p, m], y, v, A, M) {
        p ? l(d, y, A, M) : Ny(d, m);
      },
      commitMount(d, p, m, y) {
        var v;
        const A = (v = d.__r3f) != null ? v : {};
        d.raycast &&
          A.handlers &&
          A.eventCount &&
          x0(d).getState().internal.interaction.push(d);
      },
      getPublicInstance: (d) => d,
      prepareForCommit: () => null,
      preparePortalMount: (d) => qd(d.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(d) {
        var p;
        const { attach: m, parent: y } = (p = d.__r3f) != null ? p : {};
        m && y && WA(y, d, m), d.isObject3D && (d.visible = !1), Kd(d);
      },
      unhideInstance(d, p) {
        var m;
        const { attach: y, parent: v } = (m = d.__r3f) != null ? m : {};
        y && v && Fy(v, d, y),
          ((d.isObject3D && p.visible == null) || p.visible) &&
            (d.visible = !0),
          Kd(d);
      },
      createTextInstance: c,
      hideTextInstance: c,
      unhideTextInstance: c,
      getCurrentEventPriority: () => e(),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && qn.fun(performance.now)
          ? performance.now
          : qn.fun(Date.now)
            ? Date.now
            : () => 0,
      scheduleTimeout: qn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: qn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: Ny,
  };
}
var HA, VA;
const Dy = (r) => "colorSpace" in r || "outputColorSpace" in r,
  WS = () => {
    var r;
    return (r = yx.ColorManagement) != null ? r : null;
  },
  XS = (r) => r && r.isOrthographicCamera,
  PN = (r) => r && r.hasOwnProperty("current"),
  um =
    typeof window < "u" &&
    (((HA = window.document) != null && HA.createElement) ||
      ((VA = window.navigator) == null ? void 0 : VA.product) === "ReactNative")
      ? he.useLayoutEffect
      : he.useEffect;
function JS(r) {
  const e = he.useRef(r);
  return um(() => void (e.current = r), [r]), e;
}
function LN({ set: r }) {
  return um(() => (r(new Promise(() => null)), () => r(!1)), [r]), null;
}
class YS extends he.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
YS.getDerivedStateFromError = () => ({ error: !0 });
const ZS = "__default",
  GA = new Map(),
  DN = (r) => r && !!r.memoized && !!r.changes;
function qS(r) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(r) ? Math.min(Math.max(r[0], t), r[1]) : r;
}
const jf = (r) => {
  var e;
  return (e = r.__r3f) == null ? void 0 : e.root.getState();
};
function x0(r) {
  let e = r.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const qn = {
  obj: (r) => r === Object(r) && !qn.arr(r) && typeof r != "function",
  fun: (r) => typeof r == "function",
  str: (r) => typeof r == "string",
  num: (r) => typeof r == "number",
  boo: (r) => typeof r == "boolean",
  und: (r) => r === void 0,
  arr: (r) => Array.isArray(r),
  equ(
    r,
    e,
    { arrays: t = "shallow", objects: n = "reference", strict: i = !0 } = {},
  ) {
    if (typeof r != typeof e || !!r != !!e) return !1;
    if (qn.str(r) || qn.num(r) || qn.boo(r)) return r === e;
    const s = qn.obj(r);
    if (s && n === "reference") return r === e;
    const a = qn.arr(r);
    if (a && t === "reference") return r === e;
    if ((a || s) && r === e) return !0;
    let l;
    for (l in r) if (!(l in e)) return !1;
    if (s && t === "shallow" && n === "shallow") {
      for (l in i ? e : r)
        if (!qn.equ(r[l], e[l], { strict: i, objects: "reference" })) return !1;
    } else for (l in i ? e : r) if (r[l] !== e[l]) return !1;
    if (qn.und(l)) {
      if (
        (a && r.length === 0 && e.length === 0) ||
        (s && Object.keys(r).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (r !== e) return !1;
    }
    return !0;
  },
};
function FN(r) {
  const e = { nodes: {}, materials: {} };
  return (
    r &&
      r.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function NN(r) {
  r.dispose && r.type !== "Scene" && r.dispose();
  for (const e in r) e.dispose == null || e.dispose(), delete r[e];
}
function qd(r, e) {
  const t = r;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    r
  );
}
function Lv(r, e) {
  let t = r;
  if (e.includes("-")) {
    const n = e.split("-"),
      i = n.pop();
    return (t = n.reduce((s, a) => s[a], r)), { target: t, key: i };
  } else return { target: t, key: e };
}
const jA = /-\d+$/;
function Fy(r, e, t) {
  if (qn.str(t)) {
    if (jA.test(t)) {
      const s = t.replace(jA, ""),
        { target: a, key: l } = Lv(r, s);
      Array.isArray(a[l]) || (a[l] = []);
    }
    const { target: n, key: i } = Lv(r, t);
    (e.__r3f.previousAttach = n[i]), (n[i] = e);
  } else e.__r3f.previousAttach = t(r, e);
}
function WA(r, e, t) {
  var n, i;
  if (qn.str(t)) {
    const { target: s, key: a } = Lv(r, t),
      l = e.__r3f.previousAttach;
    l === void 0 ? delete s[a] : (s[a] = l);
  } else
    (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(r, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function KS(
  r,
  { children: e, key: t, ref: n, ...i },
  { children: s, key: a, ref: l, ...c } = {},
  d = !1,
) {
  const p = r.__r3f,
    m = Object.entries(i),
    y = [];
  if (d) {
    const A = Object.keys(c);
    for (let M = 0; M < A.length; M++)
      i.hasOwnProperty(A[M]) || m.unshift([A[M], ZS + "remove"]);
  }
  m.forEach(([A, M]) => {
    var w;
    if (
      ((w = r.__r3f) != null && w.primitive && A === "object") ||
      qn.equ(M, c[A])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(A))
      return y.push([A, M, !0, []]);
    let x = [];
    A.includes("-") && (x = A.split("-")), y.push([A, M, !1, x]);
    for (const C in i) {
      const T = i[C];
      C.startsWith(`${A}-`) && y.push([C, T, !1, C.split("-")]);
    }
  });
  const v = { ...i };
  return (
    p != null &&
      p.memoizedProps &&
      p != null &&
      p.memoizedProps.args &&
      (v.args = p.memoizedProps.args),
    p != null &&
      p.memoizedProps &&
      p != null &&
      p.memoizedProps.attach &&
      (v.attach = p.memoizedProps.attach),
    { memoized: v, changes: y }
  );
}
function Ny(r, e) {
  var t;
  const n = r.__r3f,
    i = n == null ? void 0 : n.root,
    s = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: a, changes: l } = DN(e) ? e : KS(r, e),
    c = n == null ? void 0 : n.eventCount;
  r.__r3f && (r.__r3f.memoizedProps = a);
  for (let d = 0; d < l.length; d++) {
    let [p, m, y, v] = l[d];
    if (Dy(r)) {
      const w = "srgb",
        x = "srgb-linear";
      p === "encoding"
        ? ((p = "colorSpace"), (m = m === 3001 ? w : x))
        : p === "outputEncoding" &&
          ((p = "outputColorSpace"), (m = m === 3001 ? w : x));
    }
    let A = r,
      M = A[p];
    if (v.length && ((M = v.reduce((w, x) => w[x], r)), !(M && M.set))) {
      const [w, ...x] = v.reverse();
      (A = x.reverse().reduce((C, T) => C[T], r)), (p = w);
    }
    if (m === ZS + "remove")
      if (A.constructor) {
        let w = GA.get(A.constructor);
        w || ((w = new A.constructor()), GA.set(A.constructor, w)), (m = w[p]);
      } else m = 0;
    if (y && n)
      m ? (n.handlers[p] = m) : delete n.handlers[p],
        (n.eventCount = Object.keys(n.handlers).length);
    else if (M && M.set && (M.copy || M instanceof Tc)) {
      if (Array.isArray(m)) M.fromArray ? M.fromArray(m) : M.set(...m);
      else if (M.copy && m && m.constructor && M.constructor === m.constructor)
        M.copy(m);
      else if (m !== void 0) {
        const w = M instanceof dt;
        !w && M.setScalar
          ? M.setScalar(m)
          : M instanceof Tc && m instanceof Tc
            ? (M.mask = m.mask)
            : M.set(m),
          !WS() && s && !s.linear && w && M.convertSRGBToLinear();
      }
    } else if (
      ((A[p] = m),
      A[p] instanceof Ln && A[p].format === wr && A[p].type === hs && s)
    ) {
      const w = A[p];
      Dy(w) && Dy(s.gl)
        ? (w.colorSpace = s.gl.outputColorSpace)
        : (w.encoding = s.gl.outputEncoding);
    }
    Kd(r);
  }
  if (n && n.parent && r.raycast && c !== n.eventCount) {
    const d = x0(r).getState().internal,
      p = d.interaction.indexOf(r);
    p > -1 && d.interaction.splice(p, 1), n.eventCount && d.interaction.push(r);
  }
  return (
    !(l.length === 1 && l[0][0] === "onUpdate") &&
      l.length &&
      (t = r.__r3f) != null &&
      t.parent &&
      Dv(r),
    r
  );
}
function Kd(r) {
  var e, t;
  const n =
    (e = r.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function Dv(r) {
  r.onUpdate == null || r.onUpdate(r);
}
function QS(r, e) {
  r.manual ||
    (XS(r)
      ? ((r.left = e.width / -2),
        (r.right = e.width / 2),
        (r.top = e.height / 2),
        (r.bottom = e.height / -2))
      : (r.aspect = e.width / e.height),
    r.updateProjectionMatrix(),
    r.updateMatrixWorld());
}
function a0(r) {
  return (r.eventObject || r.object).uuid + "/" + r.index + r.instanceId;
}
function UN() {
  var r;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return tp.DefaultEventPriority;
  switch ((r = e.event) == null ? void 0 : r.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return tp.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return tp.ContinuousEventPriority;
    default:
      return tp.DefaultEventPriority;
  }
}
function $S(r, e, t, n) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (r.delete(n), i.target.releasePointerCapture(n)));
}
function ON(r, e) {
  const { internal: t } = r.getState();
  (t.interaction = t.interaction.filter((n) => n !== e)),
    (t.initialHits = t.initialHits.filter((n) => n !== e)),
    t.hovered.forEach((n, i) => {
      (n.eventObject === e || n.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((n, i) => {
      $S(t.capturedMap, e, n, i);
    });
}
function kN(r) {
  function e(c) {
    const { internal: d } = r.getState(),
      p = c.offsetX - d.initialClick[0],
      m = c.offsetY - d.initialClick[1];
    return Math.round(Math.sqrt(p * p + m * m));
  }
  function t(c) {
    return c.filter((d) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((p) => {
        var m;
        return (m = d.__r3f) == null ? void 0 : m.handlers["onPointer" + p];
      }),
    );
  }
  function n(c, d) {
    const p = r.getState(),
      m = new Set(),
      y = [],
      v = d ? d(p.internal.interaction) : p.internal.interaction;
    for (let x = 0; x < v.length; x++) {
      const C = jf(v[x]);
      C && (C.raycaster.camera = void 0);
    }
    p.previousRoot || p.events.compute == null || p.events.compute(c, p);
    function A(x) {
      const C = jf(x);
      if (!C || !C.events.enabled || C.raycaster.camera === null) return [];
      if (C.raycaster.camera === void 0) {
        var T;
        C.events.compute == null ||
          C.events.compute(
            c,
            C,
            (T = C.previousRoot) == null ? void 0 : T.getState(),
          ),
          C.raycaster.camera === void 0 && (C.raycaster.camera = null);
      }
      return C.raycaster.camera ? C.raycaster.intersectObject(x, !0) : [];
    }
    let M = v
      .flatMap(A)
      .sort((x, C) => {
        const T = jf(x.object),
          I = jf(C.object);
        return !T || !I
          ? x.distance - C.distance
          : I.events.priority - T.events.priority || x.distance - C.distance;
      })
      .filter((x) => {
        const C = a0(x);
        return m.has(C) ? !1 : (m.add(C), !0);
      });
    p.events.filter && (M = p.events.filter(M, p));
    for (const x of M) {
      let C = x.object;
      for (; C; ) {
        var w;
        (w = C.__r3f) != null &&
          w.eventCount &&
          y.push({ ...x, eventObject: C }),
          (C = C.parent);
      }
    }
    if ("pointerId" in c && p.internal.capturedMap.has(c.pointerId))
      for (let x of p.internal.capturedMap.get(c.pointerId).values())
        m.has(a0(x.intersection)) || y.push(x.intersection);
    return y;
  }
  function i(c, d, p, m) {
    const y = r.getState();
    if (c.length) {
      const v = { stopped: !1 };
      for (const A of c) {
        const M = jf(A.object) || y,
          { raycaster: w, pointer: x, camera: C, internal: T } = M,
          I = new Y(x.x, x.y, 0).unproject(C),
          U = (N) => {
            var X, ie;
            return (X =
              (ie = T.capturedMap.get(N)) == null
                ? void 0
                : ie.has(A.eventObject)) != null
              ? X
              : !1;
          },
          F = (N) => {
            const X = { intersection: A, target: d.target };
            T.capturedMap.has(N)
              ? T.capturedMap.get(N).set(A.eventObject, X)
              : T.capturedMap.set(N, new Map([[A.eventObject, X]])),
              d.target.setPointerCapture(N);
          },
          O = (N) => {
            const X = T.capturedMap.get(N);
            X && $S(T.capturedMap, A.eventObject, X, N);
          };
        let z = {};
        for (let N in d) {
          let X = d[N];
          typeof X != "function" && (z[N] = X);
        }
        let L = {
          ...A,
          ...z,
          pointer: x,
          intersections: c,
          stopped: v.stopped,
          delta: p,
          unprojectedPoint: I,
          ray: w.ray,
          camera: C,
          stopPropagation() {
            const N = "pointerId" in d && T.capturedMap.get(d.pointerId);
            if (
              (!N || N.has(A.eventObject)) &&
              ((L.stopped = v.stopped = !0),
              T.hovered.size &&
                Array.from(T.hovered.values()).find(
                  (X) => X.eventObject === A.eventObject,
                ))
            ) {
              const X = c.slice(0, c.indexOf(A));
              s([...X, A]);
            }
          },
          target: {
            hasPointerCapture: U,
            setPointerCapture: F,
            releasePointerCapture: O,
          },
          currentTarget: {
            hasPointerCapture: U,
            setPointerCapture: F,
            releasePointerCapture: O,
          },
          nativeEvent: d,
        };
        if ((m(L), v.stopped === !0)) break;
      }
    }
    return c;
  }
  function s(c) {
    const { internal: d } = r.getState();
    for (const p of d.hovered.values())
      if (
        !c.length ||
        !c.find(
          (m) =>
            m.object === p.object &&
            m.index === p.index &&
            m.instanceId === p.instanceId,
        )
      ) {
        const m = p.eventObject.__r3f,
          y = m == null ? void 0 : m.handlers;
        if ((d.hovered.delete(a0(p)), m != null && m.eventCount)) {
          const v = { ...p, intersections: c };
          y.onPointerOut == null || y.onPointerOut(v),
            y.onPointerLeave == null || y.onPointerLeave(v);
        }
      }
  }
  function a(c, d) {
    for (let p = 0; p < d.length; p++) {
      const m = d[p].__r3f;
      m == null ||
        m.handlers.onPointerMissed == null ||
        m.handlers.onPointerMissed(c);
    }
  }
  function l(c) {
    switch (c) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (d) => {
          const { internal: p } = r.getState();
          "pointerId" in d &&
            p.capturedMap.has(d.pointerId) &&
            requestAnimationFrame(() => {
              p.capturedMap.has(d.pointerId) &&
                (p.capturedMap.delete(d.pointerId), s([]));
            });
        };
    }
    return function (d) {
      const { onPointerMissed: p, internal: m } = r.getState();
      m.lastEvent.current = d;
      const y = c === "onPointerMove",
        v = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick",
        A = n(d, y ? t : void 0),
        M = v ? e(d) : 0;
      c === "onPointerDown" &&
        ((m.initialClick = [d.offsetX, d.offsetY]),
        (m.initialHits = A.map((x) => x.eventObject))),
        v && !A.length && M <= 2 && (a(d, m.interaction), p && p(d)),
        y && s(A);
      function w(x) {
        const C = x.eventObject,
          T = C.__r3f,
          I = T == null ? void 0 : T.handlers;
        if (T != null && T.eventCount)
          if (y) {
            if (
              I.onPointerOver ||
              I.onPointerEnter ||
              I.onPointerOut ||
              I.onPointerLeave
            ) {
              const U = a0(x),
                F = m.hovered.get(U);
              F
                ? F.stopped && x.stopPropagation()
                : (m.hovered.set(U, x),
                  I.onPointerOver == null || I.onPointerOver(x),
                  I.onPointerEnter == null || I.onPointerEnter(x));
            }
            I.onPointerMove == null || I.onPointerMove(x);
          } else {
            const U = I[c];
            U
              ? (!v || m.initialHits.includes(C)) &&
                (a(
                  d,
                  m.interaction.filter((F) => !m.initialHits.includes(F)),
                ),
                U(x))
              : v &&
                m.initialHits.includes(C) &&
                a(
                  d,
                  m.interaction.filter((F) => !m.initialHits.includes(F)),
                );
          }
      }
      i(A, d, M, w);
    };
  }
  return { handlePointer: l };
}
const zN = [
    "set",
    "get",
    "setSize",
    "setFrameloop",
    "setDpr",
    "events",
    "invalidate",
    "advance",
    "size",
    "viewport",
  ],
  e6 = (r) => !!(r != null && r.render),
  vx = he.createContext(null),
  HN = (r, e) => {
    const t = zS((l, c) => {
        const d = new Y(),
          p = new Y(),
          m = new Y();
        function y(w = c().camera, x = p, C = c().size) {
          const { width: T, height: I, top: U, left: F } = C,
            O = T / I;
          x instanceof Y ? m.copy(x) : m.set(...x);
          const z = w.getWorldPosition(d).distanceTo(m);
          if (XS(w))
            return {
              width: T / w.zoom,
              height: I / w.zoom,
              top: U,
              left: F,
              factor: 1,
              distance: z,
              aspect: O,
            };
          {
            const L = (w.fov * Math.PI) / 180,
              N = 2 * Math.tan(L / 2) * z,
              X = N * (T / I);
            return {
              width: X,
              height: N,
              top: U,
              left: F,
              factor: T / X,
              distance: z,
              aspect: O,
            };
          }
        }
        let v;
        const A = (w) =>
            l((x) => ({ performance: { ...x.performance, current: w } })),
          M = new je();
        return {
          set: l,
          get: c,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (w = 1) => r(c(), w),
          advance: (w, x) => e(w, x, c()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new ux(),
          pointer: M,
          mouse: M,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const w = c();
              v && clearTimeout(v),
                w.performance.current !== w.performance.min &&
                  A(w.performance.min),
                (v = setTimeout(
                  () => A(c().performance.max),
                  w.performance.debounce,
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: y,
          },
          setEvents: (w) => l((x) => ({ ...x, events: { ...x.events, ...w } })),
          setSize: (w, x, C, T, I) => {
            const U = c().camera,
              F = {
                width: w,
                height: x,
                top: T || 0,
                left: I || 0,
                updateStyle: C,
              };
            l((O) => ({ size: F, viewport: { ...O.viewport, ...y(U, p, F) } }));
          },
          setDpr: (w) =>
            l((x) => {
              const C = qS(w);
              return {
                viewport: {
                  ...x.viewport,
                  dpr: C,
                  initialDpr: x.viewport.initialDpr || C,
                },
              };
            }),
          setFrameloop: (w = "always") => {
            const x = c().clock;
            x.stop(),
              (x.elapsedTime = 0),
              w !== "never" && (x.start(), (x.elapsedTime = 0)),
              l(() => ({ frameloop: w }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: he.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (w, x, C) => {
              const T = c().internal;
              return (
                (T.priority = T.priority + (x > 0 ? 1 : 0)),
                T.subscribers.push({ ref: w, priority: x, store: C }),
                (T.subscribers = T.subscribers.sort(
                  (I, U) => I.priority - U.priority,
                )),
                () => {
                  const I = c().internal;
                  I != null &&
                    I.subscribers &&
                    ((I.priority = I.priority - (x > 0 ? 1 : 0)),
                    (I.subscribers = I.subscribers.filter((U) => U.ref !== w)));
                }
              );
            },
          },
        };
      }),
      n = t.getState();
    let i = n.size,
      s = n.viewport.dpr,
      a = n.camera;
    return (
      t.subscribe(() => {
        const { camera: l, size: c, viewport: d, gl: p, set: m } = t.getState();
        if (c.width !== i.width || c.height !== i.height || d.dpr !== s) {
          var y;
          (i = c), (s = d.dpr), QS(l, c), p.setPixelRatio(d.dpr);
          const v =
            (y = c.updateStyle) != null
              ? y
              : typeof HTMLCanvasElement < "u" &&
                p.domElement instanceof HTMLCanvasElement;
          p.setSize(c.width, c.height, v);
        }
        l !== a &&
          ((a = l),
          m((v) => ({
            viewport: { ...v.viewport, ...v.viewport.getCurrentViewport(l) },
          })));
      }),
      t.subscribe((l) => r(l)),
      t
    );
  };
let o0,
  VN = new Set(),
  GN = new Set(),
  jN = new Set();
function Uy(r, e) {
  if (r.size) for (const { callback: t } of r.values()) t(e);
}
function Wf(r, e) {
  switch (r) {
    case "before":
      return Uy(VN, e);
    case "after":
      return Uy(GN, e);
    case "tail":
      return Uy(jN, e);
  }
}
let Oy, ky;
function zy(r, e, t) {
  let n = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof r == "number" &&
      ((n = r - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = r)),
      Oy = e.internal.subscribers,
      o0 = 0;
    o0 < Oy.length;
    o0++
  )
    (ky = Oy[o0]), ky.ref.current(ky.store.getState(), n, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function WN(r) {
  let e = !1,
    t = !1,
    n,
    i,
    s;
  function a(d) {
    (i = requestAnimationFrame(a)),
      (e = !0),
      (n = 0),
      Wf("before", d),
      (t = !0);
    for (const m of r.values()) {
      var p;
      (s = m.store.getState()),
        s.internal.active &&
          (s.frameloop === "always" || s.internal.frames > 0) &&
          !((p = s.gl.xr) != null && p.isPresenting) &&
          (n += zy(d, s));
    }
    if (((t = !1), Wf("after", d), n === 0))
      return Wf("tail", d), (e = !1), cancelAnimationFrame(i);
  }
  function l(d, p = 1) {
    var m;
    if (!d) return r.forEach((y) => l(y.store.getState(), p));
    ((m = d.gl.xr) != null && m.isPresenting) ||
      !d.internal.active ||
      d.frameloop === "never" ||
      (p > 1
        ? (d.internal.frames = Math.min(60, d.internal.frames + p))
        : t
          ? (d.internal.frames = 2)
          : (d.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(a)));
  }
  function c(d, p = !0, m, y) {
    if ((p && Wf("before", d), m)) zy(d, m, y);
    else for (const v of r.values()) zy(d, v.store.getState());
    p && Wf("after", d);
  }
  return { loop: a, invalidate: l, advance: c };
}
function xx() {
  const r = he.useContext(vx);
  if (!r)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return r;
}
function Np(r = (t) => t, e) {
  return xx()(r, e);
}
function fg(r, e = 0) {
  const t = xx(),
    n = t.getState().internal.subscribe,
    i = JS(r);
  return um(() => n(i, e, t), [e, n, t]), null;
}
const XA = new WeakMap();
function t6(r, e) {
  return function (t, ...n) {
    let i = XA.get(t);
    return (
      i || ((i = new t()), XA.set(t, i)),
      r && r(i),
      Promise.all(
        n.map(
          (s) =>
            new Promise((a, l) =>
              i.load(
                s,
                (c) => {
                  c.scene && Object.assign(c, FN(c.scene)), a(c);
                },
                e,
                (c) =>
                  l(
                    new Error(
                      `Could not load ${s}: ${c == null ? void 0 : c.message}`,
                    ),
                  ),
              ),
            ),
        ),
      )
    );
  };
}
function Qo(r, e, t, n) {
  const i = Array.isArray(e) ? e : [e],
    s = wN(t6(t, n), [r, ...i], { equal: qn.equ });
  return Array.isArray(e) ? s : s[0];
}
Qo.preload = function (r, e, t) {
  const n = Array.isArray(e) ? e : [e];
  return MN(t6(t), [r, ...n]);
};
Qo.clear = function (r, e) {
  const t = Array.isArray(e) ? e : [e];
  return SN([r, ...t]);
};
const _h = new Map(),
  { invalidate: JA, advance: YA } = WN(_h),
  { reconciler: Up, applyProps: zl } = BN(_h, UN),
  Jd = { objects: "shallow", strict: !1 },
  XN = (r, e) => {
    const t = typeof r == "function" ? r(e) : r;
    return e6(t)
      ? t
      : new gx({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...r,
        });
  };
function JN(r, e) {
  const t = typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement;
  if (e) {
    const { width: n, height: i, top: s, left: a, updateStyle: l = t } = e;
    return { width: n, height: i, top: s, left: a, updateStyle: l };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    r instanceof HTMLCanvasElement &&
    r.parentElement
  ) {
    const {
      width: n,
      height: i,
      top: s,
      left: a,
    } = r.parentElement.getBoundingClientRect();
    return { width: n, height: i, top: s, left: a, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas)
    return {
      width: r.width,
      height: r.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function YN(r) {
  const e = _h.get(r),
    t = e == null ? void 0 : e.fiber,
    n = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    s = n || HN(JA, YA),
    a =
      t ||
      Up.createContainer(s, tp.ConcurrentRoot, null, !1, null, "", i, null);
  e || _h.set(r, { fiber: a, store: s });
  let l,
    c = !1,
    d;
  return {
    configure(p = {}) {
      let {
          gl: m,
          size: y,
          scene: v,
          events: A,
          onCreated: M,
          shadows: w = !1,
          linear: x = !1,
          flat: C = !1,
          legacy: T = !1,
          orthographic: I = !1,
          frameloop: U = "always",
          dpr: F = [1, 2],
          performance: O,
          raycaster: z,
          camera: L,
          onPointerMissed: N,
        } = p,
        X = s.getState(),
        ie = X.gl;
      X.gl || X.set({ gl: (ie = XN(m, r)) });
      let re = X.raycaster;
      re || X.set({ raycaster: (re = new fx()) });
      const { params: me, ..._e } = z || {};
      if (
        (qn.equ(_e, re, Jd) || zl(re, { ..._e }),
        qn.equ(me, re.params, Jd) ||
          zl(re, { params: { ...re.params, ...me } }),
        !X.camera || (X.camera === d && !qn.equ(d, L, Jd)))
      ) {
        d = L;
        const ae = L instanceof $p,
          q = ae
            ? L
            : I
              ? new Wc(0, 0, 0, 0, 0.1, 1e3)
              : new Hr(75, 0, 0.1, 1e3);
        ae ||
          ((q.position.z = 5),
          L &&
            (zl(q, L),
            ("aspect" in L ||
              "left" in L ||
              "right" in L ||
              "bottom" in L ||
              "top" in L) &&
              ((q.manual = !0), q.updateProjectionMatrix())),
          !X.camera && !(L != null && L.rotation) && q.lookAt(0, 0, 0)),
          X.set({ camera: q }),
          (re.camera = q);
      }
      if (!X.scene) {
        let ae;
        v instanceof xh ? (ae = v) : ((ae = new xh()), v && zl(ae, v)),
          X.set({ scene: qd(ae) });
      }
      if (!X.xr) {
        var ge;
        const ae = (Xe, ye) => {
            const Pe = s.getState();
            Pe.frameloop !== "never" && YA(Xe, !0, Pe, ye);
          },
          q = () => {
            const Xe = s.getState();
            (Xe.gl.xr.enabled = Xe.gl.xr.isPresenting),
              Xe.gl.xr.setAnimationLoop(Xe.gl.xr.isPresenting ? ae : null),
              Xe.gl.xr.isPresenting || JA(Xe);
          },
          ce = {
            connect() {
              const Xe = s.getState().gl;
              Xe.xr.addEventListener("sessionstart", q),
                Xe.xr.addEventListener("sessionend", q);
            },
            disconnect() {
              const Xe = s.getState().gl;
              Xe.xr.removeEventListener("sessionstart", q),
                Xe.xr.removeEventListener("sessionend", q);
            },
          };
        typeof ((ge = ie.xr) == null ? void 0 : ge.addEventListener) ==
          "function" && ce.connect(),
          X.set({ xr: ce });
      }
      if (ie.shadowMap) {
        const ae = ie.shadowMap.enabled,
          q = ie.shadowMap.type;
        if (((ie.shadowMap.enabled = !!w), qn.boo(w))) ie.shadowMap.type = up;
        else if (qn.str(w)) {
          var Re;
          const ce = { basic: qM, percentage: Sg, soft: up, variance: _a };
          ie.shadowMap.type = (Re = ce[w]) != null ? Re : up;
        } else qn.obj(w) && Object.assign(ie.shadowMap, w);
        (ae !== ie.shadowMap.enabled || q !== ie.shadowMap.type) &&
          (ie.shadowMap.needsUpdate = !0);
      }
      const J = WS();
      J &&
        ("enabled" in J
          ? (J.enabled = !T)
          : "legacyMode" in J && (J.legacyMode = T)),
        c ||
          zl(ie, { outputEncoding: x ? 3e3 : 3001, toneMapping: C ? to : Eg }),
        X.legacy !== T && X.set(() => ({ legacy: T })),
        X.linear !== x && X.set(() => ({ linear: x })),
        X.flat !== C && X.set(() => ({ flat: C })),
        m && !qn.fun(m) && !e6(m) && !qn.equ(m, ie, Jd) && zl(ie, m),
        A && !X.events.handlers && X.set({ events: A(s) });
      const oe = JN(r, y);
      return (
        qn.equ(oe, X.size, Jd) ||
          X.setSize(oe.width, oe.height, oe.updateStyle, oe.top, oe.left),
        F && X.viewport.dpr !== qS(F) && X.setDpr(F),
        X.frameloop !== U && X.setFrameloop(U),
        X.onPointerMissed || X.set({ onPointerMissed: N }),
        O &&
          !qn.equ(O, X.performance, Jd) &&
          X.set((ae) => ({ performance: { ...ae.performance, ...O } })),
        (l = M),
        (c = !0),
        this
      );
    },
    render(p) {
      return (
        c || this.configure(),
        Up.updateContainer(
          H.jsx(ZN, { store: s, children: p, onCreated: l, rootElement: r }),
          a,
          null,
          () => {},
        ),
        s
      );
    },
    unmount() {
      n6(r);
    },
  };
}
function ZN({ store: r, children: e, onCreated: t, rootElement: n }) {
  return (
    um(() => {
      const i = r.getState();
      i.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(i),
        r.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(n);
    }, []),
    H.jsx(vx.Provider, { value: r, children: e })
  );
}
function n6(r, e) {
  const t = _h.get(r),
    n = t == null ? void 0 : t.fiber;
  if (n) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      Up.updateContainer(null, n, null, () => {
        i &&
          setTimeout(() => {
            try {
              var s, a, l, c;
              i.events.disconnect == null || i.events.disconnect(),
                (s = i.gl) == null ||
                  (a = s.renderLists) == null ||
                  a.dispose == null ||
                  a.dispose(),
                (l = i.gl) == null ||
                  l.forceContextLoss == null ||
                  l.forceContextLoss(),
                (c = i.gl) != null && c.xr && i.xr.disconnect(),
                NN(i),
                _h.delete(r);
            } catch {}
          }, 500);
      });
  }
}
function qN(r, e, t) {
  return H.jsx(KN, { children: r, container: e, state: t }, e.uuid);
}
function KN({ state: r = {}, children: e, container: t }) {
  const { events: n, size: i, ...s } = r,
    a = xx(),
    [l] = he.useState(() => new fx()),
    [c] = he.useState(() => new je()),
    d = he.useCallback(
      (m, y) => {
        const v = { ...m };
        Object.keys(m).forEach((M) => {
          (zN.includes(M) || (m[M] !== y[M] && y[M])) && delete v[M];
        });
        let A;
        if (y && i) {
          const M = y.camera;
          (A = m.viewport.getCurrentViewport(M, new Y(), i)),
            M !== m.camera && QS(M, i);
        }
        return {
          ...v,
          scene: t,
          raycaster: l,
          pointer: c,
          mouse: c,
          previousRoot: a,
          events: { ...m.events, ...(y == null ? void 0 : y.events), ...n },
          size: { ...m.size, ...i },
          viewport: { ...m.viewport, ...A },
          ...s,
        };
      },
      [r],
    ),
    [p] = he.useState(() => {
      const m = a.getState();
      return zS((y, v) => ({
        ...m,
        scene: t,
        raycaster: l,
        pointer: c,
        mouse: c,
        previousRoot: a,
        events: { ...m.events, ...n },
        size: { ...m.size, ...i },
        ...s,
        set: y,
        get: v,
        setEvents: (A) => y((M) => ({ ...M, events: { ...M.events, ...A } })),
      }));
    });
  return (
    he.useEffect(() => {
      const m = a.subscribe((y) => p.setState((v) => d(y, v)));
      return () => {
        m();
      };
    }, [d]),
    he.useEffect(() => {
      p.setState((m) => d(a.getState(), m));
    }, [d]),
    he.useEffect(
      () => () => {
        p.destroy();
      },
      [],
    ),
    H.jsx(H.Fragment, {
      children: Up.createPortal(
        H.jsx(vx.Provider, { value: p, children: e }),
        p,
        null,
      ),
    })
  );
}
Up.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: he.version,
});
const Hy = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function QN(r) {
  const { handlePointer: e } = kN(r);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set(
        (t.offsetX / n.size.width) * 2 - 1,
        -(t.offsetY / n.size.height) * 2 + 1,
      ),
        n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(Hy).reduce((t, n) => ({ ...t, [n]: e(n) }), {}),
    update: () => {
      var t;
      const { events: n, internal: i } = r.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        n.handlers &&
        n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const { set: i, events: s } = r.getState();
      s.disconnect == null || s.disconnect(),
        i((a) => ({ events: { ...a.events, connected: t } })),
        Object.entries((n = s.handlers) != null ? n : []).forEach(([a, l]) => {
          const [c, d] = Hy[a];
          t.addEventListener(c, l, { passive: d });
        });
    },
    disconnect: () => {
      const { set: t, events: n } = r.getState();
      if (n.connected) {
        var i;
        Object.entries((i = n.handlers) != null ? i : []).forEach(([s, a]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [l] = Hy[s];
            n.connected.removeEventListener(l, a);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
var Vy, ZA;
function $N() {
  if (ZA) return Vy;
  ZA = 1;
  function r(e, t, n) {
    var i, s, a, l, c;
    t == null && (t = 100);
    function d() {
      var m = Date.now() - l;
      m < t && m >= 0
        ? (i = setTimeout(d, t - m))
        : ((i = null), n || ((c = e.apply(a, s)), (a = s = null)));
    }
    var p = function () {
      (a = this), (s = arguments), (l = Date.now());
      var m = n && !i;
      return (
        i || (i = setTimeout(d, t)),
        m && ((c = e.apply(a, s)), (a = s = null)),
        c
      );
    };
    return (
      (p.clear = function () {
        i && (clearTimeout(i), (i = null));
      }),
      (p.flush = function () {
        i && ((c = e.apply(a, s)), (a = s = null), clearTimeout(i), (i = null));
      }),
      p
    );
  }
  return (r.debounce = r), (Vy = r), Vy;
}
var eU = $N();
const qA = Vv(eU);
var tU = Object.defineProperty,
  nU = Object.defineProperties,
  rU = Object.getOwnPropertyDescriptors,
  KA = Object.getOwnPropertySymbols,
  iU = Object.prototype.hasOwnProperty,
  sU = Object.prototype.propertyIsEnumerable,
  QA = (r, e, t) =>
    e in r
      ? tU(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (r[e] = t),
  $A = (r, e) => {
    for (var t in e || (e = {})) iU.call(e, t) && QA(r, t, e[t]);
    if (KA) for (var t of KA(e)) sU.call(e, t) && QA(r, t, e[t]);
    return r;
  },
  aU = (r, e) => nU(r, rU(e)),
  ew,
  tw;
typeof window < "u" &&
(((ew = window.document) != null && ew.createElement) ||
  ((tw = window.navigator) == null ? void 0 : tw.product) === "ReactNative")
  ? he.useLayoutEffect
  : he.useEffect;
function r6(r, e, t) {
  if (!r) return;
  if (t(r) === !0) return r;
  let n = r.child;
  for (; n; ) {
    const i = r6(n, e, t);
    if (i) return i;
    n = n.sibling;
  }
}
function i6(r) {
  try {
    return Object.defineProperties(r, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return r;
  }
}
const nw = console.error;
console.error = function () {
  const r = [...arguments].join("");
  if (r != null && r.startsWith("Warning:") && r.includes("useContext")) {
    console.error = nw;
    return;
  }
  return nw.apply(this, arguments);
};
const bx = i6(he.createContext(null));
class s6 extends he.Component {
  render() {
    return he.createElement(
      bx.Provider,
      { value: this._reactInternals },
      this.props.children,
    );
  }
}
function oU() {
  const r = he.useContext(bx);
  if (r === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!",
    );
  const e = he.useId();
  return he.useMemo(() => {
    for (const t of [r, r == null ? void 0 : r.alternate]) {
      if (!t) continue;
      const n = r6(t, !1, (i) => {
        let s = i.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (n) return n;
    }
  }, [r, e]);
}
function lU() {
  const r = oU(),
    [e] = he.useState(() => new Map());
  e.clear();
  let t = r;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const n =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      n && n !== bx && !e.has(n) && e.set(n, he.useContext(i6(n)));
    }
    t = t.return;
  }
  return e;
}
function uU() {
  const r = lU();
  return he.useMemo(
    () =>
      Array.from(r.keys()).reduce(
        (e, t) => (n) =>
          he.createElement(
            e,
            null,
            he.createElement(t.Provider, aU($A({}, n), { value: r.get(t) })),
          ),
        (e) => he.createElement(s6, $A({}, e)),
      ),
    [r],
  );
}
function cU(
  { debounce: r, scroll: e, polyfill: t, offsetSize: n } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  },
) {
  const i = t || (typeof window < "u" && window.ResizeObserver),
    [s, a] = he.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    });
  if (!i) return (s.width = 1280), (s.height = 800), [() => {}, s, () => {}];
  const l = he.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    c = r ? (typeof r == "number" ? r : r.scroll) : null,
    d = r ? (typeof r == "number" ? r : r.resize) : null,
    p = he.useRef(!1);
  he.useEffect(() => ((p.current = !0), () => void (p.current = !1)));
  const [m, y, v] = he.useMemo(() => {
    const x = () => {
      if (!l.current.element) return;
      const {
          left: C,
          top: T,
          width: I,
          height: U,
          bottom: F,
          right: O,
          x: z,
          y: L,
        } = l.current.element.getBoundingClientRect(),
        N = {
          left: C,
          top: T,
          width: I,
          height: U,
          bottom: F,
          right: O,
          x: z,
          y: L,
        };
      l.current.element instanceof HTMLElement &&
        n &&
        ((N.height = l.current.element.offsetHeight),
        (N.width = l.current.element.offsetWidth)),
        Object.freeze(N),
        p.current &&
          !pU(l.current.lastBounds, N) &&
          a((l.current.lastBounds = N));
    };
    return [x, d ? qA(x, d) : x, c ? qA(x, c) : x];
  }, [a, n, c, d]);
  function A() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((x) =>
        x.removeEventListener("scroll", v, !0),
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null)),
      l.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              l.current.orientationHandler,
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              l.current.orientationHandler,
            ));
  }
  function M() {
    var x;
    l.current.element &&
      ((l.current.resizeObserver = new i(y)),
      (x = l.current.resizeObserver) == null || x.observe(l.current.element),
      e &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((C) =>
          C.addEventListener("scroll", v, { capture: !0, passive: !0 }),
        ),
      (l.current.orientationHandler = () => {
        v();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            l.current.orientationHandler,
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            l.current.orientationHandler,
          ));
  }
  const w = (x) => {
    !x ||
      x === l.current.element ||
      (A(), (l.current.element = x), (l.current.scrollContainers = a6(x)), M());
  };
  return (
    hU(v, !!e),
    dU(y),
    he.useEffect(() => {
      A(), M();
    }, [e, v, y]),
    he.useEffect(() => A, []),
    [w, s, m]
  );
}
function dU(r) {
  he.useEffect(() => {
    const e = r;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [r]);
}
function hU(r, e) {
  he.useEffect(() => {
    if (e) {
      const t = r;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [r, e]);
}
function a6(r) {
  const e = [];
  if (!r || r === document.body) return e;
  const {
    overflow: t,
    overflowX: n,
    overflowY: i,
  } = window.getComputedStyle(r);
  return (
    [t, n, i].some((s) => s === "auto" || s === "scroll") && e.push(r),
    [...e, ...a6(r.parentElement)]
  );
}
const fU = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  pU = (r, e) => fU.every((t) => r[t] === e[t]),
  mU = he.forwardRef(function (
    {
      children: r,
      fallback: e,
      resize: t,
      style: n,
      gl: i,
      events: s = QN,
      eventSource: a,
      eventPrefix: l,
      shadows: c,
      linear: d,
      flat: p,
      legacy: m,
      orthographic: y,
      frameloop: v,
      dpr: A,
      performance: M,
      raycaster: w,
      camera: x,
      scene: C,
      onPointerMissed: T,
      onCreated: I,
      ...U
    },
    F,
  ) {
    he.useMemo(() => jS(yN), []);
    const O = uU(),
      [z, L] = cU({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...t }),
      N = he.useRef(null),
      X = he.useRef(null);
    he.useImperativeHandle(F, () => N.current);
    const ie = JS(T),
      [re, me] = he.useState(!1),
      [_e, ge] = he.useState(!1);
    if (re) throw re;
    if (_e) throw _e;
    const Re = he.useRef(null);
    um(() => {
      const oe = N.current;
      L.width > 0 &&
        L.height > 0 &&
        oe &&
        (Re.current || (Re.current = YN(oe)),
        Re.current.configure({
          gl: i,
          events: s,
          shadows: c,
          linear: d,
          flat: p,
          legacy: m,
          orthographic: y,
          frameloop: v,
          dpr: A,
          performance: M,
          raycaster: w,
          camera: x,
          scene: C,
          size: L,
          onPointerMissed: (...ae) =>
            ie.current == null ? void 0 : ie.current(...ae),
          onCreated: (ae) => {
            ae.events.connect == null ||
              ae.events.connect(a ? (PN(a) ? a.current : a) : X.current),
              l &&
                ae.setEvents({
                  compute: (q, ce) => {
                    const Xe = q[l + "X"],
                      ye = q[l + "Y"];
                    ce.pointer.set(
                      (Xe / ce.size.width) * 2 - 1,
                      -(ye / ce.size.height) * 2 + 1,
                    ),
                      ce.raycaster.setFromCamera(ce.pointer, ce.camera);
                  },
                }),
              I == null || I(ae);
          },
        }),
        Re.current.render(
          H.jsx(O, {
            children: H.jsx(YS, {
              set: ge,
              children: H.jsx(he.Suspense, {
                fallback: H.jsx(LN, { set: me }),
                children: r,
              }),
            }),
          }),
        ));
    }),
      he.useEffect(() => {
        const oe = N.current;
        if (oe) return () => n6(oe);
      }, []);
    const J = a ? "none" : "auto";
    return H.jsx("div", {
      ref: X,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: J,
        ...n,
      },
      ...U,
      children: H.jsx("div", {
        ref: z,
        style: { width: "100%", height: "100%" },
        children: H.jsx("canvas", {
          ref: N,
          style: { display: "block" },
          children: e,
        }),
      }),
    });
  }),
  gU = he.forwardRef(function (r, e) {
    return H.jsx(s6, { children: H.jsx(mU, { ...r, ref: e }) });
  });
function Fv() {
  return (
    (Fv = Object.assign
      ? Object.assign.bind()
      : function (r) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
          }
          return r;
        }),
    Fv.apply(null, arguments)
  );
}
const yU = parseInt(Mh.replace(/\D+/g, ""));
function rw(r, e) {
  if (e === C5)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.",
      ),
      r
    );
  if (e === ug || e === P3) {
    let t = r.getIndex();
    if (t === null) {
      const a = [],
        l = r.getAttribute("position");
      if (l !== void 0) {
        for (let c = 0; c < l.count; c++) a.push(c);
        r.setIndex(a), (t = r.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.",
          ),
          r
        );
    }
    const n = t.count - 2,
      i = [];
    if (t)
      if (e === ug)
        for (let a = 1; a <= n; a++)
          i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
      else
        for (let a = 0; a < n; a++)
          a % 2 === 0
            ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2)))
            : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.",
      );
    const s = r.clone();
    return s.setIndex(i), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e,
      ),
      r
    );
}
var Js = Uint8Array,
  Ic = Uint16Array,
  Nv = Uint32Array,
  o6 = new Js([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  l6 = new Js([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  vU = new Js([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  u6 = function (r, e) {
    for (var t = new Ic(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
    for (var i = new Nv(t[30]), n = 1; n < 30; ++n)
      for (var s = t[n]; s < t[n + 1]; ++s) i[s] = ((s - t[n]) << 5) | n;
    return [t, i];
  },
  c6 = u6(o6, 2),
  d6 = c6[0],
  xU = c6[1];
(d6[28] = 258), (xU[258] = 28);
var bU = u6(l6, 0),
  _U = bU[0],
  h6 = new Ic(32768);
for (var er = 0; er < 32768; ++er) {
  var Nl = ((er & 43690) >>> 1) | ((er & 21845) << 1);
  (Nl = ((Nl & 52428) >>> 2) | ((Nl & 13107) << 2)),
    (Nl = ((Nl & 61680) >>> 4) | ((Nl & 3855) << 4)),
    (h6[er] = (((Nl & 65280) >>> 8) | ((Nl & 255) << 8)) >>> 1);
}
var xp = function (r, e, t) {
    for (var n = r.length, i = 0, s = new Ic(e); i < n; ++i) ++s[r[i] - 1];
    var a = new Ic(e);
    for (i = 0; i < e; ++i) a[i] = (a[i - 1] + s[i - 1]) << 1;
    var l;
    {
      l = new Ic(1 << e);
      var c = 15 - e;
      for (i = 0; i < n; ++i)
        if (r[i])
          for (
            var d = (i << 4) | r[i],
              p = e - r[i],
              m = a[r[i] - 1]++ << p,
              y = m | ((1 << p) - 1);
            m <= y;
            ++m
          )
            l[h6[m] >>> c] = d;
    }
    return l;
  },
  cm = new Js(288);
for (var er = 0; er < 144; ++er) cm[er] = 8;
for (var er = 144; er < 256; ++er) cm[er] = 9;
for (var er = 256; er < 280; ++er) cm[er] = 7;
for (var er = 280; er < 288; ++er) cm[er] = 8;
var f6 = new Js(32);
for (var er = 0; er < 32; ++er) f6[er] = 5;
var AU = xp(cm, 9),
  wU = xp(f6, 5),
  Gy = function (r) {
    for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
    return e;
  },
  xa = function (r, e, t) {
    var n = (e / 8) | 0;
    return ((r[n] | (r[n + 1] << 8)) >> (e & 7)) & t;
  },
  jy = function (r, e) {
    var t = (e / 8) | 0;
    return (r[t] | (r[t + 1] << 8) | (r[t + 2] << 16)) >> (e & 7);
  },
  MU = function (r) {
    return ((r / 8) | 0) + (r & 7 && 1);
  },
  SU = function (r, e, t) {
    (t == null || t > r.length) && (t = r.length);
    var n = new (r instanceof Ic ? Ic : r instanceof Nv ? Nv : Js)(t - e);
    return n.set(r.subarray(e, t)), n;
  },
  EU = function (r, e, t) {
    var n = r.length;
    if (!n || (t && !t.l && n < 5)) return e || new Js(0);
    var i = !e || t,
      s = !t || t.i;
    t || (t = {}), e || (e = new Js(n * 3));
    var a = function (Ue) {
        var Fe = e.length;
        if (Ue > Fe) {
          var Je = new Js(Math.max(Fe * 2, Ue));
          Je.set(e), (e = Je);
        }
      },
      l = t.f || 0,
      c = t.p || 0,
      d = t.b || 0,
      p = t.l,
      m = t.d,
      y = t.m,
      v = t.n,
      A = n * 8;
    do {
      if (!p) {
        t.f = l = xa(r, c, 1);
        var M = xa(r, c + 1, 3);
        if (((c += 3), M))
          if (M == 1) (p = AU), (m = wU), (y = 9), (v = 5);
          else if (M == 2) {
            var w = xa(r, c, 31) + 257,
              x = xa(r, c + 10, 15) + 4,
              C = w + xa(r, c + 5, 31) + 1;
            c += 14;
            for (var T = new Js(C), I = new Js(19), U = 0; U < x; ++U)
              I[vU[U]] = xa(r, c + U * 3, 7);
            c += x * 3;
            for (
              var F = Gy(I), O = (1 << F) - 1, z = xp(I, F), U = 0;
              U < C;

            ) {
              var L = z[xa(r, c, O)];
              c += L & 15;
              var N = L >>> 4;
              if (N < 16) T[U++] = N;
              else {
                var X = 0,
                  ie = 0;
                for (
                  N == 16
                    ? ((ie = 3 + xa(r, c, 3)), (c += 2), (X = T[U - 1]))
                    : N == 17
                      ? ((ie = 3 + xa(r, c, 7)), (c += 3))
                      : N == 18 && ((ie = 11 + xa(r, c, 127)), (c += 7));
                  ie--;

                )
                  T[U++] = X;
              }
            }
            var re = T.subarray(0, w),
              me = T.subarray(w);
            (y = Gy(re)), (v = Gy(me)), (p = xp(re, y)), (m = xp(me, v));
          } else throw "invalid block type";
        else {
          var N = MU(c) + 4,
            _e = r[N - 4] | (r[N - 3] << 8),
            ge = N + _e;
          if (ge > n) {
            if (s) throw "unexpected EOF";
            break;
          }
          i && a(d + _e),
            e.set(r.subarray(N, ge), d),
            (t.b = d += _e),
            (t.p = c = ge * 8);
          continue;
        }
        if (c > A) {
          if (s) throw "unexpected EOF";
          break;
        }
      }
      i && a(d + 131072);
      for (var Re = (1 << y) - 1, J = (1 << v) - 1, oe = c; ; oe = c) {
        var X = p[jy(r, c) & Re],
          ae = X >>> 4;
        if (((c += X & 15), c > A)) {
          if (s) throw "unexpected EOF";
          break;
        }
        if (!X) throw "invalid length/literal";
        if (ae < 256) e[d++] = ae;
        else if (ae == 256) {
          (oe = c), (p = null);
          break;
        } else {
          var q = ae - 254;
          if (ae > 264) {
            var U = ae - 257,
              ce = o6[U];
            (q = xa(r, c, (1 << ce) - 1) + d6[U]), (c += ce);
          }
          var Xe = m[jy(r, c) & J],
            ye = Xe >>> 4;
          if (!Xe) throw "invalid distance";
          c += Xe & 15;
          var me = _U[ye];
          if (ye > 3) {
            var ce = l6[ye];
            (me += jy(r, c) & ((1 << ce) - 1)), (c += ce);
          }
          if (c > A) {
            if (s) throw "unexpected EOF";
            break;
          }
          i && a(d + 131072);
          for (var Pe = d + q; d < Pe; d += 4)
            (e[d] = e[d - me]),
              (e[d + 1] = e[d + 1 - me]),
              (e[d + 2] = e[d + 2 - me]),
              (e[d + 3] = e[d + 3 - me]);
          d = Pe;
        }
      }
      (t.l = p),
        (t.p = oe),
        (t.b = d),
        p && ((l = 1), (t.m = y), (t.d = m), (t.n = v));
    } while (!l);
    return d == e.length ? e : SU(e, 0, d);
  },
  CU = new Js(0),
  TU = function (r) {
    if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || ((r[0] << 8) | r[1]) % 31)
      throw "invalid zlib data";
    if (r[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
  };
function l0(r, e) {
  return EU((TU(r), r.subarray(2, -4)), e);
}
var RU = typeof TextDecoder < "u" && new TextDecoder(),
  IU = 0;
try {
  RU.decode(CU, { stream: !0 }), (IU = 1);
} catch {}
const BU = (r) => r && r.isCubeTexture;
class PU extends nr {
  constructor(e, t) {
    var n, i;
    const s = BU(e),
      a =
        ((i = s
          ? (n = e.image[0]) == null
            ? void 0
            : n.width
          : e.image.width) != null
          ? i
          : 1024) / 4,
      l = Math.floor(Math.log2(a)),
      c = Math.pow(2, l),
      d = 3 * Math.max(c, 16 * 7),
      p = 4 * c,
      m = [
        s ? "#define ENVMAP_TYPE_CUBE" : "",
        `#define CUBEUV_TEXEL_WIDTH ${1 / d}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / p}`,
        `#define CUBEUV_MAX_MIP ${l}.0`,
      ],
      y = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      v =
        m.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${parseInt(Mh.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `,
      A = {
        map: { value: e },
        height: { value: (t == null ? void 0 : t.height) || 15 },
        radius: { value: (t == null ? void 0 : t.radius) || 100 },
      },
      M = new sm(1, 16),
      w = new fs({ uniforms: A, fragmentShader: v, vertexShader: y, side: Xs });
    super(M, w);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
function pg(r) {
  if (typeof TextDecoder < "u") return new TextDecoder().decode(r);
  let e = "";
  for (let t = 0, n = r.length; t < n; t++) e += String.fromCharCode(r[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const wc = "srgb",
  Zo = "srgb-linear",
  iw = 3001,
  LU = 3e3;
class _x extends di {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new OU(t);
      }),
      this.register(function (t) {
        return new kU(t);
      }),
      this.register(function (t) {
        return new YU(t);
      }),
      this.register(function (t) {
        return new ZU(t);
      }),
      this.register(function (t) {
        return new qU(t);
      }),
      this.register(function (t) {
        return new HU(t);
      }),
      this.register(function (t) {
        return new VU(t);
      }),
      this.register(function (t) {
        return new GU(t);
      }),
      this.register(function (t) {
        return new jU(t);
      }),
      this.register(function (t) {
        return new UU(t);
      }),
      this.register(function (t) {
        return new WU(t);
      }),
      this.register(function (t) {
        return new zU(t);
      }),
      this.register(function (t) {
        return new JU(t);
      }),
      this.register(function (t) {
        return new XU(t);
      }),
      this.register(function (t) {
        return new FU(t);
      }),
      this.register(function (t) {
        return new KU(t);
      }),
      this.register(function (t) {
        return new QU(t);
      });
  }
  load(e, t, n, i) {
    const s = this;
    let a;
    if (this.resourcePath !== "") a = this.resourcePath;
    else if (this.path !== "") {
      const d = Vl.extractUrlBase(e);
      a = Vl.resolveURL(d, this.path);
    } else a = Vl.extractUrlBase(e);
    this.manager.itemStart(e);
    const l = function (d) {
        i ? i(d) : console.error(d),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      c = new ci(this.manager);
    c.setPath(this.path),
      c.setResponseType("arraybuffer"),
      c.setRequestHeader(this.requestHeader),
      c.setWithCredentials(this.withCredentials),
      c.load(
        e,
        function (d) {
          try {
            s.parse(
              d,
              a,
              function (p) {
                t(p), s.manager.itemEnd(e);
              },
              l,
            );
          } catch (p) {
            l(p);
          }
        },
        n,
        l,
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let s;
    const a = {},
      l = {};
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (pg(new Uint8Array(e.slice(0, 4))) === p6) {
        try {
          a[pn.KHR_BINARY_GLTF] = new $U(e);
        } catch (d) {
          i && i(d);
          return;
        }
        s = JSON.parse(a[pn.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(pg(new Uint8Array(e)));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.",
          ),
        );
      return;
    }
    const c = new hO(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let d = 0; d < this.pluginCallbacks.length; d++) {
      const p = this.pluginCallbacks[d](c);
      p.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (l[p.name] = p),
        (a[p.name] = !0);
    }
    if (s.extensionsUsed)
      for (let d = 0; d < s.extensionsUsed.length; ++d) {
        const p = s.extensionsUsed[d],
          m = s.extensionsRequired || [];
        switch (p) {
          case pn.KHR_MATERIALS_UNLIT:
            a[p] = new NU();
            break;
          case pn.KHR_DRACO_MESH_COMPRESSION:
            a[p] = new eO(s, this.dracoLoader);
            break;
          case pn.KHR_TEXTURE_TRANSFORM:
            a[p] = new tO();
            break;
          case pn.KHR_MESH_QUANTIZATION:
            a[p] = new nO();
            break;
          default:
            m.indexOf(p) >= 0 &&
              l[p] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + p + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(l), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.parse(e, t, i, s);
    });
  }
}
function DU() {
  let r = {};
  return {
    get: function (e) {
      return r[e];
    },
    add: function (e, t) {
      r[e] = t;
    },
    remove: function (e) {
      delete r[e];
    },
    removeAll: function () {
      r = {};
    },
  };
}
const pn = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class FU {
  constructor(e) {
    (this.parser = e),
      (this.name = pn.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const s = t.json,
      a = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let l;
    const c = new dt(16777215);
    a.color !== void 0 && c.setRGB(a.color[0], a.color[1], a.color[2], Zo);
    const d = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        (l = new ox(c)), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case "point":
        (l = new ax(c)), (l.distance = d);
        break;
      case "spot":
        (l = new sx(c)),
          (l.distance = d),
          (a.spot = a.spot || {}),
          (a.spot.innerConeAngle =
            a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0),
          (a.spot.outerConeAngle =
            a.spot.outerConeAngle !== void 0
              ? a.spot.outerConeAngle
              : Math.PI / 4),
          (l.angle = a.spot.outerConeAngle),
          (l.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
          l.target.position.set(0, 0, -1),
          l.add(l.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return (
      l.position.set(0, 0, 0),
      (l.decay = 2),
      Ho(l, a),
      a.intensity !== void 0 && (l.intensity = a.intensity),
      (l.name = t.createUniqueName(a.name || "light_" + e)),
      (i = Promise.resolve(l)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      i = n.json.nodes[e],
      s = ((i.extensions && i.extensions[this.name]) || {}).light;
    return s === void 0
      ? null
      : this._loadLight(s).then(function (a) {
          return n._getNodeRef(t.cache, s, a);
        });
  }
}
class NU {
  constructor() {
    this.name = pn.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return ds;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new dt(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const a = s.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], Zo), (e.opacity = a[3]);
      }
      s.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", s.baseColorTexture, wc));
    }
    return Promise.all(i);
  }
}
class UU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const i = n.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}
class OU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            a.clearcoatRoughnessTexture,
          ),
        ),
      a.clearcoatNormalTexture !== void 0 &&
        (s.push(
          n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture),
        ),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const l = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new je(l, l);
    }
    return Promise.all(s);
  }
}
class kU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const i = n.extensions[this.name];
    return (
      (t.dispersion = i.dispersion !== void 0 ? i.dispersion : 0),
      Promise.resolve()
    );
  }
}
class zU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        s.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            "iridescenceThicknessMap",
            a.iridescenceThicknessTexture,
          ),
        ),
      Promise.all(s)
    );
  }
}
class HU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new dt(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = i.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const l = a.sheenColorFactor;
      t.sheenColor.setRGB(l[0], l[1], l[2], Zo);
    }
    return (
      a.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, wc)),
      a.sheenRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture),
        ),
      Promise.all(s)
    );
  }
}
class VU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 &&
        (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        s.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class GU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const l = a.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new dt().setRGB(l[0], l[1], l[2], Zo)),
      Promise.all(s)
    );
  }
}
class jU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const i = n.extensions[this.name];
    return (t.ior = i.ior !== void 0 ? i.ior : 1.5), Promise.resolve();
  }
}
class WU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const l = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new dt().setRGB(l[0], l[1], l[2], Zo)),
      a.specularColorTexture !== void 0 &&
        s.push(
          n.assignTexture(t, "specularColorMap", a.specularColorTexture, wc),
        ),
      Promise.all(s)
    );
  }
}
class XU {
  constructor(e) {
    (this.parser = e), (this.name = pn.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      (t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1),
      a.bumpTexture !== void 0 &&
        s.push(n.assignTexture(t, "bumpMap", a.bumpTexture)),
      Promise.all(s)
    );
  }
}
class JU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return !t.extensions || !t.extensions[this.name] ? null : Ri;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength),
      a.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = a.anisotropyRotation),
      a.anisotropyTexture !== void 0 &&
        s.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class YU {
  constructor(e) {
    (this.parser = e), (this.name = pn.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const s = i.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures",
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, a);
  }
}
class ZU {
  constructor(e) {
    (this.parser = e),
      (this.name = pn.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      l = i.images[a.source];
    let c = n.textureLoader;
    if (l.uri) {
      const d = n.options.manager.getHandler(l.uri);
      d !== null && (c = d);
    }
    return this.detectSupport().then(function (d) {
      if (d) return n.loadTextureImage(e, a.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported.",
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class qU {
  constructor(e) {
    (this.parser = e),
      (this.name = pn.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      l = i.images[a.source];
    let c = n.textureLoader;
    if (l.uri) {
      const d = n.options.manager.getHandler(l.uri);
      d !== null && (c = d);
    }
    return this.detectSupport().then(function (d) {
      if (d) return n.loadTextureImage(e, a.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported.",
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class KU {
  constructor(e) {
    (this.name = pn.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        s = this.parser.getDependency("buffer", i.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files",
          );
        return null;
      }
      return s.then(function (l) {
        const c = i.byteOffset || 0,
          d = i.byteLength || 0,
          p = i.count,
          m = i.byteStride,
          y = new Uint8Array(l, c, d);
        return a.decodeGltfBufferAsync
          ? a
              .decodeGltfBufferAsync(p, m, y, i.mode, i.filter)
              .then(function (v) {
                return v.buffer;
              })
          : a.ready.then(function () {
              const v = new ArrayBuffer(p * m);
              return (
                a.decodeGltfBuffer(
                  new Uint8Array(v),
                  p,
                  m,
                  y,
                  i.mode,
                  i.filter,
                ),
                v
              );
            });
      });
    } else return null;
  }
}
class QU {
  constructor(e) {
    (this.name = pn.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const c of i.primitives)
      if (
        c.mode !== Ws.TRIANGLES &&
        c.mode !== Ws.TRIANGLE_STRIP &&
        c.mode !== Ws.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const s = n.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const c in s)
      a.push(
        this.parser
          .getDependency("accessor", s[c])
          .then((d) => ((l[c] = d), l[c])),
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((c) => {
          const d = c.pop(),
            p = d.isGroup ? d.children : [d],
            m = c[0].count,
            y = [];
          for (const v of p) {
            const A = new jt(),
              M = new Y(),
              w = new Ci(),
              x = new Y(1, 1, 1),
              C = new H3(v.geometry, v.material, m);
            for (let T = 0; T < m; T++)
              l.TRANSLATION && M.fromBufferAttribute(l.TRANSLATION, T),
                l.ROTATION && w.fromBufferAttribute(l.ROTATION, T),
                l.SCALE && x.fromBufferAttribute(l.SCALE, T),
                C.setMatrixAt(T, A.compose(M, w, x));
            for (const T in l)
              if (T === "_COLOR_0") {
                const I = l[T];
                C.instanceColor = new Fc(I.array, I.itemSize, I.normalized);
              } else
                T !== "TRANSLATION" &&
                  T !== "ROTATION" &&
                  T !== "SCALE" &&
                  v.geometry.setAttribute(T, l[T]);
            _n.prototype.copy.call(C, v),
              this.parser.assignFinalMaterial(C),
              y.push(C);
          }
          return d.isGroup ? (d.clear(), d.add(...y), d) : y[0];
        }));
  }
}
const p6 = "glTF",
  Xf = 12,
  sw = { JSON: 1313821514, BIN: 5130562 };
class $U {
  constructor(e) {
    (this.name = pn.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, Xf);
    if (
      ((this.header = {
        magic: pg(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== p6)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Xf,
      i = new DataView(e, Xf);
    let s = 0;
    for (; s < n; ) {
      const a = i.getUint32(s, !0);
      s += 4;
      const l = i.getUint32(s, !0);
      if (((s += 4), l === sw.JSON)) {
        const c = new Uint8Array(e, Xf + s, a);
        this.content = pg(c);
      } else if (l === sw.BIN) {
        const c = Xf + s;
        this.body = e.slice(c, c + a);
      }
      s += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class eO {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = pn.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      l = {},
      c = {},
      d = {};
    for (const p in a) {
      const m = Uv[p] || p.toLowerCase();
      l[m] = a[p];
    }
    for (const p in e.attributes) {
      const m = Uv[p] || p.toLowerCase();
      if (a[p] !== void 0) {
        const y = n.accessors[e.attributes[p]],
          v = lh[y.componentType];
        (d[m] = v.name), (c[m] = y.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (p) {
      return new Promise(function (m, y) {
        i.decodeDracoFile(
          p,
          function (v) {
            for (const A in v.attributes) {
              const M = v.attributes[A],
                w = c[A];
              w !== void 0 && (M.normalized = w);
            }
            m(v);
          },
          l,
          d,
          Zo,
          y,
        );
      });
    });
  }
}
class tO {
  constructor() {
    this.name = pn.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class nO {
  constructor() {
    this.name = pn.KHR_MESH_QUANTIZATION;
  }
}
class m6 extends Th {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i * 3 + i;
    for (let a = 0; a !== i; a++) t[a] = n[s + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      l = this.valueSize,
      c = l * 2,
      d = l * 3,
      p = i - t,
      m = (n - t) / p,
      y = m * m,
      v = y * m,
      A = e * d,
      M = A - d,
      w = -2 * v + 3 * y,
      x = v - y,
      C = 1 - w,
      T = x - y + m;
    for (let I = 0; I !== l; I++) {
      const U = a[M + I + l],
        F = a[M + I + c] * p,
        O = a[A + I + l],
        z = a[A + I] * p;
      s[I] = C * U + T * F + w * O + x * z;
    }
    return s;
  }
}
const rO = new Ci();
class iO extends m6 {
  interpolate_(e, t, n, i) {
    const s = super.interpolate_(e, t, n, i);
    return rO.fromArray(s).normalize().toArray(s), s;
  }
}
const Ws = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  lh = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  aw = { 9728: Qr, 9729: Un, 9984: Cg, 9985: ah, 9986: gc, 9987: Ys },
  ow = { 33071: Ar, 33648: fh, 10497: Xl },
  Wy = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  Uv = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(yU >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  Ul = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  sO = { CUBICSPLINE: void 0, LINEAR: gh, STEP: mh },
  Xy = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function aO(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new lm({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: ro,
      })),
    r.DefaultMaterial
  );
}
function uc(r, e, t) {
  for (const n in t.extensions)
    r[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function Ho(r, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(r.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras,
        ));
}
function oO(r, e, t) {
  let n = !1,
    i = !1,
    s = !1;
  for (let d = 0, p = e.length; d < p; d++) {
    const m = e[d];
    if (
      (m.POSITION !== void 0 && (n = !0),
      m.NORMAL !== void 0 && (i = !0),
      m.COLOR_0 !== void 0 && (s = !0),
      n && i && s)
    )
      break;
  }
  if (!n && !i && !s) return Promise.resolve(r);
  const a = [],
    l = [],
    c = [];
  for (let d = 0, p = e.length; d < p; d++) {
    const m = e[d];
    if (n) {
      const y =
        m.POSITION !== void 0
          ? t.getDependency("accessor", m.POSITION)
          : r.attributes.position;
      a.push(y);
    }
    if (i) {
      const y =
        m.NORMAL !== void 0
          ? t.getDependency("accessor", m.NORMAL)
          : r.attributes.normal;
      l.push(y);
    }
    if (s) {
      const y =
        m.COLOR_0 !== void 0
          ? t.getDependency("accessor", m.COLOR_0)
          : r.attributes.color;
      c.push(y);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(l), Promise.all(c)]).then(
    function (d) {
      const p = d[0],
        m = d[1],
        y = d[2];
      return (
        n && (r.morphAttributes.position = p),
        i && (r.morphAttributes.normal = m),
        s && (r.morphAttributes.color = y),
        (r.morphTargetsRelative = !0),
        r
      );
    },
  );
}
function lO(r, e) {
  if ((r.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        r.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.",
      );
  }
}
function uO(r) {
  let e;
  const t = r.extensions && r.extensions[pn.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + Jy(t.attributes))
      : (e = r.indices + ":" + Jy(r.attributes) + ":" + r.mode),
    r.targets !== void 0)
  )
    for (let n = 0, i = r.targets.length; n < i; n++)
      e += ":" + Jy(r.targets[n]);
  return e;
}
function Jy(r) {
  let e = "";
  const t = Object.keys(r).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + r[t[n]] + ";";
  return e;
}
function Ov(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type.",
      );
  }
}
function cO(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
      ? "image/webp"
      : "image/png";
}
const dO = new jt();
class hO {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new DU()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      s = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf("Firefox") > -1),
      (s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || n || (i && s < 98)
        ? (this.textureLoader = new rx(this.options.manager))
        : (this.textureLoader = new TS(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new ci(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        }),
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (a) {
          const l = {
            scene: a[0][i.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          return (
            uc(s, l, i),
            Ho(l, i),
            Promise.all(
              n._invokeAll(function (c) {
                return c.afterRoot && c.afterRoot(l);
              }),
            ).then(function () {
              for (const c of l.scenes) c.updateMatrixWorld();
              e(l);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i].joints;
      for (let l = 0, c = a.length; l < c; l++) e[a[l]].isBone = !0;
    }
    for (let i = 0, s = e.length; i < s; i++) {
      const a = e[i];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      s = (a, l) => {
        const c = this.associations.get(a);
        c != null && this.associations.set(l, c);
        for (const [d, p] of a.children.entries()) s(p, l.children[d]);
      };
    return s(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const s = e(t[i]);
      s && n.push(s);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (s, a) {
          return n.getDependency(e, a);
        }),
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported.",
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[pn.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (s, a) {
      n.load(Vl.resolveURL(t.uri, i.path), s, void 0, function () {
        a(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'),
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        s = t.byteOffset || 0;
      return n.slice(s, s + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = Wy[i.type],
        l = lh[i.componentType],
        c = i.normalized === !0,
        d = new l(i.count * a);
      return Promise.resolve(new Tn(d, a, c));
    }
    const s = [];
    return (
      i.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", i.bufferView))
        : s.push(null),
      i.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(s).then(function (a) {
        const l = a[0],
          c = Wy[i.type],
          d = lh[i.componentType],
          p = d.BYTES_PER_ELEMENT,
          m = p * c,
          y = i.byteOffset || 0,
          v =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          A = i.normalized === !0;
        let M, w;
        if (v && v !== m) {
          const x = Math.floor(y / v),
            C =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              x +
              ":" +
              i.count;
          let T = t.cache.get(C);
          T ||
            ((M = new d(l, x * v, (i.count * v) / p)),
            (T = new tm(M, v / p)),
            t.cache.add(C, T)),
            (w = new Jl(T, c, (y % v) / p, A));
        } else
          l === null
            ? (M = new d(i.count * c))
            : (M = new d(l, y, i.count * c)),
            (w = new Tn(M, c, A));
        if (i.sparse !== void 0) {
          const x = Wy.SCALAR,
            C = lh[i.sparse.indices.componentType],
            T = i.sparse.indices.byteOffset || 0,
            I = i.sparse.values.byteOffset || 0,
            U = new C(a[1], T, i.sparse.count * x),
            F = new d(a[2], I, i.sparse.count * c);
          l !== null && (w = new Tn(w.array.slice(), w.itemSize, w.normalized));
          for (let O = 0, z = U.length; O < z; O++) {
            const L = U[O];
            if (
              (w.setX(L, F[O * c]),
              c >= 2 && w.setY(L, F[O * c + 1]),
              c >= 3 && w.setZ(L, F[O * c + 2]),
              c >= 4 && w.setW(L, F[O * c + 3]),
              c >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.",
              );
          }
        }
        return w;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      i = t.textures[e].source,
      s = t.images[i];
    let a = this.textureLoader;
    if (s.uri) {
      const l = n.manager.getHandler(s.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, i, a);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      s = this.json,
      a = s.textures[e],
      l = s.images[t],
      c = (l.uri || l.bufferView) + ":" + a.sampler;
    if (this.textureCache[c]) return this.textureCache[c];
    const d = this.loadImageSource(t, n)
      .then(function (p) {
        (p.flipY = !1),
          (p.name = a.name || l.name || ""),
          p.name === "" &&
            typeof l.uri == "string" &&
            l.uri.startsWith("data:image/") === !1 &&
            (p.name = l.uri);
        const m = (s.samplers || {})[a.sampler] || {};
        return (
          (p.magFilter = aw[m.magFilter] || Un),
          (p.minFilter = aw[m.minFilter] || Ys),
          (p.wrapS = ow[m.wrapS] || Xl),
          (p.wrapT = ow[m.wrapT] || Xl),
          i.associations.set(p, { textures: e }),
          p
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[c] = d), d;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((m) => m.clone());
    const a = i.images[e],
      l = self.URL || self.webkitURL;
    let c = a.uri || "",
      d = !1;
    if (a.bufferView !== void 0)
      c = n.getDependency("bufferView", a.bufferView).then(function (m) {
        d = !0;
        const y = new Blob([m], { type: a.mimeType });
        return (c = l.createObjectURL(y)), c;
      });
    else if (a.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView",
      );
    const p = Promise.resolve(c)
      .then(function (m) {
        return new Promise(function (y, v) {
          let A = y;
          t.isImageBitmapLoader === !0 &&
            (A = function (M) {
              const w = new Ln(M);
              (w.needsUpdate = !0), y(w);
            }),
            t.load(Vl.resolveURL(m, s.path), A, void 0, v);
        });
      })
      .then(function (m) {
        return (
          d === !0 && l.revokeObjectURL(c),
          Ho(m, a),
          (m.userData.mimeType = a.mimeType || cO(a.uri)),
          m
        );
      })
      .catch(function (m) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", c), m);
      });
    return (this.sourceCache[e] = p), p;
  }
  assignTexture(e, t, n, i) {
    const s = this;
    return this.getDependency("texture", n.index).then(function (a) {
      if (!a) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((a = a.clone()), (a.channel = n.texCoord)),
        s.extensions[pn.KHR_TEXTURE_TRANSFORM])
      ) {
        const l =
          n.extensions !== void 0
            ? n.extensions[pn.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (l) {
          const c = s.associations.get(a);
          (a = s.extensions[pn.KHR_TEXTURE_TRANSFORM].extendTexture(a, l)),
            s.associations.set(a, c);
        }
      }
      return (
        i !== void 0 &&
          (typeof i == "number" && (i = i === iw ? wc : Zo),
          "colorSpace" in a
            ? (a.colorSpace = i)
            : (a.encoding = i === wc ? iw : LU)),
        (e[t] = a),
        a
      );
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const l = "PointsMaterial:" + n.uuid;
      let c = this.cache.get(l);
      c ||
        ((c = new kg()),
        Dr.prototype.copy.call(c, n),
        c.color.copy(n.color),
        (c.map = n.map),
        (c.sizeAttenuation = !1),
        this.cache.add(l, c)),
        (n = c);
    } else if (e.isLine) {
      const l = "LineBasicMaterial:" + n.uuid;
      let c = this.cache.get(l);
      c ||
        ((c = new Ii()),
        Dr.prototype.copy.call(c, n),
        c.color.copy(n.color),
        (c.map = n.map),
        this.cache.add(l, c)),
        (n = c);
    }
    if (i || s || a) {
      let l = "ClonedMaterial:" + n.uuid + ":";
      i && (l += "derivative-tangents:"),
        s && (l += "vertex-colors:"),
        a && (l += "flat-shading:");
      let c = this.cache.get(l);
      c ||
        ((c = n.clone()),
        s && (c.vertexColors = !0),
        a && (c.flatShading = !0),
        i &&
          (c.normalScale && (c.normalScale.y *= -1),
          c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)),
        this.cache.add(l, c),
        this.associations.set(c, this.associations.get(n))),
        (n = c);
    }
    e.material = n;
  }
  getMaterialType() {
    return lm;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.materials[e];
    let a;
    const l = {},
      c = s.extensions || {},
      d = [];
    if (c[pn.KHR_MATERIALS_UNLIT]) {
      const m = i[pn.KHR_MATERIALS_UNLIT];
      (a = m.getMaterialType()), d.push(m.extendParams(l, s, t));
    } else {
      const m = s.pbrMetallicRoughness || {};
      if (
        ((l.color = new dt(1, 1, 1)),
        (l.opacity = 1),
        Array.isArray(m.baseColorFactor))
      ) {
        const y = m.baseColorFactor;
        l.color.setRGB(y[0], y[1], y[2], Zo), (l.opacity = y[3]);
      }
      m.baseColorTexture !== void 0 &&
        d.push(t.assignTexture(l, "map", m.baseColorTexture, wc)),
        (l.metalness = m.metallicFactor !== void 0 ? m.metallicFactor : 1),
        (l.roughness = m.roughnessFactor !== void 0 ? m.roughnessFactor : 1),
        m.metallicRoughnessTexture !== void 0 &&
          (d.push(
            t.assignTexture(l, "metalnessMap", m.metallicRoughnessTexture),
          ),
          d.push(
            t.assignTexture(l, "roughnessMap", m.metallicRoughnessTexture),
          )),
        (a = this._invokeOne(function (y) {
          return y.getMaterialType && y.getMaterialType(e);
        })),
        d.push(
          Promise.all(
            this._invokeAll(function (y) {
              return y.extendMaterialParams && y.extendMaterialParams(e, l);
            }),
          ),
        );
    }
    s.doubleSided === !0 && (l.side = Xs);
    const p = s.alphaMode || Xy.OPAQUE;
    if (
      (p === Xy.BLEND
        ? ((l.transparent = !0), (l.depthWrite = !1))
        : ((l.transparent = !1),
          p === Xy.MASK &&
            (l.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        a !== ds &&
        (d.push(t.assignTexture(l, "normalMap", s.normalTexture)),
        (l.normalScale = new je(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const m = s.normalTexture.scale;
      l.normalScale.set(m, m);
    }
    if (
      (s.occlusionTexture !== void 0 &&
        a !== ds &&
        (d.push(t.assignTexture(l, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (l.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && a !== ds)
    ) {
      const m = s.emissiveFactor;
      l.emissive = new dt().setRGB(m[0], m[1], m[2], Zo);
    }
    return (
      s.emissiveTexture !== void 0 &&
        a !== ds &&
        d.push(t.assignTexture(l, "emissiveMap", s.emissiveTexture, wc)),
      Promise.all(d).then(function () {
        const m = new a(l);
        return (
          s.name && (m.name = s.name),
          Ho(m, s),
          t.associations.set(m, { materials: e }),
          s.extensions && uc(i, m, s),
          m
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Mn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function s(l) {
      return n[pn.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(l, t)
        .then(function (c) {
          return lw(c, l, t);
        });
    }
    const a = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const d = e[l],
        p = uO(d),
        m = i[p];
      if (m) a.push(m.promise);
      else {
        let y;
        d.extensions && d.extensions[pn.KHR_DRACO_MESH_COMPRESSION]
          ? (y = s(d))
          : (y = lw(new tn(), d, t)),
          (i[p] = { primitive: d, promise: y }),
          a.push(y);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.meshes[e],
      a = s.primitives,
      l = [];
    for (let c = 0, d = a.length; c < d; c++) {
      const p =
        a[c].material === void 0
          ? aO(this.cache)
          : this.getDependency("material", a[c].material);
      l.push(p);
    }
    return (
      l.push(t.loadGeometries(a)),
      Promise.all(l).then(function (c) {
        const d = c.slice(0, c.length - 1),
          p = c[c.length - 1],
          m = [];
        for (let v = 0, A = p.length; v < A; v++) {
          const M = p[v],
            w = a[v];
          let x;
          const C = d[v];
          if (
            w.mode === Ws.TRIANGLES ||
            w.mode === Ws.TRIANGLE_STRIP ||
            w.mode === Ws.TRIANGLE_FAN ||
            w.mode === void 0
          )
            (x = s.isSkinnedMesh === !0 ? new z3(M, C) : new nr(M, C)),
              x.isSkinnedMesh === !0 && x.normalizeSkinWeights(),
              w.mode === Ws.TRIANGLE_STRIP
                ? (x.geometry = rw(x.geometry, P3))
                : w.mode === Ws.TRIANGLE_FAN &&
                  (x.geometry = rw(x.geometry, ug));
          else if (w.mode === Ws.LINES) x = new Ea(M, C);
          else if (w.mode === Ws.LINE_STRIP) x = new Ko(M, C);
          else if (w.mode === Ws.LINE_LOOP) x = new V3(M, C);
          else if (w.mode === Ws.POINTS) x = new G3(M, C);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + w.mode,
            );
          Object.keys(x.geometry.morphAttributes).length > 0 && lO(x, s),
            (x.name = t.createUniqueName(s.name || "mesh_" + e)),
            Ho(x, s),
            w.extensions && uc(i, x, w),
            t.assignFinalMaterial(x),
            m.push(x);
        }
        for (let v = 0, A = m.length; v < A; v++)
          t.associations.set(m[v], { meshes: e, primitives: v });
        if (m.length === 1) return s.extensions && uc(i, m[0], s), m[0];
        const y = new jo();
        s.extensions && uc(i, y, s), t.associations.set(y, { meshes: e });
        for (let v = 0, A = m.length; v < A; v++) y.add(m[v]);
        return y;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new Hr(
            gp.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6,
          ))
        : n.type === "orthographic" &&
          (t = new Wc(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      Ho(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, s = t.joints.length; i < s; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const s = i.pop(),
          a = i,
          l = [],
          c = [];
        for (let d = 0, p = a.length; d < p; d++) {
          const m = a[d];
          if (m) {
            l.push(m);
            const y = new jt();
            s !== null && y.fromArray(s.array, d * 16), c.push(y);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[d],
            );
        }
        return new nm(l, c);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      n = this,
      i = t.animations[e],
      s = i.name ? i.name : "animation_" + e,
      a = [],
      l = [],
      c = [],
      d = [],
      p = [];
    for (let m = 0, y = i.channels.length; m < y; m++) {
      const v = i.channels[m],
        A = i.samplers[v.sampler],
        M = v.target,
        w = M.node,
        x = i.parameters !== void 0 ? i.parameters[A.input] : A.input,
        C = i.parameters !== void 0 ? i.parameters[A.output] : A.output;
      M.node !== void 0 &&
        (a.push(this.getDependency("node", w)),
        l.push(this.getDependency("accessor", x)),
        c.push(this.getDependency("accessor", C)),
        d.push(A),
        p.push(M));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(d),
      Promise.all(p),
    ]).then(function (m) {
      const y = m[0],
        v = m[1],
        A = m[2],
        M = m[3],
        w = m[4],
        x = [];
      for (let C = 0, T = y.length; C < T; C++) {
        const I = y[C],
          U = v[C],
          F = A[C],
          O = M[C],
          z = w[C];
        if (I === void 0) continue;
        I.updateMatrix && I.updateMatrix();
        const L = n._createAnimationTracks(I, U, F, O, z);
        if (L) for (let N = 0; N < L.length; N++) x.push(L[N]);
      }
      return new bh(s, void 0, x);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (s) {
          const a = n._getNodeRef(n.meshCache, i.mesh, s);
          return (
            i.weights !== void 0 &&
              a.traverse(function (l) {
                if (l.isMesh)
                  for (let c = 0, d = i.weights.length; c < d; c++)
                    l.morphTargetInfluences[c] = i.weights[c];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      s = n._loadNodeShallow(e),
      a = [],
      l = i.children || [];
    for (let d = 0, p = l.length; d < p; d++)
      a.push(n.getDependency("node", l[d]));
    const c =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", i.skin);
    return Promise.all([s, Promise.all(a), c]).then(function (d) {
      const p = d[0],
        m = d[1],
        y = d[2];
      y !== null &&
        p.traverse(function (v) {
          v.isSkinnedMesh && v.bind(y, dO);
        });
      for (let v = 0, A = m.length; v < A; v++) p.add(m[v]);
      return p;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      a = s.name ? i.createUniqueName(s.name) : "",
      l = [],
      c = i._invokeOne(function (d) {
        return d.createNodeMesh && d.createNodeMesh(e);
      });
    return (
      c && l.push(c),
      s.camera !== void 0 &&
        l.push(
          i.getDependency("camera", s.camera).then(function (d) {
            return i._getNodeRef(i.cameraCache, s.camera, d);
          }),
        ),
      i
        ._invokeAll(function (d) {
          return d.createNodeAttachment && d.createNodeAttachment(e);
        })
        .forEach(function (d) {
          l.push(d);
        }),
      (this.nodeCache[e] = Promise.all(l).then(function (d) {
        let p;
        if (
          (s.isBone === !0
            ? (p = new Og())
            : d.length > 1
              ? (p = new jo())
              : d.length === 1
                ? (p = d[0])
                : (p = new _n()),
          p !== d[0])
        )
          for (let m = 0, y = d.length; m < y; m++) p.add(d[m]);
        if (
          (s.name && ((p.userData.name = s.name), (p.name = a)),
          Ho(p, s),
          s.extensions && uc(n, p, s),
          s.matrix !== void 0)
        ) {
          const m = new jt();
          m.fromArray(s.matrix), p.applyMatrix4(m);
        } else
          s.translation !== void 0 && p.position.fromArray(s.translation),
            s.rotation !== void 0 && p.quaternion.fromArray(s.rotation),
            s.scale !== void 0 && p.scale.fromArray(s.scale);
        return (
          i.associations.has(p) || i.associations.set(p, {}),
          (i.associations.get(p).nodes = e),
          p
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      s = new jo();
    n.name && (s.name = i.createUniqueName(n.name)),
      Ho(s, n),
      n.extensions && uc(t, s, n);
    const a = n.nodes || [],
      l = [];
    for (let c = 0, d = a.length; c < d; c++)
      l.push(i.getDependency("node", a[c]));
    return Promise.all(l).then(function (c) {
      for (let p = 0, m = c.length; p < m; p++) s.add(c[p]);
      const d = (p) => {
        const m = new Map();
        for (const [y, v] of i.associations)
          (y instanceof Dr || y instanceof Ln) && m.set(y, v);
        return (
          p.traverse((y) => {
            const v = i.associations.get(y);
            v != null && m.set(y, v);
          }),
          m
        );
      };
      return (i.associations = d(s)), s;
    });
  }
  _createAnimationTracks(e, t, n, i, s) {
    const a = [],
      l = e.name ? e.name : e.uuid,
      c = [];
    Ul[s.path] === Ul.weights
      ? e.traverse(function (y) {
          y.morphTargetInfluences && c.push(y.name ? y.name : y.uuid);
        })
      : c.push(l);
    let d;
    switch (Ul[s.path]) {
      case Ul.weights:
        d = Uc;
        break;
      case Ul.rotation:
        d = Oc;
        break;
      case Ul.position:
      case Ul.scale:
        d = kc;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            d = Uc;
            break;
          case 2:
          case 3:
          default:
            d = kc;
            break;
        }
        break;
    }
    const p = i.interpolation !== void 0 ? sO[i.interpolation] : gh,
      m = this._getArrayFromAccessor(n);
    for (let y = 0, v = c.length; y < v; y++) {
      const A = new d(c[y] + "." + Ul[s.path], t.array, m, p);
      i.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(A),
        a.push(A);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Ov(t.constructor),
        i = new Float32Array(t.length);
      for (let s = 0, a = t.length; s < a; s++) i[s] = t[s] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (t) {
      const n = this instanceof Oc ? iO : m6;
      return new n(this.times, this.values, this.getValueSize() / 3, t);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function fO(r, e, t) {
  const n = e.attributes,
    i = new Ti();
  if (n.POSITION !== void 0) {
    const l = t.json.accessors[n.POSITION],
      c = l.min,
      d = l.max;
    if (c !== void 0 && d !== void 0) {
      if (
        (i.set(new Y(c[0], c[1], c[2]), new Y(d[0], d[1], d[2])), l.normalized)
      ) {
        const p = Ov(lh[l.componentType]);
        i.min.multiplyScalar(p), i.max.multiplyScalar(p);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const l = new Y(),
      c = new Y();
    for (let d = 0, p = s.length; d < p; d++) {
      const m = s[d];
      if (m.POSITION !== void 0) {
        const y = t.json.accessors[m.POSITION],
          v = y.min,
          A = y.max;
        if (v !== void 0 && A !== void 0) {
          if (
            (c.setX(Math.max(Math.abs(v[0]), Math.abs(A[0]))),
            c.setY(Math.max(Math.abs(v[1]), Math.abs(A[1]))),
            c.setZ(Math.max(Math.abs(v[2]), Math.abs(A[2]))),
            y.normalized)
          ) {
            const M = Ov(lh[y.componentType]);
            c.multiplyScalar(M);
          }
          l.max(c);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
          );
      }
    }
    i.expandByVector(l);
  }
  r.boundingBox = i;
  const a = new ui();
  i.getCenter(a.center),
    (a.radius = i.min.distanceTo(i.max) / 2),
    (r.boundingSphere = a);
}
function lw(r, e, t) {
  const n = e.attributes,
    i = [];
  function s(a, l) {
    return t.getDependency("accessor", a).then(function (c) {
      r.setAttribute(l, c);
    });
  }
  for (const a in n) {
    const l = Uv[a] || a.toLowerCase();
    l in r.attributes || i.push(s(n[a], l));
  }
  if (e.indices !== void 0 && !r.index) {
    const a = t.getDependency("accessor", e.indices).then(function (l) {
      r.setIndex(l);
    });
    i.push(a);
  }
  return (
    Ho(r, e),
    fO(r, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? oO(r, e.targets, t) : r;
    })
  );
}
class pO extends nx {
  constructor(e) {
    super(e), (this.type = Kr);
  }
  parse(e) {
    const t = function (x, C) {
        switch (x) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (C || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (C || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (C || ""));
          default:
          case 4:
            throw new Error("THREE.RGBELoader: Memory Error: " + (C || ""));
        }
      },
      n = `
`,
      i = function (x, C, T) {
        C = C || 1024;
        let I = x.pos,
          U = -1,
          F = 0,
          O = "",
          z = String.fromCharCode.apply(
            null,
            new Uint16Array(x.subarray(I, I + 128)),
          );
        for (; 0 > (U = z.indexOf(n)) && F < C && I < x.byteLength; )
          (O += z),
            (F += z.length),
            (I += 128),
            (z += String.fromCharCode.apply(
              null,
              new Uint16Array(x.subarray(I, I + 128)),
            ));
        return -1 < U ? ((x.pos += F + U + 1), O + z.slice(0, U)) : !1;
      },
      s = function (x) {
        const C = /^#\?(\S+)/,
          T = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          I = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          U = /^\s*FORMAT=(\S+)\s*$/,
          F = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          O = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let z, L;
        for (
          (x.pos >= x.byteLength || !(z = i(x))) && t(1, "no header found"),
            (L = z.match(C)) || t(3, "bad initial token"),
            O.valid |= 1,
            O.programtype = L[1],
            O.string +=
              z +
              `
`;
          (z = i(x)), z !== !1;

        ) {
          if (
            ((O.string +=
              z +
              `
`),
            z.charAt(0) === "#")
          ) {
            O.comments +=
              z +
              `
`;
            continue;
          }
          if (
            ((L = z.match(T)) && (O.gamma = parseFloat(L[1])),
            (L = z.match(I)) && (O.exposure = parseFloat(L[1])),
            (L = z.match(U)) && ((O.valid |= 2), (O.format = L[1])),
            (L = z.match(F)) &&
              ((O.valid |= 4),
              (O.height = parseInt(L[1], 10)),
              (O.width = parseInt(L[2], 10))),
            O.valid & 2 && O.valid & 4)
          )
            break;
        }
        return (
          O.valid & 2 || t(3, "missing format specifier"),
          O.valid & 4 || t(3, "missing image size specifier"),
          O
        );
      },
      a = function (x, C, T) {
        const I = C;
        if (I < 8 || I > 32767 || x[0] !== 2 || x[1] !== 2 || x[2] & 128)
          return new Uint8Array(x);
        I !== ((x[2] << 8) | x[3]) && t(3, "wrong scanline width");
        const U = new Uint8Array(4 * C * T);
        U.length || t(4, "unable to allocate buffer space");
        let F = 0,
          O = 0;
        const z = 4 * I,
          L = new Uint8Array(4),
          N = new Uint8Array(z);
        let X = T;
        for (; X > 0 && O < x.byteLength; ) {
          O + 4 > x.byteLength && t(1),
            (L[0] = x[O++]),
            (L[1] = x[O++]),
            (L[2] = x[O++]),
            (L[3] = x[O++]),
            (L[0] != 2 || L[1] != 2 || ((L[2] << 8) | L[3]) != I) &&
              t(3, "bad rgbe scanline format");
          let ie = 0,
            re;
          for (; ie < z && O < x.byteLength; ) {
            re = x[O++];
            const _e = re > 128;
            if (
              (_e && (re -= 128),
              (re === 0 || ie + re > z) && t(3, "bad scanline data"),
              _e)
            ) {
              const ge = x[O++];
              for (let Re = 0; Re < re; Re++) N[ie++] = ge;
            } else N.set(x.subarray(O, O + re), ie), (ie += re), (O += re);
          }
          const me = I;
          for (let _e = 0; _e < me; _e++) {
            let ge = 0;
            (U[F] = N[_e + ge]),
              (ge += I),
              (U[F + 1] = N[_e + ge]),
              (ge += I),
              (U[F + 2] = N[_e + ge]),
              (ge += I),
              (U[F + 3] = N[_e + ge]),
              (F += 4);
          }
          X--;
        }
        return U;
      },
      l = function (x, C, T, I) {
        const U = x[C + 3],
          F = Math.pow(2, U - 128) / 255;
        (T[I + 0] = x[C + 0] * F),
          (T[I + 1] = x[C + 1] * F),
          (T[I + 2] = x[C + 2] * F),
          (T[I + 3] = 1);
      },
      c = function (x, C, T, I) {
        const U = x[C + 3],
          F = Math.pow(2, U - 128) / 255;
        (T[I + 0] = bc.toHalfFloat(Math.min(x[C + 0] * F, 65504))),
          (T[I + 1] = bc.toHalfFloat(Math.min(x[C + 1] * F, 65504))),
          (T[I + 2] = bc.toHalfFloat(Math.min(x[C + 2] * F, 65504))),
          (T[I + 3] = bc.toHalfFloat(1));
      },
      d = new Uint8Array(e);
    d.pos = 0;
    const p = s(d),
      m = p.width,
      y = p.height,
      v = a(d.subarray(d.pos), m, y);
    let A, M, w;
    switch (this.type) {
      case or:
        w = v.length / 4;
        const x = new Float32Array(w * 4);
        for (let T = 0; T < w; T++) l(v, T * 4, x, T * 4);
        (A = x), (M = or);
        break;
      case Kr:
        w = v.length / 4;
        const C = new Uint16Array(w * 4);
        for (let T = 0; T < w; T++) c(v, T * 4, C, T * 4);
        (A = C), (M = Kr);
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: m,
      height: y,
      data: A,
      header: p.string,
      gamma: p.gamma,
      exposure: p.exposure,
      type: M,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function s(a, l) {
      switch (a.type) {
        case or:
        case Kr:
          "colorSpace" in a
            ? (a.colorSpace = "srgb-linear")
            : (a.encoding = 3e3),
            (a.minFilter = Un),
            (a.magFilter = Un),
            (a.generateMipmaps = !1),
            (a.flipY = !0);
          break;
      }
      t && t(a, l);
    }
    return super.load(e, s, n, i);
  }
}
const Jf = "colorSpace" in new Ln();
class mO extends nx {
  constructor(e) {
    super(e), (this.type = Kr);
  }
  parse(e) {
    const t = Math.pow(2.7182818, 2.2);
    function n(D, W) {
      for (var k = 0, ne = 0; ne < 65536; ++ne)
        (ne == 0 || D[ne >> 3] & (1 << (ne & 7))) && (W[k++] = ne);
      for (var Q = k - 1; k < 65536; ) W[k++] = 0;
      return Q;
    }
    function i(D) {
      for (var W = 0; W < 16384; W++)
        (D[W] = {}), (D[W].len = 0), (D[W].lit = 0), (D[W].p = null);
    }
    const s = { l: 0, c: 0, lc: 0 };
    function a(D, W, k, ne, Q) {
      for (; k < D; ) (W = (W << 8) | Te(ne, Q)), (k += 8);
      (k -= D), (s.l = (W >> k) & ((1 << D) - 1)), (s.c = W), (s.lc = k);
    }
    const l = new Array(59);
    function c(D) {
      for (var W = 0; W <= 58; ++W) l[W] = 0;
      for (var W = 0; W < 65537; ++W) l[D[W]] += 1;
      for (var k = 0, W = 58; W > 0; --W) {
        var ne = (k + l[W]) >> 1;
        (l[W] = k), (k = ne);
      }
      for (var W = 0; W < 65537; ++W) {
        var Q = D[W];
        Q > 0 && (D[W] = Q | (l[Q]++ << 6));
      }
    }
    function d(D, W, k, ne, Q, te, Ae) {
      for (var pe = k, Ve = 0, He = 0; Q <= te; Q++) {
        if (pe.value - k.value > ne) return !1;
        a(6, Ve, He, D, pe);
        var Qe = s.l;
        if (((Ve = s.c), (He = s.lc), (Ae[Q] = Qe), Qe == 63)) {
          if (pe.value - k.value > ne)
            throw "Something wrong with hufUnpackEncTable";
          a(8, Ve, He, D, pe);
          var ke = s.l + 6;
          if (((Ve = s.c), (He = s.lc), Q + ke > te + 1))
            throw "Something wrong with hufUnpackEncTable";
          for (; ke--; ) Ae[Q++] = 0;
          Q--;
        } else if (Qe >= 59) {
          var ke = Qe - 59 + 2;
          if (Q + ke > te + 1) throw "Something wrong with hufUnpackEncTable";
          for (; ke--; ) Ae[Q++] = 0;
          Q--;
        }
      }
      c(Ae);
    }
    function p(D) {
      return D & 63;
    }
    function m(D) {
      return D >> 6;
    }
    function y(D, W, k, ne) {
      for (; W <= k; W++) {
        var Q = m(D[W]),
          te = p(D[W]);
        if (Q >> te) throw "Invalid table entry";
        if (te > 14) {
          var Ae = ne[Q >> (te - 14)];
          if (Ae.len) throw "Invalid table entry";
          if ((Ae.lit++, Ae.p)) {
            var pe = Ae.p;
            Ae.p = new Array(Ae.lit);
            for (var Ve = 0; Ve < Ae.lit - 1; ++Ve) Ae.p[Ve] = pe[Ve];
          } else Ae.p = new Array(1);
          Ae.p[Ae.lit - 1] = W;
        } else if (te)
          for (var He = 0, Ve = 1 << (14 - te); Ve > 0; Ve--) {
            var Ae = ne[(Q << (14 - te)) + He];
            if (Ae.len || Ae.p) throw "Invalid table entry";
            (Ae.len = te), (Ae.lit = W), He++;
          }
      }
      return !0;
    }
    const v = { c: 0, lc: 0 };
    function A(D, W, k, ne) {
      (D = (D << 8) | Te(k, ne)), (W += 8), (v.c = D), (v.lc = W);
    }
    const M = { c: 0, lc: 0 };
    function w(D, W, k, ne, Q, te, Ae, pe, Ve, He) {
      if (D == W) {
        ne < 8 && (A(k, ne, Q, Ae), (k = v.c), (ne = v.lc)), (ne -= 8);
        var Qe = k >> ne,
          Qe = new Uint8Array([Qe])[0];
        if (Ve.value + Qe > He) return !1;
        for (var ke = pe[Ve.value - 1]; Qe-- > 0; ) pe[Ve.value++] = ke;
      } else if (Ve.value < He) pe[Ve.value++] = D;
      else return !1;
      (M.c = k), (M.lc = ne);
    }
    function x(D) {
      return D & 65535;
    }
    function C(D) {
      var W = x(D);
      return W > 32767 ? W - 65536 : W;
    }
    const T = { a: 0, b: 0 };
    function I(D, W) {
      var k = C(D),
        ne = C(W),
        Q = ne,
        te = k + (Q & 1) + (Q >> 1),
        Ae = te,
        pe = te - Q;
      (T.a = Ae), (T.b = pe);
    }
    function U(D, W) {
      var k = x(D),
        ne = x(W),
        Q = (k - (ne >> 1)) & 65535,
        te = (ne + Q - 32768) & 65535;
      (T.a = te), (T.b = Q);
    }
    function F(D, W, k, ne, Q, te, Ae) {
      for (var pe = Ae < 16384, Ve = k > Q ? Q : k, He = 1, Qe; He <= Ve; )
        He <<= 1;
      for (He >>= 1, Qe = He, He >>= 1; He >= 1; ) {
        for (
          var ke = 0,
            nn = ke + te * (Q - Qe),
            vt = te * He,
            It = te * Qe,
            Ht = ne * He,
            Wt = ne * Qe,
            dn,
            An,
            mn,
            Wn;
          ke <= nn;
          ke += It
        ) {
          for (var wn = ke, Fr = ke + ne * (k - Qe); wn <= Fr; wn += Wt) {
            var lr = wn + Ht,
              Dn = wn + vt,
              hi = Dn + Ht;
            pe
              ? (I(D[wn + W], D[Dn + W]),
                (dn = T.a),
                (mn = T.b),
                I(D[lr + W], D[hi + W]),
                (An = T.a),
                (Wn = T.b),
                I(dn, An),
                (D[wn + W] = T.a),
                (D[lr + W] = T.b),
                I(mn, Wn),
                (D[Dn + W] = T.a),
                (D[hi + W] = T.b))
              : (U(D[wn + W], D[Dn + W]),
                (dn = T.a),
                (mn = T.b),
                U(D[lr + W], D[hi + W]),
                (An = T.a),
                (Wn = T.b),
                U(dn, An),
                (D[wn + W] = T.a),
                (D[lr + W] = T.b),
                U(mn, Wn),
                (D[Dn + W] = T.a),
                (D[hi + W] = T.b));
          }
          if (k & He) {
            var Dn = wn + vt;
            pe ? I(D[wn + W], D[Dn + W]) : U(D[wn + W], D[Dn + W]),
              (dn = T.a),
              (D[Dn + W] = T.b),
              (D[wn + W] = dn);
          }
        }
        if (Q & He)
          for (var wn = ke, Fr = ke + ne * (k - Qe); wn <= Fr; wn += Wt) {
            var lr = wn + Ht;
            pe ? I(D[wn + W], D[lr + W]) : U(D[wn + W], D[lr + W]),
              (dn = T.a),
              (D[lr + W] = T.b),
              (D[wn + W] = dn);
          }
        (Qe = He), (He >>= 1);
      }
      return ke;
    }
    function O(D, W, k, ne, Q, te, Ae, pe, Ve, He) {
      for (
        var Qe = 0, ke = 0, nn = pe, vt = Math.trunc(Q.value + (te + 7) / 8);
        Q.value < vt;

      )
        for (A(Qe, ke, k, Q), Qe = v.c, ke = v.lc; ke >= 14; ) {
          var It = (Qe >> (ke - 14)) & 16383,
            Ht = W[It];
          if (Ht.len)
            (ke -= Ht.len),
              w(Ht.lit, Ae, Qe, ke, k, ne, Q, Ve, He, nn),
              (Qe = M.c),
              (ke = M.lc);
          else {
            if (!Ht.p) throw "hufDecode issues";
            var Wt;
            for (Wt = 0; Wt < Ht.lit; Wt++) {
              for (var dn = p(D[Ht.p[Wt]]); ke < dn && Q.value < vt; )
                A(Qe, ke, k, Q), (Qe = v.c), (ke = v.lc);
              if (
                ke >= dn &&
                m(D[Ht.p[Wt]]) == ((Qe >> (ke - dn)) & ((1 << dn) - 1))
              ) {
                (ke -= dn),
                  w(Ht.p[Wt], Ae, Qe, ke, k, ne, Q, Ve, He, nn),
                  (Qe = M.c),
                  (ke = M.lc);
                break;
              }
            }
            if (Wt == Ht.lit) throw "hufDecode issues";
          }
        }
      var An = (8 - te) & 7;
      for (Qe >>= An, ke -= An; ke > 0; ) {
        var Ht = W[(Qe << (14 - ke)) & 16383];
        if (Ht.len)
          (ke -= Ht.len),
            w(Ht.lit, Ae, Qe, ke, k, ne, Q, Ve, He, nn),
            (Qe = M.c),
            (ke = M.lc);
        else throw "hufDecode issues";
      }
      return !0;
    }
    function z(D, W, k, ne, Q, te) {
      var Ae = { value: 0 },
        pe = k.value,
        Ve = be(W, k),
        He = be(W, k);
      k.value += 4;
      var Qe = be(W, k);
      if (((k.value += 4), Ve < 0 || Ve >= 65537 || He < 0 || He >= 65537))
        throw "Something wrong with HUF_ENCSIZE";
      var ke = new Array(65537),
        nn = new Array(16384);
      i(nn);
      var vt = ne - (k.value - pe);
      if ((d(D, W, k, vt, Ve, He, ke), Qe > 8 * (ne - (k.value - pe))))
        throw "Something wrong with hufUncompress";
      y(ke, Ve, He, nn), O(ke, nn, D, W, k, Qe, He, te, Q, Ae);
    }
    function L(D, W, k) {
      for (var ne = 0; ne < k; ++ne) W[ne] = D[W[ne]];
    }
    function N(D) {
      for (var W = 1; W < D.length; W++) {
        var k = D[W - 1] + D[W] - 128;
        D[W] = k;
      }
    }
    function X(D, W) {
      for (
        var k = 0,
          ne = Math.floor((D.length + 1) / 2),
          Q = 0,
          te = D.length - 1;
        !(Q > te || ((W[Q++] = D[k++]), Q > te));

      )
        W[Q++] = D[ne++];
    }
    function ie(D) {
      for (
        var W = D.byteLength, k = new Array(), ne = 0, Q = new DataView(D);
        W > 0;

      ) {
        var te = Q.getInt8(ne++);
        if (te < 0) {
          var Ae = -te;
          W -= Ae + 1;
          for (var pe = 0; pe < Ae; pe++) k.push(Q.getUint8(ne++));
        } else {
          var Ae = te;
          W -= 2;
          for (var Ve = Q.getUint8(ne++), pe = 0; pe < Ae + 1; pe++) k.push(Ve);
        }
      }
      return k;
    }
    function re(D, W, k, ne, Q, te) {
      var Ae = new DataView(te.buffer),
        pe = k[D.idx[0]].width,
        Ve = k[D.idx[0]].height,
        He = 3,
        Qe = Math.floor(pe / 8),
        ke = Math.ceil(pe / 8),
        nn = Math.ceil(Ve / 8),
        vt = pe - (ke - 1) * 8,
        It = Ve - (nn - 1) * 8,
        Ht = { value: 0 },
        Wt = new Array(He),
        dn = new Array(He),
        An = new Array(He),
        mn = new Array(He),
        Wn = new Array(He);
      for (let Fn = 0; Fn < He; ++Fn)
        (Wn[Fn] = W[D.idx[Fn]]),
          (Wt[Fn] = Fn < 1 ? 0 : Wt[Fn - 1] + ke * nn),
          (dn[Fn] = new Float32Array(64)),
          (An[Fn] = new Uint16Array(64)),
          (mn[Fn] = new Uint16Array(ke * 64));
      for (let Fn = 0; Fn < nn; ++Fn) {
        var wn = 8;
        Fn == nn - 1 && (wn = It);
        var Fr = 8;
        for (let j = 0; j < ke; ++j) {
          j == ke - 1 && (Fr = vt);
          for (let le = 0; le < He; ++le)
            An[le].fill(0),
              (An[le][0] = Q[Wt[le]++]),
              me(Ht, ne, An[le]),
              _e(An[le], dn[le]),
              ge(dn[le]);
          Re(dn);
          for (let le = 0; le < He; ++le) J(dn[le], mn[le], j * 64);
        }
        let Zn = 0;
        for (let j = 0; j < He; ++j) {
          const le = k[D.idx[j]].type;
          for (let Me = 8 * Fn; Me < 8 * Fn + wn; ++Me) {
            Zn = Wn[j][Me];
            for (let Ee = 0; Ee < Qe; ++Ee) {
              const se = Ee * 64 + (Me & 7) * 8;
              Ae.setUint16(Zn + 0 * 2 * le, mn[j][se + 0], !0),
                Ae.setUint16(Zn + 1 * 2 * le, mn[j][se + 1], !0),
                Ae.setUint16(Zn + 2 * 2 * le, mn[j][se + 2], !0),
                Ae.setUint16(Zn + 3 * 2 * le, mn[j][se + 3], !0),
                Ae.setUint16(Zn + 4 * 2 * le, mn[j][se + 4], !0),
                Ae.setUint16(Zn + 5 * 2 * le, mn[j][se + 5], !0),
                Ae.setUint16(Zn + 6 * 2 * le, mn[j][se + 6], !0),
                Ae.setUint16(Zn + 7 * 2 * le, mn[j][se + 7], !0),
                (Zn += 8 * 2 * le);
            }
          }
          if (Qe != ke)
            for (let Me = 8 * Fn; Me < 8 * Fn + wn; ++Me) {
              const Ee = Wn[j][Me] + 8 * Qe * 2 * le,
                se = Qe * 64 + (Me & 7) * 8;
              for (let Ge = 0; Ge < Fr; ++Ge)
                Ae.setUint16(Ee + Ge * 2 * le, mn[j][se + Ge], !0);
            }
        }
      }
      for (
        var lr = new Uint16Array(pe), Ae = new DataView(te.buffer), Dn = 0;
        Dn < He;
        ++Dn
      ) {
        k[D.idx[Dn]].decoded = !0;
        var hi = k[D.idx[Dn]].type;
        if (k[Dn].type == 2)
          for (var ps = 0; ps < Ve; ++ps) {
            const Zn = Wn[Dn][ps];
            for (var jr = 0; jr < pe; ++jr)
              lr[jr] = Ae.getUint16(Zn + jr * 2 * hi, !0);
            for (var jr = 0; jr < pe; ++jr)
              Ae.setFloat32(Zn + jr * 2 * hi, Be(lr[jr]), !0);
          }
      }
    }
    function me(D, W, k) {
      for (var ne, Q = 1; Q < 64; )
        (ne = W[D.value]),
          ne == 65280
            ? (Q = 64)
            : ne >> 8 == 255
              ? (Q += ne & 255)
              : ((k[Q] = ne), Q++),
          D.value++;
    }
    function _e(D, W) {
      (W[0] = Be(D[0])),
        (W[1] = Be(D[1])),
        (W[2] = Be(D[5])),
        (W[3] = Be(D[6])),
        (W[4] = Be(D[14])),
        (W[5] = Be(D[15])),
        (W[6] = Be(D[27])),
        (W[7] = Be(D[28])),
        (W[8] = Be(D[2])),
        (W[9] = Be(D[4])),
        (W[10] = Be(D[7])),
        (W[11] = Be(D[13])),
        (W[12] = Be(D[16])),
        (W[13] = Be(D[26])),
        (W[14] = Be(D[29])),
        (W[15] = Be(D[42])),
        (W[16] = Be(D[3])),
        (W[17] = Be(D[8])),
        (W[18] = Be(D[12])),
        (W[19] = Be(D[17])),
        (W[20] = Be(D[25])),
        (W[21] = Be(D[30])),
        (W[22] = Be(D[41])),
        (W[23] = Be(D[43])),
        (W[24] = Be(D[9])),
        (W[25] = Be(D[11])),
        (W[26] = Be(D[18])),
        (W[27] = Be(D[24])),
        (W[28] = Be(D[31])),
        (W[29] = Be(D[40])),
        (W[30] = Be(D[44])),
        (W[31] = Be(D[53])),
        (W[32] = Be(D[10])),
        (W[33] = Be(D[19])),
        (W[34] = Be(D[23])),
        (W[35] = Be(D[32])),
        (W[36] = Be(D[39])),
        (W[37] = Be(D[45])),
        (W[38] = Be(D[52])),
        (W[39] = Be(D[54])),
        (W[40] = Be(D[20])),
        (W[41] = Be(D[22])),
        (W[42] = Be(D[33])),
        (W[43] = Be(D[38])),
        (W[44] = Be(D[46])),
        (W[45] = Be(D[51])),
        (W[46] = Be(D[55])),
        (W[47] = Be(D[60])),
        (W[48] = Be(D[21])),
        (W[49] = Be(D[34])),
        (W[50] = Be(D[37])),
        (W[51] = Be(D[47])),
        (W[52] = Be(D[50])),
        (W[53] = Be(D[56])),
        (W[54] = Be(D[59])),
        (W[55] = Be(D[61])),
        (W[56] = Be(D[35])),
        (W[57] = Be(D[36])),
        (W[58] = Be(D[48])),
        (W[59] = Be(D[49])),
        (W[60] = Be(D[57])),
        (W[61] = Be(D[58])),
        (W[62] = Be(D[62])),
        (W[63] = Be(D[63]));
    }
    function ge(D) {
      const W = 0.5 * Math.cos(0.7853975),
        k = 0.5 * Math.cos(3.14159 / 16),
        ne = 0.5 * Math.cos(3.14159 / 8),
        Q = 0.5 * Math.cos((3 * 3.14159) / 16),
        te = 0.5 * Math.cos((5 * 3.14159) / 16),
        Ae = 0.5 * Math.cos((3 * 3.14159) / 8),
        pe = 0.5 * Math.cos((7 * 3.14159) / 16);
      for (
        var Ve = new Array(4),
          He = new Array(4),
          Qe = new Array(4),
          ke = new Array(4),
          nn = 0;
        nn < 8;
        ++nn
      ) {
        var vt = nn * 8;
        (Ve[0] = ne * D[vt + 2]),
          (Ve[1] = Ae * D[vt + 2]),
          (Ve[2] = ne * D[vt + 6]),
          (Ve[3] = Ae * D[vt + 6]),
          (He[0] =
            k * D[vt + 1] + Q * D[vt + 3] + te * D[vt + 5] + pe * D[vt + 7]),
          (He[1] =
            Q * D[vt + 1] - pe * D[vt + 3] - k * D[vt + 5] - te * D[vt + 7]),
          (He[2] =
            te * D[vt + 1] - k * D[vt + 3] + pe * D[vt + 5] + Q * D[vt + 7]),
          (He[3] =
            pe * D[vt + 1] - te * D[vt + 3] + Q * D[vt + 5] - k * D[vt + 7]),
          (Qe[0] = W * (D[vt + 0] + D[vt + 4])),
          (Qe[3] = W * (D[vt + 0] - D[vt + 4])),
          (Qe[1] = Ve[0] + Ve[3]),
          (Qe[2] = Ve[1] - Ve[2]),
          (ke[0] = Qe[0] + Qe[1]),
          (ke[1] = Qe[3] + Qe[2]),
          (ke[2] = Qe[3] - Qe[2]),
          (ke[3] = Qe[0] - Qe[1]),
          (D[vt + 0] = ke[0] + He[0]),
          (D[vt + 1] = ke[1] + He[1]),
          (D[vt + 2] = ke[2] + He[2]),
          (D[vt + 3] = ke[3] + He[3]),
          (D[vt + 4] = ke[3] - He[3]),
          (D[vt + 5] = ke[2] - He[2]),
          (D[vt + 6] = ke[1] - He[1]),
          (D[vt + 7] = ke[0] - He[0]);
      }
      for (var It = 0; It < 8; ++It)
        (Ve[0] = ne * D[16 + It]),
          (Ve[1] = Ae * D[16 + It]),
          (Ve[2] = ne * D[48 + It]),
          (Ve[3] = Ae * D[48 + It]),
          (He[0] =
            k * D[8 + It] + Q * D[24 + It] + te * D[40 + It] + pe * D[56 + It]),
          (He[1] =
            Q * D[8 + It] - pe * D[24 + It] - k * D[40 + It] - te * D[56 + It]),
          (He[2] =
            te * D[8 + It] - k * D[24 + It] + pe * D[40 + It] + Q * D[56 + It]),
          (He[3] =
            pe * D[8 + It] - te * D[24 + It] + Q * D[40 + It] - k * D[56 + It]),
          (Qe[0] = W * (D[It] + D[32 + It])),
          (Qe[3] = W * (D[It] - D[32 + It])),
          (Qe[1] = Ve[0] + Ve[3]),
          (Qe[2] = Ve[1] - Ve[2]),
          (ke[0] = Qe[0] + Qe[1]),
          (ke[1] = Qe[3] + Qe[2]),
          (ke[2] = Qe[3] - Qe[2]),
          (ke[3] = Qe[0] - Qe[1]),
          (D[0 + It] = ke[0] + He[0]),
          (D[8 + It] = ke[1] + He[1]),
          (D[16 + It] = ke[2] + He[2]),
          (D[24 + It] = ke[3] + He[3]),
          (D[32 + It] = ke[3] - He[3]),
          (D[40 + It] = ke[2] - He[2]),
          (D[48 + It] = ke[1] - He[1]),
          (D[56 + It] = ke[0] - He[0]);
    }
    function Re(D) {
      for (var W = 0; W < 64; ++W) {
        var k = D[0][W],
          ne = D[1][W],
          Q = D[2][W];
        (D[0][W] = k + 1.5747 * Q),
          (D[1][W] = k - 0.1873 * ne - 0.4682 * Q),
          (D[2][W] = k + 1.8556 * ne);
      }
    }
    function J(D, W, k) {
      for (var ne = 0; ne < 64; ++ne) W[k + ne] = bc.toHalfFloat(oe(D[ne]));
    }
    function oe(D) {
      return D <= 1
        ? Math.sign(D) * Math.pow(Math.abs(D), 2.2)
        : Math.sign(D) * Math.pow(t, Math.abs(D) - 1);
    }
    function ae(D) {
      return new DataView(D.array.buffer, D.offset.value, D.size);
    }
    function q(D) {
      var W = D.viewer.buffer.slice(D.offset.value, D.offset.value + D.size),
        k = new Uint8Array(ie(W)),
        ne = new Uint8Array(k.length);
      return N(k), X(k, ne), new DataView(ne.buffer);
    }
    function ce(D) {
      var W = D.array.slice(D.offset.value, D.offset.value + D.size),
        k = l0(W),
        ne = new Uint8Array(k.length);
      return N(k), X(k, ne), new DataView(ne.buffer);
    }
    function Xe(D) {
      for (
        var W = D.viewer,
          k = { value: D.offset.value },
          ne = new Uint16Array(
            D.width * D.scanlineBlockSize * (D.channels * D.type),
          ),
          Q = new Uint8Array(8192),
          te = 0,
          Ae = new Array(D.channels),
          pe = 0;
        pe < D.channels;
        pe++
      )
        (Ae[pe] = {}),
          (Ae[pe].start = te),
          (Ae[pe].end = Ae[pe].start),
          (Ae[pe].nx = D.width),
          (Ae[pe].ny = D.lines),
          (Ae[pe].size = D.type),
          (te += Ae[pe].nx * Ae[pe].ny * Ae[pe].size);
      var Ve = nt(W, k),
        He = nt(W, k);
      if (He >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (Ve <= He)
        for (var pe = 0; pe < He - Ve + 1; pe++) Q[pe + Ve] = Ne(W, k);
      var Qe = new Uint16Array(65536),
        ke = n(Q, Qe),
        nn = be(W, k);
      z(D.array, W, k, nn, ne, te);
      for (var pe = 0; pe < D.channels; ++pe)
        for (var vt = Ae[pe], It = 0; It < Ae[pe].size; ++It)
          F(ne, vt.start + It, vt.nx, vt.size, vt.ny, vt.nx * vt.size, ke);
      L(Qe, ne, te);
      for (
        var Ht = 0, Wt = new Uint8Array(ne.buffer.byteLength), dn = 0;
        dn < D.lines;
        dn++
      )
        for (var An = 0; An < D.channels; An++) {
          var vt = Ae[An],
            mn = vt.nx * vt.size,
            Wn = new Uint8Array(ne.buffer, vt.end * 2, mn * 2);
          Wt.set(Wn, Ht), (Ht += mn * 2), (vt.end += mn);
        }
      return new DataView(Wt.buffer);
    }
    function ye(D) {
      var W = D.array.slice(D.offset.value, D.offset.value + D.size),
        k = l0(W);
      const ne = D.lines * D.channels * D.width,
        Q = D.type == 1 ? new Uint16Array(ne) : new Uint32Array(ne);
      let te = 0,
        Ae = 0;
      const pe = new Array(4);
      for (let Ve = 0; Ve < D.lines; Ve++)
        for (let He = 0; He < D.channels; He++) {
          let Qe = 0;
          switch (D.type) {
            case 1:
              (pe[0] = te), (pe[1] = pe[0] + D.width), (te = pe[1] + D.width);
              for (let ke = 0; ke < D.width; ++ke) {
                const nn = (k[pe[0]++] << 8) | k[pe[1]++];
                (Qe += nn), (Q[Ae] = Qe), Ae++;
              }
              break;
            case 2:
              (pe[0] = te),
                (pe[1] = pe[0] + D.width),
                (pe[2] = pe[1] + D.width),
                (te = pe[2] + D.width);
              for (let ke = 0; ke < D.width; ++ke) {
                const nn =
                  (k[pe[0]++] << 24) | (k[pe[1]++] << 16) | (k[pe[2]++] << 8);
                (Qe += nn), (Q[Ae] = Qe), Ae++;
              }
              break;
          }
        }
      return new DataView(Q.buffer);
    }
    function Pe(D) {
      var W = D.viewer,
        k = { value: D.offset.value },
        ne = new Uint8Array(D.width * D.lines * (D.channels * D.type * 2)),
        Q = {
          version: K(W, k),
          unknownUncompressedSize: K(W, k),
          unknownCompressedSize: K(W, k),
          acCompressedSize: K(W, k),
          dcCompressedSize: K(W, k),
          rleCompressedSize: K(W, k),
          rleUncompressedSize: K(W, k),
          rleRawSize: K(W, k),
          totalAcUncompressedCount: K(W, k),
          totalDcUncompressedCount: K(W, k),
          acCompression: K(W, k),
        };
      if (Q.version < 2)
        throw (
          "EXRLoader.parse: " +
          Tt.compression +
          " version " +
          Q.version +
          " is unsupported"
        );
      for (var te = new Array(), Ae = nt(W, k) - 2; Ae > 0; ) {
        var pe = Ue(W.buffer, k),
          Ve = Ne(W, k),
          He = (Ve >> 2) & 3,
          Qe = (Ve >> 4) - 1,
          ke = new Int8Array([Qe])[0],
          nn = Ne(W, k);
        te.push({ name: pe, index: ke, type: nn, compression: He }),
          (Ae -= pe.length + 3);
      }
      for (
        var vt = Tt.channels, It = new Array(D.channels), Ht = 0;
        Ht < D.channels;
        ++Ht
      ) {
        var Wt = (It[Ht] = {}),
          dn = vt[Ht];
        (Wt.name = dn.name),
          (Wt.compression = 0),
          (Wt.decoded = !1),
          (Wt.type = dn.pixelType),
          (Wt.pLinear = dn.pLinear),
          (Wt.width = D.width),
          (Wt.height = D.lines);
      }
      for (var An = { idx: new Array(3) }, mn = 0; mn < D.channels; ++mn)
        for (var Wt = It[mn], Ht = 0; Ht < te.length; ++Ht) {
          var Wn = te[Ht];
          Wt.name == Wn.name &&
            ((Wt.compression = Wn.compression),
            Wn.index >= 0 && (An.idx[Wn.index] = mn),
            (Wt.offset = mn));
        }
      if (Q.acCompressedSize > 0)
        switch (Q.acCompression) {
          case 0:
            var lr = new Uint16Array(Q.totalAcUncompressedCount);
            z(
              D.array,
              W,
              k,
              Q.acCompressedSize,
              lr,
              Q.totalAcUncompressedCount,
            );
            break;
          case 1:
            var wn = D.array.slice(
                k.value,
                k.value + Q.totalAcUncompressedCount,
              ),
              Fr = l0(wn),
              lr = new Uint16Array(Fr.buffer);
            k.value += Q.totalAcUncompressedCount;
            break;
        }
      if (Q.dcCompressedSize > 0) {
        var Dn = { array: D.array, offset: k, size: Q.dcCompressedSize },
          hi = new Uint16Array(ce(Dn).buffer);
        k.value += Q.dcCompressedSize;
      }
      if (Q.rleRawSize > 0) {
        var wn = D.array.slice(k.value, k.value + Q.rleCompressedSize),
          Fr = l0(wn),
          ps = ie(Fr.buffer);
        k.value += Q.rleCompressedSize;
      }
      for (var jr = 0, Fn = new Array(It.length), Ht = 0; Ht < Fn.length; ++Ht)
        Fn[Ht] = new Array();
      for (var Zn = 0; Zn < D.lines; ++Zn)
        for (var j = 0; j < It.length; ++j)
          Fn[j].push(jr), (jr += It[j].width * D.type * 2);
      re(An, Fn, It, lr, hi, ne);
      for (var Ht = 0; Ht < It.length; ++Ht) {
        var Wt = It[Ht];
        if (!Wt.decoded)
          switch (Wt.compression) {
            case 2:
              for (var le = 0, Me = 0, Zn = 0; Zn < D.lines; ++Zn) {
                for (var Ee = Fn[Ht][le], se = 0; se < Wt.width; ++se) {
                  for (var Ge = 0; Ge < 2 * Wt.type; ++Ge)
                    ne[Ee++] = ps[Me + Ge * Wt.width * Wt.height];
                  Me++;
                }
                le++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(ne.buffer);
    }
    function Ue(D, W) {
      for (var k = new Uint8Array(D), ne = 0; k[W.value + ne] != 0; ) ne += 1;
      var Q = new TextDecoder().decode(k.slice(W.value, W.value + ne));
      return (W.value = W.value + ne + 1), Q;
    }
    function Fe(D, W, k) {
      var ne = new TextDecoder().decode(
        new Uint8Array(D).slice(W.value, W.value + k),
      );
      return (W.value = W.value + k), ne;
    }
    function Je(D, W) {
      var k = tt(D, W),
        ne = be(D, W);
      return [k, ne];
    }
    function et(D, W) {
      var k = be(D, W),
        ne = be(D, W);
      return [k, ne];
    }
    function tt(D, W) {
      var k = D.getInt32(W.value, !0);
      return (W.value = W.value + 4), k;
    }
    function be(D, W) {
      var k = D.getUint32(W.value, !0);
      return (W.value = W.value + 4), k;
    }
    function Te(D, W) {
      var k = D[W.value];
      return (W.value = W.value + 1), k;
    }
    function Ne(D, W) {
      var k = D.getUint8(W.value);
      return (W.value = W.value + 1), k;
    }
    const K = function (D, W) {
      let k;
      return (
        "getBigInt64" in DataView.prototype
          ? (k = Number(D.getBigInt64(W.value, !0)))
          : (k =
              D.getUint32(W.value + 4, !0) +
              Number(D.getUint32(W.value, !0) << 32)),
        (W.value += 8),
        k
      );
    };
    function qe(D, W) {
      var k = D.getFloat32(W.value, !0);
      return (W.value += 4), k;
    }
    function ct(D, W) {
      return bc.toHalfFloat(qe(D, W));
    }
    function Be(D) {
      var W = (D & 31744) >> 10,
        k = D & 1023;
      return (
        (D >> 15 ? -1 : 1) *
        (W
          ? W === 31
            ? k
              ? NaN
              : 1 / 0
            : Math.pow(2, W - 15) * (1 + k / 1024)
          : 6103515625e-14 * (k / 1024))
      );
    }
    function nt(D, W) {
      var k = D.getUint16(W.value, !0);
      return (W.value += 2), k;
    }
    function Dt(D, W) {
      return Be(nt(D, W));
    }
    function it(D, W, k, ne) {
      for (var Q = k.value, te = []; k.value < Q + ne - 1; ) {
        var Ae = Ue(W, k),
          pe = tt(D, k),
          Ve = Ne(D, k);
        k.value += 3;
        var He = tt(D, k),
          Qe = tt(D, k);
        te.push({
          name: Ae,
          pixelType: pe,
          pLinear: Ve,
          xSampling: He,
          ySampling: Qe,
        });
      }
      return (k.value += 1), te;
    }
    function Z(D, W) {
      var k = qe(D, W),
        ne = qe(D, W),
        Q = qe(D, W),
        te = qe(D, W),
        Ae = qe(D, W),
        pe = qe(D, W),
        Ve = qe(D, W),
        He = qe(D, W);
      return {
        redX: k,
        redY: ne,
        greenX: Q,
        greenY: te,
        blueX: Ae,
        blueY: pe,
        whiteX: Ve,
        whiteY: He,
      };
    }
    function G(D, W) {
      var k = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        ne = Ne(D, W);
      return k[ne];
    }
    function xe(D, W) {
      var k = be(D, W),
        ne = be(D, W),
        Q = be(D, W),
        te = be(D, W);
      return { xMin: k, yMin: ne, xMax: Q, yMax: te };
    }
    function ze(D, W) {
      var k = ["INCREASING_Y"],
        ne = Ne(D, W);
      return k[ne];
    }
    function We(D, W) {
      var k = qe(D, W),
        ne = qe(D, W);
      return [k, ne];
    }
    function Oe(D, W) {
      var k = qe(D, W),
        ne = qe(D, W),
        Q = qe(D, W);
      return [k, ne, Q];
    }
    function Mt(D, W, k, ne, Q) {
      if (ne === "string" || ne === "stringvector" || ne === "iccProfile")
        return Fe(W, k, Q);
      if (ne === "chlist") return it(D, W, k, Q);
      if (ne === "chromaticities") return Z(D, k);
      if (ne === "compression") return G(D, k);
      if (ne === "box2i") return xe(D, k);
      if (ne === "lineOrder") return ze(D, k);
      if (ne === "float") return qe(D, k);
      if (ne === "v2f") return We(D, k);
      if (ne === "v3f") return Oe(D, k);
      if (ne === "int") return tt(D, k);
      if (ne === "rational") return Je(D, k);
      if (ne === "timecode") return et(D, k);
      if (ne === "preview") return (k.value += Q), "skipped";
      k.value += Q;
    }
    function ot(D, W, k) {
      const ne = {};
      if (D.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      ne.version = D.getUint8(4);
      const Q = D.getUint8(5);
      (ne.spec = {
        singleTile: !!(Q & 2),
        longName: !!(Q & 4),
        deepFormat: !!(Q & 8),
        multiPart: !!(Q & 16),
      }),
        (k.value = 8);
      for (var te = !0; te; ) {
        var Ae = Ue(W, k);
        if (Ae == 0) te = !1;
        else {
          var pe = Ue(W, k),
            Ve = be(D, k),
            He = Mt(D, W, k, pe, Ve);
          He === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${pe}'.`,
              )
            : (ne[Ae] = He);
        }
      }
      if (Q & -5)
        throw (
          (console.error("EXRHeader:", ne),
          "THREE.EXRLoader: provided file is currently unsupported.")
        );
      return ne;
    }
    function ft(D, W, k, ne, Q) {
      const te = {
        size: 0,
        viewer: W,
        array: k,
        offset: ne,
        width: D.dataWindow.xMax - D.dataWindow.xMin + 1,
        height: D.dataWindow.yMax - D.dataWindow.yMin + 1,
        channels: D.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: D.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [Jf ? "colorSpace" : "encoding"]: null,
      };
      switch (D.compression) {
        case "NO_COMPRESSION":
          (te.lines = 1), (te.uncompress = ae);
          break;
        case "RLE_COMPRESSION":
          (te.lines = 1), (te.uncompress = q);
          break;
        case "ZIPS_COMPRESSION":
          (te.lines = 1), (te.uncompress = ce);
          break;
        case "ZIP_COMPRESSION":
          (te.lines = 16), (te.uncompress = ce);
          break;
        case "PIZ_COMPRESSION":
          (te.lines = 32), (te.uncompress = Xe);
          break;
        case "PXR24_COMPRESSION":
          (te.lines = 16), (te.uncompress = ye);
          break;
        case "DWAA_COMPRESSION":
          (te.lines = 32), (te.uncompress = Pe);
          break;
        case "DWAB_COMPRESSION":
          (te.lines = 256), (te.uncompress = Pe);
          break;
        default:
          throw "EXRLoader.parse: " + D.compression + " is unsupported";
      }
      if (((te.scanlineBlockSize = te.lines), te.type == 1))
        switch (Q) {
          case or:
            (te.getter = Dt), (te.inputSize = 2);
            break;
          case Kr:
            (te.getter = nt), (te.inputSize = 2);
            break;
        }
      else if (te.type == 2)
        switch (Q) {
          case or:
            (te.getter = qe), (te.inputSize = 4);
            break;
          case Kr:
            (te.getter = ct), (te.inputSize = 4);
        }
      else
        throw (
          "EXRLoader.parse: unsupported pixelType " +
          te.type +
          " for " +
          D.compression +
          "."
        );
      te.blockCount = (D.dataWindow.yMax + 1) / te.scanlineBlockSize;
      for (var Ae = 0; Ae < te.blockCount; Ae++) K(W, ne);
      te.outputChannels = te.channels == 3 ? 4 : te.channels;
      const pe = te.width * te.height * te.outputChannels;
      switch (Q) {
        case or:
          (te.byteArray = new Float32Array(pe)),
            te.channels < te.outputChannels && te.byteArray.fill(1, 0, pe);
          break;
        case Kr:
          (te.byteArray = new Uint16Array(pe)),
            te.channels < te.outputChannels && te.byteArray.fill(15360, 0, pe);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", Q);
          break;
      }
      return (
        (te.bytesPerLine = te.width * te.inputSize * te.channels),
        te.outputChannels == 4 ? (te.format = wr) : (te.format = Kp),
        Jf ? (te.colorSpace = "srgb-linear") : (te.encoding = 3e3),
        te
      );
    }
    const Ot = new DataView(e),
      Ke = new Uint8Array(e),
      ht = { value: 0 },
      Tt = ot(Ot, e, ht),
      st = ft(Tt, Ot, Ke, ht, this.type),
      xt = { value: 0 },
      Qt = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let D = 0; D < st.height / st.scanlineBlockSize; D++) {
      const W = be(Ot, ht);
      (st.size = be(Ot, ht)),
        (st.lines =
          W + st.scanlineBlockSize > st.height
            ? st.height - W
            : st.scanlineBlockSize);
      const k =
        st.size < st.lines * st.bytesPerLine ? st.uncompress(st) : ae(st);
      ht.value += st.size;
      for (let ne = 0; ne < st.scanlineBlockSize; ne++) {
        const Q = ne + D * st.scanlineBlockSize;
        if (Q >= st.height) break;
        for (let te = 0; te < st.channels; te++) {
          const Ae = Qt[Tt.channels[te].name];
          for (let pe = 0; pe < st.width; pe++) {
            xt.value =
              (ne * (st.channels * st.width) + te * st.width + pe) *
              st.inputSize;
            const Ve =
              (st.height - 1 - Q) * (st.width * st.outputChannels) +
              pe * st.outputChannels +
              Ae;
            st.byteArray[Ve] = st.getter(k, xt);
          }
        }
      }
    }
    return {
      header: Tt,
      width: st.width,
      height: st.height,
      data: st.byteArray,
      format: st.format,
      [Jf ? "colorSpace" : "encoding"]: st[Jf ? "colorSpace" : "encoding"],
      type: this.type,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function s(a, l) {
      Jf ? (a.colorSpace = l.colorSpace) : (a.encoding = l.encoding),
        (a.minFilter = Un),
        (a.magFilter = Un),
        (a.generateMipmaps = !1),
        (a.flipY = !1),
        t && t(a, l);
    }
    return super.load(e, s, n, i);
  }
}
const Yy = new WeakMap();
class gO extends di {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, n, i) {
    const s = new ci(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (a) => {
          const l = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(a, l).then(t).catch(i);
        },
        n,
        i,
      );
  }
  decodeDracoFile(e, t, n, i) {
    const s = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
    };
    this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    for (const c in t.attributeTypes) {
      const d = t.attributeTypes[c];
      d.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[c] = d.name);
    }
    const n = JSON.stringify(t);
    if (Yy.has(e)) {
      const c = Yy.get(e);
      if (c.key === n) return c.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.",
        );
    }
    let i;
    const s = this.workerNextTaskID++,
      a = e.byteLength,
      l = this._getWorker(s, a)
        .then(
          (c) => (
            (i = c),
            new Promise((d, p) => {
              (i._callbacks[s] = { resolve: d, reject: p }),
                i.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e],
                );
            })
          ),
        )
        .then((c) => this._createGeometry(c.geometry));
    return (
      l
        .catch(() => !0)
        .then(() => {
          i && s && this._releaseTask(i, s);
        }),
      Yy.set(e, { key: n, promise: l }),
      l
    );
  }
  _createGeometry(e) {
    const t = new tn();
    e.index && t.setIndex(new Tn(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n],
        s = i.name,
        a = i.array,
        l = i.itemSize;
      t.setAttribute(s, new Tn(a, l));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new ci(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(t),
      n.setWithCredentials(this.withCredentials),
      new Promise((i, s) => {
        n.load(e, i, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((n) => {
        const i = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const s = yO.toString(),
          a = [
            "/* draco decoder */",
            i,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([a]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        (i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (i.onmessage = function (s) {
            const a = s.data;
            switch (a.type) {
              case "decode":
                i._callbacks[a.id].resolve(a);
                break;
              case "error":
                i._callbacks[a.id].reject(a);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + a.type + '"',
                );
            }
          }),
          this.workerPool.push(i);
      } else
        this.workerPool.sort(function (i, s) {
          return i._taskLoad > s._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = t), (n._taskLoad += t), n;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad),
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function yO() {
  let r, e;
  onmessage = function (a) {
    const l = a.data;
    switch (l.type) {
      case "init":
        (r = l.decoderConfig),
          (e = new Promise(function (p) {
            (r.onModuleLoaded = function (m) {
              p({ draco: m });
            }),
              DracoDecoderModule(r);
          }));
        break;
      case "decode":
        const c = l.buffer,
          d = l.taskConfig;
        e.then((p) => {
          const m = p.draco,
            y = new m.Decoder(),
            v = new m.DecoderBuffer();
          v.Init(new Int8Array(c), c.byteLength);
          try {
            const A = t(m, y, v, d),
              M = A.attributes.map((w) => w.array.buffer);
            A.index && M.push(A.index.array.buffer),
              self.postMessage({ type: "decode", id: l.id, geometry: A }, M);
          } catch (A) {
            console.error(A),
              self.postMessage({ type: "error", id: l.id, error: A.message });
          } finally {
            m.destroy(v), m.destroy(y);
          }
        });
        break;
    }
  };
  function t(a, l, c, d) {
    const p = d.attributeIDs,
      m = d.attributeTypes;
    let y, v;
    const A = l.GetEncodedGeometryType(c);
    if (A === a.TRIANGULAR_MESH)
      (y = new a.Mesh()), (v = l.DecodeBufferToMesh(c, y));
    else if (A === a.POINT_CLOUD)
      (y = new a.PointCloud()), (v = l.DecodeBufferToPointCloud(c, y));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!v.ok() || y.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + v.error_msg());
    const M = { index: null, attributes: [] };
    for (const w in p) {
      const x = self[m[w]];
      let C, T;
      if (d.useUniqueIDs) (T = p[w]), (C = l.GetAttributeByUniqueId(y, T));
      else {
        if (((T = l.GetAttributeId(y, a[p[w]])), T === -1)) continue;
        C = l.GetAttribute(y, T);
      }
      M.attributes.push(i(a, l, y, w, x, C));
    }
    return A === a.TRIANGULAR_MESH && (M.index = n(a, l, y)), a.destroy(y), M;
  }
  function n(a, l, c) {
    const d = c.num_faces() * 3,
      p = d * 4,
      m = a._malloc(p);
    l.GetTrianglesUInt32Array(c, p, m);
    const y = new Uint32Array(a.HEAPF32.buffer, m, d).slice();
    return a._free(m), { array: y, itemSize: 1 };
  }
  function i(a, l, c, d, p, m) {
    const y = m.num_components(),
      v = c.num_points() * y,
      A = v * p.BYTES_PER_ELEMENT,
      M = s(a, p),
      w = a._malloc(A);
    l.GetAttributeDataArrayForAllPoints(c, m, M, A, w);
    const x = new p(a.HEAPF32.buffer, w, v).slice();
    return a._free(w), { name: d, array: x, itemSize: y };
  }
  function s(a, l) {
    switch (l) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
let u0;
const Zy = () => {
  if (u0) return u0;
  const r =
      "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
    e =
      "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
    t = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    n = new Uint8Array([
      32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
      128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
      107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
      44, 45, 74, 156, 154, 70, 167,
    ]);
  if (typeof WebAssembly != "object") return { supported: !1 };
  let i = r;
  WebAssembly.validate(t) && (i = e);
  let s;
  const a = WebAssembly.instantiate(l(i), {}).then((m) => {
    (s = m.instance), s.exports.__wasm_call_ctors();
  });
  function l(m) {
    const y = new Uint8Array(m.length);
    for (let A = 0; A < m.length; ++A) {
      const M = m.charCodeAt(A);
      y[A] =
        M > 96 ? M - 71 : M > 64 ? M - 65 : M > 47 ? M + 4 : M > 46 ? 63 : 62;
    }
    let v = 0;
    for (let A = 0; A < m.length; ++A)
      y[v++] = y[A] < 60 ? n[y[A]] : (y[A] - 60) * 64 + y[++A];
    return y.buffer.slice(0, v);
  }
  function c(m, y, v, A, M, w) {
    const x = s.exports.sbrk,
      C = (v + 3) & -4,
      T = x(C * A),
      I = x(M.length),
      U = new Uint8Array(s.exports.memory.buffer);
    U.set(M, I);
    const F = m(T, v, A, I, M.length);
    if (
      (F === 0 && w && w(T, C, A),
      y.set(U.subarray(T, T + v * A)),
      x(T - x(0)),
      F !== 0)
    )
      throw new Error(`Malformed buffer data: ${F}`);
  }
  const d = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    p = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    };
  return (
    (u0 = {
      ready: a,
      supported: !0,
      decodeVertexBuffer(m, y, v, A, M) {
        c(s.exports.meshopt_decodeVertexBuffer, m, y, v, A, s.exports[d[M]]);
      },
      decodeIndexBuffer(m, y, v, A) {
        c(s.exports.meshopt_decodeIndexBuffer, m, y, v, A);
      },
      decodeIndexSequence(m, y, v, A) {
        c(s.exports.meshopt_decodeIndexSequence, m, y, v, A);
      },
      decodeGltfBuffer(m, y, v, A, M, w) {
        c(s.exports[p[M]], m, y, v, A, s.exports[d[w]]);
      },
    }),
    u0
  );
};
let c0 = null,
  g6 = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function y6(r = !0, e = !0, t) {
  return (n) => {
    t && t(n),
      r &&
        (c0 || (c0 = new gO()),
        c0.setDecoderPath(typeof r == "string" ? r : g6),
        n.setDRACOLoader(c0)),
      e && n.setMeshoptDecoder(typeof Zy == "function" ? Zy() : Zy);
  };
}
const dm = (r, e, t, n) => Qo(_x, r, y6(e, t, n));
dm.preload = (r, e, t, n) => Qo.preload(_x, r, y6(e, t, n));
dm.clear = (r) => Qo.clear(_x, r);
dm.setDecoderPath = (r) => {
  g6 = r;
};
const vO = 3e3,
  xO = 3001,
  v6 = (r, e, t) => {
    let n;
    switch (r) {
      case hs:
        n = new Uint8ClampedArray(e * t * 4);
        break;
      case Kr:
        n = new Uint16Array(e * t * 4);
        break;
      case so:
        n = new Uint32Array(e * t * 4);
        break;
      case Tg:
        n = new Int8Array(e * t * 4);
        break;
      case Rg:
        n = new Int16Array(e * t * 4);
        break;
      case qp:
        n = new Int32Array(e * t * 4);
        break;
      case or:
        n = new Float32Array(e * t * 4);
        break;
      default:
        throw new Error("Unsupported data type");
    }
    return n;
  };
let d0;
const bO = (r, e, t, n) => {
  if (d0 !== void 0) return d0;
  const i = new Es(1, 1, n);
  e.setRenderTarget(i);
  const s = new nr(new Kl(), new ds({ color: 16777215 }));
  e.render(s, t), e.setRenderTarget(null);
  const a = v6(r, i.width, i.height);
  return (
    e.readRenderTargetPixels(i, 0, 0, i.width, i.height, a),
    i.dispose(),
    s.geometry.dispose(),
    s.material.dispose(),
    (d0 = a[0] !== 0),
    d0
  );
};
class Ax {
  constructor(e) {
    var t, n, i, s, a, l, c, d, p, m, y, v, A, M, w, x;
    (this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget);
        try {
          this._renderer.render(this._scene, this._camera);
        } catch (T) {
          throw (this._renderer.setRenderTarget(null), T);
        }
        this._renderer.setRenderTarget(null);
      }),
      (this._width = e.width),
      (this._height = e.height),
      (this._type = e.type),
      (this._colorSpace = e.colorSpace);
    const C = {
      format: wr,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((t = e.renderTargetOptions) === null || t === void 0
          ? void 0
          : t.anisotropy) !== void 0
          ? (n = e.renderTargetOptions) === null || n === void 0
            ? void 0
            : n.anisotropy
          : 1,
      generateMipmaps:
        ((i = e.renderTargetOptions) === null || i === void 0
          ? void 0
          : i.generateMipmaps) !== void 0
          ? (s = e.renderTargetOptions) === null || s === void 0
            ? void 0
            : s.generateMipmaps
          : !1,
      magFilter:
        ((a = e.renderTargetOptions) === null || a === void 0
          ? void 0
          : a.magFilter) !== void 0
          ? (l = e.renderTargetOptions) === null || l === void 0
            ? void 0
            : l.magFilter
          : Un,
      minFilter:
        ((c = e.renderTargetOptions) === null || c === void 0
          ? void 0
          : c.minFilter) !== void 0
          ? (d = e.renderTargetOptions) === null || d === void 0
            ? void 0
            : d.minFilter
          : Un,
      samples:
        ((p = e.renderTargetOptions) === null || p === void 0
          ? void 0
          : p.samples) !== void 0
          ? (m = e.renderTargetOptions) === null || m === void 0
            ? void 0
            : m.samples
          : void 0,
      wrapS:
        ((y = e.renderTargetOptions) === null || y === void 0
          ? void 0
          : y.wrapS) !== void 0
          ? (v = e.renderTargetOptions) === null || v === void 0
            ? void 0
            : v.wrapS
          : Ar,
      wrapT:
        ((A = e.renderTargetOptions) === null || A === void 0
          ? void 0
          : A.wrapT) !== void 0
          ? (M = e.renderTargetOptions) === null || M === void 0
            ? void 0
            : M.wrapT
          : Ar,
    };
    if (
      ((this._material = e.material),
      e.renderer
        ? (this._renderer = e.renderer)
        : ((this._renderer = Ax.instantiateRenderer()),
          (this._rendererIsDisposable = !0)),
      (this._scene = new xh()),
      (this._camera = new Wc()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !bO(this._type, this._renderer, this._camera, C))
    ) {
      let T;
      switch (this._type) {
        case Kr:
          T = this._renderer.extensions.has("EXT_color_buffer_float")
            ? or
            : void 0;
          break;
      }
      T !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${or}`,
          ),
          (this._type = T))
        : ((this._supportsReadPixels = !1),
          console.warn(
            "This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown",
          ));
    }
    (this._quad = new nr(new Kl(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new Es(this.width, this.height, C)),
      (this._renderTarget.texture.mapping =
        ((w = e.renderTargetOptions) === null || w === void 0
          ? void 0
          : w.mapping) !== void 0
          ? (x = e.renderTargetOptions) === null || x === void 0
            ? void 0
            : x.mapping
          : jl);
  }
  static instantiateRenderer() {
    const e = new gx();
    return e.setSize(128, 128), e;
  }
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const e = v6(this._type, this._width, this._height);
    return (
      this._renderer.readRenderTargetPixels(
        this._renderTarget,
        0,
        0,
        this._width,
        this._height,
        e,
      ),
      e
    );
  }
  toDataTexture(e) {
    const t = new wa(
      this.toArray(),
      this.width,
      this.height,
      wr,
      this._type,
      (e == null ? void 0 : e.mapping) || jl,
      (e == null ? void 0 : e.wrapS) || Ar,
      (e == null ? void 0 : e.wrapT) || Ar,
      (e == null ? void 0 : e.magFilter) || Un,
      (e == null ? void 0 : e.minFilter) || Un,
      (e == null ? void 0 : e.anisotropy) || 1,
      ao,
    );
    return (
      (t.generateMipmaps =
        (e == null ? void 0 : e.generateMipmaps) !== void 0
          ? e == null
            ? void 0
            : e.generateMipmaps
          : !1),
      t
    );
  }
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null),
      this._rendererIsDisposable &&
        (this._renderer.dispose(), this._renderer.forceContextLoss());
  }
  dispose(e) {
    this.disposeOnDemandRenderer(),
      e && this.renderTarget.dispose(),
      this.material instanceof fs &&
        Object.values(this.material.uniforms).forEach((t) => {
          t.value instanceof Ln && t.value.dispose();
        }),
      Object.values(this.material).forEach((t) => {
        t instanceof Ln && t.dispose();
      }),
      this.material.dispose(),
      this._quad.geometry.dispose();
  }
  get width() {
    return this._width;
  }
  set width(e) {
    (this._width = e), this._renderTarget.setSize(this._width, this._height);
  }
  get height() {
    return this._height;
  }
  set height(e) {
    (this._height = e), this._renderTarget.setSize(this._width, this._height);
  }
  get renderer() {
    return this._renderer;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(e) {
    (this._renderTarget = e),
      (this._width = e.width),
      (this._height = e.height);
  }
  get material() {
    return this._material;
  }
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const _O = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  AO = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class wO extends fs {
  constructor({
    gamma: e,
    offsetHdr: t,
    offsetSdr: n,
    gainMapMin: i,
    gainMapMax: s,
    maxDisplayBoost: a,
    hdrCapacityMin: l,
    hdrCapacityMax: c,
    sdr: d,
    gainMap: p,
  }) {
    super({
      name: "GainMapDecoderMaterial",
      vertexShader: _O,
      fragmentShader: AO,
      uniforms: {
        sdr: { value: d },
        gainMap: { value: p },
        gamma: { value: new Y(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new Y().fromArray(t) },
        offsetSdr: { value: new Y().fromArray(n) },
        gainMapMin: { value: new Y().fromArray(i) },
        gainMapMax: { value: new Y().fromArray(s) },
        weightFactor: { value: (Math.log2(a) - l) / (c - l) },
      },
      blending: eo,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = a),
      (this._hdrCapacityMin = l),
      (this._hdrCapacityMax = c),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0);
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(e) {
    this.uniforms.sdr.value = e;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e;
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e);
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e);
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e);
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e);
  }
  get gamma() {
    const e = this.uniforms.gamma.value;
    return [1 / e.x, 1 / e.y, 1 / e.z];
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value;
    (t.x = 1 / e[0]), (t.y = 1 / e[1]), (t.z = 1 / e[2]);
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(e) {
    (this._hdrCapacityMin = e), this.calculateWeight();
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(e) {
    (this._hdrCapacityMax = e), this.calculateWeight();
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(e) {
    (this._maxDisplayBoost = Math.max(1, Math.min(65504, e))),
      this.calculateWeight();
  }
  calculateWeight() {
    const e =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e));
  }
}
class x6 extends Error {}
class b6 extends Error {}
const Yf = (r, e, t) => {
    const n = new RegExp(`${e}="([^"]*)"`, "i").exec(r);
    if (n) return n[1];
    const i = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, "i").exec(r);
    if (i) {
      const s = i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
      return s && s.length === 3
        ? s.map((a) => a.replace(/<\/?rdf:li>/g, ""))
        : i[1].trim();
    }
    if (t !== void 0) return t;
    throw new Error(`Can't find ${e} in gainmap metadata`);
  },
  MO = (r) => {
    let e;
    typeof TextDecoder < "u"
      ? (e = new TextDecoder().decode(r))
      : (e = r.toString());
    let t = e.indexOf("<x:xmpmeta");
    for (; t !== -1; ) {
      const n = e.indexOf("x:xmpmeta>", t),
        i = e.slice(t, n + 10);
      try {
        const s = Yf(i, "hdrgm:GainMapMin", "0"),
          a = Yf(i, "hdrgm:GainMapMax"),
          l = Yf(i, "hdrgm:Gamma", "1"),
          c = Yf(i, "hdrgm:OffsetSDR", "0.015625"),
          d = Yf(i, "hdrgm:OffsetHDR", "0.015625"),
          p = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),
          m = p ? p[1] : "0",
          y = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);
        if (!y) throw new Error("Incomplete gainmap metadata");
        const v = y[1];
        return {
          gainMapMin: Array.isArray(s)
            ? s.map((A) => parseFloat(A))
            : [parseFloat(s), parseFloat(s), parseFloat(s)],
          gainMapMax: Array.isArray(a)
            ? a.map((A) => parseFloat(A))
            : [parseFloat(a), parseFloat(a), parseFloat(a)],
          gamma: Array.isArray(l)
            ? l.map((A) => parseFloat(A))
            : [parseFloat(l), parseFloat(l), parseFloat(l)],
          offsetSdr: Array.isArray(c)
            ? c.map((A) => parseFloat(A))
            : [parseFloat(c), parseFloat(c), parseFloat(c)],
          offsetHdr: Array.isArray(d)
            ? d.map((A) => parseFloat(A))
            : [parseFloat(d), parseFloat(d), parseFloat(d)],
          hdrCapacityMin: parseFloat(m),
          hdrCapacityMax: parseFloat(v),
        };
      } catch {}
      t = e.indexOf("<x:xmpmeta", n);
    }
  };
class SO {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0,
    };
  }
  extract(e) {
    return new Promise((t, n) => {
      const i = this.options.debug,
        s = new DataView(e.buffer);
      if (s.getUint16(0) !== 65496) {
        n(new Error("Not a valid jpeg"));
        return;
      }
      const a = s.byteLength;
      let l = 2,
        c = 0,
        d;
      for (; l < a; ) {
        if (++c > 250) {
          n(new Error(`Found no marker after ${c} loops 😵`));
          return;
        }
        if (s.getUint8(l) !== 255) {
          n(
            new Error(
              `Not a valid marker at offset 0x${l.toString(16)}, found: 0x${s.getUint8(l).toString(16)}`,
            ),
          );
          return;
        }
        if (
          ((d = s.getUint8(l + 1)),
          i && console.log(`Marker: ${d.toString(16)}`),
          d === 226)
        ) {
          i && console.log("Found APP2 marker (0xffe2)");
          const p = l + 4;
          if (s.getUint32(p) === 1297106432) {
            const m = p + 4;
            let y;
            if (s.getUint16(m) === 18761) y = !1;
            else if (s.getUint16(m) === 19789) y = !0;
            else {
              n(new Error("No valid endianness marker found in TIFF header"));
              return;
            }
            if (s.getUint16(m + 2, !y) !== 42) {
              n(new Error("Not valid TIFF data! (no 0x002A marker)"));
              return;
            }
            const v = s.getUint32(m + 4, !y);
            if (v < 8) {
              n(new Error("Not valid TIFF data! (First offset less than 8)"));
              return;
            }
            const A = m + v,
              M = s.getUint16(A, !y),
              w = A + 2;
            let x = 0;
            for (let I = w; I < w + 12 * M; I += 12)
              s.getUint16(I, !y) === 45057 && (x = s.getUint32(I + 8, !y));
            const C = A + 2 + M * 12 + 4,
              T = [];
            for (let I = C; I < C + x * 16; I += 16) {
              const U = {
                MPType: s.getUint32(I, !y),
                size: s.getUint32(I + 4, !y),
                dataOffset: s.getUint32(I + 8, !y),
                dependantImages: s.getUint32(I + 12, !y),
                start: -1,
                end: -1,
                isFII: !1,
              };
              U.dataOffset
                ? ((U.start = m + U.dataOffset), (U.isFII = !1))
                : ((U.start = 0), (U.isFII = !0)),
                (U.end = U.start + U.size),
                T.push(U);
            }
            if (this.options.extractNonFII && T.length) {
              const I = new Blob([s]),
                U = [];
              for (const F of T) {
                if (F.isFII && !this.options.extractFII) continue;
                const O = I.slice(F.start, F.end + 1, "image/jpeg");
                U.push(O);
              }
              t(U);
            }
          }
        }
        l += 2 + s.getUint16(l + 2);
      }
    });
  }
}
const EO = async (r) => {
    const e = MO(r);
    if (!e) throw new b6("Gain map XMP metadata not found");
    const t = await new SO({ extractFII: !0, extractNonFII: !0 }).extract(r);
    if (t.length !== 2) throw new x6("Gain map recovery image not found");
    return {
      sdr: new Uint8Array(await t[0].arrayBuffer()),
      gainMap: new Uint8Array(await t[1].arrayBuffer()),
      metadata: e,
    };
  },
  uw = (r) =>
    new Promise((e, t) => {
      const n = document.createElement("img");
      (n.onload = () => {
        e(n);
      }),
        (n.onerror = (i) => {
          t(i);
        }),
        (n.src = URL.createObjectURL(r));
    });
class _6 extends di {
  constructor(e, t) {
    super(t),
      e && (this._renderer = e),
      (this._internalLoadingManager = new e2());
  }
  setRenderer(e) {
    return (this._renderer = e), this;
  }
  setRenderTargetOptions(e) {
    return (this._renderTargetOptions = e), this;
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        "WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.",
      );
    const e = new wO({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Ln(),
      sdr: new Ln(),
    });
    return new Ax({
      width: 16,
      height: 16,
      type: Kr,
      colorSpace: ao,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    });
  }
  async render(e, t, n, i) {
    const s = i ? new Blob([i], { type: "image/jpeg" }) : void 0,
      a = new Blob([n], { type: "image/jpeg" });
    let l,
      c,
      d = !1;
    if (typeof createImageBitmap > "u") {
      const y = await Promise.all([s ? uw(s) : Promise.resolve(void 0), uw(a)]);
      (c = y[0]), (l = y[1]), (d = !0);
    } else {
      const y = await Promise.all([
        s
          ? createImageBitmap(s, { imageOrientation: "flipY" })
          : Promise.resolve(void 0),
        createImageBitmap(a, { imageOrientation: "flipY" }),
      ]);
      (c = y[0]), (l = y[1]);
    }
    const p = new Ln(
      c || new ImageData(2, 2),
      jl,
      Ar,
      Ar,
      Un,
      Av,
      wr,
      hs,
      1,
      ao,
    );
    (p.flipY = d), (p.needsUpdate = !0);
    const m = new Ln(l, jl, Ar, Ar, Un, Av, wr, hs, 1, Ei);
    (m.flipY = d),
      (m.needsUpdate = !0),
      (e.width = l.width),
      (e.height = l.height),
      (e.material.gainMap = p),
      (e.material.sdr = m),
      (e.material.gainMapMin = t.gainMapMin),
      (e.material.gainMapMax = t.gainMapMax),
      (e.material.offsetHdr = t.offsetHdr),
      (e.material.offsetSdr = t.offsetSdr),
      (e.material.gamma = t.gamma),
      (e.material.hdrCapacityMin = t.hdrCapacityMin),
      (e.material.hdrCapacityMax = t.hdrCapacityMax),
      (e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax)),
      (e.material.needsUpdate = !0),
      e.render();
  }
}
class CO extends _6 {
  load([e, t, n], i, s, a) {
    const l = this.prepareQuadRenderer();
    let c, d, p;
    const m = async () => {
      if (c && d && p) {
        try {
          await this.render(l, p, c, d);
        } catch (L) {
          this.manager.itemError(e),
            this.manager.itemError(t),
            this.manager.itemError(n),
            typeof a == "function" && a(L),
            l.disposeOnDemandRenderer();
          return;
        }
        typeof i == "function" && i(l),
          this.manager.itemEnd(e),
          this.manager.itemEnd(t),
          this.manager.itemEnd(n),
          l.disposeOnDemandRenderer();
      }
    };
    let y = !0,
      v = 0,
      A = 0,
      M = !0,
      w = 0,
      x = 0,
      C = !0,
      T = 0,
      I = 0;
    const U = () => {
      if (typeof s == "function") {
        const L = v + w + T,
          N = A + x + I,
          X = y && M && C;
        s(
          new ProgressEvent("progress", {
            lengthComputable: X,
            loaded: N,
            total: L,
          }),
        );
      }
    };
    this.manager.itemStart(e),
      this.manager.itemStart(t),
      this.manager.itemStart(n);
    const F = new ci(this._internalLoadingManager);
    F.setResponseType("arraybuffer"),
      F.setRequestHeader(this.requestHeader),
      F.setPath(this.path),
      F.setWithCredentials(this.withCredentials),
      F.load(
        e,
        async (L) => {
          if (typeof L == "string") throw new Error("Invalid sdr buffer");
          (c = L), await m();
        },
        (L) => {
          (y = L.lengthComputable), (A = L.loaded), (v = L.total), U();
        },
        (L) => {
          this.manager.itemError(e), typeof a == "function" && a(L);
        },
      );
    const O = new ci(this._internalLoadingManager);
    O.setResponseType("arraybuffer"),
      O.setRequestHeader(this.requestHeader),
      O.setPath(this.path),
      O.setWithCredentials(this.withCredentials),
      O.load(
        t,
        async (L) => {
          if (typeof L == "string") throw new Error("Invalid gainmap buffer");
          (d = L), await m();
        },
        (L) => {
          (M = L.lengthComputable), (x = L.loaded), (w = L.total), U();
        },
        (L) => {
          this.manager.itemError(t), typeof a == "function" && a(L);
        },
      );
    const z = new ci(this._internalLoadingManager);
    return (
      z.setRequestHeader(this.requestHeader),
      z.setPath(this.path),
      z.setWithCredentials(this.withCredentials),
      z.load(
        n,
        async (L) => {
          if (typeof L != "string") throw new Error("Invalid metadata string");
          (p = JSON.parse(L)), await m();
        },
        (L) => {
          (C = L.lengthComputable), (I = L.loaded), (T = L.total), U();
        },
        (L) => {
          this.manager.itemError(n), typeof a == "function" && a(L);
        },
      ),
      l
    );
  }
}
class TO extends _6 {
  load(e, t, n, i) {
    const s = this.prepareQuadRenderer(),
      a = new ci(this._internalLoadingManager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(this.withCredentials),
      this.manager.itemStart(e),
      a.load(
        e,
        async (l) => {
          if (typeof l == "string")
            throw new Error(
              "Invalid buffer, received [string], was expecting [ArrayBuffer]",
            );
          const c = new Uint8Array(l);
          let d, p, m;
          try {
            const y = await EO(c);
            (d = y.sdr), (p = y.gainMap), (m = y.metadata);
          } catch (y) {
            if (y instanceof b6 || y instanceof x6)
              console.warn(
                `Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`,
              ),
                (m = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (d = c);
            else throw y;
          }
          try {
            await this.render(s, m, d, p);
          } catch (y) {
            this.manager.itemError(e),
              typeof i == "function" && i(y),
              s.disposeOnDemandRenderer();
            return;
          }
          typeof t == "function" && t(s),
            this.manager.itemEnd(e),
            s.disposeOnDemandRenderer();
        },
        n,
        (l) => {
          this.manager.itemError(e), typeof i == "function" && i(l);
        },
      ),
      s
    );
  }
}
const Op = {
    apartment: "lebombo_1k.hdr",
    city: "potsdamer_platz_1k.hdr",
    dawn: "kiara_1_dawn_1k.hdr",
    forest: "forest_slope_1k.hdr",
    lobby: "st_fagans_interior_1k.hdr",
    night: "dikhololo_night_1k.hdr",
    park: "rooitou_park_1k.hdr",
    studio: "studio_small_03_1k.hdr",
    sunset: "venice_sunset_1k.hdr",
    warehouse: "empty_warehouse_01_1k.hdr",
  },
  A6 =
    "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
  uh = (r) => Array.isArray(r),
  wx = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"];
function r2({
  files: r = wx,
  path: e = "",
  preset: t = void 0,
  encoding: n = void 0,
  extensions: i,
} = {}) {
  let s = null,
    a = !1;
  t && (Mx(t), (r = Op[t]), (e = A6)), (a = uh(r));
  const { extension: l, isCubemap: c } = Sx(r);
  if (((s = Ex(l)), !s))
    throw new Error("useEnvironment: Unrecognized file extension: " + r);
  const d = Np((v) => v.gl);
  he.useLayoutEffect(() => {
    if (l !== "webp" && l !== "jpg" && l !== "jpeg") return;
    function v() {
      Qo.clear(s, a ? [r] : r);
    }
    d.domElement.addEventListener("webglcontextlost", v, { once: !0 });
  }, [r, d.domElement]);
  const p = Qo(s, a ? [r] : r, (v) => {
    (l === "webp" || l === "jpg" || l === "jpeg") && v.setRenderer(d),
      v.setPath == null || v.setPath(e),
      i && i(v);
  });
  let m = a ? p[0] : p;
  if (l === "jpg" || l === "jpeg" || l === "webp") {
    var y;
    m = (y = m.renderTarget) == null ? void 0 : y.texture;
  }
  return (
    (m.mapping = c ? io : hh),
    "colorSpace" in m
      ? (m.colorSpace = (n ?? c) ? "srgb" : "srgb-linear")
      : (m.encoding = (n ?? c) ? xO : vO),
    m
  );
}
const RO = { files: wx, path: "", preset: void 0, extensions: void 0 };
r2.preload = (r) => {
  const e = { ...RO, ...r };
  let { files: t, path: n = "" } = e;
  const { preset: i, extensions: s } = e;
  i && (Mx(i), (t = Op[i]), (n = A6));
  const { extension: a } = Sx(t);
  if (a === "webp" || a === "jpg" || a === "jpeg")
    throw new Error("useEnvironment: Preloading gainmaps is not supported");
  const l = Ex(a);
  if (!l) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  Qo.preload(l, uh(t) ? [t] : t, (c) => {
    c.setPath == null || c.setPath(n), s && s(c);
  });
};
const IO = { files: wx, preset: void 0 };
r2.clear = (r) => {
  const e = { ...IO, ...r };
  let { files: t } = e;
  const { preset: n } = e;
  n && (Mx(n), (t = Op[n]));
  const { extension: i } = Sx(t),
    s = Ex(i);
  if (!s) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  Qo.clear(s, uh(t) ? [t] : t);
};
function Mx(r) {
  if (!(r in Op))
    throw new Error("Preset must be one of: " + Object.keys(Op).join(", "));
}
function Sx(r) {
  var e;
  const t = uh(r) && r.length === 6,
    n = uh(r) && r.length === 3 && r.some((s) => s.endsWith("json")),
    i = uh(r) ? r[0] : r;
  return {
    extension: t
      ? "cube"
      : n
        ? "webp"
        : i.startsWith("data:application/exr")
          ? "exr"
          : i.startsWith("data:application/hdr")
            ? "hdr"
            : i.startsWith("data:image/jpeg")
              ? "jpg"
              : (e = i.split(".").pop()) == null ||
                  (e = e.split("?")) == null ||
                  (e = e.shift()) == null
                ? void 0
                : e.toLowerCase(),
    isCubemap: t,
    isGainmap: n,
  };
}
function Ex(r) {
  return r === "cube"
    ? bS
    : r === "hdr"
      ? pO
      : r === "exr"
        ? mO
        : r === "jpg" || r === "jpeg"
          ? TO
          : r === "webp"
            ? CO
            : null;
}
const BO = (r) => r.current && r.current.isScene,
  PO = (r) => (BO(r) ? r.current : r);
function Cx(r, e, t, n, i = {}) {
  var s, a, l, c;
  i = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...i,
  };
  const d = PO(e || t),
    p = d.background,
    m = d.environment,
    y = {
      backgroundBlurriness: d.backgroundBlurriness,
      backgroundIntensity: d.backgroundIntensity,
      backgroundRotation:
        (s =
          (a = d.backgroundRotation) == null || a.clone == null
            ? void 0
            : a.clone()) !== null && s !== void 0
          ? s
          : [0, 0, 0],
      environmentIntensity: d.environmentIntensity,
      environmentRotation:
        (l =
          (c = d.environmentRotation) == null || c.clone == null
            ? void 0
            : c.clone()) !== null && l !== void 0
          ? l
          : [0, 0, 0],
    };
  return (
    r !== "only" && (d.environment = n),
    r && (d.background = n),
    zl(d, i),
    () => {
      r !== "only" && (d.environment = m), r && (d.background = p), zl(d, y);
    }
  );
}
function Tx({ scene: r, background: e = !1, map: t, ...n }) {
  const i = Np((s) => s.scene);
  return (
    he.useLayoutEffect(() => {
      if (t) return Cx(e, r, i, t, n);
    }),
    null
  );
}
function w6({
  background: r = !1,
  scene: e,
  blur: t,
  backgroundBlurriness: n,
  backgroundIntensity: i,
  backgroundRotation: s,
  environmentIntensity: a,
  environmentRotation: l,
  ...c
}) {
  const d = r2(c),
    p = Np((m) => m.scene);
  return (
    he.useLayoutEffect(() =>
      Cx(r, e, p, d, {
        backgroundBlurriness: t ?? n,
        backgroundIntensity: i,
        backgroundRotation: s,
        environmentIntensity: a,
        environmentRotation: l,
      }),
    ),
    null
  );
}
function LO({
  children: r,
  near: e = 0.1,
  far: t = 1e3,
  resolution: n = 256,
  frames: i = 1,
  map: s,
  background: a = !1,
  blur: l,
  backgroundBlurriness: c,
  backgroundIntensity: d,
  backgroundRotation: p,
  environmentIntensity: m,
  environmentRotation: y,
  scene: v,
  files: A,
  path: M,
  preset: w = void 0,
  extensions: x,
}) {
  const C = Np((z) => z.gl),
    T = Np((z) => z.scene),
    I = he.useRef(null),
    [U] = he.useState(() => new xh()),
    F = he.useMemo(() => {
      const z = new O3(n);
      return (z.texture.type = Kr), z;
    }, [n]);
  he.useLayoutEffect(() => {
    if (i === 1) {
      const z = C.autoClear;
      (C.autoClear = !0), I.current.update(C, U), (C.autoClear = z);
    }
    return Cx(a, v, T, F.texture, {
      backgroundBlurriness: l ?? c,
      backgroundIntensity: d,
      backgroundRotation: p,
      environmentIntensity: m,
      environmentRotation: y,
    });
  }, [r, U, F.texture, v, T, a, i, C]);
  let O = 1;
  return (
    fg(() => {
      if (i === 1 / 0 || O < i) {
        const z = C.autoClear;
        (C.autoClear = !0), I.current.update(C, U), (C.autoClear = z), O++;
      }
    }),
    he.createElement(
      he.Fragment,
      null,
      qN(
        he.createElement(
          he.Fragment,
          null,
          r,
          he.createElement("cubeCamera", { ref: I, args: [e, t, F] }),
          A || w
            ? he.createElement(w6, {
                background: !0,
                files: A,
                preset: w,
                path: M,
                extensions: x,
              })
            : s
              ? he.createElement(Tx, { background: !0, map: s, extensions: x })
              : null,
        ),
        U,
      ),
    )
  );
}
function DO(r) {
  var e, t, n, i;
  const s = r2(r),
    a = r.map || s;
  he.useMemo(() => jS({ GroundProjectedEnvImpl: PU }), []);
  const l = he.useMemo(() => [a], [a]),
    c = (e = r.ground) == null ? void 0 : e.height,
    d = (t = r.ground) == null ? void 0 : t.radius,
    p =
      (n = (i = r.ground) == null ? void 0 : i.scale) !== null && n !== void 0
        ? n
        : 1e3;
  return he.createElement(
    he.Fragment,
    null,
    he.createElement(Tx, Fv({}, r, { map: a })),
    he.createElement("groundProjectedEnvImpl", {
      args: l,
      scale: p,
      height: c,
      radius: d,
    }),
  );
}
function M6(r) {
  return r.ground
    ? he.createElement(DO, r)
    : r.map
      ? he.createElement(Tx, r)
      : r.children
        ? he.createElement(LO, r)
        : he.createElement(w6, r);
}
function FO(r, e) {
  const { nodes: t, materials: n } = dm("/models/thali/thali.gltf"),
    i = new rx();
  i.load("/textures/plate.jpeg");
  const s = i.load("/textures/cup.avif");
  i.load("textures/lassi.png");
  const a = new Ri({
      color: 16773757,
      metalness: 1,
      roughness: 0.05,
      envMapIntensity: 2.5,
      reflectivity: 1.5,
      clearcoat: 0.8,
      clearcoatRoughness: 0.05,
    }),
    l = new Ri({
      map: s,
      color: 11010305,
      metalness: 1,
      roughness: 0.1,
      envMapIntensity: 1.5,
      reflectivity: 1.2,
      clearcoat: 0.5,
      emissive: 11010305,
      emissiveIntensity: 0.2,
    }),
    c = new Ri({
      color: 16765952,
      metalness: 1,
      roughness: 0.1,
      envMapIntensity: 1.5,
      reflectivity: 15,
      clearcoat: 1,
      emissive: 16771899,
      emissiveIntensity: 0.1,
    });
  return H.jsxs(H.Fragment, {
    children: [
      H.jsx(M6, { preset: "studio" }),
      H.jsx("group", {
        ...e,
        dispose: null,
        children: H.jsxs("group", {
          scale: 0.01,
          children: [
            H.jsx("mesh", {
              geometry: t.pCylinder13_blinn1_0.geometry,
              material: n.blinn1,
              position: [-0.202, 0.009, 1.932],
            }),
            H.jsx("mesh", {
              geometry: t.pCylinder1_blinn5_0.geometry,
              material: l,
              position: [-0.19, 0.394, 4.978],
              rotation: [0, -0.235, 0],
              scale: 0.203,
            }),
            H.jsx("mesh", {
              geometry: t.pCylinder3_blinn10_0.geometry,
              material: a,
              position: [0.769, 0.197, 3.386],
              scale: 0.203,
            }),
            H.jsx("mesh", {
              geometry: t.pPlane4_blinn9_0.geometry,
              material: n.blinn9,
              position: [-0.888, 0.222, 2.893],
              rotation: [0.607, -1.491, 1.13],
              scale: 0.127,
            }),
            H.jsx("mesh", {
              geometry: t.pSphere8_phongE14_0.geometry,
              material: n.phongE14,
              position: [-0.928, 0.869, 2.815],
              rotation: [0.003, 0.293, 0.003],
              scale: 0.203,
            }),
            H.jsx("mesh", {
              geometry: t.pSphere9_blinn6_0.geometry,
              material: n.blinn6,
              position: [-0.928, 0.869, 2.815],
              rotation: [0.003, 0.293, 0.003],
              scale: 0.203,
            }),
            H.jsx("mesh", {
              geometry: t.pSphere10_blinn7_0.geometry,
              material: n.blinn7,
              position: [0.479, 0.869, 1.602],
              rotation: [0.003, 0.293, 0.003],
              scale: 0.203,
            }),
            H.jsx("mesh", {
              geometry: t.pPlane8_blinn8_0.geometry,
              material: n.blinn8,
              position: [0.302, 0.274, 1.543],
              rotation: [3.095, 0.177, -2.609],
              scale: 0.127,
            }),
            H.jsx("mesh", {
              geometry: t.pPlane11_blinn4_0.geometry,
              material: n.blinn4,
              position: [-4.934, -0.132, 3.857],
              rotation: [0, 0.857, 0],
              scale: [0.679, 0.867, 0.896],
            }),
            H.jsx("mesh", {
              geometry: t.pPlane12_blinn2_0.geometry,
              material: n.blinn2,
              position: [-4.782, -0.21, 3.432],
              rotation: [-0.034, 0.793, 0.026],
              scale: [0.679, 0.867, 0.896],
            }),
            H.jsx("mesh", {
              geometry: t.pDisc1_blinn3_0.geometry,
              material: n.blinn3,
              position: [1.846, 0.048, 4.032],
              scale: 1.389,
            }),
            H.jsx("mesh", {
              geometry: t.pCylinder4_blinn13_0.geometry,
              material: c,
              position: [-0.19, 1.223, 4.978],
              scale: 0.539,
            }),
            H.jsx("mesh", {
              geometry: t.pCylinder5_blinn12_0.geometry,
              material: n.blinn12,
              position: [-0.932, 0.382, 2.816],
              scale: 0.682,
            }),
            H.jsx("mesh", {
              geometry: t.pCylinder6_blinn11_0.geometry,
              material: n.blinn11,
              position: [0.477, 0.382, 1.605],
              scale: 0.682,
            }),
          ],
        }),
      }),
    ],
  });
}
dm.preload("/models/thali/thali.gltf");
const cw = new Y();
function NO() {
  return fg(({ camera: r, mouse: e }) => {
    cw.set(e.x * 0.005, e.y * 0.005, r.position.z),
      r.position.lerp(cw, 0.25),
      r.lookAt(0, 0, 0);
  });
}
function UO() {
  const [r, e] = he.useState({ x: 0, y: 0 });
  return (
    he.useEffect(() => {
      const t = (n) => {
        e({
          x: (n.clientX / window.innerWidth) * 2 - 1,
          y: -(n.clientY / window.innerHeight) * 2 + 1,
        });
      };
      return (
        window.addEventListener("mousemove", t),
        () => window.removeEventListener("mousemove", t)
      );
    }, []),
    r
  );
}
function OO() {
  const [r, e] = he.useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });
  return (
    he.useEffect(() => {
      const t = () =>
        e({ width: window.innerWidth, height: window.innerHeight });
      return (
        window.addEventListener("resize", t),
        () => window.removeEventListener("resize", t)
      );
    }, []),
    r
  );
}
function kO() {
  const r = he.useRef(null),
    [e, t] = he.useState(!1),
    [n, i] = he.useState(!1),
    { width: s } = OO();
  UO();
  const a = ((c) =>
    c < 480 ? 0.7 : c < 768 ? 0.75 : c < 1024 ? 0.8 : c < 1200 ? 0.85 : 1)(s);
  fg((c) => {
    r.current && (r.current.rotation.y += 0.01);
  });
  const l = he.useMemo(
    () =>
      new Ri({
        metalness: 0.9,
        roughness: 0.1,
        clearcoat: 1,
        clearcoatRoughness: 0.1,
        reflectivity: 1,
      }),
    [],
  );
  return (
    fg(() => {
      r.current &&
        l &&
        ((l.roughness = gp.lerp(l.roughness, n ? 0.1 : 0.5, 0.1)),
        (l.metalness = gp.lerp(l.metalness, n ? 1 : 0.8, 0.1)),
        (l.clearcoat = gp.lerp(l.clearcoat, n ? 1 : 0.5, 0.1)));
    }),
    H.jsxs(H.Fragment, {
      children: [
        H.jsx("ambientLight", { intensity: 0.6 }),
        H.jsx("spotLight", {
          position: [10, 10, 10],
          angle: 0.15,
          penumbra: 1,
          intensity: n ? 2 : 1.5,
          castShadow: !0,
        }),
        H.jsx("pointLight", {
          position: [-10, -10, -10],
          intensity: n ? 0.8 : 0.5,
        }),
        H.jsx("hemisphereLight", {
          intensity: 0.3,
          groundColor: new dt(526368),
        }),
        H.jsx(he.Suspense, {
          fallback: null,
          children: H.jsx("group", {
            ref: r,
            scale: a,
            rotation: [0, 0, -1],
            position: [0.0015, 0.0085, 2.35],
            onClick: () => t(!e),
            onPointerOver: () => i(!0),
            onPointerOut: () => i(!1),
            children: H.jsx(FO, { rotation: [0, 0, 0], material: l }),
          }),
        }),
        H.jsx(M6, { preset: "sunset" }),
        H.jsx(NO, {}),
      ],
    })
  );
}
function zO() {
  return H.jsxs("div", {
    className: "h-full w-full relative",
    children: [
      H.jsx(lt.div, {
        className:
          "absolute top-[-50%] left-[-50%] right-[-50%] bottom-[-50%] bg-gradient-to-r from-gold/10 via-spanish/20 to-gold/10 rounded-xl blur-lg",
        animate: { opacity: [0.3, 0.6, 0.3], scale: [1, 1.03, 1] },
        transition: { duration: 4, repeat: 1 / 0, ease: "easeInOut" },
      }),
      H.jsxs("div", {
        className: "relative w-full grid  overflow-clip",
        children: [
          H.jsxs("div", {
            className:
              "relative flex flex-col grid-cols-2 justify-center p-4 md:p-6 -translate-y-7 -translate-x-7 overflow-visible",
            children: [
              H.jsxs("div", {
                className: "relative flex overflow-hidden",
                children: [
                  H.jsx("div", {
                    className: "animate-marquee whitespace-nowrap py-2",
                    children: H.jsx("span", {
                      className:
                        "text-4xl md:text-5xl font-marker text-[#ecc078] tracking-wider mx-4",
                      style: {
                        WebkitTextStroke: "1px #992b0d",
                        textShadow: "2px 2px 0 #992b0d",
                      },
                      children:
                        "Delicious • Delicious • Delicious • Delicious •",
                    }),
                  }),
                  H.jsx("div", {
                    className:
                      "absolute top-0 animate-marquee2 whitespace-nowrap py-2",
                    children: H.jsx("span", {
                      className:
                        "text-4xl md:text-5xl font-marker text-[#ecc078] tracking-wider mx-4",
                      style: {
                        WebkitTextStroke: "1px #992b0d",
                        textShadow: "2px 2px 0 #992b0d",
                      },
                      children:
                        "Delicious • Delicious • Delicious • Delicious •",
                    }),
                  }),
                ],
              }),
              H.jsxs("div", {
                className: "relative flex overflow-hidden",
                children: [
                  H.jsx("div", {
                    className: "animate-marqueeReverse whitespace-nowrap py-2",
                    children: H.jsx("span", {
                      className:
                        "text-4xl md:text-5xl font-marker text-[#ecc078] tracking-wider mx-4",
                      style: {
                        WebkitTextStroke: "1px #992b0d",
                        textShadow: "2px 2px 0 #992b0d",
                      },
                      children:
                        "South Asian • South Asian • South Asian • South Asian •",
                    }),
                  }),
                  H.jsx("div", {
                    className:
                      "absolute top-0 animate-marqueeReverse2 whitespace-nowrap py-2",
                    children: H.jsx("span", {
                      className:
                        "text-4xl md:text-5xl font-marker text-[#ecc078] tracking-wider mx-4",
                      style: {
                        WebkitTextStroke: "1px #992b0d",
                        textShadow: "2px 2px 0 #992b0d",
                      },
                      children:
                        "South Asian • South Asian • South Asian • South Asian •",
                    }),
                  }),
                ],
              }),
              H.jsxs("div", {
                className: "relative flex overflow-hidden",
                children: [
                  H.jsx("div", {
                    className: "animate-marquee whitespace-nowrap py-2",
                    children: H.jsx("span", {
                      className:
                        "text-4xl md:text-5xl font-marker text-[#ecc078] tracking-wider mx-4",
                      style: {
                        WebkitTextStroke: "1px #992b0d",
                        textShadow: "2px 2px 0 #992b0d",
                      },
                      children: "Food • Food • Food • Food •",
                    }),
                  }),
                  H.jsx("div", {
                    className:
                      "absolute top-0 animate-marquee2 whitespace-nowrap py-2",
                    children: H.jsx("span", {
                      className:
                        "text-4xl md:text-5xl font-marker text-[#ecc078] tracking-wider mx-4",
                      style: {
                        WebkitTextStroke: "1px #992b0d",
                        textShadow: "2px 2px 0 #992b0d",
                      },
                      children: "Food • Food • Food • Food •",
                    }),
                  }),
                ],
              }),
            ],
          }),
          H.jsx("div", {
            className:
              "absolute w-full h-[150px] z-20  flex items-center justify-center",
            children: H.jsx(gU, {
              shadows: !0,
              camera: { position: [0, 0, 2.5], fov: 35, near: 1e-4, far: 1e4 },
              gl: {
                antialias: !0,
                toneMapping: Eg,
                toneMappingExposure: 1.5,
                outputColorSpace: Ei,
              },
              style: {
                width: "100%",
                height: "100%",
                position: "absolute",
                zIndex: 20,
              },
              children: H.jsx(kO, {}),
            }),
          }),
        ],
      }),
    ],
  });
}
const HO = (r) =>
    H.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 620 400",
      preserveAspectRatio: "xMidYMid meet",
      fill: "none",
      className: "w-full h-full",
      ...r,
      children: [
        H.jsx("path", {
          fill: "#9D8AAB",
          fillRule: "evenodd",
          d: "M298.973 140.806c-3.908 5.876-3.428 11.64 1.441 17.292-1.435.124-2.636-.357-3.603-1.441a142.85 142.85 0 0 1-3.602-12.969c-1.64 5.051-3.081 10.576-4.323 16.572a31.018 31.018 0 0 1 7.205 8.646c6.316 1.614 13.042 2.094 20.175 1.441.971-2.523 1.451-4.924 1.441-7.205-1.783-.334-3.224-1.055-4.323-2.162 2.792-2.396 6.156-3.356 10.087-2.882 2.339 7.825-.543 13.108-8.646 15.852h-10.088c-14.067-3.611-20.791-12.739-20.175-27.38v-2.882l2.882-5.765 1.442-2.882c1.39 1.76 1.149 3.681-.721 5.765a36.373 36.373 0 0 0 0 14.41c-.429-9.215 2.693-16.902 9.367-23.057 11.39-6.76 21.717-5.319 30.983 4.323 2.749 3.9 3.95 8.223 3.603 12.97-7.962-1.94-14.686-6.022-20.175-12.249-3.362-.961-6.726-.961-10.088 0-1.269 1.02-2.229 2.222-2.882 3.603Zm12.97 4.323c-1.921.48-1.921.961 0 1.441-2.084 1.604-4.486 1.844-7.206.72-1.774-1.704-1.774-3.385 0-5.043 1.441 1.921 2.882 1.921 4.323 0 1.473.511 2.434 1.472 2.883 2.882Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#2F223B",
          fillRule: "evenodd",
          d: "M296.092 129.277c-2.206 2.053-1.726 3.013 1.441 2.882-6.673 6.155-9.796 13.841-9.367 23.057a36.378 36.378 0 0 1 0-14.411c1.871-2.083 2.111-4.004.721-5.764 1.563-3.007 3.964-4.928 7.205-5.764Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#3F3B47",
          fillRule: "evenodd",
          d: "m287.445 137.923-2.882 5.765c-2.609 2.096-5.011 1.856-7.206-.721 3.093-2.309 6.456-3.989 10.088-5.044Z",
          clipRule: "evenodd",
          opacity: 0.937,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M322.031 124.954c.189 1.262-.291 2.223-1.441 2.882-7.128-1.605-14.333-1.846-21.616-.721-1.32.401-2.28 1.122-2.882 2.162-3.241.836-5.642 2.757-7.206 5.764-.479.961-.961 1.921-1.441 2.882-3.631 1.055-6.995 2.736-10.087 5.044 2.195 2.577 4.597 2.817 7.205.721v2.882c-1.112 1.72-2.553 3.162-4.323 4.323-1.816-.431-3.497-.431-5.044 0a7.107 7.107 0 0 0-.72 4.323 44.465 44.465 0 0 1-2.882-2.882c-.875.179-1.355.659-1.442 1.441-4.758 6.929-5.238 14.134-1.441 21.616-1.412 5.514-2.612 5.514-3.602 0-.335 1.783-1.055 3.224-2.162 4.323v-5.764h-4.323v-10.087c-3.196.164-6.078 1.124-8.646 2.882 3.362-3.493 7.205-6.616 11.528-9.367l-1.441-1.441a56.476 56.476 0 0 1 7.205-10.088c3.472-1.73 6.354-4.131 8.647-7.205a29.744 29.744 0 0 1 8.646-2.882c9.491-13.425 21.979-17.028 37.468-10.808Z",
          clipRule: "evenodd",
          opacity: 0.91,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M238.448 143.688c1.041.602 1.761 1.562 2.162 2.882 1.457-1.207 3.139-1.686 5.044-1.441-4.774 7.626-8.857 15.792-12.249 24.498-2.401-1.211-2.642-.49-.721 2.161-7.192-.431-7.192-2.353 0-5.764-1.228-2.49-2.669-2.731-4.323-.72a18.625 18.625 0 0 0-.721-7.206c-2.772-2.174-4.454-5.057-5.043-8.646.665-2.581 2.347-4.022 5.043-4.323a42.062 42.062 0 0 1 10.808-1.441Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#140F18",
          fillRule: "evenodd",
          d: "M322.031 124.954c15.673 11.715 18.555 25.646 8.646 41.791-6.231 2.873-8.633 7.676-7.205 14.41-1.784-.615-3.225-.615-4.323 0v-4.323l-4.324-2.882c8.103-2.744 10.986-8.027 8.647-15.852-2.271-1.128-4.192-2.81-5.765-5.044-2.882-.961-5.764-.961-8.646 0 5.614 2.574 5.135 4.256-1.441 5.044-.493-1.207-1.453-1.689-2.882-1.441-2.289-1.644-4.21-3.806-5.764-6.485-.96-2.875-.96-5.997 0-9.367.652-1.38 1.612-2.582 2.882-3.602 3.362-.961 6.725-.961 10.087 0 5.489 6.227 12.213 10.309 20.175 12.249.347-4.747-.853-9.07-3.603-12.97-9.266-9.642-19.592-11.083-30.983-4.323-3.167.131-3.647-.829-1.441-2.882.603-1.041 1.563-1.761 2.883-2.162 7.283-1.125 14.488-.885 21.616.721 1.15-.659 1.629-1.62 1.441-2.882Zm-10.088 20.175c-1.921.479-1.921.961 0 1.441-2.084 1.604-4.486 1.844-7.205.72-1.774-1.705-1.774-3.385 0-5.044 1.441 1.921 2.882 1.921 4.323 0 1.473.512 2.434 1.473 2.882 2.883Z",
          clipRule: "evenodd",
          opacity: 0.269,
        }),
        H.jsx("path", {
          fill: "#626069",
          fillRule: "evenodd",
          d: "M320.59 153.775c.338-.86 1.059-1.34 2.161-1.441a78.254 78.254 0 0 0 9.367 3.603c-4.189 1.034-8.032.314-11.528-2.162Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M284.563 146.57c-.617 14.641 6.107 23.769 20.175 27.38l-7.206 2.882-2.882 2.882c-.295-1.902-1.016-4.303-2.161-7.205l-8.647-8.646a43.397 43.397 0 0 1-12.249 4.323 268.09 268.09 0 0 0-2.882-4.323c3.048-3.048 3.529-6.412 1.441-10.088.086-.782.566-1.262 1.441-1.441a44.718 44.718 0 0 0 2.882 2.882c1.078 3.221 2.279 2.741 3.603-1.441l1.441 1.441a7.107 7.107 0 0 0 .72-4.323c1.77-1.161 3.211-2.603 4.324-4.323Z",
          clipRule: "evenodd",
          opacity: 0.961,
        }),
        H.jsx("path", {
          fill: "#392B41",
          fillRule: "evenodd",
          d: "M298.974 140.806c-.96 3.369-.96 6.492 0 9.367 1.555 2.679 3.476 4.84 5.764 6.484.493 1.208 1.453 1.689 2.882 1.441 6.576-.788 7.056-2.47 1.441-5.043 2.882-.961 5.764-.961 8.647 0 1.572 2.233 3.493 3.915 5.764 5.043-3.931-.474-7.295.486-10.088 2.883-5.18 2.425-9.503 1.465-12.969-2.883-4.87-5.651-5.349-11.416-1.441-17.292Z",
          clipRule: "evenodd",
          opacity: 0.302,
        }),
        H.jsx("path", {
          fill: "#AE94BF",
          fillRule: "evenodd",
          d: "M300.414 158.098c3.466 4.348 7.789 5.308 12.97 2.882 1.099 1.107 2.541 1.828 4.323 2.162.01 2.281-.47 4.682-1.441 7.205-7.133.653-13.859.173-20.175-1.441a31.018 31.018 0 0 0-7.205-8.646c1.242-5.996 2.683-11.522 4.323-16.572a142.62 142.62 0 0 0 3.603 12.969c.967 1.084 2.167 1.565 3.602 1.441Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M224.038 201.33c-1.86-1.402-1.86-2.843 0-4.323-.48-1.441-1.441-2.402-2.882-2.882-1.745 1.115-1.745 2.316 0 3.602-1.399 1.736-2.841 2.456-4.323 2.162a10.446 10.446 0 0 0 2.882 3.603c-2.937 1.781-4.619 4.422-5.044 7.926l-1.441-1.441c-1.512 2.715-3.673 4.637-6.485 5.764.082-1.598.562-3.039 1.441-4.323 1.631-5.52 1.631-11.043 0-16.573.856-.668 1.817-.909 2.882-.72a66.373 66.373 0 0 1 2.162 11.528c4.127-14.098 9.171-27.547 15.131-40.35 1.654-2.01 3.096-1.769 4.323.721-7.192 3.411-7.192 5.333 0 5.764-1.921-2.651-1.68-3.372.721-2.161 3.392-8.706 7.475-16.872 12.249-24.498-1.905-.245-3.587.234-5.044 1.441-.4-1.32-1.121-2.28-2.161-2.883 5.421-4.935 8.783-3.735 10.087 3.603-4.049 5.547-7.652 11.552-10.808 18.013-3.61 12.529-8.172 24.539-13.69 36.027Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M211.068 194.125c-1.065-.189-2.026.052-2.882.721 1.631 5.529 1.631 11.053 0 16.572.154-2.708-.566-3.188-2.162-1.441a33.09 33.09 0 0 1-2.882 7.205l-1.441-25.939c-.251 6.991-.971 13.716-2.161 20.175a6171.649 6171.649 0 0 0-3.603-43.232c-1.457-1.206-3.139-1.686-5.044-1.441-2.908-8.882.456-12.964 10.088-12.249 5.043-2.965 10.087-4.645 15.131-5.044a29.439 29.439 0 0 0 2.162 7.926c-2.983 1.366-5.145 3.528-6.485 6.485-.721 10.076-.96 20.163-.721 30.262Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M258.623 173.95a12.14 12.14 0 0 0 .721 5.764c1.407 1.836 2.609 1.836 3.602 0 1.107-1.099 1.827-2.54 2.162-4.323.99 5.514 2.19 5.514 3.602 0 1.97 5.195 1.73 10.478-.72 15.852a42.526 42.526 0 0 0-3.603-6.485c-1.441-.961-2.882-.961-4.323 0a91.901 91.901 0 0 0 10.088 9.367c1.86 1.48 1.86 2.921 0 4.323-2.064 3.094-4.706 3.574-7.926 1.441-.962 1.921-.962 3.844 0 5.765 1.65.171 3.331.651 5.043 1.441.962.479 1.921.961 2.883 1.441.479.961.961 1.921 1.441 2.882a22.21 22.21 0 0 1-6.485-2.882c-1.103.101-1.823.58-2.162 1.441-9.982.578-13.344-3.746-10.087-12.97l4.323-2.161c-3.985-1.581-6.385-4.463-7.205-8.647-.662-6.306-.662-12.791 0-19.454 2.568-1.758 5.45-2.718 8.646-2.882v10.087Z",
          clipRule: "evenodd",
          opacity: 0.996,
        }),
        H.jsx("path", {
          fill: "#362F3D",
          fillRule: "evenodd",
          d: "M270.152 153.775c2.088 3.676 1.607 7.04-1.441 10.088a268.09 268.09 0 0 1 2.882 4.323 160.746 160.746 0 0 1 1.441 20.175 430.696 430.696 0 0 0 21.616-4.323v-4.324l2.882-2.882v8.647c-4.435.173-8.279 1.614-11.528 4.323-4.535.341-8.859 1.542-12.97 3.603.801.551 1.281 1.272 1.441 2.161l-1.441 2.882h-2.882c1.86-1.402 1.86-2.843 0-4.323a91.804 91.804 0 0 1-10.088-9.367c1.442-.961 2.883-.961 4.324 0a42.606 42.606 0 0 1 3.602 6.485c2.45-5.374 2.691-10.657.721-15.852-3.797-7.482-3.317-14.687 1.441-21.616Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A691B7",
          fillRule: "evenodd",
          d: "M306.179 215.741v46.114a741.49 741.49 0 0 0-3.603-41.791c-3.617 7.832-4.338 15.997-2.162 24.498a214.661 214.661 0 0 0-2.161 20.175c-.552.801-1.273 1.281-2.162 1.441V254.65l1.441-31.704v-2.882c1.186-5.011 1.907-10.295 2.162-15.852l1.441 1.441a7.115 7.115 0 0 0 .721-4.323h-18.734a26.431 26.431 0 0 0-8.647-5.764c-.16-.889-.64-1.61-1.441-2.162 4.112-2.06 8.435-3.261 12.97-3.602 4.297-.668 8.62-1.147 12.969-1.441v-11.529h7.206v38.909Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M170.718 198.448c-.203 2.26-.683 4.662-1.441 7.205 4.645 4.871 4.885 9.676.721 14.411-1.035-1.37-2.235-1.61-3.603-.72.809 2.415 2.25 4.336 4.323 5.764a10.448 10.448 0 0 0-2.882 3.603c.966 3.405 1.927 6.767 2.882 10.087-.396 3.375-1.596 3.375-3.602 0-1.888 2.013-4.05 3.454-6.485 4.323a27.68 27.68 0 0 1-8.647 1.441 96.748 96.748 0 0 0-.72 24.498c1.457 1.207 3.138 1.687 5.044 1.442.795 2.638.795 5.039 0 7.205a54.857 54.857 0 0 1-21.616.72c-1.306-2.448-1.786-5.091-1.442-7.925a7.118 7.118 0 0 0 4.324-.721c-1.634-1.464-1.155-2.425 1.441-2.882.353-2.754.353-5.636 0-8.647 2.386-2.589 3.827-5.712 4.323-9.366a5.26 5.26 0 0 0-1.441-2.162l2.882-8.646c.065-4.518.065-9.082 0-13.691 2.342-6.104 3.302-12.109 2.882-18.013a1775.186 1775.186 0 0 1 5.044-32.424c3.085-4.065 7.169-5.986 12.249-5.764 3.289 9.661 5.211 19.748 5.764 30.262Zm-12.969 7.205c.889.16 1.609.64 2.161 1.442a154.865 154.865 0 0 0 5.044 20.174 118.606 118.606 0 0 1-9.367 4.324 95.102 95.102 0 0 1 2.162-25.94Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#887F94",
          fillRule: "evenodd",
          d: "M255.741 198.448h4.324c.41 2.577-.069 4.979-1.441 7.206-2.475-1.684-3.436-4.086-2.883-7.206Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A597B0",
          fillRule: "evenodd",
          d: "m270.153 208.536-2.882-1.441c1.667-6.171 3.588-6.651 5.764-1.441-.356 1.748-1.317 2.709-2.882 2.882Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#382E3F",
          fillRule: "evenodd",
          d: "M323.472 181.155c1.547 2.571 3.948 4.253 7.205 5.044 5.862 2.195 11.386 1.954 16.572-.72 3.463.468 6.105 2.15 7.926 5.043l-1.441 1.441c5.966 1.153 10.289 4.515 12.97 10.088-1.5 6.143-5.103 8.305-10.808 6.485a27.943 27.943 0 0 1-10.088 4.323c-4.072-2.817-8.636-4.738-13.69-5.764-3.74 1.062-7.583 1.062-11.529 0v5.764c5.115-2.32 9.919-1.84 14.411 1.441-1.392 2.244-3.314 4.165-5.764 5.764-3.669-.438-7.031-.438-10.088 0-.675-5.839-2.117-11.603-4.323-17.293a236.813 236.813 0 0 1 25.939-2.161 42.526 42.526 0 0 0 3.603-6.485c.222 3.693-.499 7.296-2.162 10.808.62 2.066 1.822 3.748 3.603 5.044 2.719-2.199 4.161-5.081 4.323-8.647 2.198 3.728 5.321 4.929 9.367 3.603 2.172-1.206 2.893-2.888 2.162-5.044a120.19 120.19 0 0 1-9.367-4.323c-1.339-1.713-1.819-3.634-1.441-5.764-2.983-.074-5.625.886-7.926 2.882a96.892 96.892 0 0 0-25.219-4.323c-.409-2.76.071-5.161 1.441-7.206 1.098-.615 2.54-.615 4.324 0Z",
          clipRule: "evenodd",
          opacity: 0.82,
        }),
        H.jsx("path", {
          fill: "#6E6479",
          fillRule: "evenodd",
          d: "M270.153 198.448h2.882c1.921.961 3.362 2.403 4.323 4.323-2.657 1.015-3.378 2.936-2.162 5.765 1.035-1.371 2.235-1.61 3.603-.721a43.562 43.562 0 0 0-4.323 5.044l-2.882-1.441-1.441-2.882c1.565-.173 2.526-1.134 2.882-2.882-2.176-5.21-4.097-4.73-5.765 1.441-1.711-.79-3.393-1.27-5.043-1.441-.961-1.921-.961-3.844 0-5.765 3.221 2.133 5.862 1.653 7.926-1.441Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#38353E",
          fillRule: "evenodd",
          d: "M277.358 202.771c2.444.267 4.365 1.469 5.764 3.603l-2.882 1.441c4.211.601 8.054 2.042 11.528 4.323a110.979 110.979 0 0 0-15.851 2.162c-.875-.179-1.355-.659-1.441-1.441a43.562 43.562 0 0 1 4.323-5.044c-1.368-.889-2.568-.65-3.603.721-1.216-2.829-.496-4.75 2.162-5.765Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M274.476 195.566a26.416 26.416 0 0 1 8.646 5.764c2.756 4.835 7.079 6.997 12.97 6.485-4.081 2.75-3.601 3.95 1.441 3.603v11.528c-2.776-1.069-5.417-2.51-7.926-4.323-.967 1.084-2.167 1.565-3.603 1.441-9.993 2.215-17.679-1.148-23.057-10.087.339-.861 1.059-1.341 2.162-1.441a22.237 22.237 0 0 0 6.485 2.882l2.882 1.441c.086.782.566 1.262 1.441 1.441a110.993 110.993 0 0 1 15.852-2.162c-3.475-2.281-7.318-3.722-11.529-4.323l2.882-1.441c-1.399-2.134-3.32-3.336-5.764-3.603-.961-1.921-2.402-3.362-4.323-4.323l1.441-2.882Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#3A2E40",
          fillRule: "evenodd",
          d: "M283.122 201.33h18.734a7.112 7.112 0 0 1-.721 4.324l-1.441-1.442c-.255 5.557-.975 10.842-2.161 15.852v-8.646c-5.043.347-5.522-.853-1.441-3.603-5.891.512-10.215-1.65-12.97-6.485Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M224.039 201.33c-.274 5.09.687 9.893 2.882 14.411-.204 2.26-.683 4.662-1.441 7.205a46.232 46.232 0 0 1 5.764 3.603c-1.921.961-1.921 1.921 0 2.882-1.532 1.712-3.454 2.433-5.764 2.162.27 2.31-.45 4.232-2.162 5.764-.889-1.368-.65-2.568.721-3.603a25.71 25.71 0 0 1-7.206-7.205 7.107 7.107 0 0 0-4.323-.72c.316 1.693-.164 3.134-1.441 4.323a29.133 29.133 0 0 1-2.162-8.647c-.302 2.245-1.023 4.166-2.161 5.765-1.75-3.789-1.75-7.632 0-11.529 2.811-1.127 4.973-3.049 6.484-5.764l1.442 1.441c.425-3.503 2.106-6.145 5.043-7.926a10.448 10.448 0 0 1-2.882-3.603c1.483.294 2.924-.426 4.323-2.161-1.745-1.287-1.745-2.488 0-3.603 1.441.48 2.403 1.441 2.883 2.882-1.861 1.48-1.861 2.921 0 4.323Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#675971",
          fillRule: "evenodd",
          d: "M304.738 173.95h10.087l4.323 2.882h-5.764v90.788a1476.255 1476.255 0 0 1-1.441-92.229h-4.323v40.35h-1.441v-38.909h-7.205v11.529c-4.35.294-8.673.774-12.97 1.441 3.25-2.709 7.093-4.15 11.528-4.323v-8.647l7.206-2.882Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M104.429 222.946a936.78 936.78 0 0 1-3.603 47.556l1.441-4.324c.115 2.519 1.316 4.922 3.603 7.206 5.072-1.604 10.116-1.123 15.131 1.441l1.441-7.205c2.372 2.24 2.852 4.641 1.441 7.205 1.869-1.85 3.551-1.61 5.044.72-1.81.601-2.771 1.802-2.882 3.603h-38.91c-.609-4.018.832-6.9 4.324-8.646A325.364 325.364 0 0 0 92.9 227.27c-2.13.377-4.05-.103-5.764-1.441 4.836-7.722 11.56-14.447 20.175-20.175a10.515 10.515 0 0 1 2.882 4.323 77.437 77.437 0 0 0-5.764 12.969Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#302838",
          fillRule: "evenodd",
          d: "M297.532 222.946c-.479 10.568-.961 21.136-1.441 31.704a3068.937 3068.937 0 0 0-4.323 20.175c.053-9.422.053-19.03 0-28.822a859.74 859.74 0 0 0 2.882-16.572c-3.924-2.193-6.806-5.316-8.646-9.367 1.435.124 2.636-.357 3.603-1.441a34.925 34.925 0 0 0 7.925 4.323Z",
          clipRule: "evenodd",
          opacity: 0.408,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M226.921 215.741c8.174 14.764 15.618 30.136 22.337 46.114 2.555 2.766 4.716 5.648 6.484 8.647a130.236 130.236 0 0 1-13.69-10.088 9.811 9.811 0 0 1-2.161 4.324c-.48-.241-.962-.48-1.441-.721 1.921-.961 1.921-1.921 0-2.882 1.618-1.505 3.539-2.464 5.764-2.882a168.793 168.793 0 0 1-7.926-.721c-.902 3.59-2.103 3.59-3.603 0-.024 1.289-.506 2.73-1.441 4.323a352.53 352.53 0 0 0-15.852-31.703c-1.149.658-1.629 1.62-1.441 2.882a39.795 39.795 0 0 0-7.205-2.162c-1.836-1.407-1.836-2.609 0-3.602 1.139-1.598 1.859-3.519 2.162-5.765a29.094 29.094 0 0 0 2.161 8.647c1.277-1.189 1.757-2.63 1.441-4.323a7.112 7.112 0 0 1 4.324.72 25.723 25.723 0 0 0 7.205 7.206c-1.371 1.034-1.61 2.235-.721 3.602 1.712-1.532 2.433-3.454 2.162-5.764 2.31.271 4.232-.45 5.764-2.162-1.921-.961-1.921-1.921 0-2.882a46.109 46.109 0 0 0-5.764-3.602c.758-2.544 1.238-4.946 1.441-7.206Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A590B3",
          fillRule: "evenodd",
          d: "M319.148 176.832v4.323c-1.37 2.045-1.85 4.446-1.441 7.206a96.906 96.906 0 0 1 25.219 4.323c2.301-1.996 4.943-2.956 7.926-2.882-.378 2.13.102 4.05 1.441 5.764a120.02 120.02 0 0 0 9.367 4.323c.73 2.156.01 3.838-2.162 5.044-4.047 1.326-7.169.125-9.367-3.603-.163 3.565-1.604 6.448-4.323 8.647-1.781-1.296-2.983-2.978-3.603-5.044 1.663-3.512 2.384-7.115 2.162-10.808a42.526 42.526 0 0 1-3.603 6.485c-8.687.245-17.333.965-25.939 2.161 2.206 5.69 3.647 11.454 4.323 17.293v4.323a340.372 340.372 0 0 1 1.441 33.145 662.267 662.267 0 0 1 1.441 44.673c-3.023 1.418-5.905.938-8.646-1.441V176.832h5.764Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M208.186 211.418c-.879 1.284-1.358 2.725-1.441 4.323-1.749 3.897-1.749 7.74 0 11.529-1.836.993-1.836 2.194 0 3.602a39.83 39.83 0 0 1 7.206 2.162v1.441c-1.065-.189-2.026.052-2.882.721 1.895 7.882 1.895 15.808 0 23.777 2.253 2.99 3.694 6.352 4.323 10.088-4.966-.917-9.771.044-14.411 2.882l-1.441-1.441c1.749-2.261 4.152-3.462 7.205-3.603-2.032-.53-3.473-1.731-4.323-3.603 1.035-9.28 1.035-17.927 0-25.939 7.685-1.921 7.685-3.843 0-5.764a261.626 261.626 0 0 0-2.882-14.411v-5.764c1.19-6.459 1.911-13.184 2.162-20.175l1.441 25.939a33.14 33.14 0 0 0 2.882-7.205c1.595-1.747 2.316-1.267 2.161 1.441ZM335 214.3c9.243 2.316 15.007 8.08 17.293 17.293-1.839 1.276-1.839 2.717 0 4.323 3.301 2.339 6.184 4.982 8.646 7.926-1.255 1.965-2.696 3.646-4.323 5.043a102.734 102.734 0 0 1-2.882-5.764 10.515 10.515 0 0 0-4.323 2.882c1.075 1.781 1.555 3.704 1.441 5.765-1 2.83-1 5.473 0 7.925-1.32.401-2.28 1.122-2.882 2.162-4.946-6.189-7.347-13.395-7.206-21.616a68.68 68.68 0 0 1-17.292-7.205 29.847 29.847 0 0 0 1.441-7.206c-2.103.097-4.024-.383-5.765-1.441v-4.323c3.057-.438 6.419-.438 10.088 0 2.45-1.6 4.372-3.52 5.764-5.764Zm-2.882 8.646c1.561.056 3.002.538 4.323 1.441 1.835 1.091 1.835 2.051 0 2.882-1.79 3.447-3.71 3.207-5.764-.72 1.084-.967 1.565-2.167 1.441-3.603Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#433D4A",
          fillRule: "evenodd",
          d: "M339.323 230.152c5.41-2.062 8.533-.14 9.367 5.764-2.732-2.624-5.855-4.545-9.367-5.764Z",
          clipRule: "evenodd",
          opacity: 0.831,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M104.429 222.946c1.432 15.113 1.914 30.485 1.441 46.114 11.873 2.298 18.838-2.507 20.895-14.41 4.512-2.401 6.674-.96 6.485 4.323a308.788 308.788 0 0 0-2.161 18.734c-1.457 1.206-3.139 1.686-5.044 1.441.111-1.801 1.072-3.002 2.882-3.603-1.493-2.33-3.175-2.571-5.044-.72 1.411-2.564.931-4.965-1.441-7.206l-1.441 7.206c-5.015-2.564-10.059-3.045-15.131-1.441-2.287-2.284-3.487-4.687-3.603-7.206l-1.441 4.324a936.78 936.78 0 0 0 3.603-47.556Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#AE95BF",
          fillRule: "evenodd",
          d: "M306.178 261.855v37.468c-3.493.444-6.855-.038-10.087-1.441a13.123 13.123 0 0 1-1.441-7.205 133.58 133.58 0 0 1 1.441-24.499c.889-.16 1.61-.639 2.161-1.441a215.069 215.069 0 0 1 2.162-20.175c-2.176-8.5-1.455-16.666 2.162-24.498a742.496 742.496 0 0 1 3.602 41.791Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M394.084 158.098a47.422 47.422 0 0 0-7.205-6.485c1.921-.961 1.921-1.92 0-2.882 1.909.214 3.591-.026 5.044-.72.961 1.921 1.92 3.843 2.882 5.764a40.38 40.38 0 0 1 2.161-7.205c-3.993-1.033-7.835-1.515-11.528-1.441a6.42 6.42 0 0 0-2.162 2.882 17.842 17.842 0 0 0-3.603-5.764c-3.643 1.438-3.643 2.638 0 3.602l-1.441 1.441c3.073 1.323 4.034 3.244 2.883 5.765 2.007 1.687 3.209 3.849 3.602 6.484.611-5.317 1.813-5.558 3.603-.72-4.622 4.13-5.102 8.453-1.441 12.969a10.507 10.507 0 0 0-4.323 2.883c.43 1.902.671 4.063.72 6.484.943-1.723 1.663-1.723 2.162 0a10.448 10.448 0 0 1-2.882 3.603c.386 10.83.866 22.118 1.441 33.865-3.419 2.756-2.457 4.436 2.882 5.044-2.988.17-4.91 1.611-5.764 4.323a383.455 383.455 0 0 0 0 26.66l-2.883 7.205a6.428 6.428 0 0 0 2.883 2.162 12.145 12.145 0 0 1-5.765.72l2.162-8.646a3619.298 3619.298 0 0 0 3.603-100.154c-3.502-3.163-5.905-7.007-7.206-11.529 2.214-6.676 5.576-7.636 10.088-2.882a274.71 274.71 0 0 0 15.851 2.882c2.818 3.169 3.057 6.772.721 10.808-1.068 1.644-2.27 1.644-3.603 0-1.723.499-1.723 1.219 0 2.162-.856.668-1.817.909-2.882.72ZM420.023 152.334c15.93 4.121 30.821 10.606 44.674 19.454a2366.391 2366.391 0 0 0-3.603 7.926l-1.441-1.441c-.407 5.047-.647 9.85-.721 14.411 1.959 3.882 2.439 7.725 1.441 11.528h-1.441c-1.801.111-3.001 1.073-3.602 2.883a13.608 13.608 0 0 0-3.603-2.162 33.14 33.14 0 0 1 7.205-2.882c-2.147-4.274-5.029-4.756-8.646-1.441-.577 4.807.383 9.612 2.882 14.41-.801.552-1.281 1.273-1.441 2.162-3.227-12.168-5.868-24.658-7.926-37.468-1.233-6.196-3.875-11.481-7.926-15.851-.252-3.378-1.934-5.781-5.044-7.206-2.748-.114-5.63.366-8.646 1.441a40.553 40.553 0 0 0-2.162-5.764Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M420.023 152.334a40.767 40.767 0 0 1 2.162 5.764c3.016-1.075 5.898-1.554 8.646-1.441 3.11 1.426 4.792 3.828 5.044 7.206-2.446 3.203-4.368 6.806-5.764 10.808.338 1.258.819 2.46 1.441 3.602-3.063 28.572-4.744 56.914-5.044 85.023 2.882 3.569 4.564 7.171 5.044 10.808a13.608 13.608 0 0 0-2.162 3.603 185.843 185.843 0 0 0-22.337-2.161 5.275 5.275 0 0 1-1.441-2.162c.761-2.646 1.721-5.048 2.882-7.205-.23 2.448.009 4.85.721 7.205 5.005-.689 10.288-.689 15.852 0 1.226-3.679.746-7.041-1.441-10.088-1.1 3.694-1.82 3.694-2.162 0 .656-3.647 1.136-7.25 1.441-10.808-.961-.479-1.921-.961-2.882-1.441a246.996 246.996 0 0 0 4.323-5.043c-1.483.294-2.924-.427-4.323-2.162l1.441-1.441c-2.432-4.071-3.633-8.633-3.603-13.69-2.654 8.387-3.375 16.793-2.161 25.218-.856.669-1.817.91-2.882.721a311.865 311.865 0 0 1 2.882-33.145c-.719-4.163-2.881-5.124-6.485-2.882-5.217-2.425-10.742-3.386-16.572-2.882-.316-1.693.164-3.134 1.441-4.323a65.625 65.625 0 0 0 10.087-4.323c-3.491.514-6.855-.688-10.087-3.603 2.654.098 5.057-.143 7.205-.72a27.91 27.91 0 0 1 11.529 1.441c2.179-2.149 3.62-4.79 4.323-7.926a566.645 566.645 0 0 0-.721-33.865c-3.243-3.628-4.444-7.951-3.602-12.97 2.958-.141 5.36.82 7.205 2.882ZM477.666 208.536c-3.303 4.281-5.705 3.801-7.205-1.441 3.283-1.031 5.204-2.712 5.764-5.044a90.372 90.372 0 0 1-1.441-10.808 104.027 104.027 0 0 0-4.323-10.808 16.344 16.344 0 0 0 2.162-5.044 182.975 182.975 0 0 0 16.572 10.088c1.392 2.732 1.872 5.614 1.441 8.646-2.13-.378-4.051.102-5.764 1.441-1.614 4.926-4.017 9.249-7.206 12.97ZM394.083 158.098c-1.292 1.583-2.493 1.583-3.602 0l-.721 2.162c.512 7.283.993 15.45 1.441 24.498-1.36 2.129-3.281 3.57-5.764 4.323 1.396 2.534 3.078 3.254 5.044 2.162.73 2.156.01 3.837-2.162 5.044a20.062 20.062 0 0 0 4.323 5.764c-1.367.889-2.568.65-3.602-.721l-2.882 2.883a519.176 519.176 0 0 1-2.162 14.41 2554.747 2554.747 0 0 1-1.441-33.865 10.437 10.437 0 0 0 2.882-3.603c-.499-1.723-1.219-1.723-2.162 0-.049-2.421-.289-4.582-.72-6.484a10.507 10.507 0 0 1 4.323-2.883c-3.66-4.516-3.18-8.839 1.441-12.969-1.79-4.838-2.992-4.597-3.603.72-.393-2.635-1.595-4.797-3.602-6.484 1.151-2.521.19-4.442-2.882-5.765l1.441-1.441c-3.643-.964-3.643-2.164 0-3.602a17.856 17.856 0 0 1 3.602 5.764 6.42 6.42 0 0 1 2.162-2.882c3.693-.074 7.535.408 11.529 1.441a40.383 40.383 0 0 0-2.162 7.205l-2.882-5.764c-1.453.694-3.135.934-5.044.72 1.921.962 1.921 1.921 0 2.883a47.364 47.364 0 0 1 7.205 6.484Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M394.084 158.098c1.629 8.06 1.15 16.466-1.441 25.219.08 5.323.321 10.847.72 16.572a88.413 88.413 0 0 1 7.926 2.882c-2.149.578-4.551.819-7.205.721 3.232 2.915 6.595 4.117 10.087 3.602a65.728 65.728 0 0 1-10.087 4.324c-1.277 1.189-1.757 2.63-1.441 4.323 5.83-.504 11.355.457 16.572 2.882 3.604-2.242 5.766-1.281 6.485 2.882a619.65 619.65 0 0 1-21.616-4.323 73.775 73.775 0 0 0-2.883 18.734c-1.137-.408-2.098-1.129-2.882-2.162-.876-3.147.085-6.029 2.882-8.646-.909-3.332-.909-6.935 0-10.808-.498-1.724-1.219-1.724-2.161 0-.518 4.386-1.479 4.868-2.882 1.441-.401 1.32-1.121 2.28-2.162 2.882a518.684 518.684 0 0 0 2.162-14.411l2.882-2.882c1.035 1.371 2.235 1.61 3.603.721a20.051 20.051 0 0 1-4.324-5.765c2.172-1.206 2.893-2.887 2.162-5.043-1.966 1.092-3.647.372-5.044-2.162 2.483-.754 4.404-2.195 5.764-4.323-.448-9.049-.929-17.215-1.441-24.498l.721-2.162c1.11 1.582 2.31 1.582 3.603 0ZM519.458 231.593c-1.86 1.502-1.86 3.182 0 5.044a10.515 10.515 0 0 1-4.323 2.882c4.768 3.467 4.768 6.349 0 8.646 3.31 1.82 4.51 4.463 3.602 7.926-2.632-.872-4.553-3.274-5.764-7.205-2.47 2.053-4.391 1.573-5.764-1.441-2.692 1.689-5.335 1.448-7.926-.721 3.843-.961 3.843-1.921 0-2.882l2.162-2.162c1.872.672 4.033.672 6.484 0 .933-1.115 1.413-2.556 1.442-4.323-.535-6.178-1.976-11.942-4.324-17.293-1.859.805-3.059 2.246-3.602 4.324l-1.441-1.441c-.303 1.877-.062 3.798.72 5.764-1.024 4.33-3.186 6.732-6.485 7.205a12.153 12.153 0 0 1-.72-5.764c2.553-11.758 6.636-22.806 12.249-33.145 5.044 2.162 8.646 5.765 10.808 10.808l-1.441 1.441a771.508 771.508 0 0 1 4.323 22.337ZM474.784 191.243a90.169 90.169 0 0 0 1.441 10.808c-.561 2.332-2.482 4.013-5.765 5.044 1.501 5.242 3.903 5.722 7.206 1.441a727.254 727.254 0 0 0-11.529 30.262c.025 9.41.025 18.777 0 28.101 3.61.735 5.772 2.897 6.485 6.485a129.86 129.86 0 0 0 9.367-10.088 73.834 73.834 0 0 1 5.764 3.603c-1.8 2.629-3.48 2.388-5.044-.721-1.768 3.208-4.411 5.37-7.925 6.485l1.441 1.441c4.901-.124 9.945.597 15.131 2.162 1.772-1.117 2.252-2.558 1.441-4.323-1.035 1.37-2.235 1.609-3.603.72 1.27-1.02 2.23-2.222 2.882-3.602 1.436-.124 2.636.357 3.603 1.441a18.64 18.64 0 0 1 .721 7.205c-6.517-1.45-13.002-1.45-19.455 0-1.817-.373-3.258-1.334-4.323-2.882a10.437 10.437 0 0 1-3.603 2.882c-7.418-1.304-14.624-1.784-21.616-1.441 2.57-1.376 5.452-2.337 8.647-2.882 3.793 1.354 7.635 1.595 11.528.72-2.341-1.229-2.821-2.67-1.441-4.323-4.565-.839-5.045-2.28-1.441-4.323a176.338 176.338 0 0 1-2.882-15.852l4.323-15.852c-1.251-2.687-.769-5.329 1.441-7.925l-.72-1.442a10.505 10.505 0 0 0-2.882 4.324c-.059-3.639 1.142-7.001 3.602-10.088-3.118.476-5.76-.965-7.926-4.323a5.688 5.688 0 0 0-2.882 1.441 137.992 137.992 0 0 1 3.603-7.205 14.459 14.459 0 0 0-1.441-4.323h1.441c1.999 3.425 3.201 7.267 3.603 11.528 4.448-8.233 8.051-16.399 10.808-24.498Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M391.202 235.916a145.431 145.431 0 0 0 1.441 28.821 10.517 10.517 0 0 1 2.883 4.324c-.796 2.165-.796 4.566 0 7.205-7.915-1.114-16.081-1.114-24.499 0v-11.529h4.324a12.14 12.14 0 0 0 5.764-.72 6.42 6.42 0 0 1-2.882-2.162l2.882-7.205a383.455 383.455 0 0 1 0-26.66c.854-2.712 2.777-4.153 5.764-4.323-5.339-.608-6.3-2.289-2.882-5.044 1.04-.602 1.761-1.562 2.162-2.882 1.403 3.427 2.364 2.946 2.882-1.441.942-1.724 1.663-1.724 2.161 0-.909 3.874-.909 7.476 0 10.808-2.797 2.617-3.758 5.499-2.882 8.646.784 1.034 1.745 1.754 2.882 2.162ZM458.932 204.213a14.459 14.459 0 0 1 1.441 4.323 137.992 137.992 0 0 0-3.603 7.205 5.688 5.688 0 0 1 2.882-1.441c2.166 3.358 4.808 4.799 7.926 4.323-2.46 3.087-3.662 6.449-3.602 10.088a10.505 10.505 0 0 1 2.882-4.324l.72 1.442c-2.21 2.596-2.692 5.238-1.441 7.925l-4.323 15.852a176.338 176.338 0 0 0 2.882 15.852c-3.604 2.043-3.124 3.484 1.441 4.323-1.38 1.653-.9 3.094 1.441 4.323-3.894.875-7.735.634-11.528-.72-3.195.545-6.077 1.506-8.647 2.882-1.81.056-3.251-.664-4.323-2.162a21.989 21.989 0 0 0 2.162-6.484l4.323-1.442a33.14 33.14 0 0 0 2.882-7.205c.27-9.484.99-18.851 2.162-28.101a49.657 49.657 0 0 1-2.883-13.69c.16-.889.64-1.61 1.442-2.161-2.499-4.799-3.459-9.604-2.883-14.411 3.618-3.315 6.5-2.833 8.647 1.441a33.148 33.148 0 0 0-7.206 2.882 13.619 13.619 0 0 1 3.603 2.162c.601-1.81 1.801-2.772 3.603-2.882ZM408.495 266.178c2.31-3.439 3.751-7.283 4.323-11.528 1.065.189 2.026-.052 2.882-.721-1.213-8.426-.493-16.831 2.162-25.218-.03 5.056 1.17 9.619 3.603 13.69l-1.441 1.441c1.399 1.735 2.84 2.455 4.323 2.162a256.347 256.347 0 0 1-4.323 5.043l2.882 1.441a118.642 118.642 0 0 1-1.441 10.808c.341 3.694 1.062 3.694 2.161 0 2.188 3.047 2.668 6.409 1.441 10.088-5.564-.689-10.847-.689-15.851 0a18.625 18.625 0 0 1-.721-7.206ZM505.047 220.064c-.486 6.25-2.407 12.254-5.765 18.014a315.724 315.724 0 0 1 8.647 3.602c-2.452.672-4.613.672-6.485 0l-2.162 2.162c3.844.961 3.844 1.921 0 2.882 2.591 2.169 5.234 2.409 7.926.721 1.374 3.014 3.295 3.494 5.764 1.441 1.211 3.931 3.132 6.333 5.765 7.205.908-3.463-.293-6.106-3.603-7.926 4.769-2.297 4.769-5.179 0-8.646a10.507 10.507 0 0 0 4.323-2.883c-1.86-1.861-1.86-3.542 0-5.043a380.084 380.084 0 0 0 9.367 37.468c4.622 1.088 6.783 3.97 6.485 8.646H509.37v-7.205c2.66.4 4.582-.561 5.764-2.883a384.35 384.35 0 0 1-3.603-14.41 124.929 124.929 0 0 1-13.69-4.323c-3.585 6.222-5.507 12.946-5.764 20.175-.653 1.38-1.613 2.582-2.882 3.602 1.367.889 2.568.65 3.603-.72.811 1.765.331 3.206-1.442 4.323-5.186-1.565-10.23-2.286-15.131-2.162l-1.441-1.441c3.515-1.115 6.158-3.277 7.926-6.485 1.564 3.109 3.244 3.349 5.044.721a74.021 74.021 0 0 0-5.764-3.603c2.727-11.55 6.569-22.599 11.528-33.144a12.141 12.141 0 0 0 .721 5.764c3.298-.473 5.46-2.875 6.484-7.205-.782-1.966-1.023-3.887-.72-5.765l1.441 1.441c.543-2.078 1.744-3.519 3.603-4.323ZM170.719 198.448a786.573 786.573 0 0 0 11.528 38.189l-1.441 1.441a117.636 117.636 0 0 1 5.764 23.777c-2.534 1.976-5.417 3.417-8.646 4.323-3.643-1.438-3.643-2.638 0-3.602-1.886-2.524-1.405-4.685 1.441-6.485-1.484-.078-3.166-.559-5.044-1.441-.961-.961-.961-1.921 0-2.882.943 1.723 1.663 1.723 2.162 0-.85-1.872-2.291-3.073-4.323-3.603 1.503-3.42 1.023-6.542-1.441-9.367-.956-3.32-1.917-6.682-2.882-10.087a10.437 10.437 0 0 1 2.882-3.603c-2.074-1.428-3.515-3.349-4.323-5.764 1.367-.889 2.567-.65 3.602.72 4.165-4.735 3.924-9.54-.72-14.41.758-2.544 1.238-4.946 1.441-7.206Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#3B2C42",
          fillRule: "evenodd",
          d: "M319.148 224.387c1.741 1.058 3.662 1.538 5.765 1.442a29.839 29.839 0 0 1-1.441 7.205A974.393 974.393 0 0 1 326.354 295c-1.45.631-1.45 1.591 0 2.882h-1.441a428.968 428.968 0 0 0-4.323-40.35 340.702 340.702 0 0 0-1.442-33.145Z",
          clipRule: "evenodd",
          opacity: 0.651,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M352.293 231.593c3.746.07 6.868 1.511 9.367 4.323l5.044 18.013a78.074 78.074 0 0 1-2.882 7.926c2.836 3.034 4.277 6.636 4.323 10.808-1.569 5.656-3.731 11.18-6.485 16.573-1.627 2.364-3.788 3.805-6.485 4.323-6.972 2.865-8.413 1.423-4.323-4.323a9.793 9.793 0 0 0-4.323-2.162l2.882-1.441c-2.074-1.428-3.515-3.349-4.323-5.764 1.921-.962 1.921-1.921 0-2.883a10.515 10.515 0 0 1 4.323-2.882l-2.882-1.441c1.206-1.457 1.686-3.138 1.441-5.044 1.231-2.212 1.231-4.133 0-5.764.602-1.04 1.562-1.761 2.882-2.161-1-2.453-1-5.096 0-7.926 2.858.494 4.78-.467 5.764-2.882 1.627-1.398 3.068-3.079 4.324-5.044-2.463-2.944-5.345-5.587-8.647-7.926-1.839-1.605-1.839-3.046 0-4.323Zm1.441 41.791c4.783 1.18 5.504 3.582 2.162 7.205-3.616-1.661-4.336-4.064-2.162-7.205ZM255.741 270.502c1.117 2.72 1.117 5.602 0 8.646-6.51-.774-13.236-.774-20.175 0-2.155-6.11-3.597-11.874-4.323-17.293.935-1.594 1.417-3.035 1.441-4.323 1.5 3.59 2.701 3.59 3.603 0 2.37.278 5.013.519 7.926.721-2.225.417-4.146 1.377-5.764 2.882 1.92.961 1.92 1.921 0 2.882l1.441.72a9.802 9.802 0 0 0 2.161-4.323 130.52 130.52 0 0 0 13.69 10.088ZM199.54 217.182a262.561 262.561 0 0 1 2.882 14.411c7.685 1.921 7.685 3.843 0 5.764 1.035 8.012 1.035 16.659 0 25.939.85 1.872 2.291 3.073 4.323 3.603-3.054.141-5.456 1.342-7.205 3.603l1.441 1.441c4.64-2.838 9.445-3.799 14.41-2.882-.628-3.736-2.069-7.098-4.323-10.088 1.895-7.969 1.895-15.895 0-23.778.856-.668 1.817-.909 2.882-.72a329.152 329.152 0 0 0 2.162 27.38c1.997 4.022 4.64 7.625 7.926 10.808-1.268 1.954-1.75 4.116-1.441 6.485a318.434 318.434 0 0 1-41.791-1.441c-3.832.868-4.793 2.788-2.882 5.764-4.615.054-7.015 2.454-7.206 7.206a52.514 52.514 0 0 1-2.882-6.485c2.585-2.123 4.986-3.323 7.206-3.603-1.659-1.774-3.339-1.774-5.044 0-4.874-4.794-4.394-9.118 1.441-12.969.748-8.239-.453-16.165-3.603-23.778a18.641 18.641 0 0 0-7.205-.721c2.435-.869 4.597-2.31 6.485-4.323 2.006 3.375 3.206 3.375 3.602 0 2.465 2.825 2.944 5.947 1.441 9.367 2.032.53 3.473 1.731 4.324 3.603-.499 1.723-1.22 1.723-2.162 0-.961.961-.961 1.921 0 2.882 1.878.882 3.559 1.363 5.044 1.441-2.846 1.8-3.328 3.961-1.441 6.485-3.643.964-3.643 2.164 0 3.602 3.229-.906 6.111-2.347 8.646-4.323a453.518 453.518 0 0 1 5.044 7.206l1.441-1.441 2.882 8.646c1.038-2.323.798-4.485-.72-6.485a10.051 10.051 0 0 0 5.043-3.603c.605-16.34.366-32.671-.72-48.996Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#110419",
          fillRule: "evenodd",
          d: "M313.384 267.619v33.145h-4.323c.474-19.95-.006-39.644-1.441-59.084v-66.289h4.323c-.477 30.993.005 61.735 1.441 92.228Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#463B4E",
          fillRule: "evenodd",
          d: "M296.092 254.65v11.528a133.58 133.58 0 0 0-1.441 24.499c-.946 1.616-1.426 3.537-1.441 5.764.122 2.641 1.083 4.562 2.882 5.764-3.207 1.803-6.328 1.323-9.367-1.441-4.609 5.698-7.252 5.218-7.926-1.441 2.102.097 4.023-.383 5.764-1.441 2.186.016 3.868.976 5.044 2.882-.245-8.169.475-16.816 2.161-25.939a3067.931 3067.931 0 0 1 4.324-20.175Z",
          clipRule: "evenodd",
          opacity: 0.569,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M347.969 267.62c.245 1.905-.235 3.586-1.441 5.043.961.48 1.921.962 2.882 1.441a10.507 10.507 0 0 0-4.323 2.883c1.921.961 1.921 1.921 0 2.882.808 2.415 2.249 4.336 4.323 5.764l-2.882 1.441a9.793 9.793 0 0 1 4.323 2.162c-4.09 5.747-2.649 7.188 4.323 4.323-1.912 11.557-8.637 18.763-20.175 21.616.962-3.362 1.921-6.726 2.882-10.088 1.052-1.746 2.494-3.187 4.324-4.323a10.515 10.515 0 0 0-2.882-4.323 63.539 63.539 0 0 1-8.647 5.764h-4.323v-4.323c-1.45-1.291-1.45-2.251 0-2.882 4.16-3.678 8.963-6.078 14.411-7.205-.003-7.663 2.399-14.388 7.205-20.175Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#705D7B",
          fillRule: "evenodd",
          d: "M320.59 257.532a428.968 428.968 0 0 1 4.323 40.35c-.879 1.284-1.359 2.725-1.441 4.323h-1.441a662.267 662.267 0 0 0-1.441-44.673Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#9686A3",
          fillRule: "evenodd",
          d: "M200.981 300.764h-1.441c-2.853-1.752-5.736-2.953-8.647-3.602 5.608 7.58 12.333 14.064 20.175 19.454.48.961.962 1.921 1.441 2.882l17.293 10.088c-4.013-.842-6.415.599-7.205 4.323a102.114 102.114 0 0 1-15.852-12.97 674.492 674.492 0 0 1-27.38-28.821c-1.218-3.26-3.139-4.221-5.764-2.882 1.014-2.658 2.935-3.378 5.764-2.162 8.227 3.228 15.432 7.792 21.616 13.69Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#90819B",
          fillRule: "evenodd",
          d: "M306.179 215.741h1.441v85.023c-4.158-.441-8.001.039-11.529 1.441-1.798-1.202-2.76-3.122-2.882-5.764.016-2.226.496-4.147 1.441-5.764a13.123 13.123 0 0 0 1.441 7.205c3.232 1.404 6.594 1.885 10.088 1.441v-83.582Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M284.563 297.882c-1.741 1.058-3.662 1.537-5.764 1.441.674 6.659 3.317 7.139 7.926 1.441 3.039 2.764 6.16 3.244 9.366 1.441a44.857 44.857 0 0 1 15.852 1.441 221.944 221.944 0 0 0-23.057 5.764c-3.105-.184-5.988.536-8.646 2.162l2.882 1.441c-1.861 1.862-1.861 3.542 0 5.044-.493 1.207-1.453 1.689-2.882 1.441-1.1-1.107-2.541-1.827-4.323-2.162a9.813 9.813 0 0 0 4.323-2.161l-1.441-1.441-10.088 2.882a44.718 44.718 0 0 0-2.882-2.882c.189-1.065-.052-2.027-.721-2.883-1.02 1.27-2.222 2.23-3.602 2.883-.391-2.782-1.832-4.704-4.323-5.765 1.119-3.764 3.522-6.405 7.205-7.926 6.855-2.408 13.581-3.128 20.175-2.161Zm-8.646 7.205c4.252 3.998 3.291 6.4-2.883 7.206-3.48-.316-4.921-2.237-4.323-5.765 2.76.41 5.161-.07 7.206-1.441Z",
          clipRule: "evenodd",
          opacity: 0.976,
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M307.62 241.68c1.435 19.44 1.915 39.134 1.441 59.084h4.323c2.741 2.379 5.623 2.859 8.646 1.441h1.441c-3.952 3.398-8.757 5.319-14.41 5.764v5.765a59.859 59.859 0 0 0 11.528 1.441c-.929 1.89-2.37 3.331-4.323 4.323a118.02 118.02 0 0 0-1.441 25.939c-1.424-7.407-1.904-15.094-1.441-23.057h-4.323c.471 14.672-.009 29.082-1.441 43.232v-46.114c1.262.189 2.223-.291 2.882-1.441a358.34 358.34 0 0 1-10.088-2.882h7.206v-8.647h-7.206c.342 1.861-.138 3.302-1.441 4.323-3.218.225-6.581-.256-10.087-1.441a221.88 221.88 0 0 1 23.057-5.764 44.857 44.857 0 0 0-15.852-1.441c3.528-1.402 7.371-1.882 11.529-1.441V241.68Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#67606C",
          fillRule: "evenodd",
          d: "M199.54 300.764h1.441a14.599 14.599 0 0 1 5.764 2.162 91.9 91.9 0 0 0 10.088 9.367c-.879 2.787-2.32 5.189-4.323 7.205-.48-.961-.962-1.921-1.441-2.882 2.284-.724 3.004-2.165 2.161-4.323a312.192 312.192 0 0 0-13.69-11.529Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#201B25",
          fillRule: "evenodd",
          d: "M177.924 283.471a42.593 42.593 0 0 1 12.97 5.044 167.263 167.263 0 0 1 26.659 19.454c1.577 2.274 2.779 4.677 3.603 7.206l-4.323-2.882a91.9 91.9 0 0 1-10.088-9.367 14.599 14.599 0 0 0-5.764-2.162c-6.183-5.898-13.389-10.462-21.616-13.69-2.829-1.216-4.75-.496-5.764 2.161a152.278 152.278 0 0 0 20.175 36.748l8.646 2.161a170.21 170.21 0 0 0 21.616 15.852l-5.764-1.441a12279.22 12279.22 0 0 1-27.38-14.411 140.472 140.472 0 0 1-20.175-37.467c.19-4.752 2.591-7.152 7.205-7.206Z",
          clipRule: "evenodd",
          opacity: 0.525,
        }),
        H.jsx("path", {
          fill: "#050507",
          fillRule: "evenodd",
          d: "M444.521 282.03c1.722.528 2.682 1.728 2.882 3.603-4.388 15.745-11.593 29.915-21.616 42.511a55.162 55.162 0 0 1-11.528 4.324c.15-3.564 1.591-4.524 4.323-2.882 2.85-1.878 2.85-4.279 0-7.206-3.493 1.33-6.375 3.492-8.646 6.485a7.12 7.12 0 0 1-4.324.721c3.982-4.45 8.786-7.814 14.411-10.088l2.882-5.764a147.357 147.357 0 0 1 14.411-12.97c2.081-3.038 3.04-6.4 2.882-10.087l2.882-4.324c1.303-1.021 1.783-2.462 1.441-4.323Z",
          clipRule: "evenodd",
          opacity: 0.527,
        }),
        H.jsx("path", {
          fill: "#17101E",
          fillRule: "evenodd",
          d: "M199.54 300.764a312.192 312.192 0 0 1 13.69 11.529c.843 2.158.123 3.599-2.161 4.323-7.843-5.39-14.568-11.875-20.175-19.455 2.911.65 5.793 1.851 8.646 3.603Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#9C8FA9",
          fillRule: "evenodd",
          d: "M300.414 315.175c-3.308-.438-3.788-1.879-1.441-4.323 1.303-1.022 1.783-2.463 1.441-4.324h7.206v8.647h-7.206Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M324.912 297.882h1.441v4.323h4.324c1.439 3.853 3.841 4.815 7.205 2.882L335 315.175c-1.539 1.346-3.46 1.827-5.764 1.441-.591 7.446.37 14.651 2.882 21.616 1.189 1.277 2.63 1.756 4.323 1.441 1.099 1.107 2.54 1.827 4.323 2.161a26.584 26.584 0 0 1-8.646.721c-2.411-1.215-4.093-3.136-5.044-5.764a492.409 492.409 0 0 1-2.162-21.616c-.16-.889-.64-1.61-1.441-2.162a42.478 42.478 0 0 0 6.485-3.603c.991-1.199.751-2.158-.72-2.882a38.684 38.684 0 0 1-8.647 5.044c-1.582 1.11-1.582 2.31 0 3.603a59.859 59.859 0 0 1-11.528-1.441v-5.765c5.653-.445 10.457-2.366 14.41-5.764.082-1.598.562-3.039 1.441-4.323Z",
          clipRule: "evenodd",
          opacity: 0.998,
        }),
        H.jsx("path", {
          fill: "#504756",
          fillRule: "evenodd",
          d: "M324.913 315.175h-4.323c-1.582-1.293-1.582-2.493 0-3.603a38.654 38.654 0 0 0 8.646-5.044c1.472.724 1.712 1.683.721 2.882a42.478 42.478 0 0 1-6.485 3.603c.801.552 1.281 1.273 1.441 2.162Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "M257.182 307.969c2.492 1.061 3.933 2.983 4.324 5.765-2.805 1.086-4.005 3.009-3.603 5.764 3.123-1.424 5.764-3.345 7.926-5.764a44.718 44.718 0 0 1 2.882 2.882l10.087-2.882 1.441 1.441a9.802 9.802 0 0 1-4.323 2.161c1.783.335 3.224 1.055 4.323 2.162-6.36 1.876-12.606 2.356-18.733 1.441-.75 5.816-3.632 10.38-8.647 13.69 3.609 1.006 6.971 2.206 10.088 3.603H254.3a240.287 240.287 0 0 1-20.175-8.647c-.406-1.841-1.367-3.282-2.882-4.323 3.758-5.205 8.082-10.008 12.97-14.411 4.386-2.301 8.71-3.262 12.969-2.882Zm-10.087 11.529c1.624.896 3.065 2.097 4.323 3.603a16.627 16.627 0 0 0-5.044 6.484 29.559 29.559 0 0 1-3.602-5.043c1.743-1.498 3.184-3.179 4.323-5.044Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#201827",
          fillRule: "evenodd",
          d: "M288.886 309.411c3.507 1.184 6.87 1.665 10.088 1.441-2.348 2.444-1.868 3.885 1.441 4.323 3.167.958 6.529 1.919 10.087 2.882-.658 1.15-1.619 1.63-2.882 1.441-5.912 1.053-10.956-.388-15.131-4.323a82.9 82.9 0 0 1-4.323 24.498l-2.162 2.162a122.39 122.39 0 0 1-18.734.72c-4.734-.617-9.057-2.058-12.969-4.323h8.646c7.217 1.574 14.422 1.574 21.616 0a38.63 38.63 0 0 1 4.323-9.367c-1.369-3.505-1.369-7.107 0-10.808h-5.764c-1.86-1.502-1.86-3.182 0-5.044l-2.882-1.441c2.659-1.625 5.541-2.346 8.646-2.161Z",
          clipRule: "evenodd",
          opacity: 0.063,
        }),
        H.jsx("path", {
          fill: "#4A474E",
          fillRule: "evenodd",
          d: "M265.829 313.734c-2.162 2.419-4.803 4.34-7.926 5.764-.402-2.755.798-4.678 3.602-5.764 1.381-.653 2.583-1.613 3.603-2.882.669.856.909 1.817.721 2.882Z",
          clipRule: "evenodd",
          opacity: 0.945,
        }),
        H.jsx("path", {
          fill: "#9488A0",
          fillRule: "evenodd",
          d: "m443.08 286.353-2.882 4.324c-11.611 15.452-25.542 28.422-41.791 38.908-.984-2.415-2.907-3.376-5.764-2.882a129.515 129.515 0 0 1 10.808-5.764c-.039-2.762-1.241-5.165-3.603-7.205 12.17-12.095 26.101-21.703 41.791-28.822.875.179 1.355.659 1.441 1.441Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#1A1223",
          fillRule: "evenodd",
          d: "M424.346 296.441c1.065-.189 2.027.052 2.883.72a126.305 126.305 0 0 1-18.734 18.734c-3.734.434-4.936-1.248-3.603-5.043a142.644 142.644 0 0 0 19.454-14.411Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#110B16",
          fillRule: "evenodd",
          d: "M179.364 292.118a675.138 675.138 0 0 0 27.381 28.821c.887 1.871.887 3.312 0 4.323-5.913 1.054-10.957-.387-15.132-4.323a297.098 297.098 0 0 1-12.969-24.498c-1.067-1.8-.826-3.241.72-4.323Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#140F1B",
          fillRule: "evenodd",
          d: "M440.199 290.677c.158 3.687-.802 7.049-2.883 10.087a147.23 147.23 0 0 0-14.41 12.97l-2.882 5.764c-5.625 2.274-10.429 5.637-14.411 10.087a118.795 118.795 0 0 0-14.411 9.367c3.501.65 3.741 1.852.721 3.603a5.688 5.688 0 0 0-2.882-1.441c-7.554 3.886-14.999 6.287-22.337 7.205a15259.436 15259.436 0 0 1 31.704-18.734c16.249-10.486 30.18-23.456 41.791-38.908Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#65616C",
          fillRule: "evenodd",
          d: "M179.365 292.118c-1.546 1.082-1.787 2.523-.721 4.323a296.804 296.804 0 0 0 12.97 24.498c4.175 3.936 9.218 5.377 15.131 4.323v1.441c-1.86-.341-3.301.139-4.323 1.441-2.856-.713-5.738-1.433-8.646-2.161a152.256 152.256 0 0 1-20.175-36.747c2.625-1.339 4.546-.378 5.764 2.882Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#907F9C",
          fillRule: "evenodd",
          d: "M307.62 319.498v7.205c-.961 0-1.441.48-1.441 1.441-1.079-1.485-2.039-3.167-2.882-5.043-3.46-1.498-6.822-1.738-10.087-.721.903 1.322 1.385 2.763 1.441 4.323-1.486 3.547-2.447 7.389-2.882 11.529-2.538 5.134-6.861 7.777-12.97 7.926 2.843.713 5.725.954 8.646.72-4.04 1.64-8.363 1.881-12.969.721-1.999-2.425-4.4-4.107-7.205-5.044 6.262.239 12.507-.001 18.733-.72l2.162-2.162a82.9 82.9 0 0 0 4.323-24.498c4.175 3.935 9.219 5.376 15.131 4.323Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#3B2F41",
          fillRule: "evenodd",
          d: "m216.833 312.293 4.323 2.882c-1.314 1.784-1.555 3.706-.72 5.764a63.673 63.673 0 0 1 10.808 4.323c1.514 1.041 2.475 2.482 2.882 4.324h-4.323l-17.293-10.088c2.003-2.016 3.444-4.418 4.323-7.205Z",
          clipRule: "evenodd",
          opacity: 0.582,
        }),
        H.jsx("path", {
          fill: "#251830",
          fillRule: "evenodd",
          d: "M206.745 320.939a102.114 102.114 0 0 0 15.852 12.97 160.548 160.548 0 0 0 28.821 20.895 246.908 246.908 0 0 0 23.057 10.808c-2.304-.386-4.225.095-5.764 1.441a619.566 619.566 0 0 1-34.586-19.454 231.792 231.792 0 0 0-27.38-20.896v-1.441c.888-1.011.888-2.453 0-4.323Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#51405E",
          fillRule: "evenodd",
          d: "M294.651 326.703c.451 5.105-.031 9.908-1.441 14.411.247-1.429-.234-2.389-1.441-2.882.435-4.14 1.396-7.982 2.882-11.529Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A58FB2",
          fillRule: "evenodd",
          d: "M392.643 326.703c2.858-.494 4.78.467 5.764 2.882a15996.785 15996.785 0 0 0-31.703 18.734 29.79 29.79 0 0 1-7.206 1.441 739.853 739.853 0 0 1 4.324-5.764l-4.324-1.441-18.733 2.882c-3.221.425-6.103-.056-8.647-1.441a129.739 129.739 0 0 0 25.939-3.603 217.593 217.593 0 0 1 34.586-13.69Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A790B6",
          fillRule: "evenodd",
          d: "M294.65 326.703c1.653 5.975 1.894 12.221.721 18.734-3.421 1.63-6.064 4.032-7.926 7.206a166.477 166.477 0 0 1-38.909-12.249c-3.679-1.227-7.041-.747-10.088 1.441a205.761 205.761 0 0 0 18.734 12.969c5.848-.24 10.651 1.68 14.411 5.764a263.147 263.147 0 0 1 18.734 3.603c2.084 2.075 4.725 3.036 7.926 2.882 2.389-.252 4.31-1.213 5.764-2.882a241.814 241.814 0 0 0 2.162-36.027c0-.961.48-1.441 1.441-1.441v38.909c-1.48 2.441-3.403 4.362-5.765 5.764-9.571-.087-18.697-2.01-27.38-5.764a246.534 246.534 0 0 1-23.057-10.808 160.512 160.512 0 0 1-28.821-20.895c.789-3.724 3.192-5.165 7.205-4.323h4.323a240.283 240.283 0 0 0 20.175 8.646c3.913 2.265 8.236 3.706 12.97 4.323 2.806.937 5.206 2.619 7.205 5.044 4.606 1.16 8.929.919 12.97-.721a16.552 16.552 0 0 0 5.764-5.764c1.411-4.503 1.892-9.306 1.441-14.411Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A090AD",
          fillRule: "evenodd",
          d: "M320.59 315.175h4.323a492.403 492.403 0 0 0 2.161 21.616c.951 2.628 2.633 4.549 5.044 5.764v1.441c-2.724.293-4.885-.667-6.485-2.882a75.722 75.722 0 0 1-2.161-10.087 74.416 74.416 0 0 0-1.441-10.088c-1.906-.245-3.587.235-5.044 1.441a130.375 130.375 0 0 0 0 27.38c4.59 5.619 10.593 8.021 18.013 7.206-5.009 1.647-10.292 1.888-15.852.72-3.782-3.164-5.223-7.248-4.323-12.249a118.024 118.024 0 0 1 1.441-25.939c1.953-.991 3.394-2.433 4.324-4.323Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#352B3C",
          fillRule: "evenodd",
          d: "M444.522 282.03c.341 1.861-.139 3.302-1.442 4.323-.086-.782-.566-1.262-1.441-1.441-15.69 7.119-29.621 16.727-41.791 28.822 2.362 2.04 3.564 4.442 3.603 7.205a129.673 129.673 0 0 0-10.808 5.764 217.593 217.593 0 0 0-34.586 13.69 129.739 129.739 0 0 1-25.939 3.603v-1.441a26.592 26.592 0 0 0 8.647-.72c-1.783-.335-3.224-1.055-4.324-2.162 12.591-.2 23.879-3.083 33.865-8.646a697.955 697.955 0 0 1 28.101-11.529c-3.615-6.093-2.174-11.137 4.324-15.131 12.486-9.967 26.177-17.893 41.07-23.778.575.329.814.81.721 1.441Z",
          clipRule: "evenodd",
          opacity: 0.41,
        }),
        H.jsx("path", {
          fill: "#362542",
          fillRule: "evenodd",
          d: "M323.471 331.027a75.88 75.88 0 0 0 2.161 10.087c1.6 2.215 3.762 3.175 6.485 2.882 2.544 1.385 5.426 1.866 8.647 1.441-14.887 6.015-20.651 1.211-17.293-14.41Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#040506",
          fillRule: "evenodd",
          d: "M414.259 332.468c-19.075 15.344-39.73 28.314-61.966 38.908-1.179-4.427-2.86-4.906-5.044-1.441-3.784-.805-7.386-2.485-10.808-5.043 3.878-.225 7.24-1.426 10.088-3.603 5.361-4.457 11.605-7.339 18.734-8.646 1.277-1.189 1.756-2.63 1.441-4.324 7.338-.918 14.782-3.318 22.336-7.205a5.687 5.687 0 0 1 2.883 1.441c3.02-1.751 2.779-2.953-.721-3.603a118.76 118.76 0 0 1 14.411-9.367 7.107 7.107 0 0 0 4.323-.72c2.271-2.993 5.153-5.155 8.646-6.485 2.851 2.927 2.851 5.328 0 7.205-2.732-1.641-4.173-.681-4.323 2.883Z",
          clipRule: "evenodd",
          opacity: 0.489,
        }),
        H.jsx("path", {
          fill: "#1D1029",
          fillRule: "evenodd",
          d: "M291.768 338.232c1.208.493 1.689 1.453 1.442 2.882a16.563 16.563 0 0 1-5.765 5.764 26.584 26.584 0 0 1-8.646-.72c6.109-.149 10.432-2.792 12.969-7.926Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#AF94C3",
          fillRule: "evenodd",
          d: "M306.179 328.144a241.68 241.68 0 0 1-2.162 36.027c-1.454 1.669-3.375 2.63-5.764 2.882-3.201.154-5.842-.807-7.926-2.882a118.385 118.385 0 0 0-4.323-3.603c11.873-1.738 12.354-3.179 1.441-4.323l4.323-1.441c-1.782-.334-3.223-1.055-4.323-2.161 1.862-3.174 4.505-5.576 7.926-7.206 1.173-6.513.932-12.759-.721-18.734-.056-1.56-.537-3.001-1.441-4.323 3.266-1.017 6.628-.777 10.088.721.843 1.876 1.803 3.558 2.882 5.043Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#B094C2",
          fillRule: "evenodd",
          d: "M287.445 352.643c1.099 1.106 2.54 1.827 4.323 2.161l-4.323 1.441c10.913 1.144 10.431 2.585-1.442 4.323a117.601 117.601 0 0 1 4.324 3.603 263.147 263.147 0 0 0-18.734-3.603c-3.76-4.084-8.563-6.005-14.411-5.764a205.761 205.761 0 0 1-18.734-12.969c3.047-2.188 6.409-2.668 10.088-1.442a166.417 166.417 0 0 0 38.909 12.25Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#A890B9",
          fillRule: "evenodd",
          d: "M323.472 331.027c-3.357 15.621 2.407 20.425 17.293 14.41l18.734-2.882 4.323 1.441a739.436 739.436 0 0 0-4.323 5.764c-7.254 4.824-15.421 7.226-24.498 7.206-7.42.815-13.424-1.587-18.014-7.206a130.375 130.375 0 0 1 0-27.38c1.457-1.206 3.139-1.686 5.044-1.441a74.101 74.101 0 0 1 1.441 10.088Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#857B8C",
          fillRule: "evenodd",
          d: "M202.422 328.144c1.022-1.302 2.463-1.782 4.323-1.441a231.792 231.792 0 0 1 27.38 20.896 619.566 619.566 0 0 0 34.586 19.454c14.526 5.436 26.536 14.082 36.027 25.94-.087.782-.567 1.262-1.441 1.441a311.15 311.15 0 0 0-18.734-16.573c-20.698-9.38-40.392-20.188-59.084-32.424 0-.961-.48-1.441-1.441-1.441a170.14 170.14 0 0 1-21.616-15.852Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#120C17",
          fillRule: "evenodd",
          d: "M314.825 345.437c-.901 5.001.54 9.085 4.323 12.249 5.56 1.168 10.843.927 15.852-.72 9.077.02 17.244-2.382 24.498-7.206a29.751 29.751 0 0 0 7.206-1.441c.315 1.694-.165 3.135-1.442 4.324-7.128 1.307-13.373 4.189-18.733 8.646-7 .697-13.966 1.659-20.896 2.882-4.512-3.337-9.556-5.258-15.131-5.764-.097 2.102.383 4.023 1.441 5.764-.404 6.138-3.767 8.54-10.088 7.205 2.362-1.402 4.285-3.323 5.765-5.764 1.432-14.15 1.912-28.56 1.441-43.232h4.323c-.463 7.963.017 15.65 1.441 23.057Z",
          clipRule: "evenodd",
        }),
        H.jsx("path", {
          fill: "#fff",
          fillRule: "evenodd",
          d: "m218.273 342.555 5.764 1.441c.962 0 1.441.48 1.441 1.441.407 1.842 1.368 3.283 2.883 4.324-3.481 3.013-4.201 6.375-2.162 10.087.334-1.783 1.055-3.224 2.162-4.323 0 .961.48 1.441 1.441 1.441-.189 1.262.291 2.223 1.441 2.882a21.403 21.403 0 0 0 5.044-5.764c.334 1.782 1.054 3.223 2.161 4.323-3.712 8.76-9.956 10.922-18.734 6.485-5.634-6.621-5.634-13.346 0-20.175-.801-.552-1.281-1.273-1.441-2.162Z",
          clipRule: "evenodd",
          opacity: 0.916,
        }),
        H.jsx("path", {
          fill: "#29222E",
          fillRule: "evenodd",
          d: "M225.479 345.437c18.693 12.236 38.386 23.044 59.084 32.424a310.844 310.844 0 0 1 18.734 16.573c.875-.179 1.355-.659 1.441-1.441.783.086 1.263.566 1.441 1.441-1.602 1.102-2.563 2.543-2.882 4.323a170.935 170.935 0 0 0-24.498-20.896 260.183 260.183 0 0 1-40.35-19.454c-1.107-1.1-1.827-2.541-2.161-4.323a21.403 21.403 0 0 1-5.044 5.764c-1.15-.659-1.63-1.62-1.441-2.882-.961 0-1.441-.48-1.441-1.441.652-1.381 1.612-2.583 2.882-3.603-1.32-.401-2.28-1.121-2.882-2.162-1.515-1.04-2.476-2.481-2.883-4.323Z",
          clipRule: "evenodd",
          opacity: 0.643,
        }),
        H.jsx("path", {
          fill: "#040508",
          fillRule: "evenodd",
          d: "M346.528 361.289c-2.847 2.177-6.209 3.378-10.087 3.603 3.421 2.557 7.023 4.238 10.808 5.043 2.183-3.465 3.865-2.986 5.043 1.441-13.756 5.671-25.764 13.837-36.026 24.499 1.935-3.489 3.376-7.092 4.323-10.808l-4.323-1.442a21.21 21.21 0 0 0 7.205-2.161c-2.627-4.787-6.23-8.631-10.808-11.529a12.152 12.152 0 0 1-.721-5.764c-1.057-1.741-1.537-3.662-1.441-5.764 5.576.506 10.62 2.426 15.132 5.764a279.654 279.654 0 0 1 20.895-2.882Z",
          clipRule: "evenodd",
          opacity: 0.82,
        }),
        H.jsx("path", {
          fill: "#0A080F",
          fillRule: "evenodd",
          d: "M311.943 364.171a12.14 12.14 0 0 0 .721 5.764c4.578 2.898 8.18 6.742 10.808 11.529a21.233 21.233 0 0 1-7.206 2.162c1.441.479 2.882.961 4.323 1.441-.946 3.716-2.387 7.319-4.323 10.808-3.522 4.259-7.845 5.221-12.969 2.882.318-1.78 1.279-3.221 2.882-4.323-.179-.875-.659-1.355-1.441-1.441-9.491-11.858-21.501-20.504-36.027-25.94 1.539-1.346 3.46-1.827 5.764-1.441 8.683 3.754 17.809 5.677 27.381 5.764 6.32 1.335 9.683-1.067 10.087-7.205Z",
          clipRule: "evenodd",
        }),
        H.jsxs("mask", {
          id: "a",
          width: 620,
          height: 142,
          x: 0,
          y: -1,
          fill: "#000",
          maskUnits: "userSpaceOnUse",
          children: [
            H.jsx("path", { fill: "#fff", d: "M0-1h620v142H0z" }),
            H.jsx("path", {
              d: "M31.405 24.788c5.691-.527 11.466 1.032 17.131 4.65 5.557 3.51 10.396 8.668 14.461 15.481 3.912 6.768 6.67 14.62 8.252 23.557 1.376 9.194.762 18.034-1.767 26.618-2.689 8.558-6.446 15.788-11.184 21.729-4.897 5.908-9.596 9.507-13.917 10.72-2.042.584-4 .937-5.87 1.078-3.06.494-5.339.988-6.907 1.462a360.73 360.73 0 0 0-8.15 2.688 789.04 789.04 0 0 1 4.45-7.743 190.01 190.01 0 0 0 7.157-11.368c4.088-24.994-1.41-49.326-16.497-72.994a2211.19 2211.19 0 0 1-7.164-3.587A163.13 163.13 0 0 1 4 28.81c2.57-.29 5.313-.587 8.232-.89a98.009 98.009 0 0 0 12.087-1.957c3.2-.636 5.576-1.033 7.086-1.174Zm15.85 90.469c2.58-.718 5.013-2.88 7.196-6.479 2.157-3.554 3.732-8.148 4.66-13.748.833-5.601.82-11.696-.083-18.31-1.35-7.948-3.431-14.967-6.19-21.12-2.964-6.248-6.434-11.104-10.332-14.55-4.02-3.573-8.04-5.132-11.83-4.695-1.915.224-3.124 1.424-3.547 3.605 9.7 24.627 14.295 49.563 13.783 74.81 1.568 1.084 3.68 1.251 6.286.507a.24.24 0 0 1 .058-.02Zm98.163-15.615c-9.193 2.365-18.373 4.733-27.54 7.102-.136-2.048-.277-4.099-.422-6.152 2.513-3.037 5.029-6.056 7.547-9.059a2471.2 2471.2 0 0 0-6.017-15.403 14386.58 14386.58 0 0 0-22.982 4.625c-.798 5.45-1.628 10.91-2.49 16.385 3.947 1.835 7.895 3.64 11.843 5.415-.606 2.639-1.221 5.28-1.844 7.923-7.883 2.057-15.735 4.114-23.558 6.172-.107-2.194-.22-4.393-.34-6.595l7.087-11.433a2868.039 2868.039 0 0 0 9.027-74.887c4.314-2.399 8.657-4.775 13.027-7.127 11.028 24.64 21.281 48.673 30.76 72.102a1126.14 1126.14 0 0 0 7.97 3.548c-.687 2.46-1.377 4.92-2.068 7.384Zm-43.723-64.109a5763.681 5763.681 0 0 1-4.398 35.862c6.12-1.124 12.268-2.254 18.443-3.387a1659.945 1659.945 0 0 0-14.045-32.475ZM204.46 23.228c.559 20.654.967 40.986 1.223 60.998l-6.408 1.63a4412.659 4412.659 0 0 1-38.365-45.588 2861.052 2861.052 0 0 1 2.887 42.637c3.64.94 7.272 1.869 10.895 2.784-.717 2.327-1.431 4.657-2.144 6.993-7.191 1.839-14.378 3.68-21.561 5.523-.102-1.92-.207-3.845-.313-5.774 2.185-3.276 4.372-6.537 6.561-9.783a2933.22 2933.22 0 0 0-4.321-54.576c-3.184-1.817-6.38-3.65-9.589-5.498.635-2.412 1.276-4.82 1.92-7.224 4.788-.444 9.577-.891 14.365-1.34a8576.72 8576.72 0 0 0 39.197 46.96 4705.484 4705.484 0 0 0-1.338-38.832 2760.548 2760.548 0 0 1-11.734-3.958l2.318-6.807c7.908-.723 15.816-1.441 23.724-2.156l.141 5.447a1405.895 1405.895 0 0 0-7.458 8.565Zm51.13-19.695c3.175-.256 6.849-.083 11.017.52 4.218.597 7.272 1.334 9.173 2.232-.397 6.446-.8 12.784-1.21 19.016-2.518.218-5.036.442-7.554.673-3.655-8.154-9.179-12.016-16.465-11.355-2.97.282-5.71 1.604-8.226 4.003-2.503 2.393-4.493 5.537-5.972 9.418-1.421 3.85-2.158 8.064-2.215 12.6-.071 5.075.525 9.591 1.773 13.53 1.28 3.804 3.252 6.633 5.902 8.494 2.644 1.745 5.967 2.162 9.993 1.296 4.577-.969 11.273-4.895 20.172-11.484.883 1.437 1.76 2.857 2.631 4.26-4.93 4.44-9.822 9.01-14.679 13.71-2.228 1.212-4.372 2.194-6.415 2.919a57.705 57.705 0 0 1-6.427 2.027c-5.556 1.424-10.441 1.258-14.691-.552-4.277-1.88-7.599-5.17-9.974-9.867-2.414-4.85-3.643-10.745-3.668-17.661-.052-7.166 1.786-14.101 5.563-20.722 3.828-6.665 8.655-12.067 14.474-16.18 5.876-4.15 11.484-6.44 16.798-6.877Zm51.244 58.932a155.24 155.24 0 0 0-26.477 3.163c.137-1.296.276-2.59.416-3.881a306.827 306.827 0 0 1 7.708-6.525c1.498-13.425 2.983-28.014 4.456-43.766-2.911-.812-5.83-1.61-8.758-2.393 1.037-2.053 2.079-4.116 3.124-6.19A508.83 508.83 0 0 1 316.117 2c-.192 1.788-.386 3.57-.583 5.344-2.804 2.425-5.603 4.848-8.399 7.269-1.767 15.41-3.536 29.416-5.307 42.02a126.4 126.4 0 0 1 8.092 2.355 256.663 256.663 0 0 1-3.086 3.477Zm73.542-41.636c-3.26 19.97-6.495 39.483-9.705 58.54l-6.491-1.847c-9.47-17.642-19.154-34.716-29.05-51.22a2594.095 2594.095 0 0 1-4.975 32.795 478.97 478.97 0 0 1 10.147 6.467 768.207 768.207 0 0 1-3.226 4.343 1290.461 1290.461 0 0 0-21.894-5.761c.201-1.189.401-2.382.602-3.58a398.007 398.007 0 0 0 8.021-3.971 2254.944 2254.944 0 0 0 5.998-41.867l-8.149-6.159c1.11-1.971 2.222-3.95 3.335-5.934 4.691.355 9.379.725 14.065 1.11a2526.345 2526.345 0 0 1 28.935 50.957 6238.399 6238.399 0 0 0 5.87-36.458 1746.354 1746.354 0 0 0-10.53-6.095c1.169-1.954 2.34-3.915 3.514-5.883 7.716.744 15.434 1.5 23.155 2.265l-.871 5.466c-2.923 2.3-5.84 4.578-8.751 6.832Zm63.927 60.292c.29 2.293.582 4.587.877 6.884a981.077 981.077 0 0 1-16.062 7.961c-2.618.16-5.083.052-7.388-.34-2.317-.333-4.788-.879-7.393-1.642-6.031-1.77-11.094-4.965-15.211-9.533-4.135-4.485-7.022-9.797-8.661-15.93-1.639-6.14-1.863-12.709-.647-19.785 1.255-7.339 4.392-13.883 9.449-19.701 5.102-6.037 10.979-10.657 17.637-13.826 6.747-3.323 12.848-4.753 18.283-4.208 3.303.333 7.099 1.257 11.375 2.79 4.264 1.547 7.317 3.041 9.155 4.491l-4.91 25.765c-2.446-.39-4.893-.777-7.343-1.162-2.356-12.696-7.394-19.445-15.05-20.375-3.323-.404-6.575.417-9.737 2.463-3.098 2.015-5.787 4.947-8.073 8.79-2.272 3.791-3.841 8.166-4.711 13.126-1.018 5.773-1.21 11.214-.576 16.365.691 5.1 2.298 9.489 4.833 13.152 2.529 3.644 6.011 6.069 10.467 7.236.198.052 1.139.302 2.803.738 1.671.443 3.553.725 5.653.847 1.246-6.835 2.501-13.688 3.764-20.561a1205.633 1205.633 0 0 0-11.676-6.512l3.751-6.095c10.435 1.92 20.863 3.85 31.285 5.787l-1.165 6.082c-2.958 2.39-5.907 4.756-8.847 7.095-.632 3.37-1.259 6.736-1.882 10.098Zm83.393-12.94c3.143 2.894 5.262 6.769 6.376 11.65 1.185 4.838 1.229 10.053.154 15.641-1.012 5.402-3.303 10.162-6.882 14.249-3.508 3.926-7.515 6.704-12.035 8.295-4.519 1.559-8.636 1.771-12.329.693a50.443 50.443 0 0 1-7.241-2.739c-3.937-1.566-7.003-2.65-9.205-3.292l-11.433-3.31c.392-2.121.783-4.24 1.171-6.358 2.894-2.185 5.789-4.39 8.687-6.614a6176.568 6176.568 0 0 1 13.168-65.578 1128.647 1128.647 0 0 0-8.072-4.42c1.387-2.395 2.778-4.795 4.174-7.198 3.585.372 7.167.746 10.748 1.122 4.82.5 9.622.751 14.397.77 3.675.039 6.363.141 8.06.308 3.918.398 7.112 1.803 9.57 4.234 2.497 2.438 4.104 5.595 4.827 9.508.73 3.836.551 8.058-.538 12.657-.954 4.106-2.676 7.95-5.147 11.49-2.407 3.523-5.23 6.531-8.475 9.008.008-.034.017-.073.025-.116Zm-2.65-15.84c1.306-5.908 1.485-10.777.531-14.582-.966-3.791-3.213-5.889-6.728-6.3-2.157-.25-4.321.193-6.51 1.329a5789.424 5789.424 0 0 0-6.543 30.78l8.579 1.515c2.49.436 4.628-.424 6.408-2.58 1.83-2.174 3.252-5.562 4.263-10.161Zm-17.713 55c2.9.77 5.403.147 7.502-1.893 2.158-2.046 3.643-5.241 4.462-9.552 1.089-5.665 1.044-10.483-.153-14.435-1.133-4.016-3.534-6.537-7.215-7.583-.508-.103-1.016-.203-1.523-.301l-6.402-1.245a4305.047 4305.047 0 0 0-5.8 29.825c2.535 2.502 5.55 4.234 9.058 5.165a.368.368 0 0 0 .071.019Zm62.39 15.455c2.356 2.023 4.709 4.052 7.061 6.088a438.504 438.504 0 0 1-2.727 9.116 3901.77 3901.77 0 0 1-25.127-7.044l1.095-7.5a495.712 495.712 0 0 0 8.22-8.397c.913-6.112 1.873-12.22 2.88-18.323a36076.428 36076.428 0 0 1-6.952-58.014 657.088 657.088 0 0 0-4.487-5.267c1.199-2.652 2.4-5.302 3.604-7.949 8.928.86 17.816 1.692 26.663 2.496l-2.183 7.089a1565.693 1565.693 0 0 0-7.81 6.877 4065.814 4065.814 0 0 1 2.676 38.005 499.685 499.685 0 0 1 21.522-33.758 192.307 192.307 0 0 0-6.543-9.283c1.759-2.678 3.528-5.346 5.307-8.007 7.985.526 15.678.913 23.078 1.162a960.392 960.392 0 0 1-4.347 6.357 366.893 366.893 0 0 0-10.639 8.744c-10.285 14.97-19.416 30.427-27.393 46.371a843.918 843.918 0 0 0-3.898 31.237Z",
            }),
          ],
        }),
        H.jsx("path", {
          fill: "#A790B6",
          d: "M31.405 24.788c5.691-.527 11.466 1.032 17.131 4.65 5.557 3.51 10.396 8.668 14.461 15.481 3.912 6.768 6.67 14.62 8.252 23.557 1.376 9.194.762 18.034-1.767 26.618-2.689 8.558-6.446 15.788-11.184 21.729-4.897 5.908-9.596 9.507-13.917 10.72-2.042.584-4 .937-5.87 1.078-3.06.494-5.339.988-6.907 1.462a360.73 360.73 0 0 0-8.15 2.688 789.04 789.04 0 0 1 4.45-7.743 190.01 190.01 0 0 0 7.157-11.368c4.088-24.994-1.41-49.326-16.497-72.994a2211.19 2211.19 0 0 1-7.164-3.587A163.13 163.13 0 0 1 4 28.81c2.57-.29 5.313-.587 8.232-.89a98.009 98.009 0 0 0 12.087-1.957c3.2-.636 5.576-1.033 7.086-1.174Zm15.85 90.469c2.58-.718 5.013-2.88 7.196-6.479 2.157-3.554 3.732-8.148 4.66-13.748.833-5.601.82-11.696-.083-18.31-1.35-7.948-3.431-14.967-6.19-21.12-2.964-6.248-6.434-11.104-10.332-14.55-4.02-3.573-8.04-5.132-11.83-4.695-1.915.224-3.124 1.424-3.547 3.605 9.7 24.627 14.295 49.563 13.783 74.81 1.568 1.084 3.68 1.251 6.286.507a.24.24 0 0 1 .058-.02Zm98.163-15.615c-9.193 2.365-18.373 4.733-27.54 7.102-.136-2.048-.277-4.099-.422-6.152 2.513-3.037 5.029-6.056 7.547-9.059a2471.2 2471.2 0 0 0-6.017-15.403 14386.58 14386.58 0 0 0-22.982 4.625c-.798 5.45-1.628 10.91-2.49 16.385 3.947 1.835 7.895 3.64 11.843 5.415-.606 2.639-1.221 5.28-1.844 7.923-7.883 2.057-15.735 4.114-23.558 6.172-.107-2.194-.22-4.393-.34-6.595l7.087-11.433a2868.039 2868.039 0 0 0 9.027-74.887c4.314-2.399 8.657-4.775 13.027-7.127 11.028 24.64 21.281 48.673 30.76 72.102a1126.14 1126.14 0 0 0 7.97 3.548c-.687 2.46-1.377 4.92-2.068 7.384Zm-43.723-64.109a5763.681 5763.681 0 0 1-4.398 35.862c6.12-1.124 12.268-2.254 18.443-3.387a1659.945 1659.945 0 0 0-14.045-32.475ZM204.46 23.228c.559 20.654.967 40.986 1.223 60.998l-6.408 1.63a4412.659 4412.659 0 0 1-38.365-45.588 2861.052 2861.052 0 0 1 2.887 42.637c3.64.94 7.272 1.869 10.895 2.784-.717 2.327-1.431 4.657-2.144 6.993-7.191 1.839-14.378 3.68-21.561 5.523-.102-1.92-.207-3.845-.313-5.774 2.185-3.276 4.372-6.537 6.561-9.783a2933.22 2933.22 0 0 0-4.321-54.576c-3.184-1.817-6.38-3.65-9.589-5.498.635-2.412 1.276-4.82 1.92-7.224 4.788-.444 9.577-.891 14.365-1.34a8576.72 8576.72 0 0 0 39.197 46.96 4705.484 4705.484 0 0 0-1.338-38.832 2760.548 2760.548 0 0 1-11.734-3.958l2.318-6.807c7.908-.723 15.816-1.441 23.724-2.156l.141 5.447a1405.895 1405.895 0 0 0-7.458 8.565Zm51.13-19.695c3.175-.256 6.849-.083 11.017.52 4.218.597 7.272 1.334 9.173 2.232-.397 6.446-.8 12.784-1.21 19.016-2.518.218-5.036.442-7.554.673-3.655-8.154-9.179-12.016-16.465-11.355-2.97.282-5.71 1.604-8.226 4.003-2.503 2.393-4.493 5.537-5.972 9.418-1.421 3.85-2.158 8.064-2.215 12.6-.071 5.075.525 9.591 1.773 13.53 1.28 3.804 3.252 6.633 5.902 8.494 2.644 1.745 5.967 2.162 9.993 1.296 4.577-.969 11.273-4.895 20.172-11.484.883 1.437 1.76 2.857 2.631 4.26-4.93 4.44-9.822 9.01-14.679 13.71-2.228 1.212-4.372 2.194-6.415 2.919a57.705 57.705 0 0 1-6.427 2.027c-5.556 1.424-10.441 1.258-14.691-.552-4.277-1.88-7.599-5.17-9.974-9.867-2.414-4.85-3.643-10.745-3.668-17.661-.052-7.166 1.786-14.101 5.563-20.722 3.828-6.665 8.655-12.067 14.474-16.18 5.876-4.15 11.484-6.44 16.798-6.877Zm51.244 58.932a155.24 155.24 0 0 0-26.477 3.163c.137-1.296.276-2.59.416-3.881a306.827 306.827 0 0 1 7.708-6.525c1.498-13.425 2.983-28.014 4.456-43.766-2.911-.812-5.83-1.61-8.758-2.393 1.037-2.053 2.079-4.116 3.124-6.19A508.83 508.83 0 0 1 316.117 2c-.192 1.788-.386 3.57-.583 5.344-2.804 2.425-5.603 4.848-8.399 7.269-1.767 15.41-3.536 29.416-5.307 42.02a126.4 126.4 0 0 1 8.092 2.355 256.663 256.663 0 0 1-3.086 3.477Zm73.542-41.636c-3.26 19.97-6.495 39.483-9.705 58.54l-6.491-1.847c-9.47-17.642-19.154-34.716-29.05-51.22a2594.095 2594.095 0 0 1-4.975 32.795 478.97 478.97 0 0 1 10.147 6.467 768.207 768.207 0 0 1-3.226 4.343 1290.461 1290.461 0 0 0-21.894-5.761c.201-1.189.401-2.382.602-3.58a398.007 398.007 0 0 0 8.021-3.971 2254.944 2254.944 0 0 0 5.998-41.867l-8.149-6.159c1.11-1.971 2.222-3.95 3.335-5.934 4.691.355 9.379.725 14.065 1.11a2526.345 2526.345 0 0 1 28.935 50.957 6238.399 6238.399 0 0 0 5.87-36.458 1746.354 1746.354 0 0 0-10.53-6.095c1.169-1.954 2.34-3.915 3.514-5.883 7.716.744 15.434 1.5 23.155 2.265l-.871 5.466c-2.923 2.3-5.84 4.578-8.751 6.832Zm63.927 60.292c.29 2.293.582 4.587.877 6.884a981.077 981.077 0 0 1-16.062 7.961c-2.618.16-5.083.052-7.388-.34-2.317-.333-4.788-.879-7.393-1.642-6.031-1.77-11.094-4.965-15.211-9.533-4.135-4.485-7.022-9.797-8.661-15.93-1.639-6.14-1.863-12.709-.647-19.785 1.255-7.339 4.392-13.883 9.449-19.701 5.102-6.037 10.979-10.657 17.637-13.826 6.747-3.323 12.848-4.753 18.283-4.208 3.303.333 7.099 1.257 11.375 2.79 4.264 1.547 7.317 3.041 9.155 4.491l-4.91 25.765c-2.446-.39-4.893-.777-7.343-1.162-2.356-12.696-7.394-19.445-15.05-20.375-3.323-.404-6.575.417-9.737 2.463-3.098 2.015-5.787 4.947-8.073 8.79-2.272 3.791-3.841 8.166-4.711 13.126-1.018 5.773-1.21 11.214-.576 16.365.691 5.1 2.298 9.489 4.833 13.152 2.529 3.644 6.011 6.069 10.467 7.236.198.052 1.139.302 2.803.738 1.671.443 3.553.725 5.653.847 1.246-6.835 2.501-13.688 3.764-20.561a1205.633 1205.633 0 0 0-11.676-6.512l3.751-6.095c10.435 1.92 20.863 3.85 31.285 5.787l-1.165 6.082c-2.958 2.39-5.907 4.756-8.847 7.095-.632 3.37-1.259 6.736-1.882 10.098Zm83.393-12.94c3.143 2.894 5.262 6.769 6.376 11.65 1.185 4.838 1.229 10.053.154 15.641-1.012 5.402-3.303 10.162-6.882 14.249-3.508 3.926-7.515 6.704-12.035 8.295-4.519 1.559-8.636 1.771-12.329.693a50.443 50.443 0 0 1-7.241-2.739c-3.937-1.566-7.003-2.65-9.205-3.292l-11.433-3.31c.392-2.121.783-4.24 1.171-6.358 2.894-2.185 5.789-4.39 8.687-6.614a6176.568 6176.568 0 0 1 13.168-65.578 1128.647 1128.647 0 0 0-8.072-4.42c1.387-2.395 2.778-4.795 4.174-7.198 3.585.372 7.167.746 10.748 1.122 4.82.5 9.622.751 14.397.77 3.675.039 6.363.141 8.06.308 3.918.398 7.112 1.803 9.57 4.234 2.497 2.438 4.104 5.595 4.827 9.508.73 3.836.551 8.058-.538 12.657-.954 4.106-2.676 7.95-5.147 11.49-2.407 3.523-5.23 6.531-8.475 9.008.008-.034.017-.073.025-.116Zm-2.65-15.84c1.306-5.908 1.485-10.777.531-14.582-.966-3.791-3.213-5.889-6.728-6.3-2.157-.25-4.321.193-6.51 1.329a5789.424 5789.424 0 0 0-6.543 30.78l8.579 1.515c2.49.436 4.628-.424 6.408-2.58 1.83-2.174 3.252-5.562 4.263-10.161Zm-17.713 55c2.9.77 5.403.147 7.502-1.893 2.158-2.046 3.643-5.241 4.462-9.552 1.089-5.665 1.044-10.483-.153-14.435-1.133-4.016-3.534-6.537-7.215-7.583-.508-.103-1.016-.203-1.523-.301l-6.402-1.245a4305.047 4305.047 0 0 0-5.8 29.825c2.535 2.502 5.55 4.234 9.058 5.165a.368.368 0 0 0 .071.019Zm62.39 15.455c2.356 2.023 4.709 4.052 7.061 6.088a438.504 438.504 0 0 1-2.727 9.116 3901.77 3901.77 0 0 1-25.127-7.044l1.095-7.5a495.712 495.712 0 0 0 8.22-8.397c.913-6.112 1.873-12.22 2.88-18.323a36076.428 36076.428 0 0 1-6.952-58.014 657.088 657.088 0 0 0-4.487-5.267c1.199-2.652 2.4-5.302 3.604-7.949 8.928.86 17.816 1.692 26.663 2.496l-2.183 7.089a1565.693 1565.693 0 0 0-7.81 6.877 4065.814 4065.814 0 0 1 2.676 38.005 499.685 499.685 0 0 1 21.522-33.758 192.307 192.307 0 0 0-6.543-9.283c1.759-2.678 3.528-5.346 5.307-8.007 7.985.526 15.678.913 23.078 1.162a960.392 960.392 0 0 1-4.347 6.357 366.893 366.893 0 0 0-10.639 8.744c-10.285 14.97-19.416 30.427-27.393 46.371a843.918 843.918 0 0 0-3.898 31.237Z",
        }),
        H.jsx("path", {
          stroke: "#fff",
          strokeWidth: 4,
          d: "M31.405 24.788c5.691-.527 11.466 1.032 17.131 4.65 5.557 3.51 10.396 8.668 14.461 15.481 3.912 6.768 6.67 14.62 8.252 23.557 1.376 9.194.762 18.034-1.767 26.618-2.689 8.558-6.446 15.788-11.184 21.729-4.897 5.908-9.596 9.507-13.917 10.72-2.042.584-4 .937-5.87 1.078-3.06.494-5.339.988-6.907 1.462a360.73 360.73 0 0 0-8.15 2.688 789.04 789.04 0 0 1 4.45-7.743 190.01 190.01 0 0 0 7.157-11.368c4.088-24.994-1.41-49.326-16.497-72.994a2211.19 2211.19 0 0 1-7.164-3.587A163.13 163.13 0 0 1 4 28.81c2.57-.29 5.313-.587 8.232-.89a98.009 98.009 0 0 0 12.087-1.957c3.2-.636 5.576-1.033 7.086-1.174Zm15.85 90.469c2.58-.718 5.013-2.88 7.196-6.479 2.157-3.554 3.732-8.148 4.66-13.748.833-5.601.82-11.696-.083-18.31-1.35-7.948-3.431-14.967-6.19-21.12-2.964-6.248-6.434-11.104-10.332-14.55-4.02-3.573-8.04-5.132-11.83-4.695-1.915.224-3.124 1.424-3.547 3.605 9.7 24.627 14.295 49.563 13.783 74.81 1.568 1.084 3.68 1.251 6.286.507a.24.24 0 0 1 .058-.02Zm98.163-15.615c-9.193 2.365-18.373 4.733-27.54 7.102-.136-2.048-.277-4.099-.422-6.152 2.513-3.037 5.029-6.056 7.547-9.059a2471.2 2471.2 0 0 0-6.017-15.403 14386.58 14386.58 0 0 0-22.982 4.625c-.798 5.45-1.628 10.91-2.49 16.385 3.947 1.835 7.895 3.64 11.843 5.415-.606 2.639-1.221 5.28-1.844 7.923-7.883 2.057-15.735 4.114-23.558 6.172-.107-2.194-.22-4.393-.34-6.595l7.087-11.433a2868.039 2868.039 0 0 0 9.027-74.887c4.314-2.399 8.657-4.775 13.027-7.127 11.028 24.64 21.281 48.673 30.76 72.102a1126.14 1126.14 0 0 0 7.97 3.548c-.687 2.46-1.377 4.92-2.068 7.384Zm-43.723-64.109a5763.681 5763.681 0 0 1-4.398 35.862c6.12-1.124 12.268-2.254 18.443-3.387a1659.945 1659.945 0 0 0-14.045-32.475ZM204.46 23.228c.559 20.654.967 40.986 1.223 60.998l-6.408 1.63a4412.659 4412.659 0 0 1-38.365-45.588 2861.052 2861.052 0 0 1 2.887 42.637c3.64.94 7.272 1.869 10.895 2.784-.717 2.327-1.431 4.657-2.144 6.993-7.191 1.839-14.378 3.68-21.561 5.523-.102-1.92-.207-3.845-.313-5.774 2.185-3.276 4.372-6.537 6.561-9.783a2933.22 2933.22 0 0 0-4.321-54.576c-3.184-1.817-6.38-3.65-9.589-5.498.635-2.412 1.276-4.82 1.92-7.224 4.788-.444 9.577-.891 14.365-1.34a8576.72 8576.72 0 0 0 39.197 46.96 4705.484 4705.484 0 0 0-1.338-38.832 2760.548 2760.548 0 0 1-11.734-3.958l2.318-6.807c7.908-.723 15.816-1.441 23.724-2.156l.141 5.447a1405.895 1405.895 0 0 0-7.458 8.565Zm51.13-19.695c3.175-.256 6.849-.083 11.017.52 4.218.597 7.272 1.334 9.173 2.232-.397 6.446-.8 12.784-1.21 19.016-2.518.218-5.036.442-7.554.673-3.655-8.154-9.179-12.016-16.465-11.355-2.97.282-5.71 1.604-8.226 4.003-2.503 2.393-4.493 5.537-5.972 9.418-1.421 3.85-2.158 8.064-2.215 12.6-.071 5.075.525 9.591 1.773 13.53 1.28 3.804 3.252 6.633 5.902 8.494 2.644 1.745 5.967 2.162 9.993 1.296 4.577-.969 11.273-4.895 20.172-11.484.883 1.437 1.76 2.857 2.631 4.26-4.93 4.44-9.822 9.01-14.679 13.71-2.228 1.212-4.372 2.194-6.415 2.919a57.705 57.705 0 0 1-6.427 2.027c-5.556 1.424-10.441 1.258-14.691-.552-4.277-1.88-7.599-5.17-9.974-9.867-2.414-4.85-3.643-10.745-3.668-17.661-.052-7.166 1.786-14.101 5.563-20.722 3.828-6.665 8.655-12.067 14.474-16.18 5.876-4.15 11.484-6.44 16.798-6.877Zm51.244 58.932a155.24 155.24 0 0 0-26.477 3.163c.137-1.296.276-2.59.416-3.881a306.827 306.827 0 0 1 7.708-6.525c1.498-13.425 2.983-28.014 4.456-43.766-2.911-.812-5.83-1.61-8.758-2.393 1.037-2.053 2.079-4.116 3.124-6.19A508.83 508.83 0 0 1 316.117 2c-.192 1.788-.386 3.57-.583 5.344-2.804 2.425-5.603 4.848-8.399 7.269-1.767 15.41-3.536 29.416-5.307 42.02a126.4 126.4 0 0 1 8.092 2.355 256.663 256.663 0 0 1-3.086 3.477Zm73.542-41.636c-3.26 19.97-6.495 39.483-9.705 58.54l-6.491-1.847c-9.47-17.642-19.154-34.716-29.05-51.22a2594.095 2594.095 0 0 1-4.975 32.795 478.97 478.97 0 0 1 10.147 6.467 768.207 768.207 0 0 1-3.226 4.343 1290.461 1290.461 0 0 0-21.894-5.761c.201-1.189.401-2.382.602-3.58a398.007 398.007 0 0 0 8.021-3.971 2254.944 2254.944 0 0 0 5.998-41.867l-8.149-6.159c1.11-1.971 2.222-3.95 3.335-5.934 4.691.355 9.379.725 14.065 1.11a2526.345 2526.345 0 0 1 28.935 50.957 6238.399 6238.399 0 0 0 5.87-36.458 1746.354 1746.354 0 0 0-10.53-6.095c1.169-1.954 2.34-3.915 3.514-5.883 7.716.744 15.434 1.5 23.155 2.265l-.871 5.466c-2.923 2.3-5.84 4.578-8.751 6.832Zm63.927 60.292c.29 2.293.582 4.587.877 6.884a981.077 981.077 0 0 1-16.062 7.961c-2.618.16-5.083.052-7.388-.34-2.317-.333-4.788-.879-7.393-1.642-6.031-1.77-11.094-4.965-15.211-9.533-4.135-4.485-7.022-9.797-8.661-15.93-1.639-6.14-1.863-12.709-.647-19.785 1.255-7.339 4.392-13.883 9.449-19.701 5.102-6.037 10.979-10.657 17.637-13.826 6.747-3.323 12.848-4.753 18.283-4.208 3.303.333 7.099 1.257 11.375 2.79 4.264 1.547 7.317 3.041 9.155 4.491l-4.91 25.765c-2.446-.39-4.893-.777-7.343-1.162-2.356-12.696-7.394-19.445-15.05-20.375-3.323-.404-6.575.417-9.737 2.463-3.098 2.015-5.787 4.947-8.073 8.79-2.272 3.791-3.841 8.166-4.711 13.126-1.018 5.773-1.21 11.214-.576 16.365.691 5.1 2.298 9.489 4.833 13.152 2.529 3.644 6.011 6.069 10.467 7.236.198.052 1.139.302 2.803.738 1.671.443 3.553.725 5.653.847 1.246-6.835 2.501-13.688 3.764-20.561a1205.633 1205.633 0 0 0-11.676-6.512l3.751-6.095c10.435 1.92 20.863 3.85 31.285 5.787l-1.165 6.082c-2.958 2.39-5.907 4.756-8.847 7.095-.632 3.37-1.259 6.736-1.882 10.098Zm83.393-12.94c3.143 2.894 5.262 6.769 6.376 11.65 1.185 4.838 1.229 10.053.154 15.641-1.012 5.402-3.303 10.162-6.882 14.249-3.508 3.926-7.515 6.704-12.035 8.295-4.519 1.559-8.636 1.771-12.329.693a50.443 50.443 0 0 1-7.241-2.739c-3.937-1.566-7.003-2.65-9.205-3.292l-11.433-3.31c.392-2.121.783-4.24 1.171-6.358 2.894-2.185 5.789-4.39 8.687-6.614a6176.568 6176.568 0 0 1 13.168-65.578 1128.647 1128.647 0 0 0-8.072-4.42c1.387-2.395 2.778-4.795 4.174-7.198 3.585.372 7.167.746 10.748 1.122 4.82.5 9.622.751 14.397.77 3.675.039 6.363.141 8.06.308 3.918.398 7.112 1.803 9.57 4.234 2.497 2.438 4.104 5.595 4.827 9.508.73 3.836.551 8.058-.538 12.657-.954 4.106-2.676 7.95-5.147 11.49-2.407 3.523-5.23 6.531-8.475 9.008.008-.034.017-.073.025-.116Zm-2.65-15.84c1.306-5.908 1.485-10.777.531-14.582-.966-3.791-3.213-5.889-6.728-6.3-2.157-.25-4.321.193-6.51 1.329a5789.424 5789.424 0 0 0-6.543 30.78l8.579 1.515c2.49.436 4.628-.424 6.408-2.58 1.83-2.174 3.252-5.562 4.263-10.161Zm-17.713 55c2.9.77 5.403.147 7.502-1.893 2.158-2.046 3.643-5.241 4.462-9.552 1.089-5.665 1.044-10.483-.153-14.435-1.133-4.016-3.534-6.537-7.215-7.583-.508-.103-1.016-.203-1.523-.301l-6.402-1.245a4305.047 4305.047 0 0 0-5.8 29.825c2.535 2.502 5.55 4.234 9.058 5.165a.368.368 0 0 0 .071.019Zm62.39 15.455c2.356 2.023 4.709 4.052 7.061 6.088a438.504 438.504 0 0 1-2.727 9.116 3901.77 3901.77 0 0 1-25.127-7.044l1.095-7.5a495.712 495.712 0 0 0 8.22-8.397c.913-6.112 1.873-12.22 2.88-18.323a36076.428 36076.428 0 0 1-6.952-58.014 657.088 657.088 0 0 0-4.487-5.267c1.199-2.652 2.4-5.302 3.604-7.949 8.928.86 17.816 1.692 26.663 2.496l-2.183 7.089a1565.693 1565.693 0 0 0-7.81 6.877 4065.814 4065.814 0 0 1 2.676 38.005 499.685 499.685 0 0 1 21.522-33.758 192.307 192.307 0 0 0-6.543-9.283c1.759-2.678 3.528-5.346 5.307-8.007 7.985.526 15.678.913 23.078 1.162a960.392 960.392 0 0 1-4.347 6.357 366.893 366.893 0 0 0-10.639 8.744c-10.285 14.97-19.416 30.427-27.393 46.371a843.918 843.918 0 0 0-3.898 31.237Z",
          mask: "url(#a)",
        }),
      ],
    }),
  VO = () =>
    H.jsx("div", {
      className:
        "relative w-full h-full flex items-center justify-center overflow-visible md:-translate-y-2 -translate-y-5",
      children: H.jsx("div", {
        className:
          "w-full max-w-[400px] h-[140px] md:h-[200px] translate-y-1 md:-translate-y-2",
        children: H.jsx(HO, {}),
      }),
    }),
  GO = () =>
    H.jsxs(Qf, {
      className:
        "col-span-2 md:col-span-3 lg:col-span-2 p-6 h-[150px] md:h-[200px] relative overflow-hidden",
      colorFrom: "from-[#992b0d]",
      colorTo: "to-[#e2d57e]",
      withNoise: !0,
      children: [
        H.jsx(lt.div, {
          className: "absolute inset-0 w-[200%] h-[200%] -top-1/2 -left-1/2",
          animate: {
            background: [
              "radial-gradient(circle at 30% 50%, rgba(233,213,255,0.3) 0%, transparent 50%)",
              "radial-gradient(circle at 70% 50%, rgba(233,213,255,0.3) 0%, transparent 50%)",
              "radial-gradient(circle at 30% 50%, rgba(233,213,255,0.3) 0%, transparent 50%)",
            ],
          },
          transition: { duration: 4, repeat: 1 / 0, ease: "easeInOut" },
        }),
        H.jsx(lt.div, {
          className: "absolute inset-0 w-[200%] h-[200%] -top-1/2 -left-1/2",
          animate: {
            background: [
              "radial-gradient(circle at 20% 30%, rgba(233,213,255,0.4) 0%, transparent 30%), radial-gradient(circle at 80% 70%, rgba(233,213,255,0.4) 0%, transparent 30%)",
              "radial-gradient(circle at 80% 30%, rgba(233,213,255,0.4) 0%, transparent 30%), radial-gradient(circle at 20% 70%, rgba(233,213,255,0.4) 0%, transparent 30%)",
              "radial-gradient(circle at 20% 30%, rgba(233,213,255,0.4) 0%, transparent 30%), radial-gradient(circle at 80% 70%, rgba(233,213,255,0.4) 0%, transparent 30%)",
            ],
          },
          transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" },
        }),
        H.jsx(lt.div, {
          className: "absolute inset-0 w-[200%] h-[200%] -top-1/2 -left-1/2",
          animate: { opacity: [0.3, 0.5, 0.3] },
          transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" },
          style: {
            background:
              "radial-gradient(circle at center, rgba(233,213,255,0.2) 0%, transparent 70%)",
          },
        }),
        H.jsx(lt.div, {
          className:
            "absolute inset-0 w-[200%] h-[200%] -top-1/2 -left-1/2 bg-gradient-to-r from-transparent via-purple-300/20 to-transparent",
          animate: { scale: [1, 1.1, 1], opacity: [0.3, 0.5, 0.3] },
          transition: { duration: 3, repeat: 1 / 0, ease: "easeInOut" },
        }),
        H.jsx("div", { className: "relative z-10", children: H.jsx(VO, {}) }),
      ],
    }),
  jO = () => {
    const r = {
        hidden: { pathLength: 0, opacity: 0 },
        visible: {
          pathLength: 1,
          opacity: 0.5,
          transition: {
            pathLength: { duration: 2, ease: "easeInOut" },
            opacity: { duration: 0.5 },
          },
        },
      },
      e = "#8B0000";
    return H.jsxs("div", {
      className: "absolute inset-0 pointer-events-none mix-blend-soft-light",
      children: [
        H.jsxs(lt.svg, {
          viewBox: "0 0 100 100",
          className: "absolute top-0 left-0 w-48 h-48 opacity-90",
          initial: "hidden",
          animate: "visible",
          children: [
            H.jsx(lt.path, {
              d: `M 20,20 
             C 30,10 40,30 30,40 
             C 20,50 40,60 50,50 
             Q 60,40 70,50 
             C 80,60 60,70 50,60
             M 25,25
             C 35,15 45,35 35,45
             Q 25,55 35,65`,
              stroke: e,
              strokeWidth: "1.5",
              fill: "none",
              variants: r,
            }),
            H.jsx(lt.circle, {
              cx: "35",
              cy: "35",
              r: "3",
              fill: e,
              variants: r,
            }),
            H.jsx(lt.circle, {
              cx: "45",
              cy: "55",
              r: "2",
              fill: e,
              variants: r,
            }),
          ],
        }),
        H.jsxs(lt.svg, {
          viewBox: "0 0 100 100",
          className: "absolute bottom-0 right-0 w-48 h-48 opacity-90",
          initial: "hidden",
          animate: "visible",
          children: [
            H.jsx(lt.path, {
              d: `M 80,80 
             C 70,90 60,70 70,60 
             C 80,50 60,40 50,50 
             Q 40,60 30,50 
             C 20,40 40,30 50,40
             M 75,75
             C 65,85 55,65 65,55
             Q 75,45 65,35`,
              stroke: e,
              strokeWidth: "1.5",
              fill: "none",
              variants: r,
            }),
            H.jsx(lt.path, {
              d: `M 70,70
             Q 60,80 50,70
             T 30,60
             Q 40,50 50,60
             T 70,70 Z`,
              fill: e,
              fillOpacity: "0.6",
              variants: r,
            }),
          ],
        }),
        H.jsx(lt.div, {
          className: "absolute left-0 top-1/2 -translate-y-1/2 w-12 h-48",
          initial: { opacity: 0, x: -20 },
          animate: { opacity: 0.9, x: 0 },
          transition: { duration: 1, delay: 0.5 },
          children: H.jsx(lt.div, {
            className: "w-full h-full",
            style: {
              background: `linear-gradient(90deg, ${e} 0%, transparent 100%)`,
              opacity: 0.7,
            },
            animate: { opacity: [0.7, 0.9, 0.7] },
            transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" },
          }),
        }),
        H.jsx(lt.div, {
          className: "absolute right-0 top-1/2 -translate-y-1/2 w-12 h-48",
          initial: { opacity: 0, x: 20 },
          animate: { opacity: 0.9, x: 0 },
          transition: { duration: 1, delay: 0.5 },
          children: H.jsx(lt.div, {
            className: "w-full h-full",
            style: {
              background: `linear-gradient(-90deg, ${e} 0%, transparent 100%)`,
              opacity: 0.7,
            },
            animate: { opacity: [0.7, 0.9, 0.7] },
            transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" },
          }),
        }),
        H.jsxs(lt.svg, {
          viewBox: "0 0 200 200",
          className:
            "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-64 h-64 opacity-80",
          initial: "hidden",
          animate: "visible",
          children: [
            [0, 45, 90, 135, 180, 225, 270, 315].map((t, n) =>
              H.jsx(
                lt.path,
                {
                  d: `M 100,100 
               C 120,80 140,100 120,120 
               S 80,140 100,100
               M 100,100
               C 110,90 120,100 110,110
               S 90,120 100,100`,
                  stroke: e,
                  strokeWidth: "1",
                  fill: "none",
                  transform: `rotate(${t}, 100, 100)`,
                  variants: r,
                  transition: { ...r.visible.transition, delay: n * 0.1 },
                },
                `base-${n}`,
              ),
            ),
            [0, 72, 144, 216, 288].map((t, n) =>
              H.jsx(
                lt.path,
                {
                  d: `M 100,100
               Q 110,95 120,100
               T 140,100
               Q 130,110 120,105
               T 100,100 Z`,
                  fill: e,
                  fillOpacity: "0.6",
                  transform: `rotate(${t}, 100, 100)`,
                  variants: r,
                  transition: { ...r.visible.transition, delay: 0.8 + n * 0.1 },
                },
                `detail-${n}`,
              ),
            ),
            H.jsx(lt.circle, {
              cx: "100",
              cy: "100",
              r: "4",
              fill: e,
              variants: r,
            }),
          ],
        }),
      ],
    });
  },
  WO = () => {
    const r = {
        hidden: { opacity: 0 },
        show: {
          opacity: 1,
          transition: { staggerChildren: 0.15, delayChildren: 0 },
        },
      },
      e = {
        hidden: { y: 20, opacity: 0 },
        show: {
          y: 0,
          opacity: 1,
          transition: { type: "spring", stiffness: 100, damping: 12 },
        },
      };
    return H.jsx("div", {
      className: "relative overflow-hidden w-full h-full",
      children: H.jsxs("div", {
        className: "relative h-full rounded-lg",
        children: [
          H.jsx(lt.div, {
            className:
              "absolute inset-0 bg-gradient-to-br from-[#8B2B0D] via-[#D4AF37] to-[#8B2B0D]",
            animate: { opacity: [0.7, 0.9, 0.7] },
            transition: { duration: 3, repeat: 1 / 0, ease: "easeInOut" },
          }),
          H.jsx(jO, {}),
          H.jsx(lt.div, {
            className: "absolute inset-0 mix-blend-overlay opacity-50",
            animate: { backgroundPosition: ["0% 0%", "100% 100%"] },
            transition: { duration: 8, repeat: 1 / 0, ease: "linear" },
            style: {
              backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")`,
            },
          }),
          H.jsx(lt.div, {
            initial: "hidden",
            animate: "show",
            variants: r,
            className: "relative z-10 h-full p-4",
            children: H.jsxs("div", {
              className: "flex flex-col",
              children: [
                H.jsxs("div", {
                  className: "flex justify-between items-start mb-1 w-full",
                  children: [
                    H.jsxs(lt.div, {
                      variants: e,
                      className: "flex flex-col -space-y-2",
                      children: [
                        H.jsx("span", {
                          className:
                            "text-5xl sm:text-6xl md:text-7xl font-quattrocento font-bold",
                          style: {
                            color: "#FFD700",
                            textShadow:
                              "2px 2px 0px rgba(0,0,0,0.5), -1px -1px 0px rgba(139,43,13,0.8)",
                          },
                          children: "Holud",
                        }),
                        H.jsx("span", {
                          className:
                            "text-5xl sm:text-6xl md:text-7xl font-quattrocento font-bold",
                          style: {
                            color: "#FFD700",
                            textShadow:
                              "2px 2px 0px rgba(0,0,0,0.5), -1px -1px 0px rgba(139,43,13,0.8)",
                          },
                          children: "Night",
                        }),
                      ],
                    }),
                    H.jsxs("div", {
                      className: "flex flex-col items-end space-y-4 ml-4 pr-2",
                      children: [
                        H.jsx(lt.div, {
                          variants: e,
                          className:
                            "text-lg sm:text-xl md:text-2xl lg:text-3xl font-bold font-instrumentSerif italic",
                          style: {
                            color: "#760000",
                            textShadow: "1px 1px 0px rgba(0,0,0,0.3)",
                          },
                          children: "(Get Your Henna!)",
                        }),
                        H.jsx(lt.div, {
                          variants: e,
                          className:
                            "text-base sm:text-lg md:text-xl lg:text-2xl font-quattrocento font-bold",
                          style: {
                            color: "#000",
                            textShadow: "2px 2px 4px rgba(0,0,0,0.5)",
                          },
                          children: "7:30-9:30 PM",
                        }),
                      ],
                    }),
                  ],
                }),
                H.jsx(lt.div, {
                  variants: e,
                  className: "mt-auto text-center",
                  children: H.jsx("span", {
                    className:
                      "text-xl sm:text-2xl font-instrumentSerif font-bold",
                    style: {
                      color: "#FFFFFF",
                      textShadow: "1px 1px 2px rgba(0,0,0,0.5)",
                    },
                    children: "Multicultural Community Space (1/9)",
                  }),
                }),
              ],
            }),
          }),
        ],
      }),
    });
  };
function XO() {
  return H.jsx("div", {
    className: "relative  content-start w-full max-w-7xl mx-auto space-y-8 p-4",
    children: H.jsxs("div", {
      className:
        "grid grid-cols-2 md:grid-cols-6 gap-4 md:gap-6 auto-rows-[150px] md:auto-rows-[200px] ",
      children: [
        H.jsx(Qf, {
          className: "col-span-2 md:col-span-3",
          colorFrom: "from-[#992b0d]",
          colorTo: "to-[#bf9b30]",
          children: H.jsx(g9, {}),
        }),
        H.jsx(Qf, {
          className: "col-span-2 md:col-span-3 row-span-1",
          colorFrom: "from-[#992b0d]",
          colorTo: "to-[#bf9b30]",
          withNoise: !0,
          children: H.jsx("div", {
            className: "h-full overflow-visible",
            children: H.jsx(zO, {}),
          }),
        }),
        H.jsxs(Qf, {
          className:
            "col-span-2 md:col-span-3 lg:col-span-4 row-span-2 md:row-span-2 p-6 relative overflow-hidden",
          colorFrom: "from-[#992b0d]",
          colorTo: "to-[#971a34]",
          withNoise: !0,
          children: [
            H.jsxs("div", {
              className: "absolute inset-0 opacity-20 pointer-events-none",
              children: [
                H.jsx(lt.div, {
                  className:
                    "absolute top-0 left-0 w-40 h-40 bg-[#ecc078] rounded-full blur-3xl",
                  animate: { x: [-50, 50, -50], y: [-50, 50, -50] },
                  transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" },
                }),
                H.jsx(lt.div, {
                  className:
                    "absolute bottom-0 right-0 w-40 h-40 bg-[#e2d57e] rounded-full blur-3xl",
                  animate: { x: [50, -50, 50], y: [50, -50, 50] },
                  transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" },
                }),
              ],
            }),
            H.jsxs("div", {
              className: "relative z-10 text-center mb-4",
              children: [
                H.jsx("h2", {
                  className:
                    "font-quattrocento text-3xl md:text-4xl font-bold text-white mb-2",
                  children: "🎥 Mock Shaadi Exclusive Trailer",
                }),
                H.jsx("div", {
                  className: "w-24 h-1 bg-[#ecc078] mx-auto rounded-full mt-2",
                }),
              ],
            }),
            H.jsx("div", {
              className:
                " relative z-20 h-[calc(100%-5rem)] w-full rounded-lg bg-black/10 backdrop-blur-sm p-2 transform transition-transform duration-500  group-hover:scale-[0.9]",
              children: H.jsx(p9, {}),
            }),
          ],
        }),
        H.jsx(GO, {}),
        H.jsx(Qf, {
          className: "col-span-2 md:col-span-3 lg:col-span-2",
          colorFrom: "from-[#992b0d]",
          colorTo: "to-[#d8b148]",
          children: H.jsx(WO, {}),
        }),
      ],
    }),
  });
}
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const JO = (r) => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  S6 = (...r) =>
    r
      .filter((e, t, n) => !!e && e.trim() !== "" && n.indexOf(e) === t)
      .join(" ")
      .trim();
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var YO = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ZO = he.forwardRef(
  (
    {
      color: r = "currentColor",
      size: e = 24,
      strokeWidth: t = 2,
      absoluteStrokeWidth: n,
      className: i = "",
      children: s,
      iconNode: a,
      ...l
    },
    c,
  ) =>
    he.createElement(
      "svg",
      {
        ref: c,
        ...YO,
        width: e,
        height: e,
        stroke: r,
        strokeWidth: n ? (Number(t) * 24) / Number(e) : t,
        className: S6("lucide", i),
        ...l,
      },
      [
        ...a.map(([d, p]) => he.createElement(d, p)),
        ...(Array.isArray(s) ? s : [s]),
      ],
    ),
);
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const i2 = (r, e) => {
  const t = he.forwardRef(({ className: n, ...i }, s) =>
    he.createElement(ZO, {
      ref: s,
      iconNode: e,
      className: S6(`lucide-${JO(r)}`, n),
      ...i,
    }),
  );
  return (t.displayName = `${r}`), t;
};
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const mg = i2("Instagram", [
  [
    "rect",
    {
      width: "20",
      height: "20",
      x: "2",
      y: "2",
      rx: "5",
      ry: "5",
      key: "2e1cvw",
    },
  ],
  [
    "path",
    { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" },
  ],
  ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }],
]);
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const qO = i2("Menu", [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }],
]);
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const kv = i2("SquareArrowUpRight", [
  [
    "rect",
    { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" },
  ],
  ["path", { d: "M8 8h8v8", key: "b65dnt" }],
  ["path", { d: "m8 16 8-8", key: "13b9ih" }],
]);
/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const KO = i2("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
]);
function dw() {
  return H.jsxs("div", {
    className: "relative w-full overflow-hidden pb-4",
    children: [
      H.jsxs("div", {
        className: "absolute inset-0",
        children: [
          H.jsx(lt.div, {
            className:
              "absolute inset-0 bg-gradient-radial from-gold/30 via-gold/20 to-transparent",
            animate: { scale: [1, 1.1, 1], opacity: [0.4, 0.6, 0.4] },
            transition: { duration: 8, repeat: 1 / 0, ease: "easeInOut" },
          }),
          H.jsx(lt.div, {
            className:
              "absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,_rgba(227,100,20,0.25),_transparent_60%)]",
            animate: { scale: [1.2, 1, 1.2] },
            transition: { duration: 8, repeat: 1 / 0, ease: "easeInOut" },
          }),
        ],
      }),
      H.jsx(lt.div, {
        className: "relative z-10 text-center mb-2",
        initial: { opacity: 0, y: -10 },
        animate: { opacity: 1, y: 0 },
        transition: { duration: 0.8, delay: 0.2 },
        children: H.jsx("p", {
          className:
            "text-sm md:text-lg font-quattrocento text-[#e2d57e] tracking-wider",
          children:
            "Presented by Vanderbilt University South Asian Organizations",
        }),
      }),
      H.jsx(lt.div, {
        className: "relative z-10 text-center md:pt-6 pb-4 px-4",
        initial: { opacity: 0, y: 20 },
        animate: { opacity: 1, y: 0 },
        transition: { duration: 0.8 },
        children: H.jsxs("div", {
          className: "relative",
          children: [
            H.jsx("div", {
              className: "md:hidden",
              children: H.jsxs(lt.h1, {
                className:
                  "text-6xl sm:text-7xl font-quattrocento font-bold flex flex-col items-center gap-1",
                style: {
                  background:
                    "linear-gradient(90deg, #bf9b30, #e36414, #bf9b30)",
                  backgroundSize: "200% auto",
                  color: "transparent",
                  backgroundClip: "text",
                  WebkitBackgroundClip: "text",
                  textShadow: "0px 2px 4px rgba(0,0,0,0.2)",
                  filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.1))",
                },
                animate: { backgroundPosition: ["0% center", "200% center"] },
                transition: { duration: 8, repeat: 1 / 0, ease: "linear" },
                children: [
                  H.jsx("span", { children: "Mock" }),
                  H.jsx("span", { children: "Shaadi" }),
                ],
              }),
            }),
            H.jsx(lt.h1, {
              className: "hidden md:block text-8xl font-quattrocento font-bold",
              style: {
                background: "linear-gradient(90deg, #bf9b30, #e36414, #bf9b30)",
                backgroundSize: "200% auto",
                color: "transparent",
                backgroundClip: "text",
                WebkitBackgroundClip: "text",
                textShadow: "0px 2px 4px rgba(0,0,0,0.2)",
                filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.1))",
              },
              animate: { backgroundPosition: ["0% center", "200% center"] },
              transition: { duration: 8, repeat: 1 / 0, ease: "linear" },
              children: "Mock Shaadi",
            }),
            H.jsx(lt.div, {
              className: "mt-2 md:mt-4",
              animate: { y: [0, -8, 0] },
              transition: { duration: 4, repeat: 1 / 0, ease: "easeInOut" },
              children: H.jsx("h2", {
                className:
                  "text-4xl sm:text-5xl md:text-4xl text-almond font-quattrocento font-bold",
                style: { textShadow: "0 2px 4px rgba(0,0,0,0.2)" },
                children: "2025",
              }),
            }),
            H.jsxs("div", {
              className:
                "flex items-center justify-center gap-3 md:gap-4 mt-4 md:mt-6",
              children: [
                H.jsx(lt.div, {
                  className: "h-px w-12 sm:w-16 md:w-32",
                  style: {
                    background:
                      "linear-gradient(90deg, transparent, #bf9b30, transparent)",
                    boxShadow: "0 0 8px rgba(191,155,48,0.3)",
                  },
                  animate: { scaleX: [1, 1.2, 1], opacity: [0.5, 1, 0.5] },
                  transition: { duration: 3, repeat: 1 / 0, ease: "easeInOut" },
                }),
                H.jsx(lt.div, {
                  className:
                    "w-1.5 h-1.5 md:w-2 md:h-2 rounded-full bg-spanish",
                  animate: { scale: [1, 1.3, 1], opacity: [0.7, 1, 0.7] },
                  transition: { duration: 3, repeat: 1 / 0, ease: "easeInOut" },
                }),
                H.jsx(lt.div, {
                  className: "h-px w-12 sm:w-16 md:w-32",
                  style: {
                    background:
                      "linear-gradient(90deg, transparent, #bf9b30, transparent)",
                    boxShadow: "0 0 8px rgba(191,155,48,0.3)",
                  },
                  animate: { scaleX: [1, 1.2, 1], opacity: [0.5, 1, 0.5] },
                  transition: { duration: 3, repeat: 1 / 0, ease: "easeInOut" },
                }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
}
const QO = [
    {
      name: "VABS",
      imageSrc: "src/components/orgs/OrgPhotos/vabs.png",
      instagramUrl: "https://www.instagram.com/vandy.bengalis/",
      scale: 1.5,
    },
    {
      name: "PSA",
      imageSrc: "src/components/orgs/OrgPhotos/psa.png",
      instagramUrl: "https://www.instagram.com/vandypsa/",
      scale: 1.3,
    },
    {
      name: "SACE",
      imageSrc: "src/components/orgs/OrgPhotos/sace.jpeg",
      instagramUrl: "https://www.instagram.com/vanderbiltsace/",
      scale: 1.1,
    },
    {
      name: "Spevents",
      imageSrc: "src/components/orgs/OrgPhotos/spevents.svg",
      instagramUrl: "https://spevents.github.io",
      scale: 1.1,
    },
  ],
  $O = ({ src: r, alt: e, instagramLink: t, scale: n = 1 }) =>
    H.jsxs(lt.a, {
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      className:
        "flex items-center gap-4 p-4 bg-gradient-to-r from-[#992b0d]/20 to-[#d8b148]/20 rounded-2xl hover:from-[#992b0d]/30 hover:to-[#d8b148]/30 backdrop-blur-sm",
      whileHover: { y: -2, transition: { duration: 0.2 } },
      whileTap: { scale: 0.98 },
      children: [
        H.jsxs("div", {
          className:
            "relative w-14 h-14 rounded-full overflow-hidden bg-[#992b0d]/10",
          children: [
            H.jsx(lt.img, {
              src: r,
              alt: e,
              style: { scale: n },
              className: "w-full h-full object-contain p-2",
              whileHover: { scale: n * 1.1 },
              transition: { duration: 0.2 },
            }),
            H.jsx(lt.div, {
              className:
                "absolute inset-0 flex items-center justify-center bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-300",
              children:
                e === "Spevents"
                  ? H.jsx(kv, { className: "w-6 h-6 text-white" })
                  : H.jsx(mg, { className: "w-6 h-6 text-white" }),
            }),
          ],
        }),
        H.jsxs("div", {
          className: "flex flex-col",
          children: [
            H.jsx("span", {
              className: "font-quattrocento text-[#e2d57e] text-lg font-bold",
              children: e,
            }),
            H.jsx("span", {
              className: "text-[#e2d57e]/70 text-sm",
              children: "View Profile",
            }),
          ],
        }),
        e === "Spevents"
          ? H.jsx(kv, { className: "w-5 h-5 text-[#e2d57e] ml-auto" })
          : H.jsx(mg, { className: "w-5 h-5 text-[#e2d57e] ml-auto" }),
      ],
    });
function ek() {
  const [r, e] = he.useState(!1),
    t = { closed: { opacity: 0, x: "100%" }, open: { opacity: 1, x: 0 } };
  return H.jsxs("div", {
    className: "md:hidden",
    children: [
      H.jsx(lt.button, {
        onClick: () => e(!r),
        className:
          "fixed top-4 right-4 z-50 p-3 rounded-full bg-gradient-to-r from-[#992b0d] to-[#d8b148] shadow-lg backdrop-blur-sm",
        whileHover: { scale: 1.1 },
        whileTap: { scale: 0.9 },
        children: H.jsx(lt.div, {
          initial: !1,
          animate: { rotate: r ? 180 : 0 },
          transition: { duration: 0.3 },
          children: r
            ? H.jsx(KO, { className: "w-6 h-6 text-[#e2d57e]" })
            : H.jsx(qO, { className: "w-6 h-6 text-[#e2d57e]" }),
        }),
      }),
      H.jsx(fv, {
        children:
          r &&
          H.jsxs(lt.div, {
            initial: "closed",
            animate: "open",
            exit: "closed",
            variants: t,
            className: `fixed top-0 right-0 w-full max-w-sm h-screen bg-gradient-to-b from-[#992b0d] via-[#761f0a] to-[#4d1405] p-6 pt-20 z-40 shadow-xl ${r ? "pointer-events-auto" : "pointer-events-none"}`,
            transition: { type: "spring", stiffness: 300, damping: 30 },
            children: [
              H.jsx(lt.div, {
                className:
                  "absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,_rgba(227,100,20,0.15),_transparent_70%)]",
                animate: { scale: [1, 1.2, 1], opacity: [0.3, 0.7, 0.3] },
                transition: { duration: 3, repeat: 1 / 0, ease: "easeInOut" },
              }),
              H.jsxs("div", {
                className: "space-y-6",
                children: [
                  H.jsxs("div", {
                    className: "relative",
                    children: [
                      H.jsx("h3", {
                        className:
                          "text-[#e2d57e] font-quattrocento text-2xl font-bold mb-2",
                        children: "Organizations",
                      }),
                      H.jsx("div", {
                        className:
                          "h-1 w-20 bg-gradient-to-r from-[#e2d57e] to-transparent rounded-full",
                      }),
                    ],
                  }),
                  H.jsx("div", {
                    className: "space-y-4",
                    children: QO.map((n) =>
                      H.jsx(
                        $O,
                        {
                          src: n.imageSrc,
                          alt: n.name,
                          instagramLink: n.instagramUrl,
                          scale: n.scale,
                        },
                        n.name,
                      ),
                    ),
                  }),
                ],
              }),
            ],
          }),
      }),
    ],
  });
}
const hw = [
    {
      name: "VABS",
      imageSrc: "src/components/orgs/OrgPhotos/vabs.png",
      instagramUrl: "https://www.instagram.com/vandy.bengalis/",
      scale: 1.5,
    },
    {
      name: "PSA",
      imageSrc: "src/components/orgs/OrgPhotos/psa.png",
      instagramUrl: "https://www.instagram.com/vandypsa/",
      scale: 1.2,
    },
    {
      name: "SACE",
      imageSrc: "src/components/orgs/OrgPhotos/sace.jpeg",
      instagramUrl: "https://www.instagram.com/vanderbiltsace/",
      scale: 1.3,
    },
    {
      name: "Spevents",
      imageSrc: "src/components/orgs/OrgPhotos/spevents.svg",
      instagramUrl: "https://spevents.github.io",
      scale: 0.9,
    },
  ],
  tk = ({ href: r, children: e }) =>
    H.jsx(lt.a, {
      href: r,
      target: "_blank",
      rel: "noopener noreferrer",
      className:
        "group flex flex-col items-center gap-3 transition-transform duration-300",
      whileHover: { scale: 1.05 },
      whileTap: { scale: 0.95 },
      children: e,
    }),
  nk = ({ src: r, alt: e, scale: t = 1 }) =>
    H.jsxs("div", {
      className:
        "relative group w-16 h-16 md:w-20 md:h-20 rounded-full overflow-hidden bg-[#992b0d]/10 backdrop-blur-sm",
      children: [
        H.jsx(lt.img, {
          src: r,
          alt: e,
          className: "w-full h-full object-contain p-2",
          style: { scale: t },
          whileHover: { scale: t * 1.15 },
          transition: { duration: 0.2 },
        }),
        H.jsx("div", {
          className:
            "absolute inset-0 flex items-center justify-center bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-300",
          children:
            e === "Spevents"
              ? H.jsx(kv, { className: "w-6 h-6 text-white" })
              : H.jsx(mg, { className: "w-6 h-6 text-white" }),
        }),
      ],
    }),
  fw = ({ name: r, imageSrc: e, instagramUrl: t, scale: n = 1 }) =>
    H.jsxs(tk, {
      href: t,
      children: [
        H.jsx(nk, { src: e, alt: r, scale: n }),
        H.jsx(lt.span, {
          className:
            "text-base md:text-lg font-quattrocento font-bold text-[#e2d57e] opacity-80 group-hover:opacity-100",
          whileHover: { y: -2 },
          children: r,
        }),
      ],
    });
function rk() {
  return H.jsxs("div", {
    className: "w-full max-w-7xl mx-auto px-4 pt-8 md:pt-12",
    children: [
      H.jsxs("div", {
        className: "md:hidden relative flex justify-center items-center",
        children: [
          H.jsx("div", { className: "w-full", children: H.jsx(dw, {}) }),
          H.jsx(ek, {}),
        ],
      }),
      H.jsxs("div", {
        className: "hidden md:flex justify-between items-start",
        children: [
          H.jsx("div", {
            className: "flex gap-8 items-center",
            children: hw.slice(0, 2).map((r) => H.jsx(fw, { ...r }, r.name)),
          }),
          H.jsx("div", { className: "flex-1 px-4", children: H.jsx(dw, {}) }),
          H.jsx("div", {
            className: "flex gap-8 items-center",
            children: hw.slice(2).map((r) => H.jsx(fw, { ...r }, r.name)),
          }),
        ],
      }),
    ],
  });
}
const ik = ({
  children: r,
  className: e = "",
  isMainContentVisible: t = !1,
}) => {
  const [n, i] = he.useState(!1),
    { scrollYProgress: s } = h9(),
    a = pv(s, { stiffness: 400, damping: 90 }),
    l = t ? 0.3 : 1,
    c = O7(a, [0, 0.5, 1], [l, l * 0.6, l * 0.3]);
  return (
    he.useEffect(() => {
      i(!0);
    }, []),
    H.jsxs("div", {
      className: `relative ${e}`,
      children: [
        H.jsx("div", {
          className: "fixed inset-0 pointer-events-none z-50",
          children: H.jsxs("svg", {
            className: "w-full h-full",
            viewBox: "0 0 100 100",
            preserveAspectRatio: "none",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [
              [
                [0, 0],
                [100, 0],
                [0, 100],
                [100, 100],
              ].map(([d, p], m) =>
                H.jsx(
                  lt.path,
                  {
                    d: `
                M ${d},${p}
                c ${d === 0 ? "10" : "-10"},0 ${d === 0 ? "15" : "-15"},5 ${d === 0 ? "20" : "-20"},10
                c ${d === 0 ? "-5" : "5"},-3 ${d === 0 ? "-8" : "8"},-6 ${d === 0 ? "-10" : "10"},-8
                c ${d === 0 ? "8" : "-8"},4 ${d === 0 ? "12" : "-12"},8 ${d === 0 ? "15" : "-15"},12
                c ${d === 0 ? "-12" : "12"},-6 ${d === 0 ? "-18" : "18"},-12 ${d === 0 ? "-20" : "20"},-15
                ${p === 0 ? "c 0,8 -2,15 -5,20" : "c 0,-8 -2,-15 -5,-20"}
                ${p === 0 ? "c 5,0 10,-2 15,-5" : "c 5,0 10,2 15,5"}
              `,
                    stroke: "url(#borderGradient)",
                    strokeWidth: "0.3",
                    fill: "none",
                    initial: { pathLength: 0 },
                    animate: { pathLength: 1 },
                    style: { opacity: c },
                    transition: {
                      duration: 2,
                      ease: "easeInOut",
                      delay: m * 0.2,
                    },
                  },
                  `henna-corner-${m}`,
                ),
              ),
              [0, 100].map((d, p) =>
                H.jsx(
                  t8.Fragment,
                  {
                    children: H.jsx(lt.path, {
                      d: `
                  M ${d},20 
                  c ${d === 0 ? "10" : "-10"},5 ${d === 0 ? "5" : "-5"},15 ${d === 0 ? "15" : "-15"},20
                  c ${d === 0 ? "-10" : "10"},-5 ${d === 0 ? "-5" : "5"},-15 ${d === 0 ? "-15" : "15"},-20
                  m 0,30
                  c ${d === 0 ? "8" : "-8"},3 ${d === 0 ? "4" : "-4"},9 ${d === 0 ? "12" : "-12"},12
                  c ${d === 0 ? "-8" : "8"},-3 ${d === 0 ? "-4" : "4"},-9 ${d === 0 ? "-12" : "12"},-12
                  m 0,30
                  c ${d === 0 ? "10" : "-10"},5 ${d === 0 ? "5" : "-5"},15 ${d === 0 ? "15" : "-15"},20
                  c ${d === 0 ? "-10" : "10"},-5 ${d === 0 ? "-5" : "5"},-15 ${d === 0 ? "-15" : "15"},-20
                `,
                      stroke: "url(#borderGradient)",
                      strokeWidth: "0.3",
                      fill: "none",
                      initial: { pathLength: 0 },
                      animate: { pathLength: 1 },
                      style: { opacity: c },
                      transition: {
                        duration: 1.5,
                        ease: "easeInOut",
                        delay: 1 + p * 0.3,
                      },
                    }),
                  },
                  `henna-side-${p}`,
                ),
              ),
              [25, 75].map((d, p) =>
                H.jsx(
                  lt.path,
                  {
                    d: `
                M 0,${d} 
                c 5,0 8,-5 10,-8
                s 5,-5 8,-5
                s 6,3 6,6
                s -3,6 -6,6
                s -6,-3 -6,-6
                m 20,0
                c 0,-4 4,-8 8,-8
                s 8,4 8,8
                s -4,8 -8,8
                s -8,-4 -8,-8
              `,
                    stroke: "url(#borderGradient)",
                    strokeWidth: "0.2",
                    fill: "none",
                    initial: { pathLength: 0 },
                    animate: { pathLength: 1 },
                    style: { opacity: c },
                    transition: {
                      duration: 1.5,
                      ease: "easeInOut",
                      delay: 2 + p * 0.2,
                    },
                  },
                  `flower-${p}`,
                ),
              ),
              H.jsx("defs", {
                children: H.jsxs("linearGradient", {
                  id: "borderGradient",
                  x1: "0%",
                  y1: "0%",
                  x2: "100%",
                  y2: "100%",
                  children: [
                    H.jsx("stop", { offset: "0%", stopColor: "#bf9b30" }),
                    H.jsx("stop", { offset: "25%", stopColor: "#e36414" }),
                    H.jsx("stop", { offset: "50%", stopColor: "#bf9b30" }),
                    H.jsx("stop", { offset: "75%", stopColor: "#e36414" }),
                    H.jsx("stop", { offset: "100%", stopColor: "#bf9b30" }),
                  ],
                }),
              }),
            ],
          }),
        }),
        n && r,
      ],
    })
  );
};
function sk(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function pw(r) {
  return sk(r) || Array.isArray(r);
}
function ak() {
  return !!(
    typeof window < "u" &&
    window.document &&
    window.document.createElement
  );
}
function Rx(r, e) {
  const t = Object.keys(r),
    n = Object.keys(e);
  if (t.length !== n.length) return !1;
  const i = JSON.stringify(Object.keys(r.breakpoints || {})),
    s = JSON.stringify(Object.keys(e.breakpoints || {}));
  return i !== s
    ? !1
    : t.every((a) => {
        const l = r[a],
          c = e[a];
        return typeof l == "function"
          ? `${l}` == `${c}`
          : !pw(l) || !pw(c)
            ? l === c
            : Rx(l, c);
      });
}
function mw(r) {
  return r
    .concat()
    .sort((e, t) => (e.name > t.name ? 1 : -1))
    .map((e) => e.options);
}
function ok(r, e) {
  if (r.length !== e.length) return !1;
  const t = mw(r),
    n = mw(e);
  return t.every((i, s) => {
    const a = n[s];
    return Rx(i, a);
  });
}
function Ix(r) {
  return typeof r == "number";
}
function zv(r) {
  return typeof r == "string";
}
function s2(r) {
  return typeof r == "boolean";
}
function gw(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function ar(r) {
  return Math.abs(r);
}
function Bx(r) {
  return Math.sign(r);
}
function bp(r, e) {
  return ar(r - e);
}
function lk(r, e) {
  if (r === 0 || e === 0 || ar(r) <= ar(e)) return 0;
  const t = bp(ar(r), ar(e));
  return ar(t / r);
}
function uk(r) {
  return Math.round(r * 100) / 100;
}
function kp(r) {
  return zp(r).map(Number);
}
function Ma(r) {
  return r[hm(r)];
}
function hm(r) {
  return Math.max(0, r.length - 1);
}
function Px(r, e) {
  return e === hm(r);
}
function yw(r, e = 0) {
  return Array.from(Array(r), (t, n) => e + n);
}
function zp(r) {
  return Object.keys(r);
}
function E6(r, e) {
  return [r, e].reduce(
    (t, n) => (
      zp(n).forEach((i) => {
        const s = t[i],
          a = n[i],
          l = gw(s) && gw(a);
        t[i] = l ? E6(s, a) : a;
      }),
      t
    ),
    {},
  );
}
function Hv(r, e) {
  return typeof e.MouseEvent < "u" && r instanceof e.MouseEvent;
}
function ck(r, e) {
  const t = { start: n, center: i, end: s };
  function n() {
    return 0;
  }
  function i(l) {
    return s(l) / 2;
  }
  function s(l) {
    return e - l;
  }
  function a(l, c) {
    return zv(r) ? t[r](l) : r(e, l, c);
  }
  return { measure: a };
}
function Hp() {
  let r = [];
  function e(i, s, a, l = { passive: !0 }) {
    let c;
    if ("addEventListener" in i)
      i.addEventListener(s, a, l), (c = () => i.removeEventListener(s, a, l));
    else {
      const d = i;
      d.addListener(a), (c = () => d.removeListener(a));
    }
    return r.push(c), n;
  }
  function t() {
    r = r.filter((i) => i());
  }
  const n = { add: e, clear: t };
  return n;
}
function dk(r, e, t, n) {
  const i = Hp(),
    s = 1e3 / 60;
  let a = null,
    l = 0,
    c = 0;
  function d() {
    i.add(r, "visibilitychange", () => {
      r.hidden && A();
    });
  }
  function p() {
    v(), i.clear();
  }
  function m(M) {
    if (!c) return;
    a || ((a = M), t(), t());
    const w = M - a;
    for (a = M, l += w; l >= s; ) t(), (l -= s);
    const x = l / s;
    n(x), c && (c = e.requestAnimationFrame(m));
  }
  function y() {
    c || (c = e.requestAnimationFrame(m));
  }
  function v() {
    e.cancelAnimationFrame(c), (a = null), (l = 0), (c = 0);
  }
  function A() {
    (a = null), (l = 0);
  }
  return { init: d, destroy: p, start: y, stop: v, update: t, render: n };
}
function hk(r, e) {
  const t = e === "rtl",
    n = r === "y",
    i = n ? "y" : "x",
    s = n ? "x" : "y",
    a = !n && t ? -1 : 1,
    l = p(),
    c = m();
  function d(v) {
    const { height: A, width: M } = v;
    return n ? A : M;
  }
  function p() {
    return n ? "top" : t ? "right" : "left";
  }
  function m() {
    return n ? "bottom" : t ? "left" : "right";
  }
  function y(v) {
    return v * a;
  }
  return {
    scroll: i,
    cross: s,
    startEdge: l,
    endEdge: c,
    measureSize: d,
    direction: y,
  };
}
function zc(r = 0, e = 0) {
  const t = ar(r - e);
  function n(c) {
    return c < r;
  }
  function i(c) {
    return c > e;
  }
  function s(c) {
    return n(c) || i(c);
  }
  function a(c) {
    return s(c) ? (n(c) ? r : e) : c;
  }
  function l(c) {
    return t ? c - t * Math.ceil((c - e) / t) : c;
  }
  return {
    length: t,
    max: e,
    min: r,
    constrain: a,
    reachedAny: s,
    reachedMax: i,
    reachedMin: n,
    removeOffset: l,
  };
}
function C6(r, e, t) {
  const { constrain: n } = zc(0, r),
    i = r + 1;
  let s = a(e);
  function a(y) {
    return t ? ar((i + y) % i) : n(y);
  }
  function l() {
    return s;
  }
  function c(y) {
    return (s = a(y)), m;
  }
  function d(y) {
    return p().set(l() + y);
  }
  function p() {
    return C6(r, l(), t);
  }
  const m = { get: l, set: c, add: d, clone: p };
  return m;
}
function fk(r, e, t, n, i, s, a, l, c, d, p, m, y, v, A, M, w, x, C) {
  const { cross: T, direction: I } = r,
    U = ["INPUT", "SELECT", "TEXTAREA"],
    F = { passive: !1 },
    O = Hp(),
    z = Hp(),
    L = zc(50, 225).constrain(v.measure(20)),
    N = { mouse: 300, touch: 400 },
    X = { mouse: 500, touch: 600 },
    ie = A ? 43 : 25;
  let re = !1,
    me = 0,
    _e = 0,
    ge = !1,
    Re = !1,
    J = !1,
    oe = !1;
  function ae(be) {
    if (!C) return;
    function Te(K) {
      (s2(C) || C(be, K)) && Ue(K);
    }
    const Ne = e;
    O.add(Ne, "dragstart", (K) => K.preventDefault(), F)
      .add(Ne, "touchmove", () => {}, F)
      .add(Ne, "touchend", () => {})
      .add(Ne, "touchstart", Te)
      .add(Ne, "mousedown", Te)
      .add(Ne, "touchcancel", Je)
      .add(Ne, "contextmenu", Je)
      .add(Ne, "click", et, !0);
  }
  function q() {
    O.clear(), z.clear();
  }
  function ce() {
    const be = oe ? t : e;
    z.add(be, "touchmove", Fe, F)
      .add(be, "touchend", Je)
      .add(be, "mousemove", Fe, F)
      .add(be, "mouseup", Je);
  }
  function Xe(be) {
    const Te = be.nodeName || "";
    return U.includes(Te);
  }
  function ye() {
    return (A ? X : N)[oe ? "mouse" : "touch"];
  }
  function Pe(be, Te) {
    const Ne = m.add(Bx(be) * -1),
      K = p.byDistance(be, !A).distance;
    return A || ar(be) < L
      ? K
      : w && Te
        ? K * 0.5
        : p.byIndex(Ne.get(), 0).distance;
  }
  function Ue(be) {
    const Te = Hv(be, n);
    (oe = Te),
      (J = A && Te && !be.buttons && re),
      (re = bp(i.get(), a.get()) >= 2),
      !(Te && be.button !== 0) &&
        (Xe(be.target) ||
          ((ge = !0),
          s.pointerDown(be),
          d.useFriction(0).useDuration(0),
          i.set(a),
          ce(),
          (me = s.readPoint(be)),
          (_e = s.readPoint(be, T)),
          y.emit("pointerDown")));
  }
  function Fe(be) {
    if (!Hv(be, n) && be.touches.length >= 2) return Je(be);
    const Te = s.readPoint(be),
      Ne = s.readPoint(be, T),
      K = bp(Te, me),
      qe = bp(Ne, _e);
    if (!Re && !oe && (!be.cancelable || ((Re = K > qe), !Re))) return Je(be);
    const ct = s.pointerMove(be);
    K > M && (J = !0),
      d.useFriction(0.3).useDuration(0.75),
      l.start(),
      i.add(I(ct)),
      be.preventDefault();
  }
  function Je(be) {
    const Te = p.byDistance(0, !1).index !== m.get(),
      Ne = s.pointerUp(be) * ye(),
      K = Pe(I(Ne), Te),
      qe = lk(Ne, K),
      ct = ie - 10 * qe,
      Be = x + qe / 50;
    (Re = !1),
      (ge = !1),
      z.clear(),
      d.useDuration(ct).useFriction(Be),
      c.distance(K, !A),
      (oe = !1),
      y.emit("pointerUp");
  }
  function et(be) {
    J && (be.stopPropagation(), be.preventDefault(), (J = !1));
  }
  function tt() {
    return ge;
  }
  return { init: ae, destroy: q, pointerDown: tt };
}
function pk(r, e) {
  let t, n;
  function i(d) {
    return d.timeStamp;
  }
  function s(d, p) {
    const m = `client${(p || r.scroll) === "x" ? "X" : "Y"}`;
    return (Hv(d, e) ? d : d.touches[0])[m];
  }
  function a(d) {
    return (t = d), (n = d), s(d);
  }
  function l(d) {
    const p = s(d) - s(n),
      m = i(d) - i(t) > 170;
    return (n = d), m && (t = d), p;
  }
  function c(d) {
    if (!t || !n) return 0;
    const p = s(n) - s(t),
      m = i(d) - i(t),
      y = i(d) - i(n) > 170,
      v = p / m;
    return m && !y && ar(v) > 0.1 ? v : 0;
  }
  return { pointerDown: a, pointerMove: l, pointerUp: c, readPoint: s };
}
function mk() {
  function r(e) {
    const { offsetTop: t, offsetLeft: n, offsetWidth: i, offsetHeight: s } = e;
    return {
      top: t,
      right: n + i,
      bottom: t + s,
      left: n,
      width: i,
      height: s,
    };
  }
  return { measure: r };
}
function gk(r) {
  function e(t) {
    return r * (t / 100);
  }
  return { measure: e };
}
function yk(r, e, t, n, i, s, a) {
  const l = [r].concat(n);
  let c,
    d,
    p = [],
    m = !1;
  function y(M) {
    return i.measureSize(a.measure(M));
  }
  function v(M) {
    if (!s) return;
    (d = y(r)), (p = n.map(y));
    function w(x) {
      for (const C of x) {
        if (m) return;
        const T = C.target === r,
          I = n.indexOf(C.target),
          U = T ? d : p[I],
          F = y(T ? r : n[I]);
        if (ar(F - U) >= 0.5) {
          M.reInit(), e.emit("resize");
          break;
        }
      }
    }
    (c = new ResizeObserver((x) => {
      (s2(s) || s(M, x)) && w(x);
    })),
      t.requestAnimationFrame(() => {
        l.forEach((x) => c.observe(x));
      });
  }
  function A() {
    (m = !0), c && c.disconnect();
  }
  return { init: v, destroy: A };
}
function vk(r, e, t, n, i, s) {
  let a = 0,
    l = 0,
    c = i,
    d = s,
    p = r.get(),
    m = 0;
  function y() {
    const F = n.get() - r.get(),
      O = !c;
    let z = 0;
    return (
      O
        ? ((a = 0), t.set(n), r.set(n), (z = F))
        : (t.set(r), (a += F / c), (a *= d), (p += a), r.add(a), (z = p - m)),
      (l = Bx(z)),
      (m = p),
      U
    );
  }
  function v() {
    const F = n.get() - e.get();
    return ar(F) < 0.001;
  }
  function A() {
    return c;
  }
  function M() {
    return l;
  }
  function w() {
    return a;
  }
  function x() {
    return T(i);
  }
  function C() {
    return I(s);
  }
  function T(F) {
    return (c = F), U;
  }
  function I(F) {
    return (d = F), U;
  }
  const U = {
    direction: M,
    duration: A,
    velocity: w,
    seek: y,
    settled: v,
    useBaseFriction: C,
    useBaseDuration: x,
    useFriction: I,
    useDuration: T,
  };
  return U;
}
function xk(r, e, t, n, i) {
  const s = i.measure(10),
    a = i.measure(50),
    l = zc(0.1, 0.99);
  let c = !1;
  function d() {
    return !(c || !r.reachedAny(t.get()) || !r.reachedAny(e.get()));
  }
  function p(y) {
    if (!d()) return;
    const v = r.reachedMin(e.get()) ? "min" : "max",
      A = ar(r[v] - e.get()),
      M = t.get() - e.get(),
      w = l.constrain(A / a);
    t.subtract(M * w),
      !y &&
        ar(M) < s &&
        (t.set(r.constrain(t.get())), n.useDuration(25).useBaseFriction());
  }
  function m(y) {
    c = !y;
  }
  return { shouldConstrain: d, constrain: p, toggleActive: m };
}
function bk(r, e, t, n, i) {
  const s = zc(-e + r, 0),
    a = m(),
    l = p(),
    c = y();
  function d(v, A) {
    return bp(v, A) <= 1;
  }
  function p() {
    const v = a[0],
      A = Ma(a),
      M = a.lastIndexOf(v),
      w = a.indexOf(A) + 1;
    return zc(M, w);
  }
  function m() {
    return t
      .map((v, A) => {
        const { min: M, max: w } = s,
          x = s.constrain(v),
          C = !A,
          T = Px(t, A);
        return C ? w : T || d(M, x) ? M : d(w, x) ? w : x;
      })
      .map((v) => parseFloat(v.toFixed(3)));
  }
  function y() {
    if (e <= r + i) return [s.max];
    if (n === "keepSnaps") return a;
    const { min: v, max: A } = l;
    return a.slice(v, A);
  }
  return { snapsContained: c, scrollContainLimit: l };
}
function _k(r, e, t) {
  const n = e[0],
    i = t ? n - r : Ma(e);
  return { limit: zc(i, n) };
}
function Ak(r, e, t, n) {
  const i = e.min + 0.1,
    s = e.max + 0.1,
    { reachedMin: a, reachedMax: l } = zc(i, s);
  function c(p) {
    return p === 1 ? l(t.get()) : p === -1 ? a(t.get()) : !1;
  }
  function d(p) {
    if (!c(p)) return;
    const m = r * (p * -1);
    n.forEach((y) => y.add(m));
  }
  return { loop: d };
}
function wk(r) {
  const { max: e, length: t } = r;
  function n(i) {
    const s = i - e;
    return t ? s / -t : 0;
  }
  return { get: n };
}
function Mk(r, e, t, n, i) {
  const { startEdge: s, endEdge: a } = r,
    { groupSlides: l } = i,
    c = m().map(e.measure),
    d = y(),
    p = v();
  function m() {
    return l(n)
      .map((A) => Ma(A)[a] - A[0][s])
      .map(ar);
  }
  function y() {
    return n.map((A) => t[s] - A[s]).map((A) => -ar(A));
  }
  function v() {
    return l(d)
      .map((A) => A[0])
      .map((A, M) => A + c[M]);
  }
  return { snaps: d, snapsAligned: p };
}
function Sk(r, e, t, n, i, s) {
  const { groupSlides: a } = i,
    { min: l, max: c } = n,
    d = p();
  function p() {
    const m = a(s),
      y = !r || e === "keepSnaps";
    return t.length === 1
      ? [s]
      : y
        ? m
        : m.slice(l, c).map((v, A, M) => {
            const w = !A,
              x = Px(M, A);
            if (w) {
              const C = Ma(M[0]) + 1;
              return yw(C);
            }
            if (x) {
              const C = hm(s) - Ma(M)[0] + 1;
              return yw(C, Ma(M)[0]);
            }
            return v;
          });
  }
  return { slideRegistry: d };
}
function Ek(r, e, t, n, i) {
  const { reachedAny: s, removeOffset: a, constrain: l } = n;
  function c(v) {
    return v.concat().sort((A, M) => ar(A) - ar(M))[0];
  }
  function d(v) {
    const A = r ? a(v) : l(v),
      M = e
        .map((x, C) => ({ diff: p(x - A, 0), index: C }))
        .sort((x, C) => ar(x.diff) - ar(C.diff)),
      { index: w } = M[0];
    return { index: w, distance: A };
  }
  function p(v, A) {
    const M = [v, v + t, v - t];
    if (!r) return v;
    if (!A) return c(M);
    const w = M.filter((x) => Bx(x) === A);
    return w.length ? c(w) : Ma(M) - t;
  }
  function m(v, A) {
    const M = e[v] - i.get(),
      w = p(M, A);
    return { index: v, distance: w };
  }
  function y(v, A) {
    const M = i.get() + v,
      { index: w, distance: x } = d(M),
      C = !r && s(M);
    if (!A || C) return { index: w, distance: v };
    const T = e[w] - x,
      I = v + p(T, 0);
    return { index: w, distance: I };
  }
  return { byDistance: y, byIndex: m, shortcut: p };
}
function Ck(r, e, t, n, i, s, a) {
  function l(p) {
    const m = p.distance,
      y = p.index !== e.get();
    s.add(m),
      m && (n.duration() ? r.start() : (r.update(), r.render(1), r.update())),
      y && (t.set(e.get()), e.set(p.index), a.emit("select"));
  }
  function c(p, m) {
    const y = i.byDistance(p, m);
    l(y);
  }
  function d(p, m) {
    const y = e.clone().set(p),
      v = i.byIndex(y.get(), m);
    l(v);
  }
  return { distance: c, index: d };
}
function Tk(r, e, t, n, i, s, a, l) {
  const c = { passive: !0, capture: !0 };
  let d = 0;
  function p(y) {
    if (!l) return;
    function v(A) {
      if (new Date().getTime() - d > 10) return;
      a.emit("slideFocusStart"), (r.scrollLeft = 0);
      const M = t.findIndex((w) => w.includes(A));
      Ix(M) && (i.useDuration(0), n.index(M, 0), a.emit("slideFocus"));
    }
    s.add(document, "keydown", m, !1),
      e.forEach((A, M) => {
        s.add(
          A,
          "focus",
          (w) => {
            (s2(l) || l(y, w)) && v(M);
          },
          c,
        );
      });
  }
  function m(y) {
    y.code === "Tab" && (d = new Date().getTime());
  }
  return { init: p };
}
function np(r) {
  let e = r;
  function t() {
    return e;
  }
  function n(l) {
    e = a(l);
  }
  function i(l) {
    e += a(l);
  }
  function s(l) {
    e -= a(l);
  }
  function a(l) {
    return Ix(l) ? l : l.get();
  }
  return { get: t, set: n, add: i, subtract: s };
}
function T6(r, e) {
  const t = r.scroll === "x" ? a : l,
    n = e.style;
  let i = null,
    s = !1;
  function a(m) {
    return `translate3d(${m}px,0px,0px)`;
  }
  function l(m) {
    return `translate3d(0px,${m}px,0px)`;
  }
  function c(m) {
    if (s) return;
    const y = uk(r.direction(m));
    y !== i && ((n.transform = t(y)), (i = y));
  }
  function d(m) {
    s = !m;
  }
  function p() {
    s ||
      ((n.transform = ""),
      e.getAttribute("style") || e.removeAttribute("style"));
  }
  return { clear: p, to: c, toggleActive: d };
}
function Rk(r, e, t, n, i, s, a, l, c) {
  const d = kp(i),
    p = kp(i).reverse(),
    m = w().concat(x());
  function y(U, F) {
    return U.reduce((O, z) => O - i[z], F);
  }
  function v(U, F) {
    return U.reduce((O, z) => (y(O, F) > 0 ? O.concat([z]) : O), []);
  }
  function A(U) {
    return s.map((F, O) => ({
      start: F - n[O] + 0.5 + U,
      end: F + e - 0.5 + U,
    }));
  }
  function M(U, F, O) {
    const z = A(F);
    return U.map((L) => {
      const N = O ? 0 : -t,
        X = O ? t : 0,
        ie = O ? "end" : "start",
        re = z[L][ie];
      return {
        index: L,
        loopPoint: re,
        slideLocation: np(-1),
        translate: T6(r, c[L]),
        target: () => (l.get() > re ? N : X),
      };
    });
  }
  function w() {
    const U = a[0],
      F = v(p, U);
    return M(F, t, !1);
  }
  function x() {
    const U = e - a[0] - 1,
      F = v(d, U);
    return M(F, -t, !0);
  }
  function C() {
    return m.every(({ index: U }) => {
      const F = d.filter((O) => O !== U);
      return y(F, e) <= 0.1;
    });
  }
  function T() {
    m.forEach((U) => {
      const { target: F, translate: O, slideLocation: z } = U,
        L = F();
      L !== z.get() && (O.to(L), z.set(L));
    });
  }
  function I() {
    m.forEach((U) => U.translate.clear());
  }
  return { canLoop: C, clear: I, loop: T, loopPoints: m };
}
function Ik(r, e, t) {
  let n,
    i = !1;
  function s(l) {
    if (!t) return;
    function c(d) {
      for (const p of d)
        if (p.type === "childList") {
          l.reInit(), e.emit("slidesChanged");
          break;
        }
    }
    (n = new MutationObserver((d) => {
      i || ((s2(t) || t(l, d)) && c(d));
    })),
      n.observe(r, { childList: !0 });
  }
  function a() {
    n && n.disconnect(), (i = !0);
  }
  return { init: s, destroy: a };
}
function Bk(r, e, t, n) {
  const i = {};
  let s = null,
    a = null,
    l,
    c = !1;
  function d() {
    (l = new IntersectionObserver(
      (v) => {
        c ||
          (v.forEach((A) => {
            const M = e.indexOf(A.target);
            i[M] = A;
          }),
          (s = null),
          (a = null),
          t.emit("slidesInView"));
      },
      { root: r.parentElement, threshold: n },
    )),
      e.forEach((v) => l.observe(v));
  }
  function p() {
    l && l.disconnect(), (c = !0);
  }
  function m(v) {
    return zp(i).reduce((A, M) => {
      const w = parseInt(M),
        { isIntersecting: x } = i[w];
      return ((v && x) || (!v && !x)) && A.push(w), A;
    }, []);
  }
  function y(v = !0) {
    if (v && s) return s;
    if (!v && a) return a;
    const A = m(v);
    return v && (s = A), v || (a = A), A;
  }
  return { init: d, destroy: p, get: y };
}
function Pk(r, e, t, n, i, s) {
  const { measureSize: a, startEdge: l, endEdge: c } = r,
    d = t[0] && i,
    p = A(),
    m = M(),
    y = t.map(a),
    v = w();
  function A() {
    if (!d) return 0;
    const x = t[0];
    return ar(e[l] - x[l]);
  }
  function M() {
    if (!d) return 0;
    const x = s.getComputedStyle(Ma(n));
    return parseFloat(x.getPropertyValue(`margin-${c}`));
  }
  function w() {
    return t
      .map((x, C, T) => {
        const I = !C,
          U = Px(T, C);
        return I ? y[C] + p : U ? y[C] + m : T[C + 1][l] - x[l];
      })
      .map(ar);
  }
  return { slideSizes: y, slideSizesWithGaps: v, startGap: p, endGap: m };
}
function Lk(r, e, t, n, i, s, a, l, c) {
  const { startEdge: d, endEdge: p, direction: m } = r,
    y = Ix(t);
  function v(w, x) {
    return kp(w)
      .filter((C) => C % x === 0)
      .map((C) => w.slice(C, C + x));
  }
  function A(w) {
    return w.length
      ? kp(w)
          .reduce((x, C, T) => {
            const I = Ma(x) || 0,
              U = I === 0,
              F = C === hm(w),
              O = i[d] - s[I][d],
              z = i[d] - s[C][p],
              L = !n && U ? m(a) : 0,
              N = !n && F ? m(l) : 0,
              X = ar(z - N - (O + L));
            return T && X > e + c && x.push(C), F && x.push(w.length), x;
          }, [])
          .map((x, C, T) => {
            const I = Math.max(T[C - 1] || 0);
            return w.slice(I, x);
          })
      : [];
  }
  function M(w) {
    return y ? v(w, t) : A(w);
  }
  return { groupSlides: M };
}
function Dk(r, e, t, n, i, s, a) {
  const {
      align: l,
      axis: c,
      direction: d,
      startIndex: p,
      loop: m,
      duration: y,
      dragFree: v,
      dragThreshold: A,
      inViewThreshold: M,
      slidesToScroll: w,
      skipSnaps: x,
      containScroll: C,
      watchResize: T,
      watchSlides: I,
      watchDrag: U,
      watchFocus: F,
    } = s,
    O = 2,
    z = mk(),
    L = z.measure(e),
    N = t.map(z.measure),
    X = hk(c, d),
    ie = X.measureSize(L),
    re = gk(ie),
    me = ck(l, ie),
    _e = !m && !!C,
    ge = m || !!C,
    {
      slideSizes: Re,
      slideSizesWithGaps: J,
      startGap: oe,
      endGap: ae,
    } = Pk(X, L, N, t, ge, i),
    q = Lk(X, ie, w, m, L, N, oe, ae, O),
    { snaps: ce, snapsAligned: Xe } = Mk(X, me, L, N, q),
    ye = -Ma(ce) + Ma(J),
    { snapsContained: Pe, scrollContainLimit: Ue } = bk(ie, ye, Xe, C, O),
    Fe = _e ? Pe : Xe,
    { limit: Je } = _k(ye, Fe, m),
    et = C6(hm(Fe), p, m),
    tt = et.clone(),
    be = kp(t),
    Te = ({
      dragHandler: Ot,
      scrollBody: Ke,
      scrollBounds: ht,
      options: { loop: Tt },
    }) => {
      Tt || ht.constrain(Ot.pointerDown()), Ke.seek();
    },
    Ne = (
      {
        scrollBody: Ot,
        translate: Ke,
        location: ht,
        offsetLocation: Tt,
        previousLocation: st,
        scrollLooper: xt,
        slideLooper: Qt,
        dragHandler: D,
        animation: W,
        eventHandler: k,
        scrollBounds: ne,
        options: { loop: Q },
      },
      te,
    ) => {
      const Ae = Ot.settled(),
        pe = !ne.shouldConstrain(),
        Ve = Q ? Ae : Ae && pe;
      Ve && !D.pointerDown() && (W.stop(), k.emit("settle")),
        Ve || k.emit("scroll");
      const He = ht.get() * te + st.get() * (1 - te);
      Tt.set(He), Q && (xt.loop(Ot.direction()), Qt.loop()), Ke.to(Tt.get());
    },
    K = dk(
      n,
      i,
      () => Te(ft),
      (Ot) => Ne(ft, Ot),
    ),
    qe = 0.68,
    ct = Fe[et.get()],
    Be = np(ct),
    nt = np(ct),
    Dt = np(ct),
    it = np(ct),
    Z = vk(Be, Dt, nt, it, y, qe),
    G = Ek(m, Fe, ye, Je, it),
    xe = Ck(K, et, tt, Z, G, it, a),
    ze = wk(Je),
    We = Hp(),
    Oe = Bk(e, t, a, M),
    { slideRegistry: Mt } = Sk(_e, C, Fe, Ue, q, be),
    ot = Tk(r, t, Mt, xe, Z, We, a, F),
    ft = {
      ownerDocument: n,
      ownerWindow: i,
      eventHandler: a,
      containerRect: L,
      slideRects: N,
      animation: K,
      axis: X,
      dragHandler: fk(
        X,
        r,
        n,
        i,
        it,
        pk(X, i),
        Be,
        K,
        xe,
        Z,
        G,
        et,
        a,
        re,
        v,
        A,
        x,
        qe,
        U,
      ),
      eventStore: We,
      percentOfView: re,
      index: et,
      indexPrevious: tt,
      limit: Je,
      location: Be,
      offsetLocation: Dt,
      previousLocation: nt,
      options: s,
      resizeHandler: yk(e, a, i, t, X, T, z),
      scrollBody: Z,
      scrollBounds: xk(Je, Dt, it, Z, re),
      scrollLooper: Ak(ye, Je, Dt, [Be, Dt, nt, it]),
      scrollProgress: ze,
      scrollSnapList: Fe.map(ze.get),
      scrollSnaps: Fe,
      scrollTarget: G,
      scrollTo: xe,
      slideLooper: Rk(X, ie, ye, Re, J, ce, Fe, Dt, t),
      slideFocus: ot,
      slidesHandler: Ik(e, a, I),
      slidesInView: Oe,
      slideIndexes: be,
      slideRegistry: Mt,
      slidesToScroll: q,
      target: it,
      translate: T6(X, e),
    };
  return ft;
}
function Fk() {
  let r = {},
    e;
  function t(d) {
    e = d;
  }
  function n(d) {
    return r[d] || [];
  }
  function i(d) {
    return n(d).forEach((p) => p(e, d)), c;
  }
  function s(d, p) {
    return (r[d] = n(d).concat([p])), c;
  }
  function a(d, p) {
    return (r[d] = n(d).filter((m) => m !== p)), c;
  }
  function l() {
    r = {};
  }
  const c = { init: t, emit: i, off: a, on: s, clear: l };
  return c;
}
const Nk = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0,
};
function Uk(r) {
  function e(i, s) {
    return E6(i, s || {});
  }
  function t(i) {
    const s = i.breakpoints || {},
      a = zp(s)
        .filter((l) => r.matchMedia(l).matches)
        .map((l) => s[l])
        .reduce((l, c) => e(l, c), {});
    return e(i, a);
  }
  function n(i) {
    return i
      .map((s) => zp(s.breakpoints || {}))
      .reduce((s, a) => s.concat(a), [])
      .map(r.matchMedia);
  }
  return { mergeOptions: e, optionsAtMedia: t, optionsMediaQueries: n };
}
function Ok(r) {
  let e = [];
  function t(i, s) {
    return (
      (e = s.filter(({ options: a }) => r.optionsAtMedia(a).active !== !1)),
      e.forEach((a) => a.init(i, r)),
      s.reduce((a, l) => Object.assign(a, { [l.name]: l }), {})
    );
  }
  function n() {
    e = e.filter((i) => i.destroy());
  }
  return { init: t, destroy: n };
}
function gg(r, e, t) {
  const n = r.ownerDocument,
    i = n.defaultView,
    s = Uk(i),
    a = Ok(s),
    l = Hp(),
    c = Fk(),
    { mergeOptions: d, optionsAtMedia: p, optionsMediaQueries: m } = s,
    { on: y, off: v, emit: A } = c,
    M = X;
  let w = !1,
    x,
    C = d(Nk, gg.globalOptions),
    T = d(C),
    I = [],
    U,
    F,
    O;
  function z() {
    const { container: be, slides: Te } = T;
    F = (zv(be) ? r.querySelector(be) : be) || r.children[0];
    const Ne = zv(Te) ? F.querySelectorAll(Te) : Te;
    O = [].slice.call(Ne || F.children);
  }
  function L(be) {
    const Te = Dk(r, F, O, n, i, be, c);
    if (be.loop && !Te.slideLooper.canLoop()) {
      const Ne = Object.assign({}, be, { loop: !1 });
      return L(Ne);
    }
    return Te;
  }
  function N(be, Te) {
    w ||
      ((C = d(C, be)),
      (T = p(C)),
      (I = Te || I),
      z(),
      (x = L(T)),
      m([C, ...I.map(({ options: Ne }) => Ne)]).forEach((Ne) =>
        l.add(Ne, "change", X),
      ),
      T.active &&
        (x.translate.to(x.location.get()),
        x.animation.init(),
        x.slidesInView.init(),
        x.slideFocus.init(tt),
        x.eventHandler.init(tt),
        x.resizeHandler.init(tt),
        x.slidesHandler.init(tt),
        x.options.loop && x.slideLooper.loop(),
        F.offsetParent && O.length && x.dragHandler.init(tt),
        (U = a.init(tt, I))));
  }
  function X(be, Te) {
    const Ne = q();
    ie(), N(d({ startIndex: Ne }, be), Te), c.emit("reInit");
  }
  function ie() {
    x.dragHandler.destroy(),
      x.eventStore.clear(),
      x.translate.clear(),
      x.slideLooper.clear(),
      x.resizeHandler.destroy(),
      x.slidesHandler.destroy(),
      x.slidesInView.destroy(),
      x.animation.destroy(),
      a.destroy(),
      l.clear();
  }
  function re() {
    w || ((w = !0), l.clear(), ie(), c.emit("destroy"), c.clear());
  }
  function me(be, Te, Ne) {
    !T.active ||
      w ||
      (x.scrollBody.useBaseFriction().useDuration(Te === !0 ? 0 : T.duration),
      x.scrollTo.index(be, Ne || 0));
  }
  function _e(be) {
    const Te = x.index.add(1).get();
    me(Te, be, -1);
  }
  function ge(be) {
    const Te = x.index.add(-1).get();
    me(Te, be, 1);
  }
  function Re() {
    return x.index.add(1).get() !== q();
  }
  function J() {
    return x.index.add(-1).get() !== q();
  }
  function oe() {
    return x.scrollSnapList;
  }
  function ae() {
    return x.scrollProgress.get(x.location.get());
  }
  function q() {
    return x.index.get();
  }
  function ce() {
    return x.indexPrevious.get();
  }
  function Xe() {
    return x.slidesInView.get();
  }
  function ye() {
    return x.slidesInView.get(!1);
  }
  function Pe() {
    return U;
  }
  function Ue() {
    return x;
  }
  function Fe() {
    return r;
  }
  function Je() {
    return F;
  }
  function et() {
    return O;
  }
  const tt = {
    canScrollNext: Re,
    canScrollPrev: J,
    containerNode: Je,
    internalEngine: Ue,
    destroy: re,
    off: v,
    on: y,
    emit: A,
    plugins: Pe,
    previousScrollSnap: ce,
    reInit: M,
    rootNode: Fe,
    scrollNext: _e,
    scrollPrev: ge,
    scrollProgress: ae,
    scrollSnapList: oe,
    scrollTo: me,
    selectedScrollSnap: q,
    slideNodes: et,
    slidesInView: Xe,
    slidesNotInView: ye,
  };
  return N(e, t), setTimeout(() => c.emit("init"), 0), tt;
}
gg.globalOptions = void 0;
function Lx(r = {}, e = []) {
  const t = he.useRef(r),
    n = he.useRef(e),
    [i, s] = he.useState(),
    [a, l] = he.useState(),
    c = he.useCallback(() => {
      i && i.reInit(t.current, n.current);
    }, [i]);
  return (
    he.useEffect(() => {
      Rx(t.current, r) || ((t.current = r), c());
    }, [r, c]),
    he.useEffect(() => {
      ok(n.current, e) || ((n.current = e), c());
    }, [e, c]),
    he.useEffect(() => {
      if (ak() && a) {
        gg.globalOptions = Lx.globalOptions;
        const d = gg(a, t.current, n.current);
        return s(d), () => d.destroy();
      } else s(void 0);
    }, [a, s]),
    [l, i]
  );
}
Lx.globalOptions = void 0;
const kk = {
  active: !0,
  breakpoints: {},
  delay: 4e3,
  jump: !1,
  playOnInit: !0,
  stopOnFocusIn: !0,
  stopOnInteraction: !0,
  stopOnMouseEnter: !1,
  stopOnLastSnap: !1,
  rootNode: null,
};
function zk(r, e) {
  const t = r.scrollSnapList();
  return typeof e == "number" ? t.map(() => e) : e(t, r);
}
function Hk(r, e) {
  const t = r.rootNode();
  return (e && e(t)) || t;
}
function Dx(r = {}) {
  let e,
    t,
    n,
    i,
    s = null,
    a = 0,
    l = !1,
    c = !1,
    d = !1,
    p = !1;
  function m(re, me) {
    t = re;
    const { mergeOptions: _e, optionsAtMedia: ge } = me,
      Re = _e(kk, Dx.globalOptions),
      J = _e(Re, r);
    if (((e = ge(J)), t.scrollSnapList().length <= 1)) return;
    (p = e.jump), (n = !1), (i = zk(t, e.delay));
    const { eventStore: oe, ownerDocument: ae } = t.internalEngine(),
      q = !!t.internalEngine().options.watchDrag,
      ce = Hk(t, e.rootNode);
    oe.add(ae, "visibilitychange", x),
      q && t.on("pointerDown", T),
      q && !e.stopOnInteraction && t.on("pointerUp", I),
      e.stopOnMouseEnter && oe.add(ce, "mouseenter", U),
      e.stopOnMouseEnter && !e.stopOnInteraction && oe.add(ce, "mouseleave", F),
      e.stopOnFocusIn && t.on("slideFocusStart", w),
      e.stopOnFocusIn &&
        !e.stopOnInteraction &&
        oe.add(t.containerNode(), "focusout", M),
      e.playOnInit && M();
  }
  function y() {
    t.off("pointerDown", T).off("pointerUp", I).off("slideFocusStart", w),
      w(),
      (n = !0),
      (l = !1);
  }
  function v() {
    const { ownerWindow: re } = t.internalEngine();
    re.clearTimeout(a),
      (a = re.setTimeout(X, i[t.selectedScrollSnap()])),
      (s = new Date().getTime()),
      t.emit("autoplay:timerset");
  }
  function A() {
    const { ownerWindow: re } = t.internalEngine();
    re.clearTimeout(a), (a = 0), (s = null), t.emit("autoplay:timerstopped");
  }
  function M() {
    if (!n) {
      if (C()) {
        d = !0;
        return;
      }
      l || t.emit("autoplay:play"), v(), (l = !0);
    }
  }
  function w() {
    n || (l && t.emit("autoplay:stop"), A(), (l = !1));
  }
  function x() {
    if (C()) return (d = l), w();
    d && M();
  }
  function C() {
    const { ownerDocument: re } = t.internalEngine();
    return re.visibilityState === "hidden";
  }
  function T() {
    c || w();
  }
  function I() {
    c || M();
  }
  function U() {
    (c = !0), w();
  }
  function F() {
    (c = !1), M();
  }
  function O(re) {
    typeof re < "u" && (p = re), M();
  }
  function z() {
    l && w();
  }
  function L() {
    l && M();
  }
  function N() {
    return l;
  }
  function X() {
    const { index: re } = t.internalEngine(),
      me = re.clone().add(1).get(),
      _e = t.scrollSnapList().length - 1,
      ge = e.stopOnLastSnap && me === _e;
    if (
      (t.canScrollNext() ? t.scrollNext(p) : t.scrollTo(0, p),
      t.emit("autoplay:select"),
      ge)
    )
      return w();
    M();
  }
  function ie() {
    if (!s) return null;
    const re = i[t.selectedScrollSnap()],
      me = new Date().getTime() - s;
    return re - me;
  }
  return {
    name: "autoplay",
    options: r,
    init: m,
    destroy: y,
    play: O,
    stop: z,
    reset: L,
    isPlaying: N,
    timeUntilNext: ie,
  };
}
Dx.globalOptions = void 0;
const Vk = [
    {
      id: 1,
      imageUrl: "src/components/insta_photos/advocacy_event.png",
      caption: "Learning more about our culture and traditions 📰",
    },
    {
      id: 2,
      imageUrl: "src/components/insta_photos/mshaadi.png",
      caption:
        "Celebrating our vibrant South Asian culture at Mock Shaadi 2024!✨",
    },
    {
      id: 3,
      imageUrl: "src/components/insta_photos/roth_n_roll.png",
      caption: "Sharing amazing Bengali foods for all of Rothschild! 🎉",
    },
  ],
  Gk = ({ isVisible: r = !0 }) => {
    const e = Dx({
        delay: 4e3,
        playOnInit: !0,
        stopOnInteraction: !1,
        stopOnMouseEnter: !0,
        rootNode: (s) => s.parentElement,
      }),
      [t, n] = Lx(
        {
          loop: !0,
          align: "center",
          slidesToScroll: 1,
          containScroll: "trimSnaps",
          dragFree: !0,
        },
        [e],
      ),
      i = he.useCallback(() => {
        var s;
        n &&
          document.visibilityState === "visible" &&
          ((s = n.plugins().autoplay) == null || s.reset());
      }, [n]);
    return (
      he.useEffect(
        () => (
          document.addEventListener("visibilitychange", i),
          () => {
            document.removeEventListener("visibilitychange", i);
          }
        ),
        [i],
      ),
      H.jsx("div", {
        className: `transition-opacity duration-500 ${r ? "opacity-100" : "opacity-0"}`,
        children: H.jsx("section", {
          className: "py-20 px-4 bg-gradient-to-br from-[#460b2f] to-[#9a031e]",
          children: H.jsx(lt.div, {
            className: "max-w-6xl mx-auto",
            initial: { opacity: 0, y: 20 },
            whileInView: { opacity: 1, y: 0 },
            viewport: { once: !0 },
            transition: { duration: 0.8 },
            children: H.jsxs("div", {
              className: "p-8 backdrop-blur-sm rounded-xl bg-black/10",
              children: [
                H.jsxs("div", {
                  className: "text-center mb-16",
                  children: [
                    H.jsx("h1", {
                      className:
                        "text-4xl md:text-5xl font-quattrocento font-bold text-[#eae0d5] mb-8",
                      children: "Vanderbilt Association of Bengali Students",
                    }),
                    H.jsx(lt.div, {
                      className:
                        "text-3xl font-['Tiro_Bangla'] text-[#eae0d5] mb-4",
                      whileHover: { scale: 1.05 },
                      children: "ভালো হৃদয়ের কোনো দোষ নেই",
                    }),
                    H.jsx(lt.div, {
                      className: "text-xl italic text-[#bf9b30]",
                      whileHover: { scale: 1.05 },
                      children: '"A good heart has no faults."',
                    }),
                  ],
                }),
                H.jsxs("div", {
                  className: "mt-16",
                  children: [
                    H.jsxs("div", {
                      className: "flex items-center justify-center gap-4 mb-12",
                      children: [
                        H.jsx("h2", {
                          className:
                            "text-3xl font-quattrocento font-bold text-[#eae0d5]",
                          children: "Our Events",
                        }),
                        H.jsx(lt.a, {
                          href: "https://www.instagram.com/vandy.bengalis/",
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className:
                            "flex items-center justify-center p-2 rounded-full bg-[#eae0d5]/10 hover:bg-[#e36414]/20 transition-colors",
                          whileHover: { scale: 1.1 },
                          whileTap: { scale: 0.95 },
                          children: H.jsx(mg, {
                            className: "w-6 h-6 text-[#eae0d5]",
                          }),
                        }),
                      ],
                    }),
                    H.jsx("div", {
                      className: "relative overflow-hidden",
                      ref: t,
                      children: H.jsx("div", {
                        className: "flex gap-6",
                        children: Vk.map((s) =>
                          H.jsx(
                            lt.div,
                            {
                              className:
                                "flex-[0_0_85%] sm:flex-[0_0_45%] lg:flex-[0_0_30%] min-w-0",
                              whileHover: { scale: 1.02 },
                              transition: { duration: 0.3 },
                              children: H.jsx("div", {
                                className:
                                  "h-full bg-gradient-to-br from-[#992b0d]/10 to-[#e36414]/10 p-4 rounded-xl backdrop-blur-sm",
                                children: H.jsxs("div", {
                                  className:
                                    "relative rounded-lg overflow-hidden",
                                  style: { aspectRatio: "1080/1350" },
                                  children: [
                                    H.jsx("img", {
                                      src: s.imageUrl,
                                      alt: s.caption,
                                      className: "w-full h-full object-cover",
                                    }),
                                    H.jsx(lt.div, {
                                      className:
                                        "absolute inset-0 bg-gradient-to-t from-black/70 to-transparent opacity-0 hover:opacity-100 transition-opacity duration-300",
                                      initial: { opacity: 0 },
                                      whileHover: { opacity: 1 },
                                      children: H.jsx("div", {
                                        className:
                                          "absolute bottom-0 left-0 right-0 p-4",
                                        children: H.jsx("p", {
                                          className:
                                            "text-white font-quattrocento text-sm md:text-base",
                                          children: s.caption,
                                        }),
                                      }),
                                    }),
                                  ],
                                }),
                              }),
                            },
                            s.id,
                          ),
                        ),
                      }),
                    }),
                    H.jsxs(lt.div, {
                      className: "mt-12 flex justify-center items-center gap-8",
                      initial: { opacity: 0, y: 20 },
                      whileInView: { opacity: 1, y: 0 },
                      viewport: { once: !0 },
                      children: [
                        H.jsx(lt.div, {
                          className:
                            "h-px w-24 md:w-32 bg-gradient-to-r from-transparent via-[#e2d57e] to-transparent",
                          animate: {
                            scaleX: [1, 1.2, 1],
                            opacity: [0.5, 1, 0.5],
                          },
                          transition: {
                            duration: 2,
                            repeat: 1 / 0,
                            ease: "easeInOut",
                          },
                        }),
                        H.jsx(lt.div, {
                          className: "w-3 h-3 rounded-full bg-[#e36414]",
                          animate: {
                            scale: [1, 1.2, 1],
                            opacity: [0.7, 1, 0.7],
                          },
                          transition: {
                            duration: 2,
                            repeat: 1 / 0,
                            ease: "easeInOut",
                          },
                        }),
                        H.jsx(lt.div, {
                          className:
                            "h-px w-24 md:w-32 bg-gradient-to-r from-transparent via-[#e2d57e] to-transparent",
                          animate: {
                            scaleX: [1, 1.2, 1],
                            opacity: [0.5, 1, 0.5],
                          },
                          transition: {
                            duration: 2,
                            repeat: 1 / 0,
                            ease: "easeInOut",
                          },
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          }),
        }),
      })
    );
  },
  jk = () => {
    const [r, e] = he.useState(!0),
      [t, n] = he.useState(!1);
    return (
      he.useEffect(() => {
        document.body.style.overflow = "hidden";
        const i = setTimeout(() => {
          e(!1);
          const s = setTimeout(() => {
            n(!0), (document.body.style.overflow = "auto");
          }, 1500);
          return () => clearTimeout(s);
        }, 4e3);
        return () => {
          clearTimeout(i), (document.body.style.overflow = "auto");
        };
      }, []),
      H.jsxs(ik, {
        className:
          "min-h-screen bg-gradient-to-br from-[#992b0d] via-[#761f0a] to-[#4d1405] relative overflow-hidden",
        isMainContentVisible: t,
        children: [
          H.jsx(fv, {
            children:
              r &&
              H.jsxs(lt.div, {
                initial: { opacity: 0, scale: 0.95 },
                animate: { opacity: 1, scale: 1 },
                exit: { opacity: 0, scale: 1.1, filter: "blur(10px)" },
                transition: { duration: 1.5, ease: "easeOut" },
                className:
                  "fixed inset-0 flex flex-col items-center justify-center z-40",
                children: [
                  H.jsx(lt.div, {
                    className:
                      "absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,_rgba(227,100,20,0.15),_transparent_70%)]",
                    animate: { scale: [1, 1.2, 1], opacity: [0.3, 0.7, 0.3] },
                    transition: {
                      duration: 3,
                      ease: "easeInOut",
                      times: [0, 0.5, 1],
                    },
                  }),
                  H.jsxs(lt.div, {
                    initial: { y: 50, opacity: 0 },
                    animate: { y: 0, opacity: 1 },
                    transition: { duration: 1, delay: 0.5 },
                    className: "text-center z-10",
                    children: [
                      H.jsx("h1", {
                        className:
                          "text-6xl md:text-8xl font-quattrocento font-bold bg-gradient-to-r from-gold via-spanish to-gold text-transparent bg-clip-text",
                        children: "Mock Shaadi",
                      }),
                      H.jsx(lt.div, {
                        initial: { opacity: 0, y: 20 },
                        animate: { opacity: 1, y: 0 },
                        transition: { duration: 0.8, delay: 1 },
                        className: "mt-4",
                        children: H.jsx("span", {
                          className:
                            "text-3xl md:text-4xl text-almond font-quattrocento",
                          children: "2025",
                        }),
                      }),
                    ],
                  }),
                  H.jsx(lt.p, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { duration: 0.8, delay: 1.5 },
                    className:
                      "text-lg md:text-xl text-almond/80 mt-6 font-quattrocento italic",
                    children: "Where Tradition Meets Tomorrow",
                  }),
                  H.jsx(lt.p, {
                    initial: { opacity: 0, y: 20 },
                    animate: { opacity: 1, y: 0 },
                    transition: { duration: 0.8, delay: 2 },
                    className:
                      "text-sm md:text-base text-almond/60 mt-4 font-quattrocento text-center",
                    children:
                      "Presented by Vanderbilt University South Asian Organizations",
                  }),
                  H.jsxs(lt.div, {
                    className: "mt-8 flex items-center gap-4",
                    initial: { opacity: 0, scale: 0.8 },
                    animate: { opacity: 1, scale: 1 },
                    transition: { duration: 0.8, delay: 2 },
                    children: [
                      H.jsx(lt.div, {
                        className:
                          "h-px w-24 md:w-32 bg-gradient-to-r from-transparent via-gold to-transparent",
                        animate: {
                          scaleX: [1, 1.2, 1],
                          opacity: [0.5, 1, 0.5],
                        },
                        transition: {
                          duration: 2,
                          repeat: 1 / 0,
                          ease: "easeInOut",
                        },
                      }),
                      H.jsx(lt.div, {
                        className: "w-2 h-2 rounded-full bg-spanish",
                        animate: { scale: [1, 1.3, 1], opacity: [0.7, 1, 0.7] },
                        transition: {
                          duration: 2,
                          repeat: 1 / 0,
                          ease: "easeInOut",
                        },
                      }),
                      H.jsx(lt.div, {
                        className:
                          "h-px w-24 md:w-32 bg-gradient-to-r from-transparent via-gold to-transparent",
                        animate: {
                          scaleX: [1, 1.2, 1],
                          opacity: [0.5, 1, 0.5],
                        },
                        transition: {
                          duration: 2,
                          repeat: 1 / 0,
                          ease: "easeInOut",
                        },
                      }),
                    ],
                  }),
                ],
              }),
          }),
          H.jsx(fv, {
            children:
              t &&
              H.jsxs(lt.div, {
                initial: { opacity: 0, y: 20 },
                animate: { opacity: 1, y: 0 },
                transition: { duration: 1.5, ease: "easeOut" },
                className: "min-h-screen",
                children: [
                  H.jsx(rk, {}),
                  H.jsx("div", {
                    className:
                      "max-w-7xl bg-transparent mx-auto space-y-8 relative z-10",
                    children: H.jsx("div", {
                      className: "p-6",
                      children: H.jsx(XO, {}),
                    }),
                  }),
                  H.jsx(Gk, { isVisible: t }),
                ],
              }),
          }),
        ],
      })
    );
  };
function Wk() {
  return H.jsx(l8, {
    children: H.jsx("div", {
      className:
        "min-h-screen bg-gradient-to-br from-[#992b0d] via-[#761f0a] to-[#4d1405]",
      children: H.jsx("main", {
        className: "relative z-10",
        children: H.jsx(jk, {}),
      }),
    }),
  });
}
o8.createRoot(document.getElementById("root")).render(
  H.jsx(he.StrictMode, { children: H.jsx(Wk, {}) }),
);
